# Linux加载启动可执行程序的过程（一）内核空间加载ELF的过程
- https://blog.csdn.net/chrisnotfound/article/details/80082289
# Linux加载启动可执行程序的过程（二）解释器完成动态链接
- https://blog.csdn.net/chrisnotfound/article/details/80082463
- 总结：linux在执行elf文件时大致会经历如下步骤
- 在内核空间加载elf文件（调用load_elf_binary函数）
  - 在这个过程中，linux内核会对elf文件的魔数、是否为动态链接库进行检查，并加载elf文件的程序头表，遍历elf文件的所有段，从而确定是否存在PT_INTERP类型的段，也即解释器段，
    - 如果解释器段存在，说明该程序为动态链接的，linux之后会根据解释器段的信息将解释器（ld-linux.so）的头部128字节读入内存，检查解释器头部信息，将解释器程序头表加载到内存，从而完成解释器初始化工作。之后内核将确定可执行文件的PT_LOAD段的装入地址，通过elf_map()建立用户空间虚拟地址与目标映像文件中某个连续区间的映射，即将可执行文件的PT_LOAD段装入虚拟内存中。之后确定程序的入口地址，由于此时程序为动态链接，所以需要就通过load_elf_interp装入解释器映像, 并把将来进入用户空间的入口地址设置成load_elf_interp()的返回值，即解释器映像的入口地址。之后填写目标文件的参数环境变量等必要信息，此类信息会在程序在用户空间执行后出现在用户空间堆栈上。最后通过start_thread准备进入解释器的程序入口。
    - 如果解释器不存在，程序不加载解释器（ld-linux.so）相关文件，内核将确定可执行文件的PT_LOAD段的装入地址，通过elf_map()建立用户空间虚拟地址与目标映像文件中某个连续区间的映射，即将可执行文件的PT_LOAD段装入虚拟内存中。之后将目标映像本身的入口地址作为程序的入口地址，之后填写目标文件的参数环境变量等必要信息，此类信息会在程序在用户空间执行后出现在用户空间堆栈上。最后通过start_thread准备进入新的程序入口。
- 如果程序为动态链接，则内核将elf文件以及动态链接器加载完毕后，将控制权交到动态链接器，在用户空间中完成可执行文件的动态链接
  - 解释器也称为动态链接器，在32位系统上是“/lib/ld-linux.so.2”，在x86_64系统中是“/lib64/ld-linux-x86-64.so.2”，
  - 当程序为动态链接时，可执行文件在Linux内核中通过load_elf_binary装载完成之后，不直接执行，而是先跳到动态链接器（ld-linux-XXX）执行。
    - 动态链接器根据.dynamic段的信息找到该可执行文件依赖的动态链接库，并将其加载到内存中
    - 动态链接器针对可执行文件的外部引用进行重定位，实际上即将可执行文件的外部引用（包括外部全局变量和外部函数）的实际地址填入对应got表项，（通过_dl_runtime_resolve函数），如果开启了延迟绑定，则该在函数第一次被调用时才会将对应地址写入got表项
      - 动态链接器首先会将link_map地址（对应GOT[1]）、_dl_runtime_resolve地址（对应GOT[2])写到对应GOT表项内。所以在此时，该GOT表项的不为空。
- 动态链接过程执行完毕后，动态链接库将程序控制权交给可执行文件，可执行文件中的代码开始运行
# ELF文件加载过程（经典）
- https://zhuanlan.zhihu.com/p/287863861
- 总结
- elf加载过程
  1. ELF映像的装入/启动在Linux内核中进行；
  2. 把动态链接的实现放在用户空间（glibc），并为此提供一个称为”解释器”(ld-linux.so.2)的工具软件，而解释器的装入/启动也由内核负责，解释器也称为动态链接器
- elf可执行文件执行时，shell通过execve函数以可执行文件作为参数开始可执行文件的加载运行，具体函数执行流程如下，内核中实际执行execv()或execve()系统调用的程序是do_execve()
  - ![](pic/2021-06-23-18-37-23.png)
- shell执行命令的生命周期
  1. 当shell运行一个程序时，父shell进程生成一个子进程，它是父进程的一个复制品。子进程通过execve系统调用启动加载器；
  2. 内核中实际执行execv()或execve()系统调用的程序是do_execve()，这个函数先打开目标映像文件，并从目标文件的头部（第一个字节开始）读入若干（当前Linux内核中是128）字节（实际上就是填充ELF文件头，下面的分析可以看到）；
  3. 然后调用另一个函数search_binary_handler()，在此函数里面，它会搜索我们上面提到的Linux支持的可执行文件类型链表，elf文件会调用到 load_elf_binary函数；
  4. load_elf_binary 过程如下：
     1. 填充并且检查目标程序ELF头部
     2. load_elf_phdrs加载目标程序的程序头表
     3. 如果需要动态链接, 则寻找和处理解释器段
     4. 检查并读取解释器的程序表头
     5. 装入目标程序的段segment
     6. 填写程序的入口地址，针对动态链接的程序，程序入口指向动态链接器，否则程序入口指向可执行文件
     7. create_elf_tables填写目标文件的参数环境变量等必要信息
     8. start_thread 准备进入新的程序入口
# ELF文件的加载过程(load_elf_binary函数详解)--Linux进程的管理与调度（十三）
- https://cloud.tencent.com/developer/article/1351964
- 总结
- elf主要加载过程（即函数load_elf_binary的执行过程）
  - 读取并检查目标可执行程序的头信息, 检查完成后加载目标程序的程序头表
  - 如果需要解释器则读取并检查解释器的头信息, 检查完成后加载解释器的程序头表
  - 装入目标程序的段segment, 这些才是目标程序二进制代码中的真正可执行映像
  - 填写程序的入口地址(如果有解释器则填入解释器的入口地址, 否则直接填入可执行程序的入口地址)
  - create_elf_tables填写目标文件的参数环境变量等必要信息
  - start_kernel宏准备进入新的程序入口
- ELF文件中符号的动态解析过程
  - 内核的工作
    1. 内核首先读取ELF文件头部，再读如各种数据结构，从这些数据结构中可知各段或节的地址及标识，然后调用mmap()把找到的可加载段的内容加载到内存中。同时读取段标记，以标识该段在内存中是否可读、可写、可执行。其中，文本段是程序代码，只读且可执行，而数据段是可读且可写。
    2. 从PT_INTERP的段中找到所对应的动态链接器名称，并加载动态链接器。通常是/lib/ld-linux.so.2.
    3. 内核把新进程的堆栈中设置一些标记对，以指示动态链接器的相关操作。
    4. 内核把控制权传递给动态链接器。
  - 动态链接器的工作并不是在内核空间完成的, 而是在用户空间完成的, 比如C语言程序则交给C运行时库来完成, 这个并不是我们今天内核学习的重点, 而是由glic完成的,但是其一般过程如下
  - 动态链接器的工作
    1. 动态链接器检查程序对共享库的依赖性，并在需要时对其进行加载。
    2. 动态链接器对程序的外部引用进行重定位，并告诉程序其引用的外部变量/函数的地址，此地址位于共享库被加载在内存的区间内。动态链接还有一个延迟定位的特性，即只有在“真正”需要引用符号时才重定位，这对提高程序运行效率有极大帮助。
    3. 动态链接器执行在ELF文件中标记为.init的节的代码，进行程序运行的初始化。动态链接器把控制传递给程序，从ELF文件头部中定义的程序进入点(main)开始执行。在a.out格式和ELF格式中，程序进入点的值是显式存在的，而在COFF格式中则是由规范隐含定义。
    4. 程序开始执行
# 动态链接的步骤与实现
https://www.cnblogs.com/linhaostudy/p/10544917.html
- 总结
- 动态链接器的自举
  - 动态链接器本身也是一个共享对象，但是事实上它有一些特殊性。对于普通共享对象文件来说，它的重定位工作由动态链接器来完成。他也可以依赖其他共享对象，其中的被依赖共享对象由动态链接器负责链接和装载。可是对于动态链接器来说，其重定位工作需由自身完成，这就要求动态链接器本身不可以依赖于其他任何共享对象；其次是动态链接器本身所需要的全局和静态变量和重定位工作由它本身完成
- 装载共享对象
  - 完成基本自举以后,动态链接器将可执行文件和链接器本身的符号表都合并到一个符号表当中,我们可以称它为全局符号表( Global Symbol Table)。然后链接器开始寻找可执文件所依赖的共享对象,我们前面提到过“.dynamic”段中,有一种类型的入口DT_NEEDED,它所指出的是该可执行文件(或共享对象)所依赖的共享对象。由此,链接器可以列出可执行文件所需要的所有共享对象,并将这些共享对象的名字放入到一个装载集合中。然后链接器开始从集合里取个所需要的共享对象的名字,找到相应的文件后打开该文件,读取相应的ELF文件头和“ .dynamic”段,然后将它相应的代码段和数据段映射到进程空间中。如果这个ELF共享对象还依赖于其他共享对象,那么将所依赖的共享对象的名字放到装载集合中。如此循环直到所有依赖的共享对象都被装载进来为止,当然链接器可以有不同的装载顺序,如果我们把依赖关系看作一个图的话,那么这个装载过程就是一个图的遍历过程,链接器可能会使用深度优先或者广度优先或者其他的顺序来遍历整个图,这取决于链接器,比较常见的算法一般都是广度优先的。
- 重定位与初始化
  - 当上面的步骤完成之后，链接器开始重新遍历可执行的文件和每个共享对象的重定位表，将它们的GOT/PLT的每个需要重定位的位置进行修正。因为此时动态链接器已经拥有了进程的全局符号表，所以这个修正过程也显得比较容易，跟我们前面提到的地址重定位的原理基本相同。在前面介绍动态链接的重定位表时，我们已经碰到了几种重定位类型，每种重定位入口地址的计算方法我们在这里就不再重复介绍了。
  - 重定位完成之后，如果某个共享对象有“.init”段，那么动态链接器会执行“.init”段中的代码,用以实现共享对象特有的初始化过程,比如最常见的,共享对象中的C++ 的全局静态对象的构造就需要通过“init”来初始化。相应地,共享对象中还可能有“ finit”段,当进程退出时会执行“.finit"段中的代码,可以用来实现类似C++全局对象析构之类的操作。
  - 如果进程的可执行文件也有“init”段,那么动态链接器不会执行它,因为可执行文件中的“init”段和“ finit”段由程序初始化部分代码负责执行,我们将在后面的“库”这部分详细介绍程序初始化部分。
  - 当完成了重定位和初始化之后,所有的准备工作就宣告完成了,所需要的共享对象都已经装载并且链接完成了,这时候动态链接器就如释重负,将进程的控制权转交给程序的入口并且开始执行。
# 其他关于动态链接器的补充信息
- 资料来源：
  - https://www.cnblogs.com/kelamoyujuzhen/p/9823272.html
- 可以使用ldd命令查看可执行文件所依赖的动态链接库，包括动态链接器自身
  - ![](pic/2021-06-24-10-17-31.png)
- 动态链接器(ld-linux.so.2)是链接器(linker)（即ld）的运行时组件
- elf文件中存在名为INTERP的特殊ELF程序头（即segment），它的p_type为PT_INTERP。 此程序头指定解释器(interpreter)的路径，可以使用readelf -l查看。
  - ![](pic/2021-06-24-10-27-36.png)
# Linux加载启动可执行程序的过程（一）内核空间加载ELF的过程
![](pic/2021-06-23-15-47-35.png)
# Linux加载启动可执行程序的过程（二）解释器完成动态链接
![](pic/2021-06-23-17-25-40.png)
# ELF文件加载过程
![](pic/2021-06-23-19-04-38.png)
# ELF文件的加载过程(load_elf_binary函数详解)--Linux进程的管理与调度（十三）
![](pic/2021-06-24-09-35-58.png)
# 动态链接的步骤与实现
![](pic/2021-06-24-10-02-20.png)