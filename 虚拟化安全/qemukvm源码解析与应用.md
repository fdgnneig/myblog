- https://weread.qq.com/web/reader/ec132be07263ffc1ec1dc10ka87322c014a87ff679a21ea
# 第一章
- 模拟器可以通过解释来实现，即对程序的源ISA指令一条一条进行分析，然后执行相应的ISA指令上的操作。模拟器也可以通过二进制翻译实现，即首先将程序中所有的源ISA指令翻译成目标ISA上具有同样功能的指令，然后在目标ISA指令机器上执行。模拟器的基本原理如图1-2所示。典型的模拟器有QEMU（Quick Emulator）的用户态程序模拟、Bochs模拟器等。
- 高级语言虚拟机
- 在系统虚拟化中，管理全局物理资源的软件叫作虚拟机监控器（Virtual MachineMonitor，VMM），VMM之于虚拟机就如同操作系统之于进程，VMM利用时分复用或者空分复用的办法将硬件资源在各个虚拟机之间进行分配。系统虚拟机原理如图1-4所示。典型的系统虚拟化解决方案包括VMware Workstation、QEMU、VirtualBox和HyperV等。
- 之前的x86架构不支持硬件层面的虚拟机，导致VMM的设计和实现都比较麻烦，并且性能也不是很好。为了克服x86架构的虚拟化缺陷，Intel和AMD都相继在CPU硬件层面增加了虚拟化的支持。随着用户对性能需求的不断提升，内存、外设等也在硬件层面提供了对虚拟化的支持。
- Intel和AMD在2005年左右开始在CPU层面提供对系统虚拟化的支持，叫作硬件虚拟化，Intel在x86指令集的基础上增加了一套VMX扩展指令VT-x，为CPU增加了新的运行模式，完成了x86虚拟化漏洞的修补。通过新的硬件虚拟化指令，可以非常方便地构造VMM，并且x86虚拟机中的代码能够原生地运行在物理CPU上。
- 以色列初创公司Qumranet基于新的虚拟化指令集实现了KVM，并推广到Linux内核社区。KVM本身是一个内核模块，导出了一系列的接口到用户空间，用户空间可以使用这些接口创建虚拟机。最开始KVM只负责最核心的CPU虚拟化和内存虚拟化部分，使用QEMU作为其用户态组件，负责完成大量外设的模拟，当时的方案被称为QEMU-KVM
## QEMU与KVM架构
- 半虚拟化与全虚拟化
  - 根据是否需要修改虚拟机操作系统内核，将虚拟化方案分为半虚拟化与全虚拟化，前者需要修改虚拟机操作系统内核，后者不用
- 重要的虚拟化组件
  - cpu虚拟化
  - 内存虚拟化
  - 外设虚拟化
  - 中断虚拟化
- KVM API使用实例
  - 实现了一个简易内核以及qemu程序，后者调用kvm实现虚拟化运行内核
# 第二章 QEMU基本组件
- QEMU程序的运行即是基于各类文件fd事件的，QEMU在运行过程中会将自己感兴趣的文件fd添加到其监听列表上并定义相应的处理函数，在其主线程中，有一个循环用来处理这些文件fd的事件，如来自用户的输入、来自VNC的连接、虚拟网卡对应tap设备的收包等。这种事件循环机制在Windows系统或者其他GUI应用中非常常见。QEMU的事件循环机制基于glib，glib是一个跨平台的、用C语言编写的若干底层库的集合。本节对glib提供的事件循环机制进行简单介绍。
- QEMU-KVM架构中，一个QEMU进程代表一个虚拟机。QEMU会有若干个线程，其中对于每个CPU会创建一个线程，还有其他的线程，如VNC线程、I/O线程、热迁移线程
- QEMU的代码中充满了对象，特别是设备模拟，如网卡、串口、显卡等都是通过对象来抽象的。QOM用C语言基本上实现了继承、封装、多态特点。如网卡是一个类，它的父类是一个PCI设备类，这个PCI设备类的父类是设备类，此即继承
- 