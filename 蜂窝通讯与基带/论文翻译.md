# 论文阅读：修改高通基带固件
## 手机芯片中，基带与应用处理器通常封装在同一个芯片中
## 安卓手机的/dev/diag目录下可以获得基带固件
## QXDM是高通专用的开发工具，类似的工具包括
- 在 Azenqos 的 AZQ Android 中，存在使用该界面的商业工具 [4]。它直接在手机上运行用户空间应用程序，以及修改后的内核。它提供与高通 QXDM 类似的功能。测量值、解码的第 3 层消息和其他数据会实时显示给用户。它还能够记录数据，并为常见场景提供分析工具。
- MobileInsight 项目略有不同 [23]。在这里，研究人员试图将诊断界面的数据用于其他项目的进一步研究。因此，它包括一个文档化的应用程序编程接口 (API)，是可扩展的，可以免费用于研究。它的功能仅限于当前实现的消息类型，同样主要支持第 3 层消息和一些物理层测量

## 论文翻译
### 从第10页开始
- 我们可以总结出这三个工具使用相同的数据源并收集相似类型的数据。主要区别在于工具收集数据的位置以及它们如何将数据提供给用户。这也导致了所有这些的一个共同问题：它们仅限于诊断接口提供的数据，如果接口上没有所需的数据，则无法从此处获取。例如，这是我们在 10.6 节中提取的信道状态信息 (CSI) 的情况。对于 Qualcomm 的 QXDM，此限制较弱，因为它们可以访问固件并可以实现所需的消息。然而，对于一些敏感数据，比如加密密钥，高通可能没有兴趣将它们暴露在外部，而固件会引入新的安全线程。
- 获得对调制解调器固件的访问权，此处介绍的方法有可能提取基带使用的所有内部数据。另一方面，我们必须找到并逆向工程固件的相关代码部分，以了解制造商如何实现目标功能以及我们如何读取所需的值。因此，我们建议先使用诊断接口进行数据采集，对于不能处理的情况才开始修改固件
- 其他项目打算使用软件定义无线电 (SDR) 实现收集 LTE 网络的数据，例如在 [8] 中，作者解码 LTE 的控制信道以监视小区中所有用户的资源分配，还允许跟踪网络的负载。由于这些基于特定硬件而不是商用现成智能手机，因此它们针对的用例与本文完全不同，无法满足研究廉价设备的目标
- 另请注意，数据收集只是本论文的一个目标。所有提供的项目都不能修改调制解调器代码。因此，他们只能监听但不能主动修改数据，例如查看网络如何对被操纵的值做出反应。出于同样的原因，它们不适合扩展具有新功能的调制解调器
### 第三章:LTE基础
- 本章的目的是提供 LTE 技术的最低背景知识以理解本文，如果已经知道 LTE，则可以跳过本章。提供 LTE 标准的完整摘要远远超出了这项工作的范围。因此，我们仅讨论该技术的重要部分，并仅解释本工作稍后使用的少数细节。有关更多详细信息，我们建议读者查看 LTE 规范或众多可用的书籍和在线解释之一（例如 [34]）。
- 3.1 lte overview
- 图 2 总结了 LTE 中使用的协议分层。我们主要关注物理层 (PHY) 和媒体访问控制 (MAC)。然而，正如我们在图中看到的，高层与这些层交互，主要是为了能够通过高层消息配置低层的参数。因此，还需要这些层的基本知识。
- 不同层的主要任务是（基于[44]）：
- 用于空中接口、功率控制、小区搜索、测量（例如信道估计）的物理层 (PHY) 调制
- 从逻辑信道到传输信道的介质访问控制 (MAC)（解）复用、（基于优先级的）逻辑信道数据调度、重传和使用混合 ARQ (HARQ) 的纠错
- 无线链路控制 (RLC) 连接和 SDU 分段以适应帧、重复检测、使用 ARQ 进行纠错
- 分组数据收敛控制 (PDCP) 有序分组传送（用户和 RRC 控制数据）、用户和控制数据加密、控制数据完整性保护、互联网协议 (IP) 报头压缩
- 无线资源控制 (RRC) 广播系统信息，用于 NAS、寻呼、连接管理、安全性（配置、建立、密钥管理）、无线承载维护
- 非接入层 (NAS) 支持移动性、身份验证、会话管理：为移动设备建立和维护 IP 连接
- ![](pic/2022-01-08-12-29-56.png)
- 在本描述中，我们已经使用了层间逻辑、传输通信和物理通道的概念。层之间的逻辑通道被组织在通道中，对数据进行分类并确定应如何处理。 RLC和MAC层之间的接口用于区分各种流量。它们区分控制和数据流量，以及它是专用于单个用户还是由多个用户共享。另一方面，MAC 和 PHY 层通信中的传输通道定义了数据的传输方式。最后，物理信道与无线电传输中数据的表示有关，并定义了使用哪些物理资源。例如，对于初始随机接入过程（稍后在第 3.3 节中解释），预留了专用的物理传输资源。表 2 描述了可用的通道。对于传输和物理信道，首先列出下行信道（基站到用户设备 (UE) 通信），然后是上行信道（UE 到基站）。 “映射到”列指示数据通过哪个较低级别的通道传输
- 3.2 phy layer
- 在本节中，我们将介绍与这项工作相关的 LTE PHY 层的基础知识。 LTE 在上行链路中使用与下行链路不同的调制方案。然而，对于本论文来说，主要是下行链路结构是相关的，因此我们在这里关注这个方向。此外，我们仅考虑频分双工 (FDD) LTE 网络
- ![](pic/2022-01-08-12-41-09.png)
- 3.2.1 正交频分复用（OFDM
- 所有 LTE 通信的基础是正交频率 - OFDM 是 LTE 下行链路的基础，将可用带宽划分为独立的子载波。分复用 (OFDM) 调制。该技术将可用的载波带宽分成子载波。然后使用映射到正交幅度调制 (QAM) 或正交相移键控 (QPSK) 符号的数据单独调制这些子载波中的每一个。
- 通过子载波值，我们定义了子载波频率上信号的所需分量。因此，子载波值等于频域中所需信号的表示。因此，OFDM 调制可以通过计算子载波值的快速傅里叶逆变换 (IFFT) 来实现，以获取要发送的时域数据。类似地，接收器可以对接收到的时间数据计算快速傅里叶变换 (FFT)，以找回已调制的子载波符号。请注意，LTE 在将其映射到子载波的符号之前，还会对用户数据流进行加扰，以处理突发错误。如果多输入多输出 (MIMO) 处于活动状态，则还对符号应用一些预编码，并执行到不同天线端口的映射
- 3.2.2 LTE资源网格
- OFDM 调制将可用带宽划分为子载波。表 3 列出了为 LTE 指定的带宽选项，以及使用的子载波数和资源块（我们稍后定义）。在最近的 LTE 版本中，网络可以将多个这些载波组合在一个小区中（载波聚合，从 LTE 版本 10 开始最多 5 个载波），从而增加可用资源的数量。
- 在时域中，LTE 使用具有固定 dura OFDM 的规则结构以及每个元素的重刑。最大的单位是框架。每个具有固定时间结构的帧 con 将可用的传输资源划分为规则的网格。由十个子帧组成，每个子帧有两个时隙。这些再次包含七个 OFDM 符号，如果网络配置为扩展循环前缀，则只有六个符号适合一个时隙。表 4 总结了这种结构
- 通过这种方式，可用于传输的资源被划分为频率（OFDM 子载波）和时间（帧中的时隙）。每个时隙和子载波对描述可用于发送数据的不同资源。 LTE 利用这一点为不同目的分配这些块：之前介绍的物理信道、同步信号和参考信号，我们在第 3.2.3 节中解释。
- PDSCH信道的块进一步分配给不同的用户。为了减少信令开销，资源块 (RB) 将 12 个相邻的子载波和一个时隙分组，并以这种粒度完成向不同用户的分发。图 3 说明了时间和频率网格中的资源结构，显示了 1.4 MHz LTE FDD 网络的静态信道分配示例，资源网格允许根据活动用户的当前需求进行灵活和快速的分配。两个发送天线（选择小带宽以获得更好的概览）。白块可用于 PDSCH 信道分配。
- 通过这种资源分配方案，LTE 可以根据用户的流量需求和信号质量灵活地在用户之间共享可用带宽，以增加网络的总吞吐​​量，同时保持用户之间的公平性。
- 3.2.3 Channel fading
- UE 和基站之间的物理通信信道，也称为演进节点 B (eNodeB)，对信号施加衰减和相位变化。对于典型的 LTE 信道，这不是一个恒定的因素，而是信道对信号的影响很大程度上取决于频率，例如，由多径传播引起。此外，由于用户的移动性和环境的变化，信道随时间变化很大。这些效应称为频率选择性衰落。在固定时间点，频域中的信道 H 可以描述为接收信号 Y 和发射符号 X 之间的（复）商：
- ***之后通讯的内容过于复杂，无法理解，暂不翻译***
### 第四章 目标设备
- 我们首先打算对 Google Nexus 5 智能手机进行研究。但是，由于此设备的基带固件经过身份验证，这是第 7.2 节的主题，因此无法在不利用安全机制的漏洞的情况下在此手机的调制解调器上运行修改后的固件。因此，我们决定转向华硕 PadFone Infinity 2 (A86)，因为华硕在某些情况下不启用签名检查。我们在本文中使用华硕 PadFone Infinity 2 作为主要目标。大多数结果也适用于其他设备。手机（详见第 7.2.1 节），并且此型号使用与 Google 的 Nexus 设备、Snapdragon 800 或高通命名方案中的 MSM8974 完全相同的 SoC。表 6 给出了 SoC 的主要特性。这两款智能手机的其他规格也相似，如表 7 所示
- ![](pic/2022-01-08-13-17-11.png)
- 尽管我们主要关注使用的目标，但许多结果，特别是开发的补丁框架也可以应用于其他手机，可能基于其他 SoC。这是由最近的高通调制解调器的非常相似的设计引起的，并且由源自相同源代码库的所有基带固件简化。我们实施了有助于移植到其他手机的脚本，或者只是同一手机的其他固件版本。它们在第 9.3 节中介绍
- 请注意，至少在发现绕过身份验证的漏洞之前，只能在具有以下功能的设备上进行修改，禁用身份验证或在使用不安全调试密钥进行签名的设备上。这是目前最大的限制，显着减少了潜在目标设备列表的长度。我们将在第 11 章讨论这个问题
- ![](pic/2022-01-08-13-32-50.png)
### 第五章 基带系统架构
- 为了理解调制解调器的功能，特别是它的数字基带部分，在以下部分中，我们将介绍架构，从粗略的概述开始，到基带内部的详细视图
- 5.1 overall system
- ***由于所有最近的高通芯片都具有相似的结构，至少在调制解调器方面，我们以 Snapdragon 800 (MSM8974) 芯片为例。图 6 显示了 SoC 架构，调制解调器位于右下角。此视图演示了调制解调器和主处理器之间的连接：共享内存。调制解调器可以直接访问系统的主存储器。 com- 在现代智能手机中，调制解调器是主 SoC 的一部分。它通过共享内存与系统的其他部分进行通信。与 HLOS 通信，它将数据放置在该内存的公共部分中。另一个方向的通信以相同的方式进行。因此，大量数据可以在两个实体之间轻松传递。我们将在第 7.5 节中提供有关此过程的更多详细信息，尤其是用于数据交换的协议。***
- ![](pic/2022-01-08-13-49-52.png)
- 这种直接访问调制解调器主存储器的问题是安全性。调制解调器理论上可以访问所有用户数据，例如运行应用程序的变量或来自 Android 内核的数据。因此，恶意调制解调器会导致整个系统受损。第 6.2.1 节介绍了用于防止这种情况的机制。请注意，通过共享内存进行的通信仅用于 SoC 中集成调制解调器的情况。在离散调制解调器芯片或 USB 棒调制解调器的情况下，某种高速串行链路（例如 USB）取代了此链路。
- 5.2 modem architecture
- 图 7 描绘了调制解调器系统。我们通过简化各种智能手机原理图获得它，它只是一个粗略的概述，省略了放大器或基带滤波器等细节。
- ![](pic/2022-01-08-13-52-12.png)
- 由于移动通信网络的定义范围很广，因此该系统包括多个天线，每个天线都针对特定频率范围进行了优化。此外，系统需要同一频段上的多个天线来支持 MIMO 传输模式。这些连接到开关，这些开关将它们连接到天线支持的不同频带的滤波器。通过滤波器后，接收到的信号被馈送到收发芯片的输入端口。类似地，要传输的信号采用相反的方式，来自该芯片的输出端口。这些端口通过开关在内部连接到接收器（或发射器）电路。请注意，图中显示的天线和滤波器的数量是任意选择的，并且在实际系统中会有所不同。为了克服收发器芯片提供的端口数量对最大可能支持频带的限制，系统设计人员可以在两者之间添加额外的开关。然而，这会引入一些信号衰减。
- 收发器将射频 (RF) 信号向下转换为调制解调器。调制解调器由带有同相和正交 (IQ) 组件的基带组成。用于负责在射频和基带信号之间转换的模拟部分和用于处理基带信号的数字部分，算法在软件中实现。在发射情况下，它将基带 IQ 信号向上转换为 RF。现在，该信号仅包含低于使用的最大通道带宽的频率，并且可以使用数字基带模块中的模数转换器 (ADC) 进行采样。所有进一步的处理都是使用处理器对数字数据进行的。对于传输路径，该系统生成信号，然后通过数模转换器 (DAC) 将其转换为用于收发器的模拟信号。由于这是在普通文献中发现的简单收发器系统，因此我们在此不再详细讨论。
- ***请注意，只有数字处理（即基带模块）是 SoC 的一部分，所有模拟处理均由外部组件完成。这也是为什么通常将调制解调器子系统称为基带的原因：我们所说的数字系统只是调制解调器中负责处理和生成基带信号的部分。在本文的其余部分，我们只关注调制解调器的这一部分。***
- 除了信号路径之外，收发器和开关还需要控制信号。这些也是由基带块生成的。另一方面，该模块与 SoC 系统的其余部分接口，如前一章所示
- 5.3 digital baseband
- 如前所述，图 7 中的数字基带模块处理采样信号的解码并生成用于传输的采样流。这意味着它解调信号并解码其基带信号在数字域中进行处理，在 DSP 上也运行更高层的通信技术。意义根据实现的通信技术，处理命令，生成响应等。为了传输，它根据通信标准对其消息进行编码和调制。换句话说，它实现了该技术的协议栈，或者更笼统地说，它支持的所有技术栈。
- ***由于这些堆栈非常广泛，因此使用了运行某些代码的处理器。在此处考虑的高通调制解调器的情况下，集成了该公司自己开发的特殊 DSP。它被称为 QDSP6 (Hexagon)，我们将在 6.1 节详细回顾它。除了实际的信号处理之外，所有代码，包括控制密集型协议部分，都在这个 DSP 上运行。较旧的基带或其他供应商的基带可能会使用额外的通用处理器（通常是 ARM 内核）或将其与 DSP 结合使用***
### 第六章硬件组成
- 在本章中，我们回顾了基带中使用的硬件组件。在描述了包含的处理器及其特性之后，我们来看看访问保护单元和专用的片上存储器
- 6.1 hexagon processor
- ***高通使用名为 QDSP6 (Hexagon) 的自行开发处理器在其调制解调器中执行代码。该处理器是一个 DSP，因此针对信号处理中发生的计算进行了优化，例如数字滤波器或 FFT 的计算。它可以比通用处理器更快、更节能地执行此类操作***
- ***再看一下图 6，可以发现相同的处理器类型被重新用于音频和传感器数据处理。实际上，Qualcomm Qualcomm 发布了用于使用的 Hexagon DSP 的文档和 SDK。 IDA的插件也存在。发布了一个软件开发工具包 (SDK) [28]，使开发人员能够创建自己的代码，在 DSP 上运行以处理传感器数据或将其用作通用硬件加速器。即使此 SDK 针对 SoC 中的另一个 DSP 实例，它的工具也可用于基带处理器。因此，包含编译器、汇编器、链接器和其他用于处理二进制代码文件的相关实用程序（包括反汇编器）的完整工具链是免费提供的。请注意，要在基带 DSP 上部署自己的代码，还需要 SDK 中没有的其他步骤，例如将最终固件二进制文件打包成正确的图像格式。我们将在第 9 章中针对这些步骤。***
- ***高通的发布还包括实用程序的文档，最重要的是处理器内核 [33]。遗憾的是，此文档不完整且不包含所有说明，例如，仅用于操作系统 (OS) 的说明未记录在案。但是，在逆向工程的过程中，我们也看到了这些指令，不得不了解它们的行为。对于来自 Hex Rays 的 IDA Pro 逆向工程工具，至少存在两个 Hexagon 处理器模块插件，它们都存在一些问题。 [17] 中可用的那个被发现对于代码分析更稳定，[25] 中的那个 Python 反汇编器被第 9 章的补丁框架使用。***
- 在概述了 Hexagon DSP 的不同版本之后，在本章的其余部分中，我们将展示处理器架构的详细信息。如果没有明确指出，信息是从 [10, 33] 中收集的。
- 6.1.1 Versions
- ***QDSP6 (Hexagon) 系列是高通 DSP 的最新版本。它有不同的版本，从 2006 年开始发布。表 8 总结了每个版本添加的主要功能。这些信息是从程序员的参考手册 [32, 33] 和 Weinmann 的演讲 [41] 中收集的，因为互联网上不再提供所有旧处理器版本的这些文档。这项工作中使用的智能手机包含一个 MSM8974 SoC，它使用 QDSP6V55 作为基带***
- ![](pic/2022-01-08-15-16-35.png)
- 6.1.2 指令包
- Hexagon DSP 有四个接受数据的执行单元，它们中的每一个都从系统的代码存储器中获得单独的指令，这意味着它们执行的操作由编译器明确编码在固件中 因此，用于 Hexagon 处理器的指令被分组到数据包中，这些数据包在同一处理周期中并行执行。由于需要大量指令数据（单个处理周期最多四个 32 位字），这个概念被称为超大指令字 (VLIW)。图 8 显示了执行单元
- Hexagon是一个VLIW架构，因此处理器中所执行的指令被打包为指令包且并行执行
- ![](pic/2022-01-08-15-16-56.png)
- 异构执行单元对一个数据包中的指令引入了约束。我们可以看到单元不相等，而是针对不同类型的指令（这里称为数据和执行单元）。因此，一个数据包不能包含四次相同的指令，但指令组合必须遵循可用执行单元的能力。有关确切的约束和可能的组合，请参阅 Qualcomm 的目标 DSP 版本的程序员参考手册，例如 [33]。在使用高级语言（例如 C）编写代码的正常情况下，编译器的任务是将指令分组为数据包。但是，在对现有代码进行逆向工程或修补时，我们必须手动分析数据包，并且需要生成有效的数据包。
- 请注意，指令编码仅包含标志以指示同一数据包中是否有其他指令，但不指示数据包的开始。这些只是隐含地知道的。当在数据包的中间检测到函数的开始或生成进入数据包的跳转时，这可能会导致逆向工程和修补代码出现问题。幸运的是，处理这个问题相当容易，但为其他平台开发的现有工具可能会出现问题
- 6.1.3 常量扩展器
- 常量扩展器允许对大立即数进行有效编码。
- 指令通常只能包含小于整个字的立即数，因为它们只有一个字长并且需要空间来对指令本身进行编码。由于跳跃或计算经常需要完整 32 位的常量，这是一个很大的限制，并导致许多指令只是为了加载一个常数值。为了克服这个问题，Hexagon 支持常量扩展器 (immext)。在一个指令之前，并携带那里所需的常量值的剩余位。因此，处理器可以直接加载一个完整字大小的常量，并且可以在单个指令中跳过整个地址空间（内存地址也是 32 位长）。这些扩展器的缺点是它们也消耗一个指令槽，因此在同一个数据包中必须至少有一个执行单元未被使用。由于在许多情况下，编译器不会为处理周期中的所有单元找到一条指令，这只会稍微降低性能，可能低于更快的恒定加载的优势。
- 6.1.4 Hardware Threads
- QDSP6 在硬件中具有多线程支持。例如，版本 4 包括三个硬件线程。这些指令由交错多线程 (IMT) 以循环方式执行，且始终以相同的顺序执行。对于程序员来说，不同的硬件线程看起来像运行自己的代码的独立处理器内核。如果使用的软件线程多于可用的硬件线程，则它们会在这些虚拟内核上多路复用。另一方面，当使用较少的线程时，只能实现 DSP 总性能的一小部分。
- 硬件线程的数量与执行流水线阶段的数量相匹配。使用这个技巧，每当获取一条新指令时，同一个线程的所有先前指令都会完全完成，如表 9 所示。每一行代表一个流水线阶段，每一列代表一个执行周期，由执行新指令的线程给出。结构被提取。这些条目首先代表线程，然后是该线程中的指令号。请注意，表中的“开始”不是指第一个处理周期，而是观察的开始，此时每个线程都已经活动过一次。在每个时间点，每个流水线步骤都在另一个线程的指令上工作，这意味着它们之间不存在依赖关系
- ![](pic/2022-01-08-15-50-14.png)
- 因此，Qualcomm 可以在很大程度上简化处理器的内部结构：不会发生流水线停顿，也不会出现结果转发、分支预测或其他基础，此类技术多用于高性能流水线所需然而，引入了其他问题，例如每个线程需要一个单独的寄存器文件。
- 从版本 5 开始，Hexagon DSP 支持称为动态多线程 (DMT) 的附加模式。使用这种机制，可以从调度程序中删除硬件线程，例如因为它们未使用、缓存未命中或等待中断时。然后调度程序可以跳过这些线程，而是发出下一个线程的数据包。请注意，一个线程的新数据包仍然只能在前一个完全完成时发出。但是，有些指令不需要完整的流水线深度，但可以在两个周期内完成。因此，使用 DMT 和至少一个非活动线程，可以在仅具有如此快指令的数据包之后更早地调度新数据包，因此对于某些应用程序的整体性能略有提高。 [14]
- 6.1.5 Other specialities
- Hexagon DSP 包括更多的特色。复合指令和双工指令将多条指令编码为一个字以减少代码大小。硬件循环实现的循环比仅软件循环（最多一级嵌套）的开销更少。由于所有这些的详细讨论不是本文的主题，请参阅参考手册以获取有关这些和其他附加功能的更多详细信息。
- 6.2 other related components
- 除了 DSP 之外，基带还包含 ADC，用于对接收到的模拟信号进行采样，DAC 分别用于生成基带信号以进行传输。下面介绍的其他硬件组件完善了系统。
- 6.2.1 访问保护单元
- Qualcomm 在其芯片中包含访问保护单元 (XPU)，以根据请求的系统组件实现访问权限。它们位于外围组件和互连总线之间。因此，每个外围单元都有自己的 XPU。我们的 XPU 确保 SoC 中的某些地址只能由授权子系统访问。例如，目标 SoC MSM8974 至少包含 86 个 XPU，也许更多我们没有发现。我们从第 11 章的实验中获得了关于这里介绍的单元的知识。
- 在初始配置之后，这样的 XPU 单元会将对其的每次访问与一组规则进行比较，如果不允许访问，则阻止。此外，可以在违反权利时触发中断，允许采取进一步措施，从报告或记录事件到重新启动整个系统
- 这些规则，在 Qualcomm 的规则中也称为资源组 (RG)，定义固件中的字符串，使用两种机制来定义权限。首先，每个系统组件的单独权限。为 SoC 的组件定义权限（读/写），例如应用处理器或调制解调器 DSP。其次，赋予运行代码的上下文（角色）权限，这里是非安全的、安全的（TrustZone）或调制解调器可能的。只有当这两个标准都授予权限时，才授予访问权限。每个规则都有一个所有者，以后可以更改规则，这也是访问代码的角色之一。在第一次将规则提供给所有者之后，其他任何人都无法修改、停用或阅读该规则。结果，例如，即使是 TrustZone 代码也不能简单地停用调制解调器的规则，尽管它在启动时配置了它们，但随后将所有权传递给了调制解调器
- 大多数 XPU 允许在规则中为第一种机制的 SoC 中的每个组件（最多 32 个）指定单独的权限。然而，有些人使用简化的硬件，它只能对一个组件和所有剩余的组件强制执行不同的权限。除此之外，还存在不同类型的 XPU
- 寄存器保护单元 (RPU) 这些用于保护安全关键外设的寄存器。每个规则都将权限应用于一组预定义的寄存器。一个例子是保护对加密外围设备的访问，这样另一个子系统就不能篡改单元的操作。
- 区域保护单元 (APU) 第二种类型与第一种类似，但用于更大的地址区域，例如保护包含调制解调器主引导加载程序 (PBL) 的只读存储器 (ROM)，而不仅仅是单个寄存器。
- 最后一种类型的内存保护单元 (MPU) 规则不会像其他两个那样保护预定义区域。相反，每个规则都包含它应该是 MPU 可以隔离应用到的区域的开始和结束地址。顾名思义，它们用于内存，一个子系统的内存区域来自共享主内存中的其他子系统。特别是主RAM。通过这种方式，它们允许隔离共享主内存中不同子系统的内存区域，例如，硬件可以防止从 HLOS 访问调制解调器内部数据。
- 引导加载程序在子系统的启动阶段配置 XPU。在我们的调制解调器子系统的重点案例中，这是用于加载固件的内存区域的调制解调器启动验证器 (MBA)。因此，调制解调器的内存在经过身份验证后不能再被 HLOS 读取或修改，我们将在第 7.1 节讨论此过程的详细信息。显然，共享内存区域可以从 HLOS 访问
- 请注意，在 MPU 的情况下，规则可以重叠，这意味着可以为内存区域定义两个或多个规则。单位会考虑到这一点，并根据规则的所有者实施适当的行为，如表 10 中列出的两个规则及其所有权的可能性。特别是，如果调制解调器和另一方为一个区域配置规则，它会被锁定以防止所有访问，即使这两个规则都将授予所有组件的完全权限。每个访问的地址都是单独检查的，因此，对于仅部分重叠的规则，该逻辑仅适用于规则的实际重叠区域。
- 在所有经过测试的手机上，违反来自 Android 内核的调制解调器内存权限导致基带系统没有可见的额外措施，除了 XPU 阻止访问尝试。但是，该事件仍然可以在内部记录
- 6.2.2 紧耦合内存
- 高通的 SoC 部分包含一个额外的内存，称为紧耦合内存 (TCM)。 TCM 是一种类似于缓存的快速存储器，但更可预测，因为它可以由程序员控制。它起源于 ARM 世界，例如，在 [1] 中进行了描述。顾名思义，它是一种与处理核心紧密耦合的快速存储器，对它的访问可以在比主存短得多的时间内处理。这使得它类似于处理器缓存，其用途确实是一样的：加快对常用代码和数据的访问。两者之间的主要区别在于，缓存自动决定它存储的内存位置，因此对正在运行的代码（即操作系统）是透明的。另一方面，对于 TCM，软件可以明确地确定哪些内存地址应该驻留在其中，从而提高其行为和内存访问时间的可预测性。
- 放置在 TCM 中的指令和数据元素由链接器控制，它将所需的部分放置在特殊部分中，例如 memcpy 函数位于此处。 Qualcomm 的操作系统然后在需要时将这些部分加载到 TCM 中。根据当前使用的移动技术（GSM、UMTS、LTE，...），某些部分在整个运行时都保留在快速内存中，而其他部分仅在需要时加载。 TCM内存的剩余空间用于动态分配，这意味着需求在运行时发生，在链接时无法静态预见
- ![](pic/2022-01-08-16-25-23.png)
- TCM 操作接近于在其上运行的用户代码的缓存，只是操作系统操作不同。特别是在这项工作的上下文中，我们可以将其视为透明缓存，而不会影响例如我们在第 iii 部分执行的代码修补操作，其中我们将更改应用于基带的固件。所有修改都独立于这种机制，因为 TCM 内容是在运行时从通常的固件数据加载的，包括我们的修改。然而，理解它并知道它的工作方式仍然很重要，因为我们将在逆向工程中看到对 TCM 的引用，例如，在固件中找到的字符串中
### 第七章基带软件组成
- DSP 上运行的代码及其加载方式是本章的重点。我们还包括代码认证的安全方面。
- 7.1 firmware loading
- 为了启动调制解调器，它的固件必须放在系统的内存中，HLOS 就是这样做的。这是一个三阶段加载过程，如图 9 所示并在下文中解释。括号中的数字是指图中的步骤编号。
- ![](pic/2022-01-08-18-56-31.png)
- 启动调制解调器，首先所有相关的时钟信号和电压调节器都被启用，调制解调器重启信号被移除。调制解调器固件加载是一个三个阶段的过程，每个步骤都验证下一个步骤，建立一个信任链。现在运行一个主引导加载程序 (PBL)，它驻留在芯片内部的 ROM 中，并且在制造后不可更改。它还包括一个数字证书，用于验证下一个执行阶段的真实性。
- 在下一步中，Android 操作系统加载称为调制解调器引导验证器 (MBA) 的第二阶段引导加载程序，并告诉 PBL 它在哪里找到 MBA。然后，PBL 通过验证二进制文件中包含的签名及其证书来检查数据的真实性，我们在第 7.2 节中描述了有关此验证的详细信息。当此检查成功时，PBL 会将控制权传递给加载的 MBA。从现在开始执行的所有代码都驻留在系统的主内存中。
- 下一步，HLOS 加载实际固件的元数据，性并由 MBA 检查其真实。此元数据包含有关固件内存部分的信息，例如它们在系统内存中的长度和目标地址。此外，它还包含所有部分数据的哈希值。
- 然后将固件的不同内存部分一个接一个地加载到内存中，在每个“blob”之后，MBA 被指示检查真实性。由于它已经为每个段的内容提供了一个经过身份验证的哈希值，它只需要验证这些是否匹配。
- 当所有这些步骤都没有导致错误时，最终将控制权传递给主固件代码。如果其中一个步骤失败，负责的引导加载程序将返回错误并等待重复此步骤。
- 请注意，在身份验证步骤之前，MBA 会使用访问保护单元锁定所有包含数据的内存区域（第 6.2.1 节）只允许调制解调器处理器访问它，从 HLOS 撤回访问权限。因此，在验证后简单地修改代码是不可行的。类似地，PBL 在其他子系统被验证之前保护它们免受访问。将加载的 MBA 代码移动到只能由调制解调器处理器访问的位置。这是调制解调器的内部 TCM 存储器，其中包含完整的 MBA 代码和数据。我们假设高通选择了这种解决方案来简化一次性可编程 PBL，因为它不需要在这种方法中配置 XPU，从而最大限度地减少了在芯片发货后无法更新代码中的安全问题的可能性。
- 所述方法不适用于所有 Qualcomm 调制解调器。较旧的手机使用设备 ARM TrustZone 实现来验证代码，而不是直接在调制解调器的处理器上执行计算。 TrustZone 内核由 HLOS 调用，并在成功时直接通知调制解调器。
- 7.2 firmware authentication
- 在上一节中，我们看到了以 PBL 及其包含的证书作为信任根的经典信任链。如何在链元素之间准确处理身份验证是本节的主题。首先，我们展示了主要固件代码的认证，然后展示了认证 MBA 的差异。
- ***固件映像包含一系列证书（通常是三个）。其中第一个是使用最后一个引导加载程序阶段的密钥签名的。固件的所有内存部分都使用 SHA-256 算法进行散列（SHA-1 也已定义，但未在任何已经被分析过的固件中使用）然后将这些哈希值放在一个表中。它们与标题结构（table_header）一起构建实际签名的数据。此标头包括在哪里可以找到签名、映像大小和固件在内存中的目标地址的信息。该数据是固件元数据的一部分（步骤 5 和 6 固件的元数据经过哈希处理，并与固件映像中包含的证书的签名进行核对。在图 9 中）。然后再次对其进行哈希处理***
- 与密钥哈希消息认证码 (HMAC) 的构造类似的方案（有关通用方案和使用的名称，请参阅 [20]）在计算中包括两个标识号，在证书中找到：固件标识号 (SW_ID) 用作第一步中的密钥，与 ipad 常数进行异或运算，然后将 SoC 标识号 (MSM_ID) 与 opad 常数异或作为第二步中的密钥。为了验证，通过在固件证书 (pk_fw) 中应用公共 RSA 密钥并根据计算的哈希值检查结果来检查映像中的签名。整体方案可以概括为：
- ![](pic/2022-01-08-19-30-28.png)
- 为了检查实际的固件内存部分，已验证的为了检查固件的部分，将元数据中的经过验证的哈希与计算值进行比较。将表中的哈希值与每个部分的计算哈希值进行比较。请注意，除了上述经过身份验证的部分之外，元数据已经包含一个固件部分，即可执行和可链接格式 (ELF) 标头。这些也通过检查部分哈希值来验证。
- 来自 PBL 的 MBA 代码的验证以类似的方式处理。它的二进制文件还包含一个由前一阶段验证的证书链。但是，由于MBA只包含一个section，所以直接使用code数据来代替hash表。这与之前相同的标头结构一起被散列，并用作 HMAC 进程的输入。在此之后，以与之前相同的方式进行签名验证
- 7.2.1 Issues
- 使用的身份验证方法似乎设计得很好，因为它使用通用结构并建立在经过充分研究的密码算法之上。部署设备的问题来自另一个原因：疏忽大意的智能手机供应商。对于开发人员设备，可以通过一次性可编程 QFuse 中的设置禁用身份验证或将其配置为接受特殊开发证书。对于最终用户市场上的设备，制造商应该熔断这些保险丝（不可逆地编程），以便设备只接受正确签名的调制解调器固件。因此，这本身不是问题
- 但是，并非所有供应商都在其设备上激活身份验证机制，无论是通过 QFuse 中的设置还是通过修改 PBL 或 MBA。在 [11] 中，智能手机供应商发现 Icon 225 USB 调制解调器跳过了对 MBA 签名的检查。在这项工作中，由于主要负责安全性，并不是所有的人都激活了身份验证。在互联网论坛的匿名提示中，我们发现华硕的设备在这方面配置不安全。他们要么使用公开可用的开发密钥，要么根本不使用签名检查。其他供应商或至少其他供应商的某些设备可能是相同的。正如我们在本文的第三部分中讨论的那样，这允许修改固件。它为攻击者打开了大门，特别是调制解调器固件可以简单地从正在运行的 Android 系统中被覆盖（需要 root 访问权限），并将在下次启动时加载。另一方面，它会打开手机用于本文档中讨论的研究目的。
- 7.3 operating system
- ***从历史上看，Qualcomm 使用他们完全自主开发的操作系统 Rex，后来转而在 Open Kernel Labs [41] 的 OKL4 微内核之上使用 Rex 组件。然而，当高通的基带开始基于 Hexagon 时，该公司决定改用新实施的操作系统。它最初是作为 Blast 引入的，但后来被重命名为 Qualcomm 实时操作系统 (QuRT)，只有微小的变化。 Hexagon SDK 还包括此操作系统，用于在音频 DSP 上运行的用户应用程序。即使在 Hexagon 调制解调器固件中，仍然有很多字符串引用了旧的 Rex OS，清楚地表明了软基带运行在上面运行的 ware 堆栈的起源。***
- QuRT 是针对基带需求量身定制的实时操作系统。它提供通用的操作系统功能，从 DSP 硬件中抽象出来，包括：
- • 线程/任务管理 • 线程之间的通信和同步 • 缓存/翻译后备缓冲区 (TLB) 管理• 用户内存管理 • 中断和异常处理 • 定时器和系统时钟
- 在以下部分中，我们将详细回顾与本论文相关的操作系统的选定部分。
- 7.3.1 Tasks
- 为了支持多个任务，QuRT 包含（软件）线程。这些抽象自 Hexagon 的硬件线程（在第 6.1.4 节中介绍）。 QuRT 负责在有限的可用硬件线程上调度许多软件线程，类似于多核系统中的调度。优先级值确保需要快速完成的重要任务，例如 LTE 中的物理层处理，首先获得计算资源。此外，中断总是挂起处理当前调度任务集中具有最低优先级的任务的硬件线程，从而将可能的中断降至最低。
- QuRT 实现具有优先级的线程以支持由 init 系统初始化的多个任务。
- 系统启动后，QuRT 使用其 init 系统 rcinit 初始化并启动任务。它还能够启动尚未移植到 QuRT 实施的遗留 Rex 任务。
- 线程之间的同步是通过通常的方式提供的，包括互斥锁、信号量、屏障以及原子指令，以提高灵活性。任务可以休眠并等待其他组件的信号以触发其继续执行。还为每个任务分配了一个可读的名称。表 11 列出了在我们测试智能手机的基带（Asus PadFone Infinity 2，基带版本 M3.12.15）上启动的所有任务，这些任务是通过修改 rcinit 的任务创建函数并提取感兴趣的任务信息获得的。显示的是任务名称及其优先级，范围从 0（最低）到 255（最高）。显然，活动任务取决于调制解调器支持的功能，因此每个型号都不同。有关详细信息，附录 A.1 包含 rcinit 启动序列的列表，包括任务启动和线程创建。它允许观察各种任务的加载顺序，我们还可以猜测哪些线程与哪个任务相关联。我们看到为每个同名的任务创建一个主线程，一些任务从这个主线程产生更多线程，并且在运行时动态创建和销毁子线程，类似于通常的多线程程序。
- ![](pic/2022-01-08-19-58-15.png)
- 7.3.1.1 Inter Process Communication
- 不同任务之间的通信可以通过任务之间共享的内存区域并利用同步来实现访问它们的机制。但是，QuRT 还包括一些更高级的技术，总结在表 12 中
- ![](pic/2022-01-08-19-56-44.png)
- 使用前面介绍的信号机制，一个线程可以休眠并等待另一个线程的事件，而不消耗计算时间，将资源留给其他任务。因此，这个各种 IPC 对于事件通知很有用。如果数据量较大，则机制允许任务之间进行通信。以流模式到达，应该从一个发送者传输到一个接收者，QuRT 的管道是正确的选择。对于更复杂的通信方案，高通的固件实现了自己的进程间通信（IPC）路由器，基于操作系统提供的机制，但不是它的一部分。客户端可以向该路由器注册他们想要接收的消息类型。消息的发送者用一个识别号对其进行标记，这样类似的消息类型就会获得类似的 ID，因此，客户端也可以注册 ID 范围，以从模块或 LTE 等技术获取所有消息。消息的发送者不需要知道接收客户端，导致模块之间的松散耦合和被覆盖的点对多点方案。
- 7.3.2 Memory management
- QuRT 负责缓存和 TLB 管理以及从虚拟地址到物理地址的内存地址转换。对于它的用户代码，它以堆的形式提供内存管理，就像现在几乎所有的操作系统一样
- 一个名为 Data Services Memory (DSM) 池的实现扩展了内存管理方式。它是为灵活大小的内存分配量身定制的，除了经典的内存管理之外，还提供了随大小变化的分配，并可能在其生命周期内不持续增长，它为每个分配创建一个内存缓冲区链，以链表的形式实现。每当当前链的缓冲区已满时，就可以创建一个新的链元素来增加 DSM 链的容量。一个缺点是与连续分配的内存区域相比，访问速度稍慢，因为访问需要检查哪些数据字节驻留在哪个缓冲区中，并可能写入或读取多个缓冲区项，导致需要执行对每个项目进行一些绑定检查。请注意，即使对于大缓冲区分配，这种结构也可能是有利的，因为与单个大区域的要求相比，缓冲区只需要更小的内存部分。这允许堆更好地利用可用内存，并且在剩余内存有限的情况下，更有可能分配一组小的 DSM 缓冲区而不是一个大的连续块
- API 包括用于分配和释放元素、读取、写入和提取数据的基本功能以及更高级的功能，例如锁定访问以允许在多个线程之间共享 DSM 链
- ***7.4 security features***
- 在相关工作（第 2.1 节）中显示的严重的基带安全问题之后，例如在 [40] 中，Qualcomm 在 Hexagon 时代为其固件添加了攻击缓解技术
- 第 6.2.1 节的 XPU 强制执行内存访问权限，其规则取决于请求组件。它们在引导期间由 MBA 和 PBL 进行初始化，且该机制撤回所有主系统用于基带内存区域的所有权利。
- 用于生成固件映像的构建链分析所有函数并自动将堆栈金丝雀添加到可能包含堆栈缓冲区溢出的函数中：在系统启动期间选择随机金丝雀值。然后将其写入函数堆栈帧的最后一个元素，并在函数末尾进行验证。内存损坏的利用需要覆盖金丝雀值才能写入其他堆栈帧，例如，修改函数的返回地址。因此，如果攻击者不知道正确的金丝雀值，则会检测到堆栈修改并引发异常。在对高通固件进行逆向工程时，我们可以清楚地看到这种机制。
- 根据 [41] 中的 RP Weinmann，这些额外的安全措施存在： • 堆的安全unlink：防止利用堆溢出 • 通过不可执行的堆栈/堆（可选，OEM）防止数据执行可以决定） • 内核/用户模式分离（可选，OEM 可以决定）
- 7.5 communication with hlos(HLOS: High Level Operating System)
- 过去，调制解调器通过串行接口连接到主系统。为了控制调制解调器，使用了人类可读的 AT 命令（来自注意力），以美国信息交换标准代码 (ASCII) 编码。例如，命令 AT+CPIN=“1234” 将尝试使用 PIN 码 1234 解锁 SIM。数据通信也通过使用点对点协议 (PPP) 的这种串行链路进行处理。
- HLOS通过串行链路与调制解调器通信。在共享内存架构中，此行为被模拟。
- ***尤其是 AT 协议是一种相当低效的编码，例如一个简单的字节值最多使用三个字节，并且要对值进行编码，必须将其转换为 ASCII 字符串。因此，开发了更高效和灵活的协议，我们在第 7.5.2 节中回顾了高通的 QMI 协议。由于这些协议是专有的，我们将看到，出于遗留和兼容性的原因，在调制解调器中仍然实现了 AT 接口***
- ***5.1节展示了基带与主系统之间的通信是通过共享内存实现的，取代了物理串行链路。使用的协议栈中的较低层模拟类似于串行接口的行为。***
- 7.5.1 Protocol stack
- 表 13 概述了使用的协议及其分层。共享内存 (SMEM) 驱动程序提供对物理可用内存的访问。它实现对共享内存区域的分配和安全访问，注意两个实体之间不会发生访问冲突，通过共享内存进行通信。它还将地址从虚拟地址空间转换为共享内存区域所在的物理位置。原始内存的抽象是在多层中完成的，在顶层提供独立于实际连接的协议。
- 在这一层之上运行共享内存驱动程序 (SMD)。它提供独立的数据通道，由名称标识。它用于这些通道的 API 包括读取和写入串行数据流的功能，还支持数据包中的数据传输。
- 最后，用于不同目的的各种协议使用这些通道。例如，实现包括串行接口 (TTY) 仿真。通过使用它，调制解调器看起来就像在调制解调器和主处理器分离的架构中通过相同类型的串行接口连接。另一个协议示例是用于连接 GPS 系统的 NMEA 0183 实现，它看起来像典型的 GPS 接收器一样连接，标准驱动程序可用于处理其数据
- ***本论文最有趣的协议是高通 MSM 接口 (QMI)，用于向调制解调器发送命令。在实践部分，我们还使用它在 Android 内核和我们在调制解调器固件中注入的代码之间交换消息（第 10.1 节）。***
- 7.5.2 Qualcomm MSM Interface (QMI)
- ***QMI 协议包含三种类型的消息：请求、响应和指示。可以向服务发出请求，这些服务随后会以响应消息进行响应。当多个请求在短时间内发出，响应可能会以另一个顺序到达，但包含请求 ID 并且可以与之匹配。指示消息由服务发送而无需事先请求，以防发生特定事件，从而无需轮询状态更改。 ***
- QMI 是一种灵活协议支持不同的沟通模式  
- QMI可以广播到所有客户端或仅发送到支持不同通信模式的单协议客户端。在客户端可以访问服务之前，它必须在特殊控制服务 (CTL) 上分配一个 ID。在此之后，它可以将消息发送到实现不同功能的服务，例如设备管理服务 (DMS) 或网络访问服务 (NAS)。 [27]
- 请注意，根据使用的内核驱动程序，此注册可能在驱动程序内部实现，并且对使用 QMI 接口的代码透明地发生。此处使用的 Android 内核中的 Qual comm 的 QMI 驱动程序尤其如此。
- 一个 32 位服务 ID 和一个 32 位值，用于区分实现相同服务的不同实例，例如在调制解调器和音频处理系统等两个不同子系统中标识服务。这些应该是唯一的，但是，在第 10.1.2.1 节中，我们给出了一个实际示例，但情况并非如此。 QMI 消息中的参数可以是强制的，也可以是可选的，这也可以依赖于其他参数值。它们使用类型-长度-值 (TLV) 字段进行编码。
### 第八章逆向基带
- 由于高通调制解调器的内部结构是公司的机密，因此公开文档中只有很少的信息，或者可以从中获得信息。因此，剩余的信息需要通过逆向工程来获取。相关工作章节中介绍的先前项目的结果可以替代此逆向工程或至少提供一个起点。甚至旧调制解调器模型的工作也包括在此处，因为显然 Qual comm 的工程师不会在每次修订中从头开始重新设计整个调制解调器硬件和软件，而是重用设计的大部分。但是，我们必须验证设计方面是否仍然有效，如果没有，则分析它是如何变化的。
- ***我们使用多种技术对目标调制解调器系统进行逆向工程。检查相关的开源Android内核代码，可以研究一些方面。我们结合多个来源对调制解调器进行逆向工程。它们一起可以推断出呈现的结果。这方面的例子是调制解调器和 HLOS 之间的通信机制（第 7.5 节）以及固件加载方案（第 7.1 节），因为它们需要 Android 内核中的相应实现。固件加载程序，以及在十六进制编辑器中对原始固件映像的调查，分别是映像中包含的文件，允许导出所使用的固件格式（第 9.1 节），这是对调制解调器软件的所有进一步分析的先决条件和修改的关键。***
- ***了解固件格式后，我们可以将其转换为通用格式 (ELF)，从而允许使用完善的逆向工程工具，例如 IDA pro。在 6.1 节中，我们已经介绍了用于 IDA 的 Hexagon 处理器的可用插件。完善的技术随后允许分析固件。特别是，我们发现二进制文件中的字符串很有用，我们将在下一节中展示***
- ***此外，Qualcomm 还发布了针对 Hexagon DSP 的 SDK，以音频加速器上的用户应用程序为目标。由于它包含相同的操作系统，因此可以从 SDK 的代码中收集有关 QuRT 实时操作系统 (RTOS) 的信息。它还包含对开发修补框架很有用的构建工具的文档。***
- 这些是通过在特殊情况下使用的技术完成的，用于特定目的。一个例子是在补丁代码实现阶段对变量值的动态观察。允许简单的动态分析场景也是调制解调器内存访问补丁的目标（第 10.3 节）
- ***主要使用的静态技术可以概括为： • Android 内核代码分析（固件加载程序、QMI、...） • 原始二进制检查 • SDK 分析（QuRT、构建工具） • IDA 专业逆向工程 - 字符串分析 • 其他技术特殊用途***
- 8.1 string analysis
- ***在加载我们的目标设备 Asus PadFone Infinity 2 (A86) 的固件时，IDA 工具发现其中总共有 79,198 个字符串。其中一些是错误检测并且不包含有用的字符串。字符串的另一部分从未使用过，或者至少 IDA 找不到引用。尽管如此，仍有大量有用的字符串。***
- ***这些字符串包括文件和函数名称、作为文本表示的断言条件以及状态和错误信息。清单 1 给出了几个示例。第一个字符串是严重的错误信息。通过比较条件判断其何时被打印出来，我们可以在引用字符串的汇编代码中识别消息中引用的“payload_ptr”***
- 更有用的是清单中的第二个示例。它首先告诉它使用的函数是“CSF::CALLBACK”，我们可以将其识别为通道状态反馈回调的首字母缩写词，允许用有意义的名称标记函数。它还告诉我们现在“进入 csf 后处理”，那么该函数的以下代码在做什么。有了这些知识，我们也许还可以用名称标记几个被调用的函数，从而更好地了解固件的内部结构。格式字符串中的变量值输出允许标记变量列表（帧、子帧、carrier_index、sys_bandwidth、csf_config_flag），当我们将它们与传递给 print 函数的参数进行比较，以与字符串一起使用。这些可以存储在函数本地的寄存器或堆栈位置中，它们的识别极大地有助于理解目标汇编代码的目的和工作方式。如果变量甚至是全局变量，存储在系统范围的内存位置，它们还为分析进一步的函数提供信息。
- 清单 1 的最后一个示例只包含一个文件名。有趣的是，它包含构建系统上文件的完整路径。像这样的字符串允许知道周围代码来自哪个文件，并以此估计其用途。它们有助于减少代码量以在大型调制解调器代码中针对给定功能搜索正确的目标函数
- ![](pic/2022-01-08-21-00-52.png)
## 第九章修改固件
- 如第 1.2 节所述，这项工作的目的是修改调制解调器的固件，以扩展其功能、访问内部数据或发动攻击。我们必须修改二进制映像以实现所需的行为，因为调制解调器的源代码不公开。在这项工作的早期阶段，固件补丁首先是手工完成的，无论是在汇编程序中，还是在之前甚至直接计算指令的二进制编码并将它们放入二进制文件中。显然，这很耗时，并且仅适用于小补丁，例如更改字符串常量、重定向跳转到另一个函数或删除条件检查（例如删除 SIM 锁）。
- 简单地用高级语言编写并使用编译器是不可能的，因为代码必须与现有的固件二进制文件链接并集成到其中。此外，固件包含需要更正的校验值，如第 7.2 节所示。因此，除了代码编译步骤之外，我们还需要执行更多操作，我们将在 9.2 节中详细说明。
- 开发的框架允许使用用 C 编写的补丁来修改固件映像。
- 现在应该很明显，对于复杂的固件修改，需要一些比手动将补丁应用到二进制文件更复杂的解决方案。因此，受 nexmon 项目 [36] 的启发，我们使用 Python 脚本实现了一个补丁框架来实现自定义功能。 Makefile 控制构建过程并调用不同的工具（Hexagon 编译器、链接器等）和 Python 脚本。该框架包括以下补丁代码的主要功能：
- • 通过使用属性注释补丁代码函数来覆盖函数 
- • 使用属性将函数放置在指针表（例如处理程序调度表）中 
- • 调用固件的函数 
- • 通过使用自动生成的函数调用固件的原始（覆盖）函数以“FUNC_NAME_fw_org”形式命名（在第 9.2.3 节中解释）
- 为了启用这些功能，框架需要知道目标固件二进制文件中函数和其他符号（如字符串）的位置。这些可以在附加的固件包装头文件中指定，在第 9.2.2 节中我们提供了更多详细信息。
- ***不幸的是，不可能为打补丁的二进制文件生成有效的数字签名，需要通过第 7.2 节中描述的真实性检查。因此，该框架只能用于禁用此检查的智能手机（第 7.2.1 节）。***
- 9.1 firmware image format
- ***系统更新包中的一个特殊分区存储基带固件，并将基带固件存储在多个文件中，其基本上由 MBA 和实际固件的 ELF 文件和元数据组成。***
- ***使用文件分配表 16 (FAT16) 文件系统格式化的特殊分区存储调制解调器固件。系统更新包含此分区的映像文件，因此可以用作获取固件来源,该分区可以从正在运行的手机中读取或dump出来。我们的目标设备使用 64 MiB 大小。其他手机使用的容量略有不同，主要取决于其他子系统的固件文件也放在这个分区上。表 14 列出了它包含的调制解调器文件集及其用途***
- ![](pic/2022-01-09-10-34-29.png)
- 这些文件可以分为两类：Android 内核中固件加载器使用的元数据文件 (.mdt) 和包含正在加载到基带内存部分的实际内容的文件 (.bXX)。对于 MBA，仅使用一个内容文件。另一方面，实际固件使用 20 到 30 个文件，具体取决于调制解调器型号和启用的功能。这些文件中的每一个都包含 ELF 标头中指定的部分之一。标头还可以定义文件大小为零或内存大小大于节文件实际大小的节。然后加载程序用零字节初始化这些内存区域。
- 由于第一部分包含 ELF 标头，所有连接的内容文件都会生成固件的有效 ELF 文件（可能需要在文件之间填充字节）。
- 请注意，固件元数据文件等于前两个内容文件的串联，因此这些文件包含冗余信息。由于这些仅在固件加载时需要，因此前两个内容部分并未实际加载，文件是不需要的。它们只是高通内部固件构建过程的残余。另请参阅第 7.1 节以了解如何加载文件以及如何使用元数据。
- 9.2 patching process
- 固件修补分多个步骤完成，从基础映像开始，生成已准备好加载的修补映像。
1. 从映像文件中提取基本 ELF 二进制文件（第 9.2.1 节） 
2. 生成固件二进制包装文件（第 9.2.2 节） 
3. 分析补丁代码并创建所需的 fw_org 函数（第 9.2.3 节）
4. 编译补丁文件（第 9.2.4 节）
5. 将补丁代码文件和固件包装链接在一起（第 9.2.5 节）
6. 将（补丁）基础 ELF 文件与生成的补丁二进制文件合并（第 9.2.6 节）
7. 生成可以加载的图像文件（第9.2.7节）
- 如果之前已经执行了这些步骤之一并且输入文件没有更改，则不会再次执行。一个很好的例子是提取基本 ELF 文件，它只需要在第一次运行时完成。
- 除了（带注释的）补丁代码之外，该框架只需要固件映像文件和一个定义现有功能及其位置的包装器作为输入。为了分析源代码，该框架使用名为 pycparser [6] 的 C 语言解析器的 Python 实现，扩展名为 pycparserext [19]。对于 fw_org 函数的生成，需要使用 hexagondisasm 反汇编器 [26]，我们在第 9.2.3 节中对此进行了详细说明
- 由于框架的简单注解接口，步骤之间的交互以及在步骤之间传递的生成的中间文件是相当复杂的。图 10 说明了该过程和使用的文件。图中箭头上的数字是指上表中的步骤编号。表 15 详细说明了所有出现的文件的内容和用途。在这两者中，符号名称（全部大写）用于输入文件或名称取决于实际补丁项目的文件。
- ![](pic/2022-01-09-14-10-28.png)
- 该框架通过将原始函数的第一条指令替换为新函数的第一条指令的跳转指令来覆盖函数。因此，它破坏了原有的功能。如果我们仍然想使用旧功能，我们必须重新生成一个具有相同行为的fw_org 函数，我们在第 9.2.3 节中针对这个问题进行介绍。
- 覆盖函数的另一种方法是修补所有调用并使用新地址跳转到该函数。显然，这使旧功能保持不变，如果需要，仍然可以从补丁代码中调用它。但是，为此我们需要找到对该函数的所有调用。对于具有直接编码的目标地址的调用指令，这是可行的，另一方面，对于对存储在寄存器中的地址的调用，正确修补它们不再是微不足道的。例如，当在源代码中使用函数指针时，就会出现这种情况，这是调制解调器代码中广泛使用的一个特性。所选择的方法保证重定向所有发生的调用，而无需对这种情况进行特殊处理。
- 由于 Hexagon 的硬件线程交错执行，如第 6.1.4 节所示，处理器在加载插入的跳转指令之前完成所有先前的指令，并在加载该线程的下一条指令之前完成跳转指令。因此，与其他处理器设计相比，下一个程序计数器地址的计算已经完成，处理器可以加载正确的指令，而无需停止流水线或删除错误加载的指令。因此，跳转指令没有额外的流水线惩罚，插入跳转的总惩罚只有一个执行周期
- 9.2.1 Extracting the base firmware
- 作为第一步，框架从基础镜像中提取一个 ELF 文件。
- ***从系统更新文件或直接从手机获得的固件是分区映像，如第 9.1 节所示。我们还发现所有的 modem.bXX 文件一起形成了一个 ELF 文件。由于这是一个许多工具支持的标准文件格式，因此易于处理，框架执行的第一步是从基本固件生成这样的文件***
- 为了从图像中提取节文件，使用了 Unix 程序 mcopy（mtools 的一部分）。 Python 脚本 (blob-merge.py) 然后合并这些。该脚本从第一个节文件中读取 ELF 信息，然后通过将各个节文件内容写入读取的标头数据中指示的文件偏移量，将所有节组合到一个文件中。
- 修补框架使用的文件。首先列出输入文件，然后是中间文件，最后一个文件是输出图像。
- ![](pic/2022-01-09-14-24-20.png)
- 请注意，我们基于 [37] 中可用的 pil-splitter.py 脚本的脚本和 ELF 标头处理的想法，该脚本执行逆操作，从 ELF 文件中提取段文件。我们稍后也会使用这个脚本来生成第 9.2.7 节中的输出图像文件。
- 9.2.2 Firmware wrapper generation
- 上一步获得的二进制文件包含固件的所有（机器）代码，但没有关于这些指令集内的函数及其参数的信息。知道了函数的地址和参数，就可以直接调用这个地址，并将参数放在正确的位置。然而，这对于补丁代码编程器来说并不方便，而且由于调制解调器型号之间甚至同一调制解调器的不同固件版本之间的功能地址不同，因此该补丁无法移植并且只能与单个固件二进制文件一起使用
- 9.2.2.1 Purpose of the wrapper header
- 因此，有关二进制文件中现有函数的信息是存储在头文件（包装器）中。通过包含此标头，固件二进制文件中的函数可以像普通函数一样调用 C 代码：它们为编译器定义得很好。该框架还使用此文件来定义符号（名称到值/地址的映射） 对于函数并将它们提供给链接器，以便它可以解析调用这些函数的目标地址。我们给予更多 9.2.4 和 9.2.5 节中处理这些步骤的详细信息。 每个固件需要手动编写一次头文件 但是，在第 9.3 节中，我们展示了能够移植文件的脚本 自动从一个目标到另一个目标
- 该框架还使用此包装器来确定需要更改哪些指令（地址）以覆盖某个函数（第 9.2.6 节）并构造 fw_org 函数（第 9.2.3 节）。因此，固件映像文件本身和包装头是唯一的调制解调器和版本相关文件。只要在标头中声明了所有使用的固件功能，就可以为所有可用的目标处理补丁项目。请记住，固件的内部结构可能仍然不同，这意味着可用功能、它们的签名和它们的内部行为之间可能存在差异。因此，依赖于这种功能的补丁代码不再可移植，或者在特定目标上表现不同。幸运的是，我们发现观察到的高通固件非常相似，尤其是实际的移动通信堆栈实现似乎源自相同的代码库
- 9.2.2.2 Wrapper header content
- 包装器像通常的 C 声明一样存储函数信息，并带有额外的注释来定义内存地址。
- 与 C 语言中的常见头文件一样，固件包装器包含变量和函数及其签名（名称、参数和返回值）的声明。我们的框架扩展了__attribute__ 机制，用于代码注释，带有地址属性的 GNU C 的附加信息，以便定义函数的内存地址。清单 2 显示了一个示例来说明 this 的语法。为了进一步简化注释，我们在这里定义了一个宏 ADDRESS
- ![](pic/2022-01-09-14-35-42.png)
- 我们可以看到，这种方法使添加固件二进制所需数据的工作量很小。它将功能所需的所有信息编码在一起。相反，每个新固件都需要再次声明函数签名，这可以通过将位置数据和签名拆分到单独的文件中来避免。然而，我们仍然需要在地址文件中写入函数名称来识别符号，结果只有一点点优势。由于可用功能及其签名也可能在固件之间有所不同，如前所述（第 9.2.2.1 节），我们更喜欢另一种方法
- 请注意，包装头文件还可能包含其他头文件，例如按用途对函数声明进行分组。由于这只是预处理器处理的普通 C 包含，为了简单起见，我们可以将包装头视为单个文件。
- 除了函数和变量之外，补丁代码和数据段的基地址可以在包装器中通过声明伪（void）指针来定义，分别称为__patch_addr_text_base__，分别为__patch_addr_data_base__，使用与之前相同的注释方案来定义地址。
- 9.2.2.3 Wrapper processing
- 标头被转换为链接器脚本和 JSON 格式以供进一步处理。
- 从包装头文件生成两个文件作为稍后的处理步骤的输入。 fw_wrapper.lcs 文件是一个链接描述文件，其中包含从头文件中声明的所有函数和变量到附加属性中指定的地址的符号映射。传递给链接器的控制脚本可以直接包含此文件，因为符号定义是有效的链接器控制指令。
- 作为第二个文件，生成 symtab.json。它包含 JavaScript 对象表示法 (JSON) 格式的头文件的所有信息（名称、函数签名、地址）。它的唯一目的是简化后续步骤脚本中信息的读取，并避免再次缓慢解析代码的需要。它用于 fw_org 函数生成（第 9.2.3 节）
- create_wrapper_lcs.py 脚本对头文件进行此处理。它使用 Python C 解析器（pyc 解析器 [6] 和 pycparserext [19]）解析输入包装文件，然后以两个文件的格式写出数据。
- 9.2.3 准备：fw_org函数生成
- 在补丁过程的一般讨论中（第 9.2 节），我们已经看到了覆盖框架使用的函数的方法：函数的第一条指令被替换为补丁函数的跳转。显然，这将破坏原始函数，因为它的第一条指令丢失并且处理器将不再访问剩余的指令，至少只要代码源自标准 C 编译器并且不包含跳转到中间的功能。这似乎没问题，因为我们无论如何都想用新功能替换该功能，因此不再需要原始版本。
- 但是，在某些情况下，希望调用原始函数的版本。而不是完全改变一个函数，通常只是想为其添加一些功能。一个例子是向函数添加调用计数器。计数器必须在函数调用之后递增，函数的其余部分应该像之前的原始函数一样执行。另一个类似的情况可能是从生成器函数中检索加密密钥。在这里，我们首先要进行与原始函数相同的计算，然后对结果进行额外的处理。如果原始函数不再可用，我们必须重新实现它的完整行为，而不是在补丁函数中的所需位置调用旧代码。
- 作为一种解决方案，该框架提供了 fw_org 功能。这些再现了固件的原始（覆盖）函数的行为，因此可以在前面给出的示例中使用。通过简单地调用带有后缀 _fw_org 的原始函数名称的函数来使用它们。然后，框架将自动检测此调用并创建具有适当内容的所需函数
- 9.2.3.1 检测所需功能
- 这些 fw_org 函数的生成是相当复杂和缓慢的。因此，作为第一步，我们需要检测哪些是需要和应该生成的，而不是创建所有可能的。为此，使用先前用于包装头的 Python C 解析器（pycparser [6] 和 pycparserext [19]），框架解析代码并检查函数调用以查找以标识符前缀结尾的名称，从而生成所需的 fw_org 列表职能。
- 9.2.3.2 Function generation
- 为了重新生成原始函数的行为，我们生成一个新函数包含原始函数的第一条指令，然后跳转到原始代码序列的其余部分，因为重定向跳转仅破坏了前几条指令。
- Hexagon 上的跳转指令的目标地址相对于当前执行地址的范围是有限的。由于补丁代码位于与原函数不同的内存段，重定向跳转通常较远，其值大于此范围。因此，我们可能需要一个常量扩展器（第 6.1.3 节），并且总共需要修改原始函数的两条指令。
- 在重新生成函数的第一条指令时，拆分指令包（第 6.1.2 节）会导致未定义的行为。因此，总是需要复制完整的数据包。大多数情况下，只需要重新实现第一个数据包，仅当第一个数据包包含单个指令并且跳转需要常量扩展器时，才需要复制两个数据包。
- 由于指令可能包含调用或跳转的相对地址，并且它们将像以前一样被重新定位到 fw_org 函数中的另一个地址，因此只需复制二进制编码值就会改变它们的含义。作为解决方案， generate_fw_org_functions.py脚本将它们传递给反汇编器实现（可在 [26] 中获得），从而生成汇编器代码。该代码连同跳转到原始函数的第一个未更改数据包的第一条指令，然后在 fw_org C 函数的周围用作内联汇编器实现。
- 我们的脚本用符号替换其中的所有相对地址值。因此，链接器将根据指令的最终位置来纠正这些值。当距离现在太远而无法在指令立即字段中编码时，它还将通过创建跳转到另一个位置来处理问题，在该位置它有足够的空间将跳转指令与常量扩展器（即所谓的“蹦床”）一起放置。
- 列表3 显示了一个生成的 fw_org 函数实现的示例。在第 3 行，我们看到一个相对地址被一个符号替换，而在第 6 行是跳转到剩余的原始函数代码。请注意，C 编译器将在此跳转后生成一个函数返回，该函数将永远无法到达。而是函数以原代码的返回指令结束，直接跳转回C函数的调用指令
- ![](pic/2022-01-09-15-44-20.png)
- 这些函数被写入 fw_org_functions.c 文件，它们的签名声明在相应的头文件 (fw_org_functions.h) 中可用。在内联汇编代码中出现的符号定义在 fw_org_functions.lcs 中生成，该文件与 fw_wrapper.lcs 文件具有相同的格式，因此也可以直接用作链接器的输入。
- 9.2.4 Compiling
- 接下来，框架单独编译所有源代码文件，所有的函数调用现在已经为这一步很好地声明了，固件中的函数在包装头文件中给出，上一步生成的头文件包含 fw_org 函数。除了补丁代码文件之外，fw_org_functions.c 文件中原始固件功能的生成代码也被编译。为此，我们从可用的 SDK [28] 中调用 Qualcomm 的 Hexagon 编译器，提供一组目标文件作为输出
- 请注意，我们忽略了自定义函数注释以覆盖此步骤中的函数（稍后我们将展示这些函数的工作原理）。这些仅影响补丁代码与基本固件文件的组合，而不影响编译过程。
- 9.2.5 Linking
- ***各个目标文件需要组合成一个二进制文件。这是通过将它们传递给链接器来完成的，同样，我们利用了来自 SDK [28] 的 Qualcomm 自己的实现。除目标文件外，框架还将前面步骤中生成的链接器文件传递给工具，定义 fw_org 函数和基本固件二进制文件所需的符号。***
- The main work done by the linker can be summarized as:
- 通常的链接过程：将目标文件链接在一起，用其他文件中定义的符号解析未定义的符号（例如，其他文件中的函数调用，数据引用）
- 使用 fw_wrapper.lcs 中的符号定义解决对固件函数的调用和对基本固件数据的引用
- 使用 fw_org_functions.lcs 中的符号定义解析 fw_org 函数的内联汇编代码中使用的符号
- 因此，链接器会生成一个包含所有 ELF 格式 (fw_patch.elf) 的补丁代码和数据部分的文件。该文件不再包含未定义的符号引用，其中的功能是最终版本，以后的步骤将不再更改
- 9.2.6 Patching
- 补丁代码最终形成后，需要与基础固件结合。因此，我们必须合并两个 ELF 文件的部分。此外，需要更改基本固件代码以覆盖功能。然后，此步骤会生成一个修补固件 ELF (patched.elf) 文件，其中包含所有最终调制解调器指令和数据
- 9.2.6.1 源代码注释
- 对于覆盖函数，框架的补丁过程需要知道哪个补丁代码应该替换基础固件中的哪个函数。为了使这尽可能简单，该框架使用的机制类似于固件包装头中基本固件功能的地址规范。要指定函数替换，可以使用属性注释补丁函数以覆盖另一个函数。此注释包括目标函数作为参数。
- 补丁步骤合并补丁代码和基础固件。它由补丁代码中的注释指示，例如覆盖函数
- 列表4 显示了如何定义函数 mem set_hook 以便它替换基本固件的函数 memset（第 1 到 5 行）的示例。第 7 到 19 行使用了框架中包含的另一个特性，pointer_table 属性。它允许在函数指针表中直接放置指向函数的指针。该方案通常用于处理函数，根据消息类型将进一步的消息处理分派给下一个函数，使用此值作为包含处理函数的指针表的索引。它需要表格基础和偏移值作为参数。请注意，补丁还使用它通过使用零偏移量来替换简单的函数指针（不在表内）。
- ![](pic/2022-01-09-15-58-12.png)
- 9.2.6.2 Generation of a list of required patches
- 9.2.6.3 ELF section combination
- 9.2.6.4 Other binary patches
- 9.2.7 Image generation