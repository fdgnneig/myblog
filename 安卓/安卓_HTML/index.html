<!doctype html><html>
    <head>
      <meta http-equiv="content-type" content="text/html; charset=utf-8">
      <title>sqliteNoteBook.ctb</title>
      <meta name="generator" content="CherryTree">
      <link rel="stylesheet" href="res/styles3.css" type="text/css" />
    </head>
    <body><div class='page'><h1 class='title level-1'>安卓</h1><br/><br /></div><div class='page'><h1 class='title level-2'>apk安装过程</h1><br/><h1>本文的源码是基于Android6.0</h1><br /><br /><h1>APK安装的预备知识点</h1><br /> （1）PackageManagerService是由SystemServer启动，PMS负责应用的安装、卸载、权限检查等工作<br /> （2）在/system/app和/data/app目录下的apk文件，PMS在启动过程中，都会扫描安装<br /> （3）每次开机时，PMS都会在构造函数中对指定目录下的apk进行扫描，没有安装的apk就会触发安装。<br /><br /><br /><h1>APK安装涉及到的几个常用目录</h1><br />system/app ： 系统自带的应用程序，获得root权限才能删除<br /> data/app ： 用户程序安装目录，安装时会把apk文件复制到此目录下<br /> data/data ： 存放应用程序的数据<br /> data/dalvik-cache ： 将apk中的dex文件安装到该目录下（dex文件是dalvik虚拟机的可执行文件，大小约为原始apk的四分之一）<br />APK安装的四大步骤<br /> （1）拷贝apk到指定的目录<br /> 默认情况下，用户安装的apk首先会拷贝到/data/app下，用户有访问/data/app目录的权限（系统出厂的apk文件会被放到/system分区下，括/system/app，/system/vendor/app，以及/system/priv-app等。该分区需要<br /> root权限的用户才能访问）<br /> <br /> （2）加载apk、拷贝文件、创建应用的数据目录<br /> 为了加快APP的启动速度，apk在安装的时候，会首先将APP的可执行文件（dex）拷贝到/data/dalvik-cache目录下，缓存起来。再在/data/data/目录下创建应用程序的数据目录（以应用包名命名），用来存放应用的数据库、xml文件、cache、二进制的so动态库等。<br /> <br /> （3）解析apk的AndroidManifest.xml文件<br /> 在安装apk的过程中，会解析apk的AndroidManifest.xml文件，将apk的权限、应用包名、apk的安装位置、版本、userID等重要信息保存在/data/system/packages.xml文件中。这些操作都是在PackageManagerService中完成的。<br /> <br /> （4）显示icon图标<br /> 应用程序经过PMS中的逻辑处理后，相当于已经注册好了，如果想要在Android桌面上看到icon图标，则需要Launcher将系统中已经安装的程序展现在桌面上。<br /><br />作者：深色星空<br />链接：https://www.jianshu.com/p/22594204eb8f<br />来源：简书<br />著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br /></div><div class='page'><h1 class='title level-2'>app数据库（sqlite）分析</h1><br/>车机系统中的sqllite可以看到很多数据，包括apk包与汽车具体应用名称的对应<br /><br />使用navicat查看安卓中的sqlite数据库<br /><a href=""><img src="images\43-1.png" alt="images\43-1.png" /></a><br /><br />navicat破解<br /><a href="https://www.cnblogs.com/kkdaj/p/12794804.html">https://www.cnblogs.com/kkdaj/p/12794804.html</a><br /><br />可以使用db-browser查看数据库<br />可以使用sqlitestdio查看数据库中内容<br />	</div><div class='page'><h1 class='title level-2'>HOOK</h1><br/><br /></div><div class='page'><h1 class='title level-3'>frida</h1><br/>frida<br /><a href="https://www.jianshu.com/p/c349471bdef7">Frida详细安装 - 简书 (jianshu.com)</a><br /><a href="https://eternalsakura13.com/2020/07/04/frida/">Frida Android hook | Sakuraのblog (eternalsakura13.com)</a><br /><a href="https://www.52pojie.cn/thread-611938-1-1.html">Frida使用和Hook代码整理 - 『移动安全区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn</a><br /><a href="https://www.cnblogs.com/luoyesiqiu/p/10718997.html">frida的用法--Hook Java代码篇 - luoyesiqiu - 博客园 (cnblogs.com)</a><br /><a href="https://zhuanlan.zhihu.com/p/41662447">详解Hook框架frida，让你在逆向工作中效率成倍提升 - 知乎 (zhihu.com)</a><br />安装<br /><a href="https://www.cnblogs.com/action-go/p/11652399.html">Firda入门 - action555 - 博客园 (cnblogs.com)</a><br />编写python脚本<br /><a href="https://www.jianshu.com/p/ca8381d3e094">Android逆向之hook框架frida篇 - 简书 (jianshu.com)</a><br />优秀教程<br /><a href="https://www.cnblogs.com/luoyesiqiu/p/10718997.html">frida的用法--Hook Java代码篇 - luoyesiqiu - 博客园 (cnblogs.com)</a><br />frida系列教程<br /><a href="https://github.com/r0ysue/AndroidSecurityStudy#opposrc%E6%9D%A5%E8%87%AA%E9%AB%98%E7%BA%AC%E7%9A%84%E5%AF%B9%E6%8A%97%E7%B3%BB%E5%88%97">r0ysue/AndroidSecurityStudy: 安卓应用安全学习 (github.com)</a><br /><a href="https://www.secpulse.com/archives/132082.html">Frida Java Hook 详解（安卓9）：代码及示例（上） - SecPulse.COM | 安全脉搏</a><br /><a href="https://www.secpulse.com/archives/132777.html">Frida Java Hook 详解（安卓9）：代码及示例（下） - SecPulse.COM | 安全脉搏</a><br /><a href="https://mp.weixin.qq.com/s/mvTxwQdX9n9e_m-Kar7OyQ">Android逆向之旅---Hook神器家族的Frida工具使用详解 (qq.com)</a><br /><br />pip安装卸载与更新<br />pip install frida==11.0.13<br />pip install prompt-toolkit==1.0.15<br /><a href="https://www.cnblogs.com/xiexiaoxiao/p/7147920.html">python pip ,安装，卸载，查看等命令，不同版本 - x.cube - 博客园 (cnblogs.com)</a><br />安装指定版本<br />		pip install SomePackage           # latest version<br />		pip install SomePackage==1.0.4     # specificversion<br />		pip install &#39;SomePackage&gt;=1.0.4&#39;     #minimum version<br /><br />关于frida的安装<br />pip install frida<br />	安装最新版<br />pip install frida==xxxx<br />	安装指定版本<br />pip uninstall frida ==xxx<br />	卸载指定版本的frida<br />frida --version<br />	查看当前frida版本，确定是否安装正确<br />对应版本的服务端上传到要hook的安卓机器中，设置执行权限，以root开始执行<br />	没有错误回显说明运行正常，如果存在错误回显，则可能frida版本过高，考虑使用低版本<br /><a href="https://www.freebuf.com/column/232055.html">Brida Python3环境下的不完全折腾手册 - FreeBuf网络安全行业门户</a><br />	</div><div class='page'><h1 class='title level-4'>安装</h1><br/>python<br />	<a href="https://www.python.org/downloads/windows/">Python Releases for Windows | Python.org</a><br />frida相关软件源<br />	<a href="https://pypi.tuna.tsinghua.edu.cn/simple/frida/">Links for frida (tsinghua.edu.cn)</a><br /><br />C:\Users\zhuyupeng&gt; easy_install D:\Program Files\Python2.7\lxml-2.3.py2.7.win32.egg<br /><br />Windows环境<br />Windows环境下需要进入安装步骤中的安装路径，如C:\Users\[用户名]\AppData\Local\Programs\Python\Python37<br />在此处打开命令行，输入命令：<br />C:\Users\xx\AppData\Local\Programs\Python\Python37&gt;.\Scripts\easy_install.exe C:\Users\xx\Downloads\frida-12.8.17-py3.7-win-amd64.egg<br /><br />不要安装以下命令，会导致frida被更新<br />安装Frida。安装成功后，输入.\Scripts\pip.exe install frida-tools来安装Frida-tools。<br /><br />成功经验<br />frida安装<br />	Brida Python3环境下的不完全折腾手册<br />		<a href="https://www.freebuf.com/column/232055.html">Brida Python3环境下的不完全折腾手册 - FreeBuf网络安全行业门户</a><br />测试frida<br />	Frida Java Hook 详解（安卓9）：代码及示例（上）<br />		<a href="https://www.secpulse.com/archives/132082.html">Frida Java Hook 详解（安卓9）：代码及示例（上） - SecPulse.COM | 安全脉搏</a><br />	frida的用法--Hook Java代码篇<br />		<a href="https://www.cnblogs.com/luoyesiqiu/p/10718997.html">frida的用法--Hook Java代码篇 - luoyesiqiu - 博客园 (cnblogs.com)</a><br />可行的frida和python搭配<br />	frida：11.0.13  python 3.6.6<br />frida-server下载<br />	<a href="https://github.com/frida/frida/releases">Releases · frida/frida (github.com)</a></div><div class='page'><h1 class='title level-4'>从零开始安卓hook</h1><br/><a href="https://mp.weixin.qq.com/s/0hdhEhCAr0sao88AzSC_bw">https://mp.weixin.qq.com/s/0hdhEhCAr0sao88AzSC_bw</a><br /><a href=""><img src="images\827-1.png" alt="images\827-1.png" /></a><br /><br />相关代码<br /><div class="codebox"><div class="codebox"><br />public&nbsp;class&nbsp;MainActivity&nbsp;extends&nbsp;AppCompatActivity&nbsp;{<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;onCreate(Bundle&nbsp;savedInstanceState)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MainActivity.super.onCreate(savedInstanceState);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setContentView(R.layout.activity_main);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(true)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread.sleep(500);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(InterruptedException&nbsp;e)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fun(50,&nbsp;30);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;fun(int&nbsp;x,&nbsp;int&nbsp;y)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Log.d(&quot;Sum&quot;,&nbsp;String.valueOf(x&nbsp;+&nbsp;y));<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />}<br /></div></div><br /><div class="codebox"><div class="codebox"><br />Java.perform(function(){<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;当JAVA环境存在时回调函数<br />&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;MainActivity&nbsp;=&nbsp;Java.use(&quot;com.example.myapplication.MainActivity&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;获取MainActivity这个类<br />&nbsp;&nbsp;&nbsp;&nbsp;MainActivity.fun.implementation&nbsp;=&nbsp;function(x,y){<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;修改MainActivity类中fun这个函数的实现<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(&quot;fun(&quot;+x+&quot;,&nbsp;&quot;+y+&quot;)&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;在控制台中打印一条日志，内容为原来的参数<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;ret&nbsp;=&nbsp;this.fun(2,3);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;调用自身，将参数修改为2和3，并获取返回值<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;这里的this是指MainActivity这个类<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;ret;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;传送返回值<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />})</div></div><br /><br /><br /><br /><div class="codebox"><div class="codebox"><br />public&nbsp;class&nbsp;MainActivity&nbsp;extends&nbsp;AppCompatActivity&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;AesUtils&nbsp;aesUtils;<br />&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;String&nbsp;savedPassword;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;@Override<br />&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;void&nbsp;onCreate(Bundle&nbsp;savedInstanceState)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super.onCreate(savedInstanceState);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setContentView(R.layout.activity_main);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TextView&nbsp;password&nbsp;=&nbsp;findViewById(R.id.password);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EditText&nbsp;input&nbsp;=&nbsp;findViewById(R.id.input);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Button&nbsp;button&nbsp;=&nbsp;findViewById(R.id.button);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;secret&nbsp;=&nbsp;AesUtils.getRandom(4);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;key&nbsp;=&nbsp;AesUtils.getRandom(16);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;aesUtils&nbsp;=&nbsp;new&nbsp;AesUtils(key);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;savedPassword&nbsp;=&nbsp;aesUtils.encrypt(secret);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;password.setText(savedPassword);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;button.setOnClickListener(new&nbsp;View.OnClickListener()&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Override<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;onClick(View&nbsp;v)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;testPassword&nbsp;=&nbsp;aesUtils.encrypt(input.getText().toString());<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(savedPassword.equals(testPassword)){<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Toast.makeText(getApplicationContext(),&quot;正确！&quot;,Toast.LENGTH_SHORT).show();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Toast.makeText(getApplicationContext(),&quot;错误！&quot;,Toast.LENGTH_SHORT).show();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />}</div></div><br /><br /><div class="codebox"><div class="codebox">public&nbsp;class&nbsp;AesUtils&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;String&nbsp;key;<br />&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;final&nbsp;String&nbsp;DATA&nbsp;=&nbsp;&quot;0123456789abcdefghijklmnopqrstuvwxyz&quot;;<br />&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Random&nbsp;RANDOM&nbsp;=&nbsp;new&nbsp;Random();<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;AesUtils(String&nbsp;key)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.key&nbsp;=&nbsp;key;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;String&nbsp;encrypt(String&nbsp;text)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte[]&nbsp;result&nbsp;=&nbsp;this.encrypt(this.key,&nbsp;text);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;String(Base64.encode(result,&nbsp;Base64.DEFAULT));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(Exception&nbsp;e)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;null;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;String&nbsp;decrypt(String&nbsp;text)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte[]&nbsp;cipher&nbsp;=&nbsp;Base64.decode(text,&nbsp;Base64.DEFAULT);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte[]&nbsp;res&nbsp;=&nbsp;this.decrypt(cipher,this.key);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;String(res,&nbsp;&quot;utf-8&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(Exception&nbsp;e)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;null;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;String&nbsp;getRandom(int&nbsp;len)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringBuilder&nbsp;sb&nbsp;=&nbsp;new&nbsp;StringBuilder(len);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;len;&nbsp;i++)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sb.append(DATA.charAt(RANDOM.nextInt(DATA.length())));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;sb.toString();<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;byte[]&nbsp;encrypt(String&nbsp;password,&nbsp;String&nbsp;clear)&nbsp;throws&nbsp;Exception&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SecretKeySpec&nbsp;secretKeySpec&nbsp;=&nbsp;new&nbsp;SecretKeySpec(password.getBytes(),&nbsp;&quot;AES/CBC/PKCS5PADDING&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cipher&nbsp;cipher&nbsp;=&nbsp;Cipher.getInstance(&quot;AES&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cipher.init(Cipher.ENCRYPT_MODE,&nbsp;secretKeySpec);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;cipher.doFinal(clear.getBytes(&quot;UTF-8&quot;));<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;byte[]&nbsp;decrypt(byte[]&nbsp;content,&nbsp;String&nbsp;password)&nbsp;throws&nbsp;Exception&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SecretKeySpec&nbsp;key&nbsp;=&nbsp;new&nbsp;SecretKeySpec(password.getBytes(),&nbsp;&quot;AES/CBC/PKCS5PADDING&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cipher&nbsp;cipher&nbsp;=&nbsp;Cipher.getInstance(&quot;AES&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cipher.init(Cipher.DECRYPT_MODE,&nbsp;key);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;cipher.doFinal(content);<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />}</div></div><br /><br /><div class="codebox"><div class="codebox"><br />Java.perform(function(){<br />&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;AesUtils&nbsp;=&nbsp;Java.use(&quot;com.example.myapplication.AesUtils&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;AesUtils.getRandom.implementation&nbsp;=&nbsp;function(x){<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;ret&nbsp;=&nbsp;this.getRandom(x);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(&quot;[call]&nbsp;AesUtils.getRandom(&quot;+x+&quot;)&nbsp;-&gt;&nbsp;&quot;+ret);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;ret;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />}</div></div><br /><br /><div class="codebox"><div class="codebox"><br />Java.perform(function(){<br />&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;AesUtils&nbsp;=&nbsp;Java.use(&quot;com.example.myapplication.AesUtils&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;AesUtils.getRandom.implementation&nbsp;=&nbsp;function(x){<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;ret&nbsp;=&nbsp;this.getRandom(x);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(&quot;[call]&nbsp;AesUtils.getRandom(&quot;+x+&quot;)&nbsp;-&gt;&nbsp;&quot;+ret);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;ret;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;AesUtils.encrypt.overload(&#39;java.lang.String&#39;).implementation&nbsp;=&nbsp;function(x){<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;ret&nbsp;=&nbsp;this.encrypt(x);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(&quot;[call]&nbsp;AesUtils.encrypt(&quot;+x+&quot;)&nbsp;-&gt;&nbsp;&quot;+ret);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;ret;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;Java.choose(&quot;com.example.myapplication.MainActivity&quot;,&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;onMatch:function(instance){<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(&quot;[Java.choose&nbsp;MainActivity]&nbsp;&quot;+instance);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;savedPassword&nbsp;=&nbsp;instance.savedPassword.value;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(&quot;[savedPassword]&nbsp;&quot;+savedPassword);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java.choose(&quot;com.example.myapplication.AesUtils&quot;,&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;onMatch:function(instance){<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(&quot;[Java.choose&nbsp;AesUtils]&nbsp;&quot;+instance);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;key&nbsp;=&nbsp;instance.key.value;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(&quot;[AesUtils.key]&nbsp;&quot;+key);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;secret&nbsp;=&nbsp;instance.decrypt(savedPassword);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(&quot;[secret]&nbsp;&quot;+secret);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;onComplete:function()&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(&quot;[Java.choose&nbsp;AesUtils]&nbsp;end&quot;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;onComplete:function()&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(&quot;[Java.choose&nbsp;MainActivity]&nbsp;end&quot;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;});<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />})</div></div><br /><br /></div><div class='page'><h1 class='title level-3'>xposed</h1><br/><a href=""><img src="images\244-1.png" alt="images\244-1.png" /></a></div><div class='page'><h1 class='title level-4'>安装</h1><br/><a href=""><img src="images\245-1.png" alt="images\245-1.png" /></a><br /></div><div class='page'><h1 class='title level-4'>原理研究</h1><br/>·<br /><a href=""><img src="images\384-1.png" alt="images\384-1.png" /></a></div><div class='page'><h1 class='title level-2'>JVM Dalvik VM的不同</h1><br/><a href=""><img src="images\321-1.png" alt="images\321-1.png" /></a></div><div class='page'><h1 class='title level-2'>NDK开发</h1><br/>部分资料可见麦洛科菲的ndk开发、看雪高研ndk开发<br /></div><div class='page'><h1 class='title level-3'>JavaVM和JNIEnv</h1><br/>在c和c++中JavaVM以及JNIEnv指向不同的结构体<br /><a href=""><img src="images\590-1.png" alt="images\590-1.png" /></a><br /><br /><a href=""><img src="images\590-2.png" alt="images\590-2.png" /></a><br /><br /><a href=""><img src="images\590-3.png" alt="images\590-3.png" /></a></div><div class='page'><h1 class='title level-4'>JavaVM</h1><br/><a href=""><img src="images\602-1.png" alt="images\602-1.png" /></a><br /><br /><a href=""><img src="images\602-2.png" alt="images\602-2.png" /></a><br /><br />c++中JavaVM指向的结构体存在以下函数其中GetEnv是常用的函数<br />如果当前为主线程，则直接使用GetEnv可以获得JNIEnv<br />如果当前线程为新创建的线程，则需要先执行AttachCurrentThread函数，将当前线程附加到JVM<br />然后执行GetEnv可以获得JNIEnv<br /><a href=""><img src="images\602-3.png" alt="images\602-3.png" /></a><br /><br /><br />c中<br />暂略<br /><br />注意无论是c或c++中JavaVM共仅有该5个api可供使用<br /><br /><br /><br /></div><div class='page'><h1 class='title level-4'>JNIEnv</h1><br/><a href=""><img src="images\603-1.png" alt="images\603-1.png" /></a><br /><br /><a href=""><img src="images\603-2.png" alt="images\603-2.png" /></a><br /><br />c++中JNIEnv指向的结构体定义了大量的函数，即jni接口<br /><a href=""><img src="images\603-3.png" alt="images\603-3.png" /></a><br />使用c++编写jni<br /><a href=""><img src="images\603-4.png" alt="images\603-4.png" /></a><br /><br /><br /><br />c中JNIEnv指向的函数结构体<br />与c++不同之处在于第一个参数必须为JNIEnc指针<br /><a href=""><img src="images\603-5.png" alt="images\603-5.png" /></a><br /><br />使用c语言编写jni<br /><a href=""><img src="images\603-6.png" alt="images\603-6.png" /></a><br /><br /><a href=""><img src="images\603-7.png" alt="images\603-7.png" /></a><br /><br />JNIEnv获取<br /><a href=""><img src="images\603-8.png" alt="images\603-8.png" /></a><br /><br />注意事项<br /><a href=""><img src="images\603-9.png" alt="images\603-9.png" /></a><br /><br /><a href=""><img src="images\603-10.png" alt="images\603-10.png" /></a><br /><br /><a href=""><img src="images\603-11.png" alt="images\603-11.png" /></a><br /><br />为解决子线程中获得的JNIEnv无法通过FindClass获得主线程中的类，有两种共解决方案<br />1、主线程中保存一份全局classloader，方便子线程使用<br />2、主线程中使用到指定类时，保存一份为全局变量，方便子线程使用</div><div class='page'><h1 class='title level-3'>JAVA反射</h1><br/><a href=""><img src="images\592-1.png" alt="images\592-1.png" /></a><br />针对任意类-》获得该类的所有方法和属性<br />针对任意类的静态方法-》获得并设置静态属性，调用静态方法<br />对于任意对象-》调用任意方法和属性，包含私有方法与属性<br /><br /><a href=""><img src="images\592-2.png" alt="images\592-2.png" /></a><br /><br />java反射使用到的类<br /><a href=""><img src="images\592-3.png" alt="images\592-3.png" /></a><br /><br />class类：通过loadClass和forName两个函数可以对类进行加载或针对已经加载的类进行查询<br /><a href=""><img src="images\592-4.png" alt="images\592-4.png" /></a><br /><br /><a href=""><img src="images\592-5.png" alt="images\592-5.png" /></a><br /><br /><a href=""><img src="images\592-6.png" alt="images\592-6.png" /></a><br /><br /><a href=""><img src="images\592-7.png" alt="images\592-7.png" /></a><br /><br /><a href=""><img src="images\592-8.png" alt="images\592-8.png" /></a><br /><br /><a href=""><img src="images\592-9.png" alt="images\592-9.png" /></a><br /><br />field类<br />对于静态field，访问时无需传入Object obj参数，设置为null即可<br /><a href=""><img src="images\592-10.png" alt="images\592-10.png" /></a><br /><br />Method类<br />对于静态函数，调用时不用object，该参数为null即可<br /><a href=""><img src="images\592-11.png" alt="images\592-11.png" /></a><br /><br />Constructor类<br /><a href=""><img src="images\592-12.png" alt="images\592-12.png" /></a><br /><br /><br />AccessibleObject类（实现通过反射访问私有类域）<br />注意访问一个类私有的属性或方法时，需要使用setAccessible函数设置权限为true<br /><a href=""><img src="images\592-13.png" alt="images\592-13.png" /></a><br /><a href=""><img src="images\592-14.png" alt="images\592-14.png" /></a><br />field类继承自AccessibleObject <br /><a href=""><img src="images\592-15.png" alt="images\592-15.png" /></a><br /><br />Method归根也继承自AccessibleObject类<br /><a href=""><img src="images\592-16.png" alt="images\592-16.png" /></a><br /><a href=""><img src="images\592-17.png" alt="images\592-17.png" /></a><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /></div><div class='page'><h1 class='title level-4'>代码实例</h1><br/>三种获取类的方法，前两种使用反射（loadClass、forName）最后一种因为Test与MainActivity在同一个包下，所以直接使用<br /><a href=""><img src="images\593-1.png" alt="images\593-1.png" /></a><br /><br />进一步代码查看看雪高研ndk开发课时3<br />JNI中访问java类中的方法和属性，流程与java反射相同<br /></div><div class='page'><h1 class='title level-3'>java反射与jni反射区别</h1><br/><a href=""><img src="images\608-1.png" alt="images\608-1.png" /></a></div><div class='page'><h1 class='title level-3'>java中加载so文件</h1><br/>加载so文件的两个api <br />loadLibrary<br />load<br />前者仅需指定native-lib即可<br />后者需要so文件的绝对路径<br /><a href=""><img src="images\601-1.png" alt="images\601-1.png" /></a><br /></div><div class='page'><h1 class='title level-3'>JNIOnload</h1><br/><a href=""><img src="images\600-1.png" alt="images\600-1.png" /></a><br /><br />执行时间早于所有jni中的函数，一般在该函数中完成变量初始化、动态函数注册等，返回值为JNI具体版本号<br /><br />当so文件被加载后，会由art查询so文件的导出符号表，之后进行调用<br /><br /><a href="安卓--NDK开发--java中加载so文件.html">so文件加载</a><br /><br />仅使用静态注册函数的so文件中没有JNIOnload函数<br /><br />jni.h中存在该函数声明，该两个函数实现在so文件中并导出<br /><a href=""><img src="images\600-2.png" alt="images\600-2.png" /></a><br /><br />so文件中初步实现的JNIOnload函数，仅返回当前JNI版本<br /><a href=""><img src="images\600-3.png" alt="images\600-3.png" /></a><br /><br /></div><div class='page'><h1 class='title level-3'>JNI创建java对象并访问属性</h1><br/>有两种方式创建对象<br /><a href=""><img src="images\605-1.png" alt="images\605-1.png" /></a><br /><br />~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br /><br />访问java类属性<br />访问静态类属性<br />获取共有静态属性<br /><a href=""><img src="images\605-2.png" alt="images\605-2.png" /></a><br /><br />获取私有静态属性<br />注意JNI中通过反射获取类私有属性的过程与java中通过反射获取类私有属性不同，<br />后者需要通过setAccessible函数设置权限后才能获取私有属性<br /><a href=""><img src="images\605-3.png" alt="images\605-3.png" /></a><br /><br />修改静态属性<br /><a href=""><img src="images\605-4.png" alt="images\605-4.png" /></a><br /><br />JNI提供的获取类属性的部分api，注意获得类属性时，api第一个参数为jclass clazz，表示类<br /><a href=""><img src="images\605-5.png" alt="images\605-5.png" /></a><br /><br />~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br /><br />访问对象属性（与获取类属性不同，关键在于此时使用GetObjectField函数，该函数获取对象属性）<br />访问对象私有属性<br /><a href=""><img src="images\605-6.png" alt="images\605-6.png" /></a><br />修改对象私有属性<br /><a href=""><img src="images\605-7.png" alt="images\605-7.png" /></a><br /><br />获取类对象的数组属性并遍历<br /><a href=""><img src="images\605-8.png" alt="images\605-8.png" /></a><br /><br />修改类对象的数组属性并遍历<br /><a href=""><img src="images\605-9.png" alt="images\605-9.png" /></a><br /><br />jni中修改对象属性的部分函数，主要当修改对象属性时，函数第一个参数为jobject obj，表示类对象<br /><a href=""><img src="images\605-10.png" alt="images\605-10.png" /></a><br /><br /><br /><br /><br /><br /><br /><br /></div><div class='page'><h1 class='title level-3'>JNI访问java函数</h1><br/><a href=""><img src="images\607-1.png" alt="images\607-1.png" /></a><br /><br />~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br /><br />访问构造函数<br /><a href=""><img src="images\607-2.png" alt="images\607-2.png" /></a><br />jni函数创建java对象<br /><a href=""><img src="images\607-3.png" alt="images\607-3.png" /></a><br />java中调用该jni函数创建java对象<br /><a href=""><img src="images\607-4.png" alt="images\607-4.png" /></a><br /><br />~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br /><a href=""><img src="images\607-5.png" alt="images\607-5.png" /></a><br />访问静态类函数<br />关键函数是CallStaticVoidMethod<br />调用类的公有静态函数<br /><a href=""><img src="images\607-6.png" alt="images\607-6.png" /></a><br /><br />调用类的私有静态函数<br /><a href=""><img src="images\607-7.png" alt="images\607-7.png" /></a><br /> <br /> 类似的，调用返回值为int类型数据的静态函数<br /> <a href=""><img src="images\607-8.png" alt="images\607-8.png" /></a><br /><br /> 调用返回值为jstring类型数据的静态函数<a href=""><img src="images\607-9.png" alt="images\607-9.png" /></a><br /><br />~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br /><a href=""><img src="images\607-10.png" alt="images\607-10.png" /></a><br />调用对象函数<br />调用对象函数之前需要先创建对象<br /><a href=""><img src="images\607-11.png" alt="images\607-11.png" /></a><br /><br />调用私有类对象函数，与调用公有差别不大<br /><a href=""><img src="images\607-12.png" alt="images\607-12.png" /></a><br /><br />三种调用类对象函数的api，区别主要在于最后一个传参的参数不同<br /><a href=""><img src="images\607-13.png" alt="images\607-13.png" /></a><br /><br />使用CallObjectMethodA，用array进行传参<br /><a href=""><img src="images\607-14.png" alt="images\607-14.png" /></a><br /><br />jni中调用返回值为数组的java类对象函数<br /><a href=""><img src="images\607-15.png" alt="images\607-15.png" /></a><br /><br /><br />~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br />调用指定类的父类函数<br />目标类，其onCreate函数中调用了父类函数onCreate<br />将该类原先的onCreate函数注释掉，修改为Native函数<br /><a href=""><img src="images\607-16.png" alt="images\607-16.png" /></a><br /><br />jni编写MainActivity的onCreate函数<br /><a href=""><img src="images\607-17.png" alt="images\607-17.png" /></a><br /><br />onCreate函数后半部分加加入输出logcat的函数，用于表示onCreate函数确实执行<br /><a href=""><img src="images\607-18.png" alt="images\607-18.png" /></a><br /></div><div class='page'><h1 class='title level-3'>JNI静态注册与动态注册</h1><br/><a href=""><img src="images\610-1.png" alt="images\610-1.png" /></a><br /><br />静态注册<br /><a href=""><img src="images\610-2.png" alt="images\610-2.png" /></a><br /><br />~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br /><br />动态注册<br />关键函数RegisterNatives完成native函数与so中方法的绑定<br /><a href=""><img src="images\610-3.png" alt="images\610-3.png" /></a><br /><br />自己实现RegisterNatives函数，该函数中使用env-&gt;RegisterNatives函数动态注册native函数<br /><a href=""><img src="images\610-4.png" alt="images\610-4.png" /></a><br /><br />准备动态注册onCreate函数<br />MainActivity中将onCreate函数设置为native函数<br /><a href=""><img src="images\610-5.png" alt="images\610-5.png" /></a><br /><br />jni中实现onCreate函数 <br /><a href=""><img src="images\610-6.png" alt="images\610-6.png" /></a><br /><br />JNIOnload函数中动态注册onCreate函数<br />构造jniNativeMethod结构体<br />获得native的onCreate函数所在类<br />调用env-&gt;RegisterNatives函数直接进行注册（此时并未像上图中单独实现注册函数，而是直接在JNIOnload中调用env-&gt;RegisterNatives）<br /><a href=""><img src="images\610-7.png" alt="images\610-7.png" /></a><br /><br />注册多个函数进入扩展jniNativeMethod结构体<br /><a href=""><img src="images\610-8.png" alt="images\610-8.png" /></a><br /><br /></div><div class='page'><h1 class='title level-4'>加混淆</h1><br/>需要对动态注册原理过程有研究，通过hook特定函数，在指定函数中添加log信息，重新编译rom，从而在app运行时自动输出jni函数在so中的地址<br />动态注册原理需要关系registerNative函数实现<br /><a href="安卓--NDK开发--动态注册原理.html">动态注册原理</a></div><div class='page'><h1 class='title level-4'>未加混淆</h1><br/>逆向动态注册的函数<br />找到JNIOnload函数<br /><a href=""><img src="images\612-1.png" alt="images\612-1.png" /></a><br /><br />找到env-&gt;RegisterNative函数,其第三个参数即为jniNativeMethod结构体，<br />同时从之前构造jniNativeMethod结构体过程，也能找到被动态注册的函数的地址，<br /><a href=""><img src="images\612-2.png" alt="images\612-2.png" /></a><br /><br />通过设置红框中的标签，可以在生成的so文件中将onCreate函数地址隐藏<br /><a href=""><img src="images\612-3.png" alt="images\612-3.png" /></a><br />隐藏后函数名不再出现，而是出现函数地址<br /><a href=""><img src="images\612-4.png" alt="images\612-4.png" /></a><br /><br /></div><div class='page'><h1 class='title level-3'>JNI开发中内存管理</h1><br/>详见看雪高研 ndk开发，课时7<br /><a href=""><img src="images\609-1.png" alt="images\609-1.png" /></a><br /><br /><a href=""><img src="images\609-2.png" alt="images\609-2.png" /></a><br /><br /><a href=""><img src="images\609-3.png" alt="images\609-3.png" /></a><br /><br /><a href=""><img src="images\609-4.png" alt="images\609-4.png" /></a><br /><br /><a href=""><img src="images\609-5.png" alt="images\609-5.png" /></a><br /><br /><a href=""><img src="images\609-6.png" alt="images\609-6.png" /></a><br /><br /><a href=""><img src="images\609-7.png" alt="images\609-7.png" /></a><br /><br /><a href=""><img src="images\609-8.png" alt="images\609-8.png" /></a><br /><br /><a href=""><img src="images\609-9.png" alt="images\609-9.png" /></a><br /><br /><a href=""><img src="images\609-10.png" alt="images\609-10.png" /></a><br /><br /><a href=""><img src="images\609-11.png" alt="images\609-11.png" /></a><br /><br /><a href=""><img src="images\609-12.png" alt="images\609-12.png" /></a><br /><br /><a href=""><img src="images\609-13.png" alt="images\609-13.png" /></a><br /><br /></div><div class='page'><h1 class='title level-3'>JNI数组操作api</h1><br/><a href=""><img src="images\606-1.png" alt="images\606-1.png" /></a></div><div class='page'><h1 class='title level-3'>JNI中多线程</h1><br/>创建线程回调函数<br /><a href=""><img src="images\604-1.png" alt="images\604-1.png" /></a><br /><br />这里在JNI_Onload函数中创建子线程<br /><a href=""><img src="images\604-2.png" alt="images\604-2.png" /></a><br /><br /><br />jni主席主线程中获得JNIEnv（在JNIOnload函数中）<br /><a href=""><img src="images\604-3.png" alt="images\604-3.png" /></a><br /><br />在子线程中若要获取JNIEnv，从而调用JNI接口，需要使用进程全局JavaVM调用AttachCurrentThread函数，从而将线程附加到进程的jvm中，进一步获得线程的JNIEnv，从而调用JNI接口<br />线程功能执行完毕后还需执行DetachCurrentThread函数，才能线程退出<br /><a href=""><img src="images\604-4.png" alt="images\604-4.png" /></a><br /><a href=""><img src="images\604-5.png" alt="images\604-5.png" /></a><br /><br /><br /></div><div class='page'><h1 class='title level-3'>JNI中访问java类</h1><br/>JNI中访问java类中的方法和属性，流程与java反射相同，这只不过使用api不同<br /><a href=""><img src="images\594-1.png" alt="images\594-1.png" /></a><br />这里通过获得fieldID引用field类，类似的如果要引用method，则需要获得methodID<br /><br />java反射中针对类的描述使用.进行间隔<br /><a href=""><img src="images\594-2.png" alt="images\594-2.png" /></a><br />JNI反射中针对类的描述使用/进行间隔<br /><a href=""><img src="images\594-3.png" alt="images\594-3.png" /></a><br /><br /><br /></div><div class='page'><h1 class='title level-3'>JNI中特殊数据类型</h1><br/><a href=""><img src="images\595-1.png" alt="images\595-1.png" /></a><br /><br /><a href=""><img src="images\595-2.png" alt="images\595-2.png" /></a><br /><br /><br /><a href=""><img src="images\595-3.png" alt="images\595-3.png" /></a></div><div class='page'><h1 class='title level-3'>JNI中字符串操作</h1><br/><a href=""><img src="images\591-1.png" alt="images\591-1.png" /></a><br /><br /><a href=""><img src="images\591-2.png" alt="images\591-2.png" /></a><br /><br /><a href=""><img src="images\591-3.png" alt="images\591-3.png" /></a><br />将jstring类型给字符串转为c类型字符串，如果转换失败，则输出logcat<br />此时jni中使用__android_log_print函数输出logcat信息<br />最后将c类型字符串转为jstring类型字符串<br /><a href=""><img src="images\591-4.png" alt="images\591-4.png" /></a><br /><br /><a href=""><img src="images\591-5.png" alt="images\591-5.png" /></a><br /><br /><br /><br /><br /><br /><br /><br /><br /></div><div class='page'><h1 class='title level-3'>JNI种两种数据类型</h1><br/></div><div class='page'><h1 class='title level-4'>基本数据类型</h1><br/><a href=""><img src="images\583-1.png" alt="images\583-1.png" /></a><br />基本数据类型的实际使用<br />java中声明native函数参数为int类型，使用的是java中的数据类型<br /><a href=""><img src="images\583-2.png" alt="images\583-2.png" /></a><br />对应的jni函数的参数即jint类型，是jni的数据类型<br /><a href=""><img src="images\583-3.png" alt="images\583-3.png" /></a><br /><br />其他数据类型对照关系以此类推<br /><br />实际开发过程中，jni函数中也可以直接使用c\c++中数据类型，因为jni进行了相关定义<br />直接只用使用int，而非jint<br /><a href=""><img src="images\583-4.png" alt="images\583-4.png" /></a><br /><br />在jni.h文件中，对jint进行了定义<br /><a href=""><img src="images\583-5.png" alt="images\583-5.png" /></a><br />跟踪下去<br /><a href=""><img src="images\583-6.png" alt="images\583-6.png" /></a><br />发现jint就是int <br /><a href=""><img src="images\583-7.png" alt="images\583-7.png" /></a><br /><br />即jni编程中，8种基本数据类型可以被直接使用<br /><a href=""><img src="images\583-8.png" alt="images\583-8.png" /></a></div><div class='page'><h1 class='title level-4'>引用数据类型</h1><br/></div><div class='page'><h1 class='title level-5'>基本引用数据类型</h1><br/>只有四种基本引用数据类型<br /><a href=""><img src="images\588-1.png" alt="images\588-1.png" /></a><br /><br /><a href=""><img src="images\588-2.png" alt="images\588-2.png" /></a><br /><br />引用数据类型之间的继承关系<br /><a href=""><img src="images\588-3.png" alt="images\588-3.png" /></a><br /></div><div class='page'><h1 class='title level-5'>数组引用数据类型</h1><br/>数组引用类型<br />可以分为基本引用类型数组和对象引用类型数组<br /><a href=""><img src="images\589-1.png" alt="images\589-1.png" /></a></div><div class='page'><h1 class='title level-3'>ndk开发实例</h1><br/><a href=""><img src="images\582-1.png" alt="images\582-1.png" /></a><br /><br />选择native c++支持<br /><a href=""><img src="images\582-2.png" alt="images\582-2.png" /></a><br /><br />创建nkd项目，默认生成的jni函数<br />java函数中加载so库<br /><a href=""><img src="images\582-3.png" alt="images\582-3.png" /></a><br />java中声明native函数<br /><a href=""><img src="images\582-4.png" alt="images\582-4.png" /></a><br />so文件中实现的native函数<br /><a href=""><img src="images\582-5.png" alt="images\582-5.png" /></a><br /><br /><br /><a href=""><img src="images\582-6.png" alt="images\582-6.png" /></a><br /><br />编写自己的native函数<br />若native函数不是静态函数，则native函数第二个参数即为jobject，代表当前MainActivity的实例<br />若native函数是静态函数，则native函数第二个参数即为jclass，因为可以通过类名方式访问类静态成员<br /><br />java中静态注册函数<br /><a href=""><img src="images\582-7.png" alt="images\582-7.png" /></a><br />c++中实现函数<br /><a href=""><img src="images\582-8.png" alt="images\582-8.png" /></a><br /><br />jni函数至少有两个参数，从第三个参数开始，才是函数自身的参数</div><div class='page'><h1 class='title level-3'>调试</h1><br/>as中支持对ndk的c++函数下断点调试<br /><a href=""><img src="images\584-1.png" alt="images\584-1.png" /></a></div><div class='page'><h1 class='title level-3'>动态注册原理</h1><br/></div><div class='page'><h1 class='title level-4'>art下动态注册</h1><br/></div><div class='page'><h1 class='title level-4'>dalvik下动态注册</h1><br/>详见看雪高研 ndk开发 课时8<br /><a href=""><img src="images\615-1.png" alt="images\615-1.png" /></a> <br /><br /><a href=""><img src="images\615-2.png" alt="images\615-2.png" /></a><br /><br /><a href=""><img src="images\615-3.png" alt="images\615-3.png" /></a><br /><br /><a href=""><img src="images\615-4.png" alt="images\615-4.png" /></a><br /><br /><a href=""><img src="images\615-5.png" alt="images\615-5.png" /></a><br /><br /></div><div class='page'><h1 class='title level-3'>介绍</h1><br/><a href=""><img src="images\581-1.png" alt="images\581-1.png" /></a><br /><br />java语言特点<br /><a href=""><img src="images\581-2.png" alt="images\581-2.png" /></a><br /><br /><a href=""><img src="images\581-3.png" alt="images\581-3.png" /></a><br /><br /><a href=""><img src="images\581-4.png" alt="images\581-4.png" /></a><br /><br />jni与ndk的关系<br />jni是一种规范，不仅dalvik、art虚拟机有，所有jvm虚拟机均有下<br /><a href=""><img src="images\581-5.png" alt="images\581-5.png" /></a><br /><br />ndk环境单独下载<br /><a href=""><img src="images\581-6.png" alt="images\581-6.png" /></a><br />官方ndk指南<br /><a href=""><img src="images\581-7.png" alt="images\581-7.png" /></a><br /><br /></div><div class='page'><h1 class='title level-3'>描述符</h1><br/>描述符常用于反射过程中作为函数参数，表示反射要获取到的类、域、函数</div><div class='page'><h1 class='title level-4'>函数描述符</h1><br/><a href=""><img src="images\599-1.png" alt="images\599-1.png" /></a></div><div class='page'><h1 class='title level-4'>类描述符</h1><br/><a href=""><img src="images\596-1.png" alt="images\596-1.png" /></a><br /></div><div class='page'><h1 class='title level-4'>域描述符</h1><br/>域描述符用于描述java类中定义的属性<br /><a href=""><img src="images\598-1.png" alt="images\598-1.png" /></a><br /><br /><a href=""><img src="images\598-2.png" alt="images\598-2.png" /></a></div><div class='page'><h1 class='title level-3'>逆向动态注册的native函数</h1><br/></div><div class='page'><h1 class='title level-3'>性能提升</h1><br/><a href=""><img src="images\585-1.png" alt="images\585-1.png" /></a><br /><br /><a href=""><img src="images\585-2.png" alt="images\585-2.png" /></a><br /><br /><a href=""><img src="images\585-3.png" alt="images\585-3.png" /></a><br /><br />优化过程中生成的vdex中包含原dex中所有代码<br /><a href=""><img src="images\585-4.png" alt="images\585-4.png" /></a><br /><br />vdex有自己独特的文件头，其后就存放着dex文件头，删除dex文件头之前的数据，010editor可以将odex成功解析为dex<br /><a href=""><img src="images\585-5.png" alt="images\585-5.png" /></a><br /><br /><a href=""><img src="images\585-6.png" alt="images\585-6.png" /></a><br /><br /><br /></div><div class='page'><h1 class='title level-2'>OTA升级</h1><br/><a href="https://source.android.google.cn/devices/tech/ota?hl=zh-cn#nonab_updates">https://source.android.google.cn/devices/tech/ota?hl=zh-cn#nonab_updates</a><br /><a href="https://android.googlesource.com/platform/bootable/recovery/+/master/updater_sample/">https://android.googlesource.com/platform/bootable/recovery/+/master/updater_sample/</a><br />	<h3>在现代 Android 设备中，每个分区都存在两个副本（A 和 B）。当系统运行但处于空闲状态时，设备会将更新应用到当前未使用的分区。A/B 设备不需要空间来下载更新软件包，因为它们可以在从网络中读取更新的同时应用更新；这称之为“流式传输 A/B”。如需详细了解 A/B 设备的 OTA 更新，请参阅 </h3><a href="https://source.android.google.cn/devices/tech/ota/ab?hl=zh-cn">A/B（无缝）系统更新</a><h3>。如需查看示例应用以了解如何使用 Android 系统更新 API（即 </h3><code>update_engine</code><h3>）安装 A/B 更新，请参阅 </h3><a href="https://android.googlesource.com/platform/bootable/recovery/+/master/updater_sample/">SystemUpdaterSample</a><h3>（</h3><a href="https://android.googlesource.com/platform/bootable/recovery/+/master/updater_sample/README.md">updater_sample/README.md</a><h3> 中提供了应用详情）。</h3><br />	<br />	<br />A/B分区的命名<br />	A/B 设备不需要恢复分区或缓存分区，因为 Android 已不再使用这些分区。数据分区现在用于存储下载的 OTA 软件包，而恢复映像代码位于启动分区。 A/B 化的所有分区都应按以下方法命名（插槽始终被命名为 a、b 等）：boot_a、boot_b、system_a、system_b、vendor_a、vendor_b。<br /><br /><br />	<br /><h2>	</h2><h2>更新包仍通过 HTTPS 提供。</h2><br />	<br /><h1>实现OTA客户端应该考虑的部分</h1>（关键：用update_engine(https网址)获取更新包）<br />• 确定何时进行更新。由于 A/B 更新是在后台进行，因此不再需要由用户启动。为了避免干扰用户，建议将更新安排在设备处于闲时维护模式（如夜间）并已连接到 WLAN 网络时进行。 不过，客户端可以使用您希望使用的任何启发法。<br />• 向 OTA 更新包服务器进行核查，确定是否有可用的更新。这应与您现有的客户端代码大体相同，不过您需要表明相应设备支持 A/B 更新。（Google 的客户端还包含立即检查按钮，以便用户检查是否有最新更新。）<br />• 调用 update_engine（使用 HTTPS 网址），以获取更新包（假设有可用的更新包）。update_engine 将在流式传输更新包的同时，在当前未使用的分区上更新原始数据块。<br />• 根据 update_engine 结果代码向您的服务器报告安装是成功了还是失败了。如果更新已成功应用，update_engine 将会告知引导加载程序在下次重新启动时启动到新的操作系统。如果新的操作系统无法启动，引导加载程序将会回退到旧的操作系统，因此无需在客户端执行任何操作。如果更新失败，客户端将需要根据详细的错误代码确定何时（以及是否）重试。例如，优秀的客户端能够识别出是一部分（“diff”）OTA 更新包失败，并改为尝试完整的 OTA 更新包。<br /><br /><h3>A/B 系统更新过程会使用名为 </h3><code><h3>update_engine</h3></code><h3> 的后台守护程序使系统做好准备，以启动到更新后的新版本。该守护程序可以执行以下操作：</h3><br />• 按照 OTA 更新包的指示，从当前槽位 A/B 分区读取数据，然后将所有数据写入到未使用槽位 A/B 分区。<br />• 在预定义的工作流程中调用 <code>boot_control</code> 接口。<br />• 按照 OTA 更新包的指示，在将数据写入到所有未使用槽位分区之后，从新分区运行安装后程序。（有关详细信息，请参阅<a href="https://source.android.google.cn/devices/tech/ota/ab?hl=zh-cn#post-installation">安装后</a>）。<br /><br /><br />由于 update_engine 守护程序本身不会参与到启动流程中，因此该守护程序在更新期间可以执行的操作受当前槽位中的 SELinux 政策和功能限制（在系统启动到新版本之前，此类政策和功能无法更新）。为了维持一个稳定可靠的系统，更新流程不应修改分区表、当前槽位中各个分区的内容，以及无法通过恢复出厂设置擦除的非 A/B 分区的内容。<br /><br /><br />引导加载程序交互<br />boot_control HAL 供 update_engine（可能还有其他守护程序）用于指示引导加载程序从何处启动。常见的示例情况及其相关状态包括：<br />• 正常情况：系统正在从其当前槽位（槽位 A 或槽位 B）运行。到目前为止尚未应用任何更新。系统的当前槽位是可启动且被标记为成功的活动槽位。<br />• 正在更新：系统正在从槽位 B 运行，因此，槽位 B 是可启动且被标记为成功的活动槽位。 由于槽位 A 中的内容正在更新，但是尚未完成，因此槽位 A 被标记为不可启动。在此状态下，应继续从槽位 B 重新启动。<br />• 已应用更新，正在等待重新启动：系统正在从槽位 B 运行，槽位 B 可启动且被标记为成功，但槽位 A 之前被标记为活动槽位（因此现在被标记为可启动）。槽位 A 尚未被标记为成功，引导加载程序应尝试从槽位 A 启动若干次。<br />• 系统已重新启动到新的更新：系统正在首次从槽位 A 运行，槽位 B 仍可启动且被标记为成功，而槽位 A 仅可启动，且仍是活动槽位，但未被标记为成功。在进行一些检查之后，用户空间守护程序 update_verifier 应将槽位 A 标记为成功。<br /><br />	<br /><h3>有可用的有效负载后，更新流程将遵循如下步骤：</h3><br /><table class="table"><tr><th>步骤</th><th>操作</th></tr><tr><td>1</td><td>通过 markBootSuccessful() 将当前槽位（或“源槽位”）标记为成功（如果尚未标记）。</td></tr><tr><td>2</td><td>调用函数 setSlotAsUnbootable()，将未使用的槽位（或“目标槽位”）标记为不可启动。当前槽位始终会在更新开始时被标记为成功，以防止引导加载程序回退到未使用的槽位（该槽位中很快将会有无效数据）。如果系统已做好准备，可以开始应用更新，那么即使其他主要组件出现损坏（例如界面陷入崩溃循环），当前槽位也会被标记为成功，因为可以通过推送新软件解决这些问题。

更新有效负载是不透明的 Blob，其中包含更新到新版本的指示。更新有效负载由以下部分组成：• 元数据。元数据在更新有效负载中所占的比重相对较小，其中包含一系列用于在目标槽位上生成和验证新版本的操作。例如，某项操作可能会解压缩特定 Blob 并将其写入到目标分区中的特定块，或者从源分区读取数据、应用二进制补丁程序，然后写入到目标分区中的特定块。
• 额外数据。与操作相关的额外数据在更新有效负载中占据了大部分比重，其中包含这些示例中的已压缩 Blob 或二进制补丁程序。</td></tr><tr><td>3</td><td>下载有效负载元数据。</td></tr><tr><td>4</td><td>对于元数据中定义的每项操作，都将按顺序发生以下行为：将相关数据（如果有）下载到内存中，应用操作，然后释放关联的内存。</td></tr><tr><td>5</td><td>对照预期的哈希重新读取并验证所有分区。</td></tr><tr><td>6</td><td>运行安装后步骤（如果有）。如果在执行任何步骤期间出现错误，更新失败，系统可能会通过其他有效负载重新尝试更新。如果上述所有步骤均已成功完成，更新成功，系统会执行最后一个步骤。</td></tr><tr><td>7</td><td>调用 setActiveBootSlot()，将未使用的槽位标记为活动槽位。将未使用的槽位标记为活动槽位并不意味着它将完成启动。如果引导加载程序（或系统本身）未读取到“成功”状态，可以将活动槽位切换回来。</td></tr><tr><td>8</td><td>安装后步骤（如下所述）包括从“新更新”版本中运行仍在旧版本中运行的程序。如果此步骤已在 OTA 更新包中定义，则为强制性步骤，且程序必须返回并显示退出代码 0，否则更新会失败。</td></tr><tr><td>9</td><td>在系统足够深入地成功启动到新槽位并完成重新启动后检查之后，系统会调用 markBootSuccessful()，将现在的当前槽位（原“目标槽位”）标记为成功。</td></tr></table><br /><br /><br /><br /><h3>重新启动后</h3><br /><h3>重新启动后，</h3><code><h3>update_verifier</h3></code><h3> 会触发利用 dm-verity 进行完整性检查。系统会先启动该检查，然后再启动 zygote，以避免 Java 服务进行任何无法撤消且会导致无法进行安全回滚的更改。在此过程中，如果验证启动功能或 dm-verity 检测到任何损坏，引导加载程序和内核还可能会触发重新启动。检查完成后，</h3><code><h3>update_verifier</h3></code><h3> 会将启动标记为成功。</h3><br /><code><h3>update_verifier</h3></code><h3> 只会读取 </h3><code><h3>/data/ota_package/care_map.txt</h3></code><h3>（在使用 AOSP 代码时，该文件会包含在 A/B OTA 更新包中）中列出的数据块。Java 系统更新客户端（例如 GmsCore）会在重新启动设备前提取 </h3><code><h3>care_map.txt</h3></code><h3> 并设置访问权限，在系统成功启动到新版本后会删除所提取的文件。</h3><br /><br /><br />可能的配置文件位置<br /><h3>在实际更新系统中，预期从服务器到应用的配置文件，但在此示例中，配置文件存储在设备上。该目录可以在日志或 UI 中找到。在大多数情况下，它应位于 。</h3><code><h3>/data/user/0/com.example.android.systemupdatersample/files/configs/</h3></code><br /><br />下载的ota包可能的目录以及名称，可以通过find命令检索<br />SystemUpdaterSample 应用程序从 下载 OTA 包。在此示例中，应用应指向文件系统，例如 。<code>urlurlfile:///data/my-sample-ota-builds-dir/ota-002.zip</code><br /><br /></div><div class='page'><h1 class='title level-2'>root与刷机</h1><br/>安卓系统安装在磁盘上，磁盘不同分区中保存系统不同的数据内容，进行刷机时需要将特定分区内容刷入对应名称的分区中，才能保证刷机结果正确，详见磁盘分区名与磁盘路径匹配<br /><br /> 大家可以简单的把手机的ROM存储类比为我们电脑上的硬盘，这个硬盘被分成了几个分区：bootloader分区，boot分区，system分区等等。关于各分区用途，见安卓系统分区<br /> <br /> 所谓的刷机我们可以简单的理解成把软件安装在手机的某些分区中，类似于我们在电脑上安装Windows系统。 <br /><br />如果要获取root，有两种途径<br />1、利用漏洞将su程序写入sbin目录下并执行<br />2、刷机，分为卡刷和线刷<br /><br /><a href="https://zhuanlan.zhihu.com/p/31882232">学会Root，让你的安卓更快更强（上） - 知乎 (zhihu.com)</a><br /><a href=""><img src="images\229-1.png" alt="images\229-1.png" /></a><br /><a href=""><img src="images\229-2.png" alt="images\229-2.png" /></a><br /><br /><br />安卓刷机思路<br />1、解锁bootloader-&gt;刷入第三方Recovery-&gt;刷入第三方系统<br />2、解锁bootloader-&gt;直接刷入第三方系统<br /><br />两种刷机模式<br />通常大家所讨论的Fastboot，通常都是说安卓手机的Fastboot模式。在安卓手机中fastboot是一种比recovery更底层的刷机模式。简单来说，就是使用USB数据线，连接电脑的一种刷机模式。这种刷机方式，我们又通常称为“线刷”刷机。另外安卓手机还有一种刷机方式，叫做“卡刷”，两者区别如下。<br /><br />线刷： 直接想手机硬盘写入*.img 文件，我个人觉得这种方法比较快捷，而且省事。但是必须借助电脑和数据线。<br /><br />卡刷：就是利用recovery的从SD卡中更新系统的这个功能，如果你想刷第三方Rom，必须刷入个第三方recovery，只有fastboot模式才能刷recovery.img。卡刷有个限制，必须要把想要更新的ROM（Android系统）拷贝到SD卡上。如果手机已经是砖了。那只能用线刷了。</div><div class='page'><h1 class='title level-3'>OEM锁、安卓recovery、bootloader</h1><br/></div><div class='page'><h1 class='title level-4'>bootloader与fastboot</h1><br/>安卓中boot与bootloader不是一回事,部分版本中boot和recovery是一起的<br /><h1>bootloader</h1><br />	简单地说，BootLoader就是在操作系统内核运行之前运行的一段小程序。通过这段小程序，我们可以初始化硬件设备、建立内存空间映射图，从而将系统的软硬件环境带到一个合适状态，以便为最终调用操作系统内核准备好正确的环境。在嵌入式系统中，通常并没有像BIOS那样的固件程序（注，有的嵌入式CPU也会内嵌一段短小的启动程序），因此整个系统的加载启动任务就完全由BootLoader来完成。比如在一个基于ARM7TDMI core的嵌入式系统中，系统在上电或复位时通常都从地址0x00000000处开始执行，而在这个地址处安排的通常就是系统的BootLoader程序。<br /><br /><h1>fastboot</h1><br />	fastboot 主要是用来与bootloader的USB通讯的PC命令行工具。他一般主要也用来向bootloader传送刷机文件进行文件分区重烧。 因此在使用时，必须有一个PC机并且USB线要始终联着。所以这种方式称为线刷。 用fastboot需要bootloader 支持，所以不是每一家公司产品都支的这个功能的<br />	<br /><h1>进入bootloader并使用fashboot命令刷写固件</h1><br />	大多数安卓手机，都可以在关机状态下，然后同时按住【电源键】+【音量+】键，大约2-3s后，就可以进入Fastboot模式。<br />作为开发者在开机状态下可以用下面的方式进入：<br />adb reboot bootloader<br /><br /><h2>fastboot命令</h2><br />  fastboot flashing unlock    #6.0以上设备 设备必须解锁，开始刷机（这个不同的手机厂商不同）<br />  fastboot erase {partition}  # 擦除分区<br />  fastboot  erase  frp    # 擦除 frp 分区，frp 即 Factory Reset Protection，用于防止用户信息在手机丢失后外泄<br />  fastboot  flash  boot  boot.img    # 刷入 boot 分区<br />  fastboot  flash  system  system.img    # 刷入 system 分区<br />  fastboot  flash  recovery  recovery.img    # 刷入 recovery 分区<br />  fastboot flashall    #烧写所有分区，注意：此命令会在当前目录中查找所有img文件，将这些img文件烧写到所有对应的分区中，并重新启动手机。<br />  fastboot  format  data    # 格式化 data 分区<br />  fastboot  flashing lock    # 设备上锁，刷机完毕<br />  fastboot  continue    # 自动重启设备<br />  fastboot reboot# 重启手机<br />  fastboot reboot-bootloader# 重启到bootloader 刷机用<br />  fastboot devices  ## 发现手机，显示当前哪些手机通过fastboot连接了<br /><br />一次烧写boot，system，recovery分区<br />创建包含boot.img，system.img，recovery.img文件的zip包。<br />执行：fastboot update {*.zip}<br /><br />车机中执行adb reboot bootloader之后，命令行会直接返回，设备会黑屏，需要使用本地的fastboot工具对bootloader进行连接（类似于adb连接安卓），使用命令fastboot devices可以显示当前可以连接的bootloader<br /></div><div class='page'><h1 class='title level-4'>OEM锁</h1><br/><h1>所谓oem解锁，即允许bootloader启动运行未经验证的fastboot、recovery、安卓系统，从而允许刷机</h1><br /><br />OEM锁<br />Bootloader相当于是电脑的BIOS一样，而锁住的Bootloader，只能校验官方系统的完整性，并且会拒绝诸如在线刷模式下修改官方系统的请求，比如：<br />刷入第三方Recovery<br />刷入第三方操作系统<br /><br /><br />ROOT手机<br />如果你解锁了Bootloader，就相当于给它开放了“ROOT”权限，让他可以放行第三方修改系统操作的程序运行。这时候，我们就可以愉快的刷入各种Magisk模块、第三方操作系统来随心所欲的DIY手机系统啦。<br />		<br />手机厂家在自己出厂的手机上一般都加了BL（引导加载程序，相当于电脑的BIOS）锁，防止刷入非本厂家的系统。OEM解锁就是允许解BL锁，请注意这只是允许，并不是说这样就解锁了BL，要解BL，需要知道解BL的方法。解了BL才可以刷其它的包，以及其它的recovery。不然这个OEM解锁打开了也没有用。<br /><br />开发者选项中存在OEM解锁，勾选后仅允许解锁bootloader，需要其他方法才能实际解锁bootloader<br />有BL锁的手机，刷机之前一般都要先解锁BL；而想要解锁BL呢，又需要在手机上先打开“启用OEM解锁”。不过并非所有手机都有这个选项，如果没有就不用理会了。<br /><a href=""><img src="images\728-1.png" alt="images\728-1.png" /></a><br /><br />华为，小米，三星，索尼等常见机型解锁<br />		<a href="https://zhuanlan.zhihu.com/p/27583651">https://zhuanlan.zhihu.com/p/27583651</a><br /><br />华为手机解锁命令: fastboot oem unlock 解锁码</div><div class='page'><h1 class='title level-4'>安卓recovery</h1><br/>recovery是安卓的一个恢复系统，有点像WIND的PE或DOS，设备出厂时就有recovery了，但原厂的recovery是不能用来刷第三方修改后的系统的，也就是说不能刷那些民间高手做的精简、优化ROM，刷时就会像图上的机器人一样躺下睡了。原厂的recovery通常用来进行恢复出厂设置、升级官方固件。<br /><br />注意原厂的recovery不能刷入第三方系统，即如果要刷机，需要先刷入第三方recovery<br />常见recovery功能<br /><a href=""><img src="images\729-1.png" alt="images\729-1.png" /></a><br /><a href=""><img src="images\729-2.png" alt="images\729-2.png" /></a><br /><br />Recovery 更类似于一个小型的管理系统。只不过功能简单，所做的管理有限。在recovery模式下，会加载了部分文件系统，所以才可以读sdcard中的update.zip进行刷机，当然，也可以清除cache和用户数据。<br /><br />该模式可根据用户的需要进行修改，因此有官方recovery模式以及第三方recovery模式。第三方recovery模式可以识别第三方rom包，因此可以用来刷机。而官方recovery一般不能识别第三方zip文件。好用的第三方RE:TWRP 和 CWM<br /><br />Recovery刷机包是称为Google Update 格式。在用Recovery恢复时，刷机包通常放在SD卡里，所以这里刷机一般称为卡刷。<br /><br />源代码位置<br />Android recovery的源码位置在Android SDK的 /bootable/recovery/ 位置<br />	<br />进入recovery<br />使用adb 命令，adb reboot recovery<br />组合键进入recovery 模式，绝大部分手机时候power+音量 加 键，好了，不是加就是减<br />恢复出厂设置也会进入recovery模式，恢复出厂设置可以通过界面点击，也可以通过命令触发<br />恢复出厂设置的命令<br /><br />在fastboot中刷入recovery的命令<br />首先进入 bootloader（fastboot）模式<br />fastboot flash recovery recovery.img<br />	<br />一个不错的发布RE和刷机包和root包的网站<br /><a href="https://www.androidsage.com/">https://www.androidsage.com/</a><br />twrp：官方网站：<a href="https://twrp.me/">https://twrp.me/</a><br />官方适配手机设备型号：<a href="https://twrp.me/Devices/">https://twrp.me/Devices/</a><br /><br />相关概念<br /><a href=""><img src="images\729-3.png" alt="images\729-3.png" /></a>	<br />		</div><div class='page'><h1 class='title level-4'>进入recovery和bootloader</h1><br/><a href="安卓--安卓sdk工具使用--adb命令--进入recovery和bootloader.html">进入recovery和bootloader</a></div><div class='page'><h1 class='title level-4'>启用system目录写权限</h1><br/><a href="中汽研实习--IVI安装app--IVI中安装并替换系统apk.html">替换车机系统app</a><br /><br />获取安卓设备System目录下文件的写入权限<br /><a href="https://blog.csdn.net/ting_qifengl/article/details/94411295">https://blog.csdn.net/ting_qifengl/article/details/94411295</a><br /><br /><a href="https://blog.csdn.net/h784707460/article/details/79938160">https://blog.csdn.net/h784707460/article/details/79938160</a><br /># adb root<br /># adb disable-verity<br /># adb reboot<br /># adb root<br /># adb remount<br /># adb shell mount /firmware -o rw,remount<br /># adb push ...<br /><br /><br /><h1>实际命令</h1><br />adb remount<br />需要执行adb disable-verity<br />adb disable-verity<br />需要解锁设备<br /><br />执行adb disable-verity提示：Device is locked. Please unlock the device first<br /><br /><a href="https://blog.csdn.net/hanhan1016/article/details/89876197">https://blog.csdn.net/hanhan1016/article/details/89876197</a><br /> (1)进入开发者模式，打开OEM 解锁<br />(2)adb reboot bootloader进入fastboot模式<br />(3)fastboot flashing unlock,会提示Finished. Total time: 0.025s<br />(4)如果机器没有自动重启，则执行fastboot reboot重启手机.在运行过程中我的机器会自动重启所以省略了这一步<br />(5)开机之后，依次adb root，adb disable-verity，adb reboot即可，此时查看OEM 解锁项是灰显的<br />			<br />			<br />安卓手机解锁：Device is locked. Please unlock the device first<br /><a href="https://blog.csdn.net/xiangzaixiansheng/article/details/89286381?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.compare&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.compare">https://blog.csdn.net/xiangzaixiansheng/article/details/89286381?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.compare&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.compare</a><br /><br />1.首先需要打开开发者模式中的OEM unlocking开关<br />2.adb reboot bootloader<br />3.fastboot flashing unlock<br />4.fastboot getvar unlocked<br />等待结果 一般会出现unlocked：yes<br />5.adb root <br />6.adb remount<br />7.adb disable-verity<br />8.adb reboot</div><div class='page'><h1 class='title level-3'>概述资料</h1><br/><a href="https://sspai.com/post/43338">Android 玩机终极指南 - 少数派 (sspai.com)</a><br /><a href=""><img src="images\241-1.png" alt="images\241-1.png" /></a><br /></div><div class='page'><h1 class='title level-3'>获取root</h1><br/>刷入recovery之后可以通过以下方法获取root<br /><a href=""><img src="images\243-1.png" alt="images\243-1.png" /></a></div><div class='page'><h1 class='title level-3'>解锁bootloader</h1><br/><a href=""><img src="images\242-1.png" alt="images\242-1.png" /></a><br /></div><div class='page'><h1 class='title level-3'>卡刷命令</h1><br/><a href=""><img src="images\234-1.png" alt="images\234-1.png" /></a><br />与线刷类似，只不过仅需要刷入recovery，然后使用recovery读取tf卡或sd卡中的刷入rom，从而刷机<br />刷入recovery<br />fastboot flash recovery recovery.img<br /></div><div class='page'><h1 class='title level-3'>设备解锁</h1><br/>所有刷机或者重新挂载系统目录从而修改读写权限的操作其前提均为设备本身oem已经解锁<br />关于oem解锁<br />OEM锁<br />	Bootloader相当于是电脑的BIOS一样，而锁住的Bootloader，只能校验官方系统的完整性，并且会拒绝诸如在线刷模式下修改官方系统的请求，比如：<br />刷入第三方Recovery<br />刷入第三方操作系统<br />ROOT手机<br />如果你解锁了Bootloader，就相当于给它开放了“ROOT”权限，让他可以放行第三方修改系统操作的程序运行。这时候，我们就可以愉快的刷入各种Magisk模块、第三方操作系统来随心所欲的DIY手机系统啦。<br />		手机厂家在自己出厂的手机上一般都加了BL（引导加载程序，相当于电脑的BIOS）锁，防止刷入非本厂家的系统。OEM解锁就是允许解BL锁，请注意这只是允许，并不是说这样就解锁了BL，要解BL，需要知道解BL的方法。解了BL才可以刷其它的包，以及其它的recovery。不然这个OEM解锁打开了也没有用。<br />			开发者选项中存在OEM解锁，勾选后仅允许解锁bootloader，需要其他方法才能实际解锁bootloader<br />有BL锁的手机，刷机之前一般都要先解锁BL；而想要解锁BL呢，又需要在手机上先打开“启用OEM解锁”。不过并非所有手机都有这个选项，如果没有就不用理会了。<br />	华为，小米，三星，索尼等常见机型解锁<br />		<a href="https://zhuanlan.zhihu.com/p/27583651">https://zhuanlan.zhihu.com/p/27583651</a><br />	华为手机解锁命令: fastboot oem unlock 解锁码<br />	<br />哪吒车机本身存在root权限，但是oem未解锁，且x86架构未找到合适的安卓第三方桌面，所以未开启开发者选项中允许解锁oem的选项<br /><br />解锁oem的另一种思路是进入安卓recovery，查看是否有解锁oem或重新挂载/system目录的命令<br /><br /><h2>注意fastboot  flashing  unlock以及fastboot oem unlock 123456789的区别，前一条指令用于允许固件刷入flash文件，后一条命令是部分厂商用于解锁oem锁的命令，两者功能不能混淆，单凭fastboot  flashing  unlock无法解锁oem，oem解锁方式视各厂商情况不同</h2><br /><a href="安卓--root与刷机--线刷命令--理想的刷机指令序列.html">两命令实例</a></div><div class='page'><h1 class='title level-3'>刷机实例</h1><br/><br /></div><div class='page'><h1 class='title level-4'>pixel刷机fart</h1><br/><h1>谷歌Pixel系列手机每月更新无痛刷机技巧</h1><br /><br />本文适合小白，高手可以关闭。（以下技巧基本为Pixel3操作，window7平台，Pixel系列手机大同小异）<br />谷歌Pixel系列手机属于小众手机，当中刷机有技巧，本人也是小白，经过无数次的实践经验得出以下刷机技巧。<br /><strong>以下技巧前提是Pixel手机解锁了Bootloader！必须的。</strong><br />Pixel系列手机官方rom会在以下网站每月放出：<br /><a href="https://developers.google.cn/android/images">https://developers.google.cn/android/images</a><a href="https://link.zhihu.com/?target=https%3A//developers.google.cn/android/images"><br /></a>不要以为谷歌网站就一定是404，这是谷歌少数可以在国内不用爬出去可以访问的网页之一。打开后便可以看到Pixel系列手机列表在右侧。<br /><a href=""><img src="images\543-1.png" alt="images\543-1.png" /></a><br />选择自己手机，以我手中Pixel3（blueline）为例，其实有人认为每月更新都是安全更新不重视，而且刷机恢复手机太痛苦，但我认为安全还是第一的，我下面就是介绍无痛更新（不擦除数据的安全更新）的技巧，让每月更新变得容易。<br /><a href=""><img src="images\543-2.png" alt="images\543-2.png" /></a><br />右键点击最新的更新旁边的那个link，复制链接地址到自己的下载软件，例如迅雷之类的，以我的网络为例，平时最高速度一般2~3m/s，不知道为啥唯独这个网页的连接，基本达到8~10m/s，速度奇快，一个1.7G的更新包，一阵就下载完了。（这里全部不需要爬出去）<br />你会得到一个zip包的更新包，解压后，随便放。<br /><a href=""><img src="images\543-3.png" alt="images\543-3.png" /></a><br />特别要注意红框的flash-all的这个批处理文件，不修改这个文件的话，你安装的更新就会完全擦除手机的数据，你所有app，照片等全没了，除非你想重置手机，<strong>不然，记得一定要修改这个文件，不然，记得一定要修改这个文件，不然，记得一定要修改这个文件，重要事情说三遍！</strong>以下是修改步骤，不需要特定软件，windows自带文本编辑器便可。<br />1）随手打开电脑一个txt文档，将flash-all文件拖去这个txt的编辑窗口上。<br /><a href=""><img src="images\543-4.png" alt="images\543-4.png" /></a><br />拖过去之后：留意update前的这个“-w”，删掉，保存，记得一定要保存。<br /><a href=""><img src="images\543-5.png" alt="images\543-5.png" /></a><br />就变成这样了，记得保存：<br /><a href=""><img src="images\543-6.png" alt="images\543-6.png" /></a><br />2）然后，回到刚才解压的文件夹，还需要下载adb工具。下载地址在这里：<br /><a href="https://link.zhihu.com/?target=https%3A//developer.android.google.cn/studio/releases/platform-tools.html">SDK Platform Tools release notes | Android Developers</a><a href="https://link.zhihu.com/?target=https%3A//developer.android.google.cn/studio/releases/platform-tools.html">​developer.android.google.cn</a><br />下载到一个约10m的工具包（下面以windows7平台为例），解压到刚才月度更新包的解压文件夹内即可。这样就配置好了adb环境。<br />usb驱动：<br /><a href="https://link.zhihu.com/?target=https%3A//developer.android.google.cn/studio/run/win-usb">获取 Google USB 驱动程序 | Android Developers</a><a href="https://link.zhihu.com/?target=https%3A//developer.android.google.cn/studio/run/win-usb">​developer.android.google.cn</a><a href="https://link.zhihu.com/?target=https%3A//developer.android.google.cn/studio/run/win-usb"><br /></a>3）手机打开开发者选项，允许usb调试（这一步不会的自己百度），usb连接手机，手机显示是否允许该电脑调试，允许。<br />4）回到电脑界面，在刚才配置好adb环境的月度更新文件夹，按住电脑“shift”键，鼠标右键点击文件夹空白处，点击“在此处打开命令窗口”，便可打开命令窗口。<br />输入：adb devices<br />直至出现红框内容表示电脑与手机已经通过adb连接起来。<br />接下来就要重启手机到bootloader，输入：adb reboot bootloader<br />（另一种方法是将手机用usb连接前同样打开usb调试，关机，然后按住音量下键开机，也可以进入bootloader，进入后用usb线连接电脑）<br />5）这样，手机进入bootloader，并用usb连接电脑了，再回到刚才的文件夹。双击flash-all的批处理文件，即可完成更新，完成更新后重新开机，手机保留数据，便完成了更新。<br />更新完，root会被破坏，须重新刷magisk。这是需要解除手机的锁屏，设置为“无”，这样连指纹都会删除掉，不然进入twrp会出现乱码。预先将刷magisk的zip文件放到手机存储内，记住路径。<br />同样用以上方法进入bootloader（步骤3、4），usb连接电脑。<br />回到刚才的命令窗口，输入：fastboot boot，然后找到twrp所在的文件夹，将twrp的文件拖到命令窗口，twrp的文件路径就会自动填入（不需要将twrp文件放入特定的文件夹，拖动即可），变成这样：<br /><a href=""><img src="images\543-7.png" alt="images\543-7.png" /></a><br /><a href=""><img src="images\543-8.png" alt="images\543-8.png" /></a><br />回车后，手机便会进入临时twrp，然后可以刷magisk了（这一步不会的自己百度），再开机，手机便可以root，这样既保留数据，又更新了安全补丁，也保留了root。<br />为了保护隐私，记得设定屏幕锁定和指纹重新录入。<br />Magisk金丝雀<br /><a href="https://link.zhihu.com/?target=https%3A//github.com/topjohnwu/magisk_files/tree/canary">topjohnwu/magisk_files</a><br /><br /><br /></div><div class='page'><h1 class='title level-5'>pixel刷机后的问题</h1><br/>1、连接wifi，显示WiFi已经连接但无法上网（wifi图标出现x）<br />一、叉号/叹号出现的原因<br />我们刷完LineageOS后，连接WiFi或者移动网络，会出现叉号或叹号。这是因为在连接一个网络的时候，系统会去请求一个google的网址来确定这个网络是否具有网络访问。由于我国GFW封锁策略，导致系统请求google网址不成功，就会出现叉号或叹号。<br /><br />二、去除教程<br />1. 手机root并开启调试模式。<br />2. 电脑配置adb环境，打开命令行。<br />Android 7.0之前版本的系统，执行以下命令：<br />1. adb shell &quot;settings put global captive_portal_server connect.rom.miui.com&quot;;<br />复制代码Android 7.0之后的版本需要执行下面的两条命令：<br />1. adb shell &quot;settings put global captive_portal_http_url <a href="http://connect.rom.miui.com/generate_204";">http://connect.rom.miui.com/generate_204&quot;;</a><br />2. adb shell &quot;settings put global captive_portal_https_url <a href="https://connect.rom.miui.com/generate_204";">https://connect.rom.miui.com/generate_204&quot;;</a><br />复制代码<br />3. 然后打开飞行模式，关闭飞行模式，此时，应该去除了叉号或叹号。<br /><br />设置pixel时区与时间，关闭自动时间设置<br /><a href=""><img src="images\544-1.png" alt="images\544-1.png" /></a></div><div class='page'><h1 class='title level-4'>红米4x刷机</h1><br/>目标：获得设备的root权限<br />通过刷入开发板的miui系统，可以直接获取root权限<br /><br />pc端安装小米手机驱动（否则无法连接fastboot）<br /><a href="https://developer.android.com/studio/run/oem-usb?hl=zh-cn#Drivers">安装原始设备制造商 (OEM) USB 驱动程序  |  Android 开发者  |  Android Developers</a><br /><a href="https://www.xiaomi.cn/post/18464849">图文详解小米手机驱动安装 - 小米社区 (xiaomi.cn)</a><br /><br />小米手机申请解锁并下载解锁工具<br />开发者选项中点击设备解锁状态，从而开始解锁<br /><a href="https://www.miui.com/unlock/index.html">申请解锁小米手机 (miui.com)</a><br /><a href=""><img src="images\230-1.png" alt="images\230-1.png" /></a><br /><br />小米官方刷机<br /><a href="https://www.miui.com/shuaji-393.html">通过线刷升级 (miui.com)</a><br /><br />红米4x开发版系统下载（官方）<br /><a href="https://miuiver.com/santoni_developer_fastboot/">红米4X MIUI开发版下载索引 (线刷包) – MIUI历史版本 (miuiver.com)</a><br /><a href="https://roms.miuier.com/devices/santoni">红米4X(santoni)官方ROM合集 -- MIUI官方ROM仓库 (miuier.com)</a></div><div class='page'><h1 class='title level-5'>尝试刷入pixel</h1><br/><br />小米手机注册并下载解锁软件 并解锁<br /><a href="https://www.miuibbs.cn/threads/fastboot.1284/"> - 【刷机技巧】玩点不一样的！FASTBOOT模式常用命令汇总 | 柚坛社区 (miuibbs.cn)</a><br /><a href="https://blog.csdn.net/geniusmen/article/details/7892398?utm_medium=distribute.pc_relevant.none-task-blog-OPENSEARCH-2.not_use_machine_learn_pai&depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-2.not_use_machine_learn_pai">fastboot 详解_geniusmen的专栏-CSDN博客_fastboot</a><br /><br />使用线刷、卡刷或第三方刷机工具刷机<br /><br /><br />红米4x的twrp<br /><br /><br /><br />遇到的问题：刷入的recovery无法启动，如果fastboot flash recovery xxxx.img执行完毕后直接重启，则刷入的recovery不会生效，所以需要使用fastboot boot xxxx.img命令直接启动recovery，从而刷入系统镜像，但是此时fastboot boot xxxx.img执行是失败无法启动，疑似recovery版本不适配<br /><a href="安卓--root与刷机--相关工具--fastboot.html">fastboot详细命令</a><br /><br /><a href=""><img src="images\231-1.png" alt="images\231-1.png" /></a></div><div class='page'><h1 class='title level-4'>哪吒车机刷机救砖</h1><br/><a href="中汽研实习--IVI救砖--哪吒.html">救砖</a></div><div class='page'><h1 class='title level-3'>刷机问题诊断</h1><br/>刷机完成后，重新启动之后发现设备并未正常启动，为了查询其原因，可以使用adb logcat输出安卓日志，其中会保存安卓启动过程所作的操作，一般正是由于一些刷机错误，从而导致安卓系统启动过程中未读取到相关数据，从而启动失败，通过重刷该数据对应的分区镜像，可以修复该问题<br /></div><div class='page'><h1 class='title level-3'>线刷命令</h1><br/>使用fastboot进行刷机<br /><a href="https://blog.csdn.net/s13383754499/article/details/82755012">https://blog.csdn.net/s13383754499/article/details/82755012</a><br /><br /><h1>命令示例</h1><br />• 进入刷机模式:<br />adb reboot bootloader<br />fastboot oem unlock<br />fastboot format cache<br />fastboot format userdata<br />• 分别刷入<br />fastboot flash recovery recovery.img<br />fastboot flash  boot boot.img<br />fastboot flash system system.img<br />fastboot flash userdata userdata.img<br />fastboot continue    //进入手机，自动重启设备<br /><br /><br /><a href="https://www.jianshu.com/p/d960a6f517d8">Android Fastboot 与 Recovery 和刷机 - 简书 (jianshu.com)</a><br /><code>fastboot flashing unlock    #</code><code><span style="color:#f19250;">6.0</span></code><code>以上设备 必须解锁，开始刷机（这个不同的手机厂商不同）<br />fastboot erase </code><code><span style="color:#373c43;">{</span></code><code>partition</code><code><span style="color:#373c43;">}</span></code><code>  # 擦除分区<br />fastboot  erase  frp    # 擦除 frp 分区，frp 即 </code><code><span style="color:#f8c657;">Factory</span></code><code> </code><code><span style="color:#f8c657;">Reset</span></code><code> Protection，用于防止用户信息在手机丢失后外泄<br />fastboot  flash  boot  boot</code><code><span style="color:#373c43;">.</span></code><code>img    # 刷入 boot 分区<br />fastboot  flash  system  system</code><code><span style="color:#373c43;">.</span></code><code>img    # 刷入 system 分区<br />fastboot  flash  recovery  recovery</code><code><span style="color:#373c43;">.</span></code><code>img    # 刷入 recovery 分区<br />fastboot flashall    #烧写所有分区，注意：此命令会在当前目录中查找所有img文件，将这些img文件烧写到所有对应的分区中，并重新启动手机。<br />fastboot  format  data    # 格式化 data 分区<br />fastboot  flashing </code><code><span style="color:#ca95cb;">lock</span></code><code>    # 设备上锁，刷机完毕<br />fastboot  </code><code><span style="color:#ca95cb;">continue</span></code><code>    # 自动重启设备<br />fastboot reboot# 重启手机<br />fastboot reboot</code><code><span style="color:#6ecfce;">-</span></code><code>bootloader# 重启到bootloader 刷机用<br />fastboot devices  ## 发现手机，显示当前哪些手机通过fastboot连接了</code><br /><br /><br />通过dd命令刷recovery<br /><h3>dd if=/sdcard/twrp.img of=/dev/block/bootdevice/by-name/recovery</h3><br /><br /><br /><h3>按住音量减键开启电源进入fastboot模式，使用fastboot命令键入</h3><br />fastboot flash recovery &lt;twrp.img&gt;<br /><h3>其中&lt;twrp.img&gt;即为TWRP镜像。等待刷入，接着</h3><br />fastboot boot &lt;twrp.img&gt;<br /><h3>现在就可以操作recovery了！</h3><br /><br /><h1>刷机需要清空原有用户数据、缓存数据，称为双清，否则不能保证成功</h1><br />双清命令：<br /><h3>fastboot -w</h3><br />或者<br />fastboot format cache——清除手机缓存<br />fastboot format userdata——清除用户数据<br /><br /><a href="https://blog.csdn.net/u010758623/article/details/106872633">乐视Pro3 使用FastBoot命令 双清 恢复出厂设置_u010758623的博客-CSDN博客_fastboot双清命令</a><br /><a href=""><img src="images\233-1.png" alt="images\233-1.png" /></a><br /><h3> </h3><br /><br /><a href="https://ghost.atibm.com/adb-an-zhuo-shua-ji-chang-yong-de-adbhe-fastbootming-ling/">ADB: 安卓刷机常用的adb和fastboot命令 (atibm.com)</a><br /><h1>ADB: 安卓刷机常用的adb和fastboot命令</h1><br /><br /><h1>adb 开头的命令</h1><br /><br /><h3>adb命令</h3><br />• 要求手机处于USB调试模式才能起作用。<br />而USB调试模式是在手机的安卓系统运行后才有的状态，所以adb命令大多在手机正常开机的状态下使用。<br /><br /><br /><h3>adb install name.apk</h3><br />◇ 安装apk命令。<br />其中包名为name.apk，使用的是相对路径，也就是说name.apk文件在电脑的adb目录里，当然你也可以用绝对路径来表达。另外，如果你给adb目录加了PATH环境变量，还可以直接在apk文件所在目录下，直接执行adb install name.apk<br /><br /><br /><h3>adb uninstall name.apk</h3><br />◇ 卸载apk命令。<br /><br /><br /><h3>adb devices</h3><br />◇ 查看adb连接设备列表，<br />如果adb服务没有开启，这个命令会初始开启。正常连接会看到安卓设备编号，但如果是连接异常，还会看到在每一行的设备号后面，写着异常状态，比如offline和unauthorized。<br /><br /><br /><h3>adb reboot</h3><br />◇ 正常重启手机<br /><br /><br /><h3>adb reboot-bootloader</h3><br />◇ 重启手机，并直接进入bootloader模式，也就是刷机常用的模式<br /><br /><br /><h3>adb reboot-recovery</h3><br />◇ 重启手机，进入bootloader模式，并且直接进入recovery系统。<br />recovery系统是运行在bootloader模式下的刷机小系统，通过recovery，我们可以对系统进行更新升级，刷补丁，刷rom固件，备份，替换系统文件，修改文件属性权限，通过bootloader和recovery，可以实现常见的刷机几个模式：flash线刷，sideload线刷，还有卡刷。<br /><br /><br /><h1>fastboot开头的命令</h1><br />◇ fastboot命令<br />用于bootloader模式，<br />也就是手机重启按电源+音量下进入的那个字母界面，也就是recovery系统所处的模式。你可以称之为工程模式，或者安卓系统引导菜单。如果手机已经进入安卓系统的桌面，自然也就用不了fastboot命令，只能开usb调试，用adb命令了。<br />所以，adb与fastboot命令分别作用于手机的两种模式下。<br /><br /><br /><h3>fastboot flash bootloader bootloader-name.img</h3><br />◇ 刷入bootloader镜像文件，一般用于刷机后引导不正常时，或者引导模式对手机信息识别错误的情况下，刷入官方包里的bootloader镜像文件，另外如果是官方的升级包，一般都是默认刷入它。在官方的升级包的bat批处理命令里，也可以看到这一条类似的命令。<br /><br /><br /><h3>fastboot flash radio radio-name.img</h3><br />◇ 刷入radio无线驱动包，管理手机信号芯片等。<br /><br /><br /><h3>fastboot flash recovery TWRP-name.img</h3><br />◇ 刷入recovery系统的镜像文件，这里是TWRP的recovery系统，一种常用的第三方recovery刷机系统。recovery镜像文件需要匹配不同的机型，如果刷入后进不去recovery，很简单，找个机型正确的recovery包再次刷入就行了。所以刷这玩意，常备一个官方rom里提取出来的recovery文件，随时刷回。<br /><br /><br /><h3>fastboot flash boot boot.img</h3><br />◇ 刷入boot包，应该是引导系统的底层包？经常刷机时会遇到刷机成功，启动进入系统却失败，都是boot.img没刷导致。可能原因就是boot.img与system.img不匹配，但是我并不是非常确定，所以也不好跟你乱说，只是说了这种用法，更明确的技术解释期待他人吧。<br /><br /><br /><h3>fastboot flash system system.img</h3><br />◇ 刷入system的安卓系统主要文件。<br />这里好几条命令，又是bootloader，又是boot，还有radio，recovery为什么要这么命名。这个我也没有过多深究，说一下个人理解，并非肯定正确的解释。<br />安卓的文件管理类似linux，linux与windows对存储分区的管理不同。windows我们是c盘d盘这样说，linux就是data目录，system目录，etc目录这样，是不是明白了点。bootloader这些名词应该也是对应的目录，但是这些是特殊目录，在安卓系统的框架里，已经固定了各自的权限和作用。所以刷机就是用特殊的命令去写入各种包，组成一套新的系统。你可以把这些命令理解为ctrl c和ctrl v……<br /><br /><br /><h3>fastboot flash cache cache.img</h3><br />◇ 刷入cache缓存文件，如果不刷它的话也可以清空，系统如果找不到cache缓存文件，就会自动生成。虽然它不是必须的可以为空，但是如果它已经有了，反而可能会影响系统启动，比如cache为旧系统产生的，刷机后新系统会先去读取cache的数据，导致不匹配而启动异常。所以刷机常说要双清，其中一清就是清除cache，还有一清就在下一条命令，叫userdata<br /><br /><br /><h3>fastboot flash userdata userdata.img</h3><br />◇ 刷入userdata镜像文件，直接字面理解，就是用户数据，既然是用户数据，它也同cache缓存一样，是可有可无的。cache和userdata的清除只会删掉你的使用数据，但不会导致系统崩溃。清除是很容易的，但是要保留就很难了。啥都清空刷机没啥意思，如果你能保留住自己的数据刷机那就很有成就感了。<br /><br /><br /><h3>fastboot reboot-bootloader</h3><br />◇ 重启bootloader模式<br /><br /><br /><h3>fastboot -w</h3><br />◇ 清空用户数据区和缓存区.相当于recovery菜单中的&quot;wipe data/factoryreset&quot;<br />这和别人用的刷机命令里的双清是否是同一个命令就不知道了。<br />在nexus5升级6.0的过程里，我折腾了十几遍刷机，这条命令起到的是双清的作用。<br /><br /><br /><h3>fastboot erase boot</h3><br />◇ fastboot erase cache<br />◇ fastboot erase recovery<br />◇ fastboot erase system<br />◇ fastboot erase userdata<br /><code>清空不同的文件系统分区</code><br /><br /></div><div class='page'><h1 class='title level-4'>常见rom包（zip格式）刷机</h1><br/>常见的rom包中的flash_all.bat中存放线刷命令<br /><a href=""><img src="images\464-1.png" alt="images\464-1.png" /></a><br /></div><div class='page'><h1 class='title level-4'>理想的刷机指令序列</h1><br/><a href="https://www.cnblogs.com/dengshuangjang/p/12462053.html">https://www.cnblogs.com/dengshuangjang/p/12462053.html</a><br /><br /><h3>fastboot命令</h3><br /><h3>主流Android手机进入Fastboot的方式为【音量－】+【电源键】。</h3><br /><h3>执行命令 adb  reboot  fastboot。</h3><br /><h3>fastboot devices 列出所有与电脑连接的设备。</h3><br /><h3>fastboot reboot 正常启动系统。</h3><br /><h3>adb reboot recovery</h3><br /><h3>fastboot reboot-bootloader 启动系统到hboot。</h3><br /><h3>在工具界面输入 fastboot oem get-bootinfo命令，如果弹出的提示是unlocked，说明手机已经解锁了。</h3><br /><h3>fastboot  flashing  unlock 设备解锁，开始刷机。</h3><br /><h3>在工具界面输入：fastboot oem unlock 123456789 命令，（123456789代表您手机的解锁码，注意每个手机解锁码都不一样，需要在官网查询），有的机型上锁命令是fastboot oem lock 123456789。</h3><br /><h3>Android系统分区介绍：</h3><br /><h3>hboot—系统开机引导类似电脑BIOS，这块刷错手机就会变成砖。</h3><br /><h3>radio—通讯模块、基带、WIFI、Bluetooth等衔接硬件的驱动软件。</h3><br /><h3>recovery－系统故障时负责恢复。</h3><br /><h3>boot－Linux嵌入式系统内核。</h3><br /><h3>system－系统文件、应用。</h3><br /><h3>cache－系统运行时产生的缓存。</h3><br /><h3>userdata－用户使用APP产生的缓存数据。</h3><br /><h3>fastboot erase system</h3><br /><h3>fastboot erase boot #擦除boot分区</h3><br /><h3>……</h3><br /><h3>几种分区写入如下：(例如：system.img刷入的分区电脑上具体的路径)。</h3><br /><h3>fastboot flash recovery recovery.img # 刷入 recovery 分区</h3><br /><h3>fastboot flash system system.img</h3><br /><h3>fastboot flash boot boot.img</h3><br /><h3>fastboot flash radio radio.img 一般不刷它。</h3><br /><h3>fastboot flash bootloader bootloader  # 刷入 bootloader</h3><br /><h3>fastboot update update.zip #将update.zip刷入。</h3><br /><h3>fastboot flashall 刷入boot.img、system.img、recovery.img 例句：fastboot flashall update.zip。</h3><br /><h3>fastboot update &lt;文件名&gt; 从官方update.zip升级系统.该update.zip必须是官方的。</h3><br /><h3>fastboot erase frp # 擦除 frp 分区，frp 即 Factory Reset Protection，用于防止用户信息在手机丢失后外泄。</h3><br /><h3>fastboot flashing lock # 设备上锁，刷机完毕。</h3><br /><h3>fastboot reboot命令重启系统，也可以长按电源键8秒进行重启。</h3><br /><br /><h3>adb shell pm list packages -s &gt;系统应用.txt</h3><br /><h3>adb shell pm list packages -s -e&gt;启用的应用.txt</h3><br /><h3>adb shell pm list packages -s -d&gt;停用的应用.txt</h3><br /><h3>停用，adb shell pm disable-user+空格+应用名</h3><br /><h3>启用，adb shell pm enable+空格+应用名</h3><br /><h3>adb shell pm enable com.huawei.himovie</h3></div><div class='page'><h1 class='title level-3'>相关工具</h1><br/></div><div class='page'><h1 class='title level-4'>fastboot</h1><br/><a href="https://www.miuibbs.cn/threads/fastboot.1284/"> - 【刷机技巧】玩点不一样的！FASTBOOT模式常用命令汇总 | 柚坛社区 (miuibbs.cn)</a><br /><a href=""><img src="images\236-1.png" alt="images\236-1.png" /></a><br /><br />OEM解锁相关命令(非通用)<br /><a href=""><img src="images\236-2.png" alt="images\236-2.png" /></a><br /></div><div class='page'><h1 class='title level-4'>recovery</h1><br/>好用的recovery ：twrp，但是没有找到与红米4x版本相适配的<br /> <br />Magisk-v17.1是用来获取root权限的<br />疑似红米4x可用的recovery来源<br /><a href="https://www.xiaomi.cn/post/2054206">[RECOVERY][支持MiRecovery刷入]TWRP 3.1.0-0 汉化版 17/03/11 - 小米社区 (xiaomi.cn)</a><br /><a href="https://www.cnblogs.com/tyxx/p/10920731.html">小米手机 fastboot 方式刷入 TWRP recovery ，以红米4X(santoni)为例 - one-noob - 博客园 (cnblogs.com)</a><br /><a href="https://twrp.me/">TeamWin - TWRP</a><br /><a href="https://twrp.me/xiaomi/xiaomiredmi4x.html">Xiaomi Redmi 4X (twrp.me)</a><br /><br /></div><div class='page'><h1 class='title level-4'>系统镜像</h1><br/>pixel镜像官方下载地址，输入设备型号即可找到适配镜像<br /><a href="https://download.pixelexperience.org/">Home - PixelExperience</a><br /><a href="https://download.pixelexperience.org/santoni">Xiaomi Redmi 4X (santoni) - PixelExperience</a></div><div class='page'><h1 class='title level-2'>smali</h1><br/><a href=""><img src="images\322-1.png" alt="images\322-1.png" /></a><br /><a href=""><img src="images\322-2.png" alt="images\322-2.png" /></a><br /><a href=""><img src="images\322-3.png" alt="images\322-3.png" /></a><br /><a href=""><img src="images\322-4.png" alt="images\322-4.png" /></a><br /><br /><br /></div><div class='page'><h1 class='title level-2'>so层逆向</h1><br/>如果未能直接搜索到目标函数名，则说明该含糊可能是动他注册的，需要分析JNI_Onload函数<br /><br />未加ollvm保护的jnionload函数，sub_9108处动态注册jni函数<br /><a href=""><img src="images\463-1.png" alt="images\463-1.png" /></a><br />动态注册<br /><a href=""><img src="images\463-2.png" alt="images\463-2.png" /></a><br />从结构体中找到动态注册的函数的地址<br /><a href=""><img src="images\463-3.png" alt="images\463-3.png" /></a><br />找到check函数<br /><a href=""><img src="images\463-4.png" alt="images\463-4.png" /></a><br /><br /><br /><br />增加了ollvm保护的jnionload函数，同时该apk也增加了字符串加密<br /><a href=""><img src="images\463-5.png" alt="images\463-5.png" /></a><br /><br /></div><div class='page'><h1 class='title level-2'>安装谷歌服务</h1><br/><a href=""><img src="images\246-1.png" alt="images\246-1.png" /></a></div><div class='page'><h1 class='title level-2'>安卓sdk工具使用</h1><br/><br /></div><div class='page'><h1 class='title level-3'>aapt获得包名类名</h1><br/>	反编译某些app，从而获得其包名和类名信息，如果jeb和androidkiller均不行，则可以使用aapt工具<br />	<a href=""><img src="images\24-1.png" alt="images\24-1.png" /></a><br />	<a href=""><img src="images\24-2.png" alt="images\24-2.png" /></a><br />	 <a href=""><img src="images\24-3.png" alt="images\24-3.png" /></a><br />	<a href=""><img src="images\24-4.png" alt="images\24-4.png" /></a><br />	<a href=""><img src="images\24-5.png" alt="images\24-5.png" /></a><br />	</div><div class='page'><h1 class='title level-3'>adb命令</h1><br/>adb命令<a name="adb命令"></a><br />注意进行adb命令时，参数中不能出现中文，否则可能执行失败<br /><br /><h1>启动与关闭sapk</h1><br />启动APK，在终端直接输入：<br />adb shell am start -n 包名/.类名<br />比如要打开camera，就输入 adb shell am start -n com.android.camera/.Camera 即可。<br /><br />关闭APK，在终端直接输入：<br />adb shell am force-stop 包名<br />比如要关闭camera，就输入 adb shell am force-stop com.android.camera 即可。<br /><a href=""><img src="images\25-1.png" alt="images\25-1.png" /></a><br /><br />adb install安装的apk可以在/data/data中找到对应包名<br />adb push 1.jpg /sdcard/<br />adb pull /sdcard/zhuabao0.pcap d:\test\<br /><br />adb常用命令<br /><a href=""><img src="images\25-2.png" alt="images\25-2.png" /></a><br /><a href=""><img src="images\25-3.png" alt="images\25-3.png" /></a><br />	<br />adb进入指定的设备<br />adb -s 设备名 shell<br />adb logcat，输出当前设备的logcat<br /><br />adb 截屏<br />adb shell screencap -p /sdcard/screen.png<br />adb pull /sdcard/screen.png<br /></div><div class='page'><h1 class='title level-4'>adb查看顶层activity</h1><br/><h3>使用adb命令查看最上层activity：</h3><br /><h3>方法一 ：</h3><br /><h3> 在cmd命令中输入：adb shell dumpsys activity activities</h3><br /><h3> 查看    * Hist #1: ActivityRecord{76f895b u0 com.hardwaremanager/.activity.SystemInfoActivity t39}<br />          packageName=com.hardwaremanager processName=com.hardwaremanager<br />          launchedFromUid=1000 launchedFromPackage=com.hardwaremanager userId=0<br />          app=ProcessRecord{adb308c 11225:com.hardwaremanager/1000}<br />          Intent { cmp=com.hardwaremanager/.activity.SystemInfoActivity }<br />          frontOfTask=false task=TaskRecord{e4f3bde #39 A=com.hardwaremanager U=<br />0 sz=2}<br />          taskAffinity=com.hardwaremanager<br />          realActivity=com.hardwaremanager/.activity.SystemInfoActivity<br />          baseDir=/system/app/LzyHardWareManager/LzyHardWareManager.apk<br />          dataDir=/data/user/0/com.hardwaremanager</h3><br /><h3>其中 com.hardwaremanager为包名，.activity.SystemInfoActivity为当前activity名，</h3><br /><h3>而且我们还可以看到一些其他信息，</h3><br /><h3> </h3><br /><h3>方法二 ：</h3><br /><h3>在cmd命令中输入adb shell dumpsys activity | findstr &quot;mFocusedActivity&quot;</h3><br /><h3>查看     mFocusedActivity: ActivityRecord{76f895b u0 com.hardwaremanager/.activity.SystemInfoActivity</h3><br /><h3>其中 com.hardwaremanager为包名 ，SystemInfoActivity 为当前activity名</h3><br /></div><div class='page'><h1 class='title level-4'>adb获取安卓配置信息</h1><br/>实例：查看app签名密钥<br /><a href=""><img src="images\418-1.png" alt="images\418-1.png" /></a><br /><br /><br />命令使用<br /><a href=""><img src="images\418-2.png" alt="images\418-2.png" /></a></div><div class='page'><h1 class='title level-4'>查看当前运行的apk的包名</h1><br/>确定车机中app及对应app包名的方法<br />1、通过monitor将指定进程关闭，然后观察车机中对应app是否被关闭，从而确定车机app与其包名的关系<br />2、输入命令：adb shell am monitor，然后启动需要获取包名的应用，可以显示对应app的包名<br /><a href=""><img src="images\504-1.png" alt="images\504-1.png" /></a><br />3、adb shell pm list packages -3查看自己安装的app包名，或者在shell中使用命令  pm list packages -3 <br /><a href=""><img src="images\504-2.png" alt="images\504-2.png" /></a><br />4、安卓系统中：设置——应用——正在运行 查看<br /><a href=""><img src="images\504-3.png" alt="images\504-3.png" /></a><br />5、安卓系统中：文件管理器访问目录/data/data下，文件夹即为包名<br /><a href=""><img src="images\504-4.png" alt="images\504-4.png" /></a><br />6、将apk包反编译后，打开AndroidManifest.xml，搜索package获取包名<br /><a href=""><img src="images\504-5.png" alt="images\504-5.png" /></a></div><div class='page'><h1 class='title level-4'>进入recovery和bootloader</h1><br/><a href="https://www.cnblogs.com/0616--ataozhijia/p/5606891.html">https://www.cnblogs.com/0616--ataozhijia/p/5606891.html</a><br /><br />重启到Recovery界面<br />adb reboot recovery<br />重启到bootloader界面<br />adb reboot bootloader<br /><br />adb wait-for-device #等待设备<br />adb reboot-bootloader #这个是重启到bootloader界面 默认是fastboot。可以先重启到这里再刷入boot.img<br />fastboot flash boot boot.img #这个是刷入boot的命令。官解的要手动刷一次。<br />fastboot flash recovery recovery.img #刷入recovery 已有recovery的可以跳过。<br />fastboot erase boot #擦除boot分区<br />以下两个是一样的 有加-w 跟 没有加-w 的区别<br />fastboot erase system -w #擦除system分区 擦除 userdata分区和cache分区<br />fastboot erase system #擦除system分区<br />fastboot erase cache #擦除cache分区<br />fastboot erase userdata #擦除userdata分区<br />fastboot update update.zip #将update.zip刷入<br />fastboot reboot #重启手机<br /><br />开机状态下：<br />adb reboot fastboot   命令进入fastboot模式<br />adb reboot recovery　命令行进recovery模式<br />power +　音量下　recovery 模式<br />关机状态下：<br />power + 音量下 recovery 模式<br />power + 音量上 fastboot 模式<br />recovery 模式下可以选择进入fastboot 模式</div><div class='page'><h1 class='title level-3'>devices monitor</h1><br/>使用<br />android devices monitor的使用<br /><a href="https://www.jianshu.com/p/e6e930a4c67d">android device monitor的配置和使用 - 简书 (jianshu.com)</a><br /><a href="https://jingyan.baidu.com/article/3a2f7c2e07e43b26afd611f0.html">Android Device Monitor怎么用-百度经验 (baidu.com)</a><br /><a href="https://blog.csdn.net/ancientear/article/details/81086127">Android Device Monitor使用方法及常见问题解决方案_ancientear的博客-CSDN博客_android device monitor</a><br /><a href="https://jingyan.baidu.com/article/3a2f7c2e07e43b26afd611f0.html">Android Device Monitor怎么用-百度经验 (baidu.com)</a><br /><a href="https://blog.csdn.net/deniro_li/article/details/79459002">在 Android Device Monitor 的 File Explorer 中，无法打开某些文件夹的解决方法_读万卷书，行万里路-CSDN博客</a><br />	<br />device montor中不能查看文件系统解决方案<br /><a href=""><img src="images\47-1.png" alt="images\47-1.png" /></a><br />	<br />可以使用adb连接进去，使用chmod修改文件权限	<br />查看logcat级别，关注d级别</div><div class='page'><h1 class='title level-2'>安卓开发相关</h1><br/>查看麦洛克菲笔记、第一行安卓代码笔记<br />app网络通讯<br />	《第一行安卓代码》网络部分<br />	网络类一般单独实现，并且发起网络连接时创建子线程处理<br /><br />app/build.gradle文件<br />	<a href="https://www.jianshu.com/p/55e6e670a2ce">https://www.jianshu.com/p/55e6e670a2ce</a><br />	如果需要使用第三方库，则需要将相关依赖信息保存到该文件中<br />		</div><div class='page'><h1 class='title level-3'>安卓webview实现</h1><br/><a href="https://blog.csdn.net/brian512/article/details/42529831">https://blog.csdn.net/brian512/article/details/42529831</a><br /><h1>Android使用WebView显示网页（图片大小的处理及内容的自适应）</h1><br /><br /><h3>在Android开发过程中，会遇到需要显示网页的需求，或者需要用webview控件来达到某个效果。我这段时间在做CSDN博客的客户端，使用webview来显示博文内容，一是因为解析博文内容再适配比较麻烦，并且效果很不理想，后来想到直接用webview来显示，将博文原汁原味的呈现出来。</h3><br /><h3>webview使用起来比较容易，但是想要达到比较理想的效果还需要很多摸索。我做的CSDNBlog客户端，现在基本可以使用，已经在进行版本迭代了，但是博文的webview显示效果依然不太满意，主要是因为图片的缩放问题。接下来就看看代码：</h3><br /><div class="codebox"><div class="codebox">&lt;pre&nbsp;name=<span style="color:#3ad900;font-weight:400">&quot;code&quot;</span>&nbsp;<span style="color:#7f0044;font-weight:400">class</span>=<span style="color:#3ad900;font-weight:400">&quot;java&quot;</span>&gt;		webView&nbsp;=&nbsp;(WebView)&nbsp;findViewById(R.id.article_content);<br />		<br />		webView.setWebViewClient(<span style="color:#ff9d00;font-weight:700">new</span>&nbsp;MyWebViewClient());<br />		webView.getSettings().setDefaultTextEncodingName(<span style="color:#3ad900;font-weight:400">&quot;utf-8&quot;</span>);<br />		webView.getSettings().setAppCacheEnabled(<span style="color:#ff0044;font-weight:400">true</span>);<span style="color:#0088ff;font-weight:400">//&nbsp;设置启动缓存</span><br />		webView.getSettings().setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK);<br />		<br />		<span style="color:#7f0044;font-weight:400">boolean</span>&nbsp;isLoadImg&nbsp;=&nbsp;CSDNPreferences.getPreferenceSetting(<span style="color:#ff9d00;font-weight:700">this</span>,&nbsp;getString(R.string.pre_key_loadImg),&nbsp;<span style="color:#ff0044;font-weight:400">true</span>);<br />		Log.i(TAG,&nbsp;<span style="color:#3ad900;font-weight:400">&quot;isLoadImg=&quot;</span>&nbsp;+&nbsp;isLoadImg);<br />		webView.getSettings().setLoadsImagesAutomatically(isLoadImg);<br />		<br />		webView.getSettings().setBlockNetworkImage(<span style="color:#ff0044;font-weight:400">true</span>);<span style="color:#0088ff;font-weight:400">//拦截图片的加载，网页加载完成后再去除拦截</span><br />		<br />		<br /><span style="color:#0088ff;font-weight:400">//		webView.getSettings().setJavaScriptEnabled(true);</span><br /><span style="color:#0088ff;font-weight:400">//		webView.getSettings().setDisplayZoomControls(true);//&nbsp;设置显示缩放按钮</span><br /><span style="color:#0088ff;font-weight:400">//		webView.getSettings().setSupportZoom(true);&nbsp;//&nbsp;支持缩放&nbsp;</span><br /><span style="color:#0088ff;font-weight:400">//		webView.getSettings().setBuiltInZoomControls(true);</span><br />		<br />		<span style="color:#0088ff;font-weight:400">//方法一：</span><br /><span style="color:#0088ff;font-weight:400">//		webView.getSettings().setUseWideViewPort(true);//让webview读取网页设置的viewport，pc版网页</span><br /><span style="color:#0088ff;font-weight:400">//		webView.getSettings().setLoadWithOverviewMode(true);</span><br />		<br />		<span style="color:#0088ff;font-weight:400">//方法二：</span><br />		webView.getSettings().setLayoutAlgorithm(LayoutAlgorithm.NARROW_COLUMNS);<span style="color:#0088ff;font-weight:400">//适应内容大小</span><br /><span style="color:#0088ff;font-weight:400">//		webView.getSettings().setLayoutAlgorithm(LayoutAlgorithm.SINGLE_COLUMN);//适应屏幕，内容将自动缩放</span></div></div><br /><br />webview的使用主要是其setting的配置，一些常用的方法注释写的比较清楚了。<br /><h3>写的博客已经是可以离线查看的，所以不需要启用缓存，每次打开新的博文时，已经把获取的网页源码截取出文章正文内容存储在数据库中了。</h3><br /><br /><br /><h3>目前遗留的问题就是图片的缩放：打开网页时，字体显示的还好，只是图片显示太大了，如果图片的宽度大于屏幕的宽度，webview就可以横向滑动，这样的体验不太好，并且给用户的感觉很耗流量。在网上查找解决办法，得到代码里提示的两种方法（大家推荐的其实还有一种方法），第一种方法中，webview会按照pc网页设置的viewport属性进行加载网页。</h3><br /><span style="color:#0000ff;">&lt;</span>meta <span style="color:#ff0000;">name</span><span style="color:#0000ff;">=&quot;viewport&quot;</span><span style="color:#ff0000;"> content</span><span style="color:#0000ff;">=&quot;width=device-width&quot; &gt;</span><br /><h3>如果有上面这样的设置，就可以适配到移动设备上，如果没有，就会默认显示pc版式的网页。</h3><br /><h3>第二种方法，如注释写的一样，NARROW_COLUMNS内容不变，会根据屏幕宽度自动换行；而SINGLE_COLUMN则会让更加内容的宽度，缩放内容的大小，这样的效果就是网页被缩小到甚至文字都看不到了。</h3><br /><br /><br /><h3>第三种方法我还没有尝试过，就是根据不同的dpi，让网页进行相应的缩放。感觉是不能解决问题的，具体效果还是得试试。</h3><br /><br /><br /><h3>其实我想通过修改网页源码来更改图片的标签的属性，把图片的宽度设置为屏幕的宽度，正准备尝试这种办法。</h3><br /><br /><br /><h3>需要复写一个客户端类：</h3><br /><div class="codebox"><div class="codebox">	<span style="color:#0088ff;font-weight:400">/**<br />	&nbsp;*&nbsp;继承WebViewClient<br />	&nbsp;*/</span><br />	<span style="color:#7f0044;font-weight:400">class</span>&nbsp;MyWebViewClient&nbsp;<span style="color:#7f0044;font-weight:400">extends</span>&nbsp;WebViewClient&nbsp;{<br />&nbsp;<br />		&nbsp;<span style="color:#0088ff;font-weight:400">//重写shouldOverrideUrlLoading方法，使点击链接后不使用其他的浏览器打开。&nbsp;</span><br />	&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;<br />	&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#7f0044;font-weight:400">public</span>&nbsp;<span style="color:#7f0044;font-weight:400">boolean</span>&nbsp;shouldOverrideUrlLoading(WebView&nbsp;view,&nbsp;String&nbsp;url)&nbsp;{&nbsp;<br />	&nbsp;&nbsp;&nbsp;&nbsp;	<br />	&nbsp;&nbsp;&nbsp;&nbsp;	progressBar.setVisibility(View.VISIBLE);<br />	&nbsp;&nbsp;&nbsp;&nbsp;	<br />	&nbsp;&nbsp;&nbsp;&nbsp;	String&nbsp;bloger&nbsp;=&nbsp;Constants.DEFAULT_BLOG_USER_ID;<br />	&nbsp;&nbsp;&nbsp;&nbsp;	Pattern&nbsp;pattern&nbsp;=&nbsp;<span style="color:#ff0044;font-weight:700">null</span>;<br />	&nbsp;&nbsp;&nbsp;&nbsp;	System.out.println(url);<br />	&nbsp;&nbsp;&nbsp;&nbsp;	<span style="color:#ff9d00;font-weight:700">if</span>&nbsp;(url.matches(Constants.DEF_STR_REGEX.REGEX_DETAILS))&nbsp;{<span style="color:#0088ff;font-weight:400">//链接为CSDN博客内容</span><br />	&nbsp;&nbsp;&nbsp;&nbsp;		<span style="color:#ff9d00;font-weight:700">new</span>&nbsp;MainTask().execute(url);<br />	&nbsp;&nbsp;&nbsp;&nbsp;		<span style="color:#ff9d00;font-weight:700">return</span>&nbsp;<span style="color:#ff0044;font-weight:400">true</span>;<br />			}&nbsp;<span style="color:#ff9d00;font-weight:700">else</span>&nbsp;<span style="color:#ff9d00;font-weight:700">if</span>&nbsp;(url.matches(Constants.DEF_STR_REGEX.REGEX_BLOG))&nbsp;{<span style="color:#0088ff;font-weight:400">//博客主页</span><br />				<br />				pattern&nbsp;=&nbsp;Pattern.compile(Constants.DEF_STR_REGEX.REGEX_BLOG);<br />				<br />			}&nbsp;<span style="color:#ff9d00;font-weight:700">else</span>&nbsp;<span style="color:#ff9d00;font-weight:700">if</span>&nbsp;(url.matches(Constants.DEF_STR_REGEX.REGEX_CATEGORY)<span style="color:#0088ff;font-weight:400">//博客列表或者分类</span><br />					||&nbsp;url.matches(Constants.DEF_STR_REGEX.REGEX_BLOGLIST))&nbsp;{<br />				<br />				pattern&nbsp;=&nbsp;Pattern.compile(Constants.DEF_STR_REGEX.REGEX_LIST);<br />				<br />			}&nbsp;<span style="color:#ff9d00;font-weight:700">else</span>&nbsp;{<br />				<span style="color:#ff9d00;font-weight:700">return</span>&nbsp;<span style="color:#ff0044;font-weight:400">false</span>;<span style="color:#0088ff;font-weight:400">//让系统处理该链接请求</span><br />			}<br />	&nbsp;&nbsp;&nbsp;&nbsp;	<br />	&nbsp;&nbsp;&nbsp;&nbsp;	Matcher&nbsp;matcher&nbsp;=&nbsp;pattern.matcher(url);<br />	&nbsp;&nbsp;&nbsp;&nbsp;	<span style="color:#ff9d00;font-weight:700">if</span>&nbsp;(matcher.find())&nbsp;{<br />	&nbsp;&nbsp;&nbsp;&nbsp;		bloger&nbsp;=&nbsp;matcher.group(<span style="color:#ff0044;font-weight:400">1</span>);<br />	&nbsp;&nbsp;&nbsp;&nbsp;	}<br />	&nbsp;&nbsp;&nbsp;&nbsp;	CSDNApplication.getInstance().setCurrentBlogerID(bloger);<br />	&nbsp;&nbsp;&nbsp;&nbsp;	<br />	&nbsp;&nbsp;&nbsp;&nbsp;	mDB.saveBloger(bloger);<br />	&nbsp;&nbsp;&nbsp;&nbsp;	<br />	&nbsp;&nbsp;&nbsp;&nbsp;	Intent&nbsp;intent&nbsp;=&nbsp;<span style="color:#ff9d00;font-weight:700">new</span>&nbsp;Intent();<br />	&nbsp;&nbsp;&nbsp;&nbsp;	intent.setClass(BlogContentActivity.<span style="color:#ff9d00;font-weight:700">this</span>,&nbsp;MainTabActivity.<span style="color:#7f0044;font-weight:400">class</span>);<br />	&nbsp;&nbsp;&nbsp;&nbsp;	intent.putExtra(getString(R.string.app_name),&nbsp;Constants.DEF_BLOG_TYPE.BLOGERBLOG);<br />	&nbsp;&nbsp;&nbsp;&nbsp;	startActivity(intent);<br />	&nbsp;&nbsp;&nbsp;&nbsp;	BlogContentActivity.<span style="color:#ff9d00;font-weight:700">this</span>.finish();<br />	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#0088ff;font-weight:400">//如果不需要其他对点击链接事件的处理返回true，否则返回false&nbsp;</span><br />	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#ff9d00;font-weight:700">return</span>&nbsp;<span style="color:#ff0044;font-weight:400">true</span>;&nbsp;<br />	&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<br />	&nbsp;&nbsp;&nbsp;&nbsp;<br />	&nbsp;&nbsp;&nbsp;&nbsp;@Override<br />	&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#7f0044;font-weight:400">public</span>&nbsp;<span style="color:#7f0044;font-weight:400">void</span>&nbsp;onPageFinished(WebView&nbsp;view,&nbsp;String&nbsp;url)&nbsp;{</div></div><br /><code><br /></code><div class="codebox"><div class="codebox">&lt;span&nbsp;style=<span style="color:#3ad900;font-weight:400">&quot;white-space:pre&quot;</span>&gt;		&lt;/span&gt;webView.getSettings().setBlockNetworkImage(<span style="color:#ff0044;font-weight:400">false</span>);<span style="color:#0088ff;font-weight:400">//去除图片拦截，继续加载图片</span><br />	&nbsp;&nbsp;&nbsp;&nbsp;	<span style="color:#ff9d00;font-weight:700">super</span>.onPageFinished(view,&nbsp;url);<br />	&nbsp;&nbsp;&nbsp;&nbsp;	Log.i(TAG,&nbsp;<span style="color:#3ad900;font-weight:400">&quot;onPageFinished&quot;</span>);<br />	&nbsp;&nbsp;&nbsp;&nbsp;}<br />	&nbsp;&nbsp;&nbsp;&nbsp;<br />	&nbsp;&nbsp;&nbsp;&nbsp;@Override<br />	&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#7f0044;font-weight:400">public</span>&nbsp;<span style="color:#7f0044;font-weight:400">void</span>&nbsp;onReceivedError(WebView&nbsp;view,&nbsp;<span style="color:#7f0044;font-weight:400">int</span>&nbsp;errorCode,&nbsp;String&nbsp;description,&nbsp;String&nbsp;failingUrl)&nbsp;{<br />	&nbsp;&nbsp;&nbsp;&nbsp;	<span style="color:#ff9d00;font-weight:700">super</span>.onReceivedError(view,&nbsp;errorCode,&nbsp;description,&nbsp;failingUrl);<br />	&nbsp;&nbsp;&nbsp;&nbsp;	Log.i(TAG,&nbsp;<span style="color:#3ad900;font-weight:400">&quot;onReceivedError&quot;</span>);<br />	&nbsp;&nbsp;&nbsp;&nbsp;	<span style="color:#0088ff;font-weight:400">//这里进行无网络或错误处理，具体可以根据errorCode的值进行判断，做跟详细的处理。</span><br />	&nbsp;&nbsp;&nbsp;&nbsp;}<br />		<br />	}</div></div><br /><br /><br /><h3>在这里把代码都贴过来了，主要是对webview网页内部的链接进行的处理，如果是CSDN的博文，就直接显示在当前页，如果是博文列表就退出到上一个界面进行显示，如果是其他的网页链接就直接通过android默认的打开方式处理。</h3><br /><a href="https://img-blog.csdn.net/20150108225059937"><img src="images\772-1.png" alt="images\772-1.png" /></a><br /><br /><h3>webview的其他使用技巧，等到大神前来指点。</h3><br /><h3>此致</h3><br /><br /><a href=""><img src="images\772-2.png" alt="images\772-2.png" /></a><br /><br /></div><div class='page'><h1 class='title level-3'>安卓客户端与服务器端通讯</h1><br/>在客户端和服务端之间进行http数据传输<br />HttpURLConnection.getInputStream与HttpURLConnection.getOutputStream<br />	客户端上的使用<br />1.getInputStream方法可以得到一个输入流，客户端的Socket对象上的getInputStream方法得到输入流其实就是从服务器端发回的数据。<br />2.getOutputStream方法得到的是一个输出流，客户端的Socket对象上的getOutputStream方法得到的输出流其实就是发送给服务器端的数据。<br /><br />服务器端上的使用<br />1.getInputStream方法得到的是一个输入流，服务端的Socket对象上的getInputStream方法得到的输入流其实就是从客户端发送给服务器端的数据流。<br />2.getOutputStream方法得到的是一个输出流，服务端的Socket对象上的getOutputStream方法得到的输出流其实就是发送给客户端的数据。</div><div class='page'><h1 class='title level-3'>安卓四大组件</h1><br/></div><div class='page'><h1 class='title level-4'>activity</h1><br/><h1>activity切换</h1><br />设置一个按钮<br />创建Intent<br />设置启动信息，参数是自己的以及被启动的activity<br />启动类<br />		代码<br />			        //启动另一个activity<br />        Button button5=findViewById(R.id.btn5);<br />        button5.setOnClickListener(new View.OnClickListener() {<br />            @Override<br />            public void onClick(View view) {<br />                Intent intent = new Intent(MainActivity.this,Main2Activity.class);<br />                startActivity(intent);<br />            }<br />        });<br />        <br /><h1>activity生命周期</h1><br />		可能执行7种函数<br />			onCreate<br />			onStop<br />			onStart<br />			onPause<br />			onResume<br />			onRestart<br />			onDestory<br />		7种函数两两相对（除了onRestart）形成3种生存期<br />			完整生存期<br />				onCreate<br />				onDestory<br />			可见生存期<br />				onStart<br />				onStop<br />			前台生存期<br />				onPause<br />				onResume<br />		以上函数用于activity对应界面生成，切换，关闭等时刻调用<br />		<br />		程序运行起来<br />			onCreate<br />			onStart<br />			onResume<br />		当activity被覆盖的时候<br />			onPause<br />			onStop<br />		当重新显示<br />			onRestart<br />			onStart<br />			onResume<br />		当关闭<br />			onPause<br />			onStop<br />			onDestory</div><div class='page'><h1 class='title level-3'>当前as的API版本与设备要求不符</h1><br/>修改build.gradle文件<br /><a href=""><img src="images\804-1.png" alt="images\804-1.png" /></a></div><div class='page'><h1 class='title level-2'>安卓模拟器使用</h1><br/></div><div class='page'><h1 class='title level-3'>GenyMotion</h1><br/></div><div class='page'><h1 class='title level-4'>安装arm架构的apk</h1><br/>genymotion虚拟机架构为x86 x64，如果需要安装arm架构apk，需要安装Genymotion_ARM_Translation，该程序以zip格式存在，针对不同版本的安卓，需要使用不同版本的Genymotion_ARM_Translation，不同版本程序可以在下面连接中下载<br /><a href="https://github.com/m9rco/Genymotion_ARM_Translation">https://github.com/m9rco/Genymotion_ARM_Translation</a><br /><br />安装Genymotion_ARM_Translation时，可直接将zip包拖到genymotion虚拟机界面上，虚拟机会自动将Genymotion_ARM_Translation内容刷入，刷入完成后重启即可<br /><br /><br />Genymotion_ARM_Translation的github中提供了另一种刷入固件的方法<br /><a href=""><img src="images\472-1.png" alt="images\472-1.png" /></a><br /><br /><code>  1. adb shell<br />  2. cd /sdcard/Download/<br />  3. sh /system/bin/flash-archive.sh /sdcard/Download/Genymotion-ARM-Translation.zip<br />  4. adb reboot</code><br /><br /><br /><br /></div><div class='page'><h1 class='title level-4'>安装genymation</h1><br/><a href="https://www.genymotion.com/">https://www.genymotion.com/</a><br />将本机的virtualbox删除，官网直接下载带virtualbox的genymotion版本直接安装<br />可以保证安卓虚拟机正常运行<br /><a href=""><img src="images\471-1.png" alt="images\471-1.png" /></a></div><div class='page'><h1 class='title level-2'>安卓逆向工具</h1><br/>对应安卓逆向工具总结的xmind，待补充<br /></div><div class='page'><h1 class='title level-3'>apksigner</h1><br/>apk签名验证工具<br /><br />使用keytool生成密钥对<br />1<br />keytool -genkeypair -keystore 密钥名 -alias 密钥别名 -validity 有效天数 -keyalg RSA<br />使用apksigner给apk重新签名<br /><br />1<br />java -jar apksigner.jar sign  --ks 密钥名  --ks-key-alias 密钥别名 --out output.apk  input.apk</div><div class='page'><h1 class='title level-3'>apktool</h1><br/>apktool反编译 java -jar apktool.jar d input.apk -o output<br />回编译 java -jar apktool.jar b input -o output.apk<br /><a href=""><img src="images\318-1.png" alt="images\318-1.png" /></a><br /></div><div class='page'><h1 class='title level-3'>dex2jar</h1><br/>dex文件转.jar<br /><a href=""><img src="images\320-1.png" alt="images\320-1.png" /></a></div><div class='page'><h1 class='title level-3'>查看vdex文件内容</h1><br/>vdexExtractor</div><div class='page'><h1 class='title level-2'>安卓逆向一般流程</h1><br/><a href=""><img src="images\452-1.png" alt="images\452-1.png" /></a><br /><br />注意搜索目标字符串或目标api如果没有发现，则说明apk使用了字符串加密或反射机制，需要使用动态调试以及hook进行分析</div><div class='page'><h1 class='title level-2'>安卓系统分区</h1><br/>安卓系统分区<br /><a href=""><img src="images\726-1.png" alt="images\726-1.png" /></a><br /><br /><a href=""><img src="images\726-2.png" alt="images\726-2.png" /></a><br /><br /><a href=""><img src="images\726-3.png" alt="images\726-3.png" /></a><br />	<br />首先介绍的是Android标准分区，但是有些芯片厂家会根据自己的需要做修改，Android默认的分区如下：<br />boot<br />system<br />recovery<br />data<br />cache<br />misc<br />		<br /><a href=""><img src="images\726-4.png" alt="images\726-4.png" /></a><br /><br /><br />车机ivi等安卓系统固件中常见同一个安卓系统分区（例如：sysytem boot等）常会区分a b区（例如systema.img systemb.img）该两个分区内容相同，其中一个分区（一般是b）会作为OTA更新的备份，即OTA仅更新a分区，如果更新后程序出错，会运行回原来的b分区，而作为备份数据的b分区，一般会存在访问权限限制，从而保护数据</div><div class='page'><h1 class='title level-3'>boot</h1><br/>Boot：<br />Boot分区的格式是固定的，首先是一个头部，然后是Linux内核，最后是用作根文件系统的ramdisk。<br /><br />包含了kernel(内核) 和ramdisk(虚拟内存盘：通过软件将一部分内存（RAM）模拟为硬盘来使用的一种技术，可以极大的提高在其上进行的文件访问的速度)，ramdisk中会加载一个极小的根文件系统<br /><br />该分区用于挂载系统和其他的分区，并开始Runtime。<br /><br />如果没有此分区，手机通常不能正常启动。只有必要的时候，才去通过Recovery软件擦除（format）这个分区，一旦擦除，设备只有再重新安装一个新的boot分区，可以通过安装一个包含boot分区的ROM来实现，否则无法启动安卓系统。</div><div class='page'><h1 class='title level-3'>bootloader</h1><br/>用于设备启动，根据设备启动方法的不同，可以引导设备进入fastboot、recovery、安卓主系统<br />详见安卓系统启动过程<br /></div><div class='page'><h1 class='title level-3'>cache</h1><br/>	Cache：<br />	系统缓存区，临时的保存应用数据（要把数据保存在这里，需要特定的app permission）<br />	<br />	OTA的升级包也可以保存在这里。OTA升级过程可能会清楚这个分区的数据。一般来讲，Android差分包升级也需要依赖此分区存放一些中间文件。<br /></div><div class='page'><h1 class='title level-3'>data</h1><br/>data：<br />也称userdata<br />用户数据区，用户安装的应用程序会把数据保存在这里，包含了用户的数据：联系人、短信、设置、用户安装的程序。<br /><br />擦除这个分区，本质上等同于手机恢复出厂设置，也就是手机系统第一次启动时的状态，或者是最后一次安装官方或第三方ROM后的状态。<br /><br />在Recovery程序中进行的“data/factory reset ”操作就是在擦除这个分区。正常情况下OTA是不会清除这里的数据的，指定要删除数据的除外。<br /><br />此分区下的一些常见目录： /data/data/[packagename]/files 文件缓存目录,一般存小的文件缓存，如果是图片，不建议放这里，一般放到外置卡; /data/data/[packagename]/cache目录，存放一些其他缓存; /data/data/[packagename]/databases，存放数据库; /data/data/[packagename]/lib，应用的so目录; /data/data/[packagename]/shared_prefs 应用的SharedPreferences保存;<br /><br /></div><div class='page'><h1 class='title level-3'>misc</h1><br/>Misc：<br />一个非常小的分区，4 MB左右。<br /><br />recovery用这个分区来保存一些关于升级的信息，应对升级过程中的设备掉电重启的状况<br /><br />Bootloader启动的时候，会读取这个分区里面的信息，以决定系统是否进Recovery System 或 Main System。<br /><br />此分区包含了一些系统设置和系统功能启用禁用的相关设置。<br /><br />这些设置包括CID(运营商或区域识别码）、USB设置和一些硬件设置等等。<br /><br />这是一个很重要的分区，如果此分区损坏或者部分数据丢失，手机的一些特定功能可能不能正常工作。</div><div class='page'><h1 class='title level-3'>recovery</h1><br/>Recovery：包括了一个完整Linux内核和一些特殊的recovery binary，可以读取升级文件用这些文件来更新其他的分区。<br /><br />在正常分区或内核分区被破坏，不能正常启动时，可以进入此分区进行恢复，他相当与一个简易的OS或blos，可以认为是一个boot分区的替代品，通过他可以让我们在这一分区进行备份维护和恢复，我们通常说的刷机便指的是此分区。<br /><br />进入此分区方法：<br />1、通过 adb reboot recovery<br />2、通过组合键，电源键+音量键</div><div class='page'><h1 class='title level-3'>sdcard</h1><br/><h2>/sdcard</h2><br /><h3>此分区为内部存储，可以存放相片、视频、文档、ROM安装包等，擦除这个分区是完全安全的</h3><br /><br /><h3>/storage/emulated/</h3><h3>0</h3><h3>/Android/data/[packagename]/cache 外置缓存 <br />/storage/emulated/</h3><h3>0</h3><h3>/Android/data/[packagename]/files 外置文件缓存 <br />注意: /storage/emulated/</h3><h3>0</h3><h3>/Android/data/[packagename] 在android2.2之后，在应用卸载后也会一并卸载</h3><br /><br /><br /><h2>/sd-ext</h2><br /><h3>SD卡扩展分区，即我们通常所说的外部存储区。</h3><br /><h2>这不是一个标准的分区，但已经在自定义ROM中流行。它基本上是与具有特殊功能称为APP2SD+或data2ext启用某些ROM中使用时充当/data分区上的SD卡额外的分区。因此，谁想要安装更多程序比内部存储器的用户允许可以让这个分区，使用它与支持此功能的自定义ROM，获得额外的存储空间用于安装他们的应用程序。擦除这个分区在本质上与擦/data分区是一样的，你失去了你的通讯录，短信，应用市场和设置。</h2><br /><br /><br /></div><div class='page'><h1 class='title level-3'>system</h1><br/>System：<br />这个分区几乎包含了除kerner和ramdisk之外的整个android操作系统，包括了用户界面、和所有预装的系统应用程序和库文件（AOSP中可以获取到源代码）。<br /><br />在运行的过程中，这个分区是read-only的。当然，一些Android设备，也允许在remount的情况下，对system分区进行读写。<br /><br /> 擦除这个分区，相当于删除整个安卓系统，会导致不能进入Main System, 但不会影响到Recovery。因此，可以通过进入Recovery程序或者bootloader程序中，升级安装一个新ROM。</div><div class='page'><h1 class='title level-2'>安卓系统目录</h1><br/><a href="file://D:\CherryTreeNoteBook\技术思维导图\易锦安卓逆向\易锦安卓逆向0.xmind">易锦安卓逆向0-系统文件目录结构</a><br /><h3>一. Android应用安装路径有两种情况：</h3><br />1. system/app 系统自带的应用程序，无法删除。root后可以删除,注意可能造成系统崩溃,不过有的垃圾捆绑软件只能这么删除了<br />2. data/app 用户程序安装的目录，有删除权限。安装时把apk文件复制到此目录。<br />3. data/data 存放应用程序的数据。<br />4. data/dalvik-cache 将apk中的dex文件安装到dalvik-cache目录下(dex文件是dalvik虚拟机的可执行文件,其大小约为原始apk文件大小的四分之一)。<br /><h3>二. APP安装过程：复制APK安装包到data/app目录下，解压并扫描安装包，把dex文件(Dalvik字节码)保存到dalvik-cache目录，并data/data目录下创建对应的应用数据目录。</h3><br /><h3>三. APP卸载过程：删除安装过程中在上述三个目录下创建的文件及目录。</h3><br /></div><div class='page'><h1 class='title level-2'>安卓系统目录结构</h1><br/><a href="安卓--安卓系统启动过程.html">安卓系统启动过程</a><br />安卓中主要目录是system和data</div><div class='page'><h1 class='title level-3'>data目录</h1><br/>下载安装一些APP，<br />这些APP都安装在data/app目录下。<br />所有的Android程序生成的数据基本上都保存在data/data目录下。<br />wipe data实质上就是格式化data分区，这样我们安装的所有APP和程序数据就都丢失了。<br /><br /><h3>/data/app/<br />用户自己安装的apk放在这个目录下。如果我们把apk放在该目录下，就算安装好了，这就叫做静默安装。<br /><br />/data/data/<br />这里是每个安装过应用的用户文件存储位置，一般为设置文件、数据库或临时缓存文件，进入后以每个软件的package name包名来命名<br /><br />/data/system/ </h3><br /><h3>记录手机安装信息等文件的目录。<br /><br />/data/misc/ </h3><br /><h3>保存wifi账号和vpn等配置信息的目录。</h3><br /><br />/<h3>data/dalvik-cache/<br />将apk中的dex文件安装到该目录下（dex文件是dalvik虚拟机的可执行文件，大小约为原始apk的四分之一）</h3></div><div class='page'><h1 class='title level-3'>ect目录</h1><br/>链接到/system/etc</div><div class='page'><h1 class='title level-3'>proc目录</h1><br/><h3>/proc/<br />文件系统下的多种文件提供的系统信息不是针对某个特定进程的，而是能够在整个系统范围的上下文中使用。</h3></div><div class='page'><h1 class='title level-3'>sbin</h1><br/><h3>/sbin/ </h3><br /><h3>只放了一个用于调试的adbd程序。</h3></div><div class='page'><h1 class='title level-3'>system目录</h1><br/>system/app: app目录下存放的是核心应用，也就是大家熟知的系统APP，这些系统自带的程序是不能简单的卸载的，要通过一些特殊的方式才能删除（大家熟悉的一种方法是用RE文件管理器）。<br /><br />/system/app，/system/vendor/app，以及/system/priv-app目录也会存放系统apk文件<br /><br />/system/usr/ <br />用户的配置文件，如键盘布局、共享、时区文件等等<br /><br />system/lib: lib目录下存放的是组成JNI层，Dalvik虚拟机，本地库，HAL层和厂家适配层的所有动态链接库(.so文件)。<br /><br />system/framework: 该目录下存放的是框架层的JAR包，其中对MIUI移植来说有3个最重要的JAR包(framework.jar, android.policy.jar, services.jar)。后续的文章会重点介绍这3个包。<br /><br />system/fonts: 该目录下存放的是系统缺省的字体文件。<br /><br />system/media：该目录下存放的是系统所使用的各种媒体文件，比如说开机音乐，动画，壁纸文件等。不同的手机该目录的组织方式可能不一样。如何修改这些文件请参考网上对应机型形形色色的教程，这里不再赘叙。<br /><br />/system/media/audio/<br />这里面保存着安卓系统默认的铃声，alarms是闹铃提醒的，notification是短信或提示音，ringtones是来电铃声，而ui是一些界面音效，比如键盘敲击声<br /><br />system/bin: 该目录下存放的是一些可执行文件，基本上是由C/C++编写的。其中有一个重要的命令叫app_process下一节单独介绍。<br /><br />system/xbin: 该目录下存放的是一些扩展的可执行文件，既该目录可以为空。大家常用的busybox就放在该目录下。Busybox所建立的各种符号链接命令都是放在该目录。<br /><br />system/build.prop: build.prop和上节说得根文件系统中的default.prop文件格式一样，都称为属性配置文件。它们都定义了一些属性值，代码可以读取或者修改这些属性值。属性值有一些命名规范：<br />    ro开头的表示只读属性，即这些属性的值代码是无法修改的。<br />    persist开头的表示这些属性值会保存在文件中，这样重新启动之后这些值还保留。<br />    其它的属性一般以所属的类别开头，这些属性是可读可写的，但是对它们的修改重启之后不会保留。<br />    很多ROM制作者都会修改一下build.prop信息，里面的一些以ro.build开头的属性就是你在手机设置中的关于手机里看到的。可以通过修改build.prop文件来将这个ROM打上自己的印记（XXX所修改）。我见过一个只是删了system/app的一些程序，然后修改build.prop中的ro.build.display.id和ro.build.version.incremental中的两个属性值打上自己的大名的ROM。<br /><br />system/etc: 该目录存放一些配置文件，和属性配置文件不一样，这下面的配置文件可能稍微没那么的有规律。一般来说，一些脚本程序，还有大家所熟悉GPS配置文件(gps.conf)和APN配置文件(apns-conf.xml)放在这个目录。像HTC将相机特效所使用的一些文件也放在这个目录下。<br /><br />/ect是链接到system/etc目录下的</div><div class='page'><h1 class='title level-3'>sys目录</h1><br/><h3>/sys/</h3><br /><h3>用于挂载 sysfs文件系统。 在设备模型中，sysfs文件系统用来表示设备的结构。将设备的层次结构形象的反应到用户空间中，用户空间可以修改sysfs中的文件属性来修改设备的属性值 。</h3></div><div class='page'><h1 class='title level-3'>敏感目录文件</h1><br/>参考一部分<a href="linux--linux敏感目录.html">linuc敏感目录</a><br />参考一部分<a href="中汽研实习--IVI信息泄露.html">ivi信息泄露</a><br /><h1>在Android系统中.prop文件很重要，记录了系统的设置和改变，类似于/etc中的文件</h1><br /><br /><h1>init.rc</h1><br />boot分区启动-》linux内核启动完毕-》init程序会读取启动脚本文件(init.rc和init.xxxx.rc)启动安卓系统<br /><h3>/init.rc </h3><br /><h3>一个初始化脚本，用于将/system/modules和/system/xbin挂载为cramfs，避免系统被无意破坏</h3><br /><br />~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br /><br /><h1>default.prop</h1><br />根文件系统中有一个重要的配置文件，叫default.prop，该文件的内容一般为：<br />#<br /># ADDITIONAL_DEFAULT_PROPERTIES<br />#<br />ro.secure=1<br />ro.allow.mock.location=1<br />ro.debuggable=0<br />persist.service.adb.enable=1。<br />    文件中的每一行对某个属性赋值，在后续的文章中我们还会谈到属性。这里面大家需要注意的两个属性：ro.secure和ro.debuggable。如果ro.secure=0允许我们运行adb root命令。在下一篇我们会详细介绍adb，这是我们做ROM移植的利器。通常大家说得内核ROOT指的就是ro.secure=0。ROOT权限只是的手机上有一个名为授权管理的程序（Superuser.apk)可以授予程序root用户的权限。ro.deguggable=1允许调试系统APP。<br /><br />~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br /><br /><h1>system/etc（GPS配置gps.conf和APN配置apns-conf.xml）</h1><br />system/etc: 该目录存放一些配置文件，和属性配置文件不一样，这下面的配置文件可能稍微没那么的有规律。一般来说，一些脚本程序，还有大家所熟悉GPS配置文件(gps.conf)和APN配置文件(apns-conf.xml)放在这个目录。像HTC将相机特效所使用的一些文件也放在这个目录下。<br /><br />~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br /><br /><h1>system/media（开机音乐与动画</h1>）<br /><br />~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br /><br /><h1>system/build.prop（类似default.prop）<br /></h1>build.prop和上节说得根文件系统中的default.prop文件格式一样，都称为属性配置文件。它们都定义了一些属性值，代码可以读取或者修改这些属性值。属性值有一些命名规范：<br />    ro开头的表示只读属性，即这些属性的值代码是无法修改的。<br />    persist开头的表示这些属性值会保存在文件中，这样重新启动之后这些值还保留。<br />    其它的属性一般以所属的类别开头，这些属性是可读可写的，但是对它们的修改重启之后不会保留。<br />    很多ROM制作者都会修改一下build.prop信息，里面的一些以ro.build开头的属性就是你在手机设置中的关于手机里看到的。可以通过修改build.prop文件来将这个ROM打上自己的印记（XXX所修改）<br /><br />~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br /><br /><h1>/system/app  /data/app    </h1><a href="安卓--apk安装过程.html">静默安装应用</a><br />以上两目录中保存安卓系统应用的apk文件以及用户应用apk文件，将apk拷贝到以上两个目录，重启机器，可以自动安装应用<br /><br />~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br /><br /><h1>/data/data</h1><br />保存安卓已安装app的相关数据<br /><br />~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br /><br /><h1>/data/misc/ </h1><br />保存wifi账号和vpn等配置信息的目录。<br /><br />~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br /><br /><h1>/data/system/ </h1><br />记录手机安装信息等文件的目录。<br /><br />~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br /><br /><br /><br /><br /><br /></div><div class='page'><h1 class='title level-2'>安卓系统启动过程</h1><br/><h1>手机上电</h1><br />	当按下电源键手机上电启动后，首先从bootloader分区中一个固定的地址开始执行指令，bootloader分区分成两个部分，分别叫做primary bootloader和secondary stage bootloader。<br />	<h1><br />执行</h1><h1>primary bootloader</h1><br />	Primary bootloader主要执行硬件检测，确保硬件能正常工作后将secondary stage bootloader拷贝到内存(RAM)开始执行。 <h3><br /><br /></h3><h1>执行secondary stage bootloader ,进入fastboot、recovery或安卓主系统</h1><br />	Secondary stage bootloader会进行一些硬件初始化工作，获取内存大小信息等，然后根据用户的按键进入到某种启动模式。比如说大家所熟知的通过电源键和其它一些按键的组合，可以进入到recovery，fastboot或者选择启动模式的启动界面等。我们在论坛上看到的bootloader通常指的就是secondary stage bootloader。不过我们不需要关心太多的细节，可以简单的理解为bootloader就是一段启动代码，根据用户按键有选择的进入某种启动模式。 <br />	<br /><h1>进入fastboot模式</h1><br />fastboot是android定义的一种简单的刷机协议<br /><br /><h1>进入recovery模式</h1><br />recovery是一个简单linux系统<br />secondary stage bootloader从recovery分区开始启动，从而进入recovery<br />recovery分区启动-》内核启动完毕-》开始第一个进程init-》init启动recovery程序<br /><br /><br /><h1>进入安卓主系统</h1><br />Secondary stage bootloader从boot分区开始启动<br />boot分区启动-》内核启动完毕-》init程序会读取启动脚本文件(init.rc和init.xxxx.rc)启动-》启动脚本开始运行system分区中的程序-》运行system/bin/app_process（即Zygote，所有安卓进程均由该进程产生）-》加载Dalvik虚拟机-》产生system_server（安卓系统服务程序，管理整个安卓系统）-》检索运行启动器-》zygote开始启动执行启动器，出现桌面<br /></div><div class='page'><h1 class='title level-3'>详细资料</h1><br/>相关资料<br /><a href="https://www.xiaomi.cn/post/11444205">https://www.xiaomi.cn/post/11444205</a><br /><a href="https://www.xiaomi.cn/post/10984220">https://www.xiaomi.cn/post/10984220</a><br /><br /><br /><h3> 注意：该结构图并不反映手机的实际分区顺序和位置，只是一个逻辑结构图。</h3><br /> <br /><h1>MIUI ROM适配之旅第一天——认识Android手机</h1><br /><br /><br />      写这篇文章时想起我的第一部Android手机HTC Hero。买回来后，同事告诉我可以去刷机玩玩。刷机，怎么刷？同事说，你个土人，刷机都不知道，很多刷机论坛的，你去逛逛，挺简单的。我去逛了逛机锋论坛（那时还不知道MIUI），打开一看，什么recovery, radio, root各种词汇扑面而来，oh my lady gaga，这么复杂。但是为了不被鄙视，而且闲着也是闲着，还是刷着玩玩吧。后来就结识MIUI来到了小米。这是题外话，咱们言归正传。<br /><br />     在这纷纷扰扰的Android世界里，如何找到那条刷机大道呢，或许它只是个传说，我们只是一直在探索。让我们从零开始来看一看，看能发现点什么。<br /><br />1. bootloader<br />    当我们拿到一款手机，第一件事应该就是按下电源键开机，那么从开机到进入到桌面程序这中间发生了些什么呢，我们从下面这张简化了的手机结构图开始：<br /><br /><a href=""><img src="images\782-1.png" alt="images\782-1.png" /></a><br /><br />    注意：该结构图并不反映手机的实际分区顺序和位置，只是一个逻辑结构图。<br /><br />    大家可以简单的把手机的ROM存储类比为我们电脑上的硬盘，这个硬盘被分成了几个分区：bootloader分区，boot分区，system分区等等。后面我们会逐渐介绍各个分区的用途。所谓的刷机我们可以简单的理解成把软件安装在手机的某些分区中，类似于我们在电脑上安装Windows系统。<br /><br />    当按下电源键手机上电启动后，首先从bootloader分区中一个固定的地址开始执行指令，如图所示，bootloader分区分成两个部分，分别叫做primary bootloader和secondary stage bootloader。Primary bootloader主要执行硬件检测，确保硬件能正常工作后将secondary stage bootloader拷贝到内存(RAM)开始执行。Secondary stage bootloader会进行一些硬件初始化工作，获取内存大小信息等，然后根据用户的按键进入到某种启动模式。比如说大家所熟知的通过电源键和其它一些按键的组合，可以进入到recovery，fastboot或者选择启动模式的启动界面等。我们在论坛上看到的bootloader通常指的就是secondary stage bootloader。不过我们不需要关心太多的细节，可以简单的理解为bootloader就是一段启动代码，根据用户按键有选择的进入某种启动模式。<br /><br />    fastboot模式：fastboot是android定义的一种简单的刷机协议，用户可以通过fastboot命令行工具来进行刷机。比如说fastboot flash boot boot.img这个命令就是把boot.img的内容刷写到boot分区中。一般的手机厂商不直接提供fastboot模式刷机，而是为了显示他们的牛B之处，总是会提供自己专有的刷机工具和刷机方法。比如说三星的Odin，摩托的RSD，华为的粉屏等等。但是其本质实际上是相同的，都是将软件直接flash到各个分区中。<br />    <br />    recovery模式：recovery是android定义的一个标准刷机协议。当进入recovery模式时，secondary stage bootloader从recovery分区开始启动，recovery分区实际上是一个简单的Linux系统，当内核启动完毕后，开始执行第一个程序init(init程序是Linux系统所有程序的老祖宗)。init会启动一个叫做recovery的程序（recovery模式的名称也由此而来）。通过recovery程序，用户可以执行清除数据，安装刷机包等操作。一般的手机厂商都提供一个简单的recovery刷机，而大名鼎鼎的CWM Recovery就是一个加入了很多增强功能的recovery，要想用上CWM Recovery前提是recovery分区可以被刷写。大家在论坛上看到的解锁bootloader，通常指的就是解锁recovery或fastboot，允许刷写recovery分区，这样大家就可以用上喜爱的CWM Recovery了。<br /><br />    手机除了普通的CPU芯片以外，还有MODEM处理器芯片。该芯片的功能就是实现手机必需的通信功能，大家通常所的刷RADIO就是刷写modem分区。<br /><br />2. 正常启动<br /><br />    当我们只是按下电源键开机时，会进入正常启动模式。Secondary stage bootloader会从boot分区开始启动。Boot分区的格式是固定的，首先是一个头部，然后是Linux内核，最后是用作根文件系统的ramdisk。<br />    <br />    一般针对每个机型的完整刷机包中会有一个boot.img文件，这就是boot分区镜像文件。如何编辑该镜像文件可以参照这篇文章http://android-dls.com/wiki/inde ... Re-Pack_Boot_Images。<br />    <br />    当Linux内核启动完毕后，就开始执行根文件系统中的init程序，init程序会读取启动脚本文件(init.rc和init.xxxx.rc)。启动脚本文件的格式大家可以在网上找到很多参考资料，这里就不写了，而且我们在原厂ROM上移植MIUI的原则是不修改boot分区，因为有一些机型无法修改boot分区。<br />    <br />    根文件系统中有一个重要的配置文件，叫default.prop，该文件的内容一般为：<br />#<br /># ADDITIONAL_DEFAULT_PROPERTIES<br />#<br />ro.secure=1<br />ro.allow.mock.location=1<br />ro.debuggable=0<br />persist.service.adb.enable=1。<br />    文件中的每一行对某个属性赋值，在后续的文章中我们还会谈到属性。这里面大家需要注意的两个属性：ro.secure和ro.debuggable。如果ro.secure=0允许我们运行adb root命令。在下一篇我们会详细介绍adb，这是我们做ROM移植的利器。通常大家说得内核ROOT指的就是ro.secure=0。ROOT权限只是的手机上有一个名为授权管理的程序（Superuser.apk)可以授予程序root用户的权限。ro.deguggable=1允许调试系统APP。<br />    <br />    init程序读取启动脚本，执行脚本中指定的动作和命令，脚本中的一部分是运行system分区的程序，下一节我们就来看看system分区的结构。<br /><br />3. system分区<br />    在讲system分区之前，我们先来看下面这张Android的软件系统架构图。<br /><br /><a href=""><img src="images\782-2.png" alt="images\782-2.png" /></a><br /><br />    从上到下依次为：<br />    核心应用层：这一层就是大家平常所接触的各种各样的系统自带应用，比如联系人，电话，音乐等。应用层往下就是开发人员所接触的。<br /><br />    框架层：这一层是Android系统的核心，它提供了整个Android系统运作的机制，像窗口管理，程序安装包管理，开发人员所接触的Activity, Service, broadcast等等。<br /><br />    JNI层：JNI层是Java程序和底层操作系统通信的一个机制，它使得Java代码可以调用C/C++代码来访问底层操作系统的API。<br /><br />    Dalvik虚拟机：Android开发使用Java语言，应用程序的Java代码会被编译成dalvik虚拟机字节码，这些字节码由dalvik虚拟机解释执行。<br /><br />    本地库：本地库一般是由C/C++语言所开发，直接编译成相应CPU的机器码，这其中包含标准C库，用以绘制图形的skia库，浏览器核心引擎webkit等。<br /><br />    HAL：硬件抽象层，为了和各个厂家的不同硬件工作，Android定义了一套硬件接口，比如说为了使用相机，厂家的相机驱动必须提供的接口方法。这样使得上层的代码可以独立于不同的硬件运行。<br /><br />    厂家适配层：本来Android定义的HAL层是直接和厂家提供的设备驱动打交道的，但是目前厂家不想开源HAL部分的代码，因此很多厂家都提供了一个我称之为厂家适配层的代码，这样在HAL层接口的实现只是一个简单的对厂家适配层接口函数的调用。<br /><br />    内核：这一层就是大家熟悉的Linux内核，内核中包含有各种硬件驱动，这些驱动不同的手机厂商不同的手机是不一样的。Linux内核是支持驱动模块化机制的，简单的说就是允许用户动态的加载或者卸载某个硬件驱动，但是目前来看，手机厂商除了提供WIFI驱动单独加载外，其它驱动都是和内核绑定在一起的。<br /><br />从这张软件结构图来看，除了内核是放在boot分区外，其它层的代码都是在system分区中。<br /><br />下面结合这张图来介绍system分区的主要目录内容：<br />system/app: app目录下存放的是核心应用，也就是大家熟知的系统APP，这些系统自带的程序是不能简单的卸载的，要通过一些特殊的方式才能删除（大家熟悉的一种方法是用RE文件管理器）。<br /><br />system/lib: lib目录下存放的是组成JNI层，Dalvik虚拟机，本地库，HAL层和厂家适配层的所有动态链接库(.so文件)。<br /><br />system/framework: 该目录下存放的是框架层的JAR包，其中对MIUI移植来说有3个最重要的JAR包(framework.jar, android.policy.jar, services.jar)。后续的文章会重点介绍这3个包。<br /><br />system/fonts: 该目录下存放的是系统缺省的字体文件。<br /><br />system/media：该目录下存放的是系统所使用的各种媒体文件，比如说开机音乐，动画，壁纸文件等。不同的手机该目录的组织方式可能不一样。如何修改这些文件请参考网上对应机型形形色色的教程，这里不再赘叙。<br /><br />system/bin: 该目录下存放的是一些可执行文件，基本上是由C/C++编写的。其中有一个重要的命令叫app_process下一节单独介绍。<br /><br />system/xbin: 该目录下存放的是一些扩展的可执行文件，既该目录可以为空。大家常用的busybox就放在该目录下。Busybox所建立的各种符号链接命令都是放在该目录。<br /><br />system/build.prop: build.prop和上节说得根文件系统中的default.prop文件格式一样，都称为属性配置文件。它们都定义了一些属性值，代码可以读取或者修改这些属性值。属性值有一些命名规范：<br />    ro开头的表示只读属性，即这些属性的值代码是无法修改的。<br />    persist开头的表示这些属性值会保存在文件中，这样重新启动之后这些值还保留。<br />    其它的属性一般以所属的类别开头，这些属性是可读可写的，但是对它们的修改重启之后不会保留。<br />    很多ROM制作者都会修改一下build.prop信息，里面的一些以ro.build开头的属性就是你在手机设置中的关于手机里看到的。可以通过修改build.prop文件来将这个ROM打上自己的印记（XXX所修改）。我见过一个只是删了system/app的一些程序，然后修改build.prop中的ro.build.display.id和ro.build.version.incremental中的两个属性值打上自己的大名的ROM。<br /><br />system/etc: 该目录存放一些配置文件，和属性配置文件不一样，这下面的配置文件可能稍微没那么的有规律。一般来说，一些脚本程序，还有大家所熟悉GPS配置文件(gps.conf)和APN配置文件(apns-conf.xml)放在这个目录。像HTC将相机特效所使用的一些文件也放在这个目录下。<br /><br />4. Zygote(app_process)<br />    上一节提到init会执行一个重要的命令程序叫app_process，一般大家称之为Zygote。（Zygote是卵的意思，所有的Android进程都是由它生出来的)。Zygote首先会加载dalvik虚拟机，然后产生一个叫做system_server的进程。system_server顾名思义被称作Android的系统服务程序，它主要管理整个android系统。system_server启动完成后开始寻找一个叫做启动器的程序，找到之后由zygote开始启动执行启动器，这就是我们常见到的桌面程序。<br /><br />上面描述的是一个相当简化的启动过程，了解这些对于适配MIUI基本上就够了，如果大家对这些想进一步了解的话，请关注市面上各种Android内幕书籍。<br /><br />5. data和cache分区<br />    这一节简单的介绍一下data和cache分区。当我们开机进入桌面程序后，一般来说我们都会下载安装一些APP，这些APP都安装在data/app目录下。所有的Android程序生成的数据基本上都保存在data/data目录下。wipe data实质上就是格式化data分区，这样我们安装的所有APP和程序数据就都丢失了。<br />    <br />    cache分区从名字上来看是用来缓存一些文件的，比如说一些音乐下载的临时文件，或者下载管理下载的内容基本上放在这个分区。<br /><br />6. 小结<br />    本章主要是介绍了一下Android手机的硬软件结构以及主要分区的内容，并简要的介绍了一些开机启动过程。了解这些内容有助于我们从整体上理解ROM移植。<br /></div><div class='page'><h1 class='title level-2'>安卓自动分析工具</h1><br/>DevCheck  安卓硬件分析工具<br /><a href="http://zhushou.360.cn/detail/index/soft_id/3063046">http://zhushou.360.cn/detail/index/soft_id/3063046</a><br /><br />在线app自动分析<br />腾讯金刚app分析<br /><a href="https://service.security.tencent.com/kingkong">https://service.security.tencent.com/kingkong</a><br /><br />drozer-Android安全测试基本使用（Windows10）<br /><a href="https://blog.csdn.net/jianglianye21/article/details/80667346">drozer-Android安全测试基本使用（Windows10）_jianglianye21的博客-CSDN博客_drozer使用</a><br /><a href="https://blog.csdn.net/LuckChouDog/article/details/50924089?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param">Windows端Drozer使用（Android APP应用安全评估框架）_LuckChouDog的博客-CSDN博客</a><br />	<br />直接使用mobsf分析ivi中的app<br />Mobsf github <br /><a href="https://github.com/MobSF/Mobile-Security-Framework-MobSF.git">https://github.com/MobSF/Mobile-Security-Framework-MobSF.git</a><br /><a href=""><img src="images\26-1.png" alt="images\26-1.png" /></a><br />默认运行在8000端口<br />使用msf的docker<br />运行以下命令将 MobSF 运行起来：<br />docker pull opensecurity/mobile-security—framework—mobsf<br />docker run —it —p 8000:8000 opensecurity/mobile—security—framework-mobsf:latest<br />使用浏览器访问服务器的 8000 端口就能进入到系统主页面，将需要分析的应用程序上传到服务器进行分析即可：<br /><br /><br /><h1>apkurlgrep</h1><br />该工具用于提取apk中的url信息，使用时需要配置go环境，需要较新版本的go环境<br /><br /><br /><h1>安卓app敏感信息提取 apkanalyser</h1><br /><a href="https://github.com/TheKingOfDuck/ApkAnalyser">https://github.com/TheKingOfDuck/ApkAnalyser</a><br /><a href=""><img src="images\26-2.png" alt="images\26-2.png" /></a><br /><br /></div><div class='page'><h1 class='title level-2'>调试</h1><br/><br /></div><div class='page'><h1 class='title level-3'>ida动态调试</h1><br/><a href=""><img src="images\382-1.png" alt="images\382-1.png" /></a><br /></div><div class='page'><h1 class='title level-2'>脱壳</h1><br/></div><div class='page'><h1 class='title level-3'>APP启动流程及dex动态加载</h1><br/>参考资料 <br /><a href=""><img src="images\565-1.png" alt="images\565-1.png" /></a><br />发起进程中通过调用startActivity等函数发送binder给system_servier进程，该进程发送socket给Zygote进程，后者复制自身进程从而创建新进程，新进程中指定ActiviyThread.main函数，该main函数仍在位于安卓framewotrk代码中，未执行app自身代码<br /><a href=""><img src="images\565-2.png" alt="images\565-2.png" /></a><br /><br />查找源码中的ActivityThread类<br /><a href=""><img src="images\565-3.png" alt="images\565-3.png" /></a><br /><br />ActivityThread类中存在currenyActivityThread函数，通过调用该函数可以获取获取进程中的ActivityThread实例，进而获取ActivityThread中重要变量<br /><a href=""><img src="images\565-4.png" alt="images\565-4.png" /></a><br /><br /><br />ActivityThread类中存在LoadedApk变量<br /><a href=""><img src="images\565-5.png" alt="images\565-5.png" /></a><br /><br />查看LoadedApk类，其中存在加载app四大组件的classloader（PathClassLoader），在LoadedApk类中称之为mClassLoader<br /><a href=""><img src="images\565-6.png" alt="images\565-6.png" /></a><br /><br />LoadedApk中的mClassLoader<br /><a href=""><img src="images\565-7.png" alt="images\565-7.png" /></a><br /><br />通过反射可以获取app进程中仅有的ActivityThread实例（因为ActivityThread单例模式运行）<br />之后在ActivityThread中通过反射获得<a href=""><img src="images\565-8.png" alt="images\565-8.png" /></a><br />之后通过当前apk包名获得对应LoadedApk<br />最后通过LoadedApk获得<a href=""><img src="images\565-9.png" alt="images\565-9.png" /></a>，mClassLoader即PathClassLoader，后期使用其加载app的四大组件<br /><br /><br />ActivityThread中从handleBindApplication中开始进入app自己的代码<br /><a href=""><img src="images\565-10.png" alt="images\565-10.png" /></a><br /><a href=""><img src="images\565-11.png" alt="images\565-11.png" /></a><br /><br />handleBindApplication函数中，从makeApplication函数开始执行app代码<br /><a href=""><img src="images\565-12.png" alt="images\565-12.png" /></a><br /><br />private void handleBindApplication(AppBindData data) {<br />    //step 1: 创建LoadedApk对象<br />    data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo);<br />    ...<br />    //step 2: 创建ContextImpl对象;<br />    final ContextImpl appContext = ContextImpl.createAppContext(this, data.info);<br /> <br />    //step 3: 创建Instrumentation<br />    mInstrumentation = new Instrumentation();<br /> <br />    //step 4: 创建Application对象;在makeApplication函数中调用了newApplication，在该函数中又调用了app.attach(context)，在attach函数中调用了Application.attachBaseContext函数<br />    Application app = data.info.makeApplication(data.restrictedBackupMode, null);<br />    mInitialApplication = app;<br /> <br />    //step 5: 安装providers<br />    List&lt;ProviderInfo&gt; providers = data.providers;<br />    installContentProviders(app, providers);<br /> <br />    //step 6: 执行Application.Create回调<br />    mInstrumentation.callApplicationOnCreate(app);<br /><br /><br />根据上图<br />在makeApplication函数中调用了newApplication，在该函数中又调用了app.attach(context)，在attach函数中调用了Application.attachBaseContext函数<br /><br />所以app执行的第一个函数为Application.attachBaseContext函数和onCreate<br /><br />app启动流程<br />如果app未加壳则PathClassLoader加载app的dex时就会获得app所有的类信息<br />若app加壳，则PathClassLoader仅加载了壳代码，而没有加载app真正的代码，即壳解密释放的代码<br />如果被加壳app没有设置application，则加壳厂商会为app声明application，然后在application的两个函数中完成解密以及替换classloader操作<br />如果被加壳app已经设置了application，则需要代理的application，此时壳的application不仅需要完成解密dex、修复classloader，还需要完成被加壳app原本的application的两个函数的调用<br /><br /><br /><a href=""><img src="images\565-13.png" alt="images\565-13.png" /></a><br /><br />加壳app启动流程<br />点击app按钮<br />进入壳的application中的attachBaseContext函数，解密原始dex文件，完成执行权交付<br />此时因为app的dex不同于之前的将dex作为插件加载，所以无法仅使用DexClassLoader对dex加载使用，因为该方法无法找到安卓四大组件，会导致PathClassLoader找不到组件信息<br /><a href=""><img src="images\565-14.png" alt="images\565-14.png" /></a><br /><br />处理动态加载过程中dex类生命周期<br /><a href=""><img src="images\565-15.png" alt="images\565-15.png" /></a><br /><br />解决方案1：修改系统组件类的mClassLoader<br /><a href=""><img src="images\565-16.png" alt="images\565-16.png" /></a><br /><br /><a href=""><img src="images\565-17.png" alt="images\565-17.png" /></a><br /><br />解决方案2<br /><a href=""><img src="images\565-18.png" alt="images\565-18.png" /></a><br /><br /><br /></div><div class='page'><h1 class='title level-4'>动态加载</h1><br/>动态加载<br /><a href=""><img src="images\567-1.png" alt="images\567-1.png" /></a><br /><br />classdex修正<br /><a href=""><img src="images\567-2.png" alt="images\567-2.png" /></a><br /><a href=""><img src="images\567-3.png" alt="images\567-3.png" /></a><br /><br /><a href=""><img src="images\567-4.png" alt="images\567-4.png" /></a><br /><br /><a href=""><img src="images\567-5.png" alt="images\567-5.png" /></a><br /><br /></div><div class='page'><h1 class='title level-4'>示例代码（一代壳原型）</h1><br/>在使用DexClassLoader加载dex作为插件的基础上，实现对动态加载的dex中的四大组件的调用，该过程类似与壳代码对解密后的真实dex的调用<br /><br />创建被动态加载的dex：TestActivity<br /><a href=""><img src="images\566-1.png" alt="images\566-1.png" /></a><br /><br />将该dex放入sdcard目录<br /><a href=""><img src="images\566-2.png" alt="images\566-2.png" /></a><br /><br />在之前动态加载dex项目的基础上注册testactivity<br /><a href=""><img src="images\566-3.png" alt="images\566-3.png" /></a><br /><br />第一种处理动态加载dex生命周期的方法（加壳厂商大多使用该种方法）<br /><a href=""><img src="images\566-4.png" alt="images\566-4.png" /></a><br /><a href=""><img src="images\566-5.png" alt="images\566-5.png" /></a><br /><br /><a href=""><img src="images\566-6.png" alt="images\566-6.png" /></a><br /><br /><br />完成classloader替换函数<br />1通过反射方法获取ActivityThread类<br />2通过反射获取ActivityThread类中的currentActivityThread函数<br />3设置权限<br />4调用currentActivityThread函数获得ActivityThread实例<br />5获取ActivityThread类中mPackages的Field<br />6设置权限<br />7获取mPackages，该变量为一个ArrayMap<br />8从mPackages中根据包名获得loadedApk<br />9获得loadedApk对象<br />10通过反射获得loadedApk类<br />11获得mClassLoader的field<br />12设置权限<br />13使用loadedApk替换掉ClassLoader（即DexClassLoader）<br /><a href=""><img src="images\566-7.png" alt="images\566-7.png" /></a><br /><br /><br />第二种处理动态加载dex生命周期的方法<br /><a href=""><img src="images\566-8.png" alt="images\566-8.png" /></a><br /><br /><a href=""><img src="images\566-9.png" alt="images\566-9.png" /></a><br /><br /><a href=""><img src="images\566-10.png" alt="images\566-10.png" /></a><br /><br /><br />替换完成后的classloader继承关系<br /><a href=""><img src="images\566-11.png" alt="images\566-11.png" /></a> </div><div class='page'><h1 class='title level-3'>art抽取壳实现</h1><br/>相关资料<br />看雪高研课时7<br /><a href=""><img src="images\579-1.png" alt="images\579-1.png" /></a></div><div class='page'><h1 class='title level-3'>so加固及逆向策略</h1><br/>针对自变形的so、加壳的so<br />加载so文件的过程，即源码中linker部分，详见麦洛科菲教程<br /><br />针对此类加壳的so文件，需要将程序断在_init函数执行前，此时需要将手机中的linker拉出来，分析_init和initarray函数执行过程<br />很多so壳加固过程位于_init和initarray函数中<br /><br /><a href=""><img src="images\618-1.png" alt="images\618-1.png" /></a></div><div class='page'><h1 class='title level-3'>加壳技术发展</h1><br/>资料来源：常见android app加固厂商脱壳方法研究<br /><a href=""><img src="images\568-1.png" alt="images\568-1.png" /></a><br /><a href=""><img src="images\568-2.png" alt="images\568-2.png" /></a><br /><a href=""><img src="images\568-3.png" alt="images\568-3.png" /></a><br /><br /><h3>第四代壳 arm vmp（未来）</h3><br />一代壳：dex整体保护，在内存当中的映射是整体的、连续的，所以方便在内存中定位dex起始地址从而脱壳，在指定脱壳点可以dump出来完整dex<br />二代壳：在一代壳基础上对dex中关键代码进行了抽取，dex加载到内存后，其内容并不完整，因为其中部分代码可能并未被执行，所以没有被加载到内存中，通过遍历dex中所有类，对类进行加载和初始化，可以让内存中的dex完整，进一步进行脱壳<br />三代壳：dex动态解密，dex中某些函数只有在调用或被加载之后才会解密执行，dex在内存中总是不完整的<br /><br />另一种视角<br />dex加固<br /><a href=""><img src="images\568-4.png" alt="images\568-4.png" /></a><br /><a href=""><img src="images\568-5.png" alt="images\568-5.png" /></a><br /><a href=""><img src="images\568-6.png" alt="images\568-6.png" /></a><br /><a href=""><img src="images\568-7.png" alt="images\568-7.png" /></a>常用于加固厂商付费功能<br />目前vpm基本上是samli指令集级别的vmp，之后随着手机性能提升，arm vmp会出现，目前的vmp壳的限制是性能方面<br />如果是vmp壳，需要逆向分析其解释器，从而找到其取址译码执行的流程<br />dex整体加固的特征：反编译工具无法找到dex入口类<br /><br />so加固<br /><a href=""><img src="images\568-8.png" alt="images\568-8.png" /></a><br /><br /></div><div class='page'><h1 class='title level-4'>资料</h1><br/>常见android app加固厂商脱壳方法研究<br /><a href=""><img src="images\569-1.png" alt="images\569-1.png" /></a><br /><a href=""><img src="images\569-2.png" alt="images\569-2.png" /></a></div><div class='page'><h1 class='title level-3'>加壳特征</h1><br/>360<br /><a href=""><img src="images\450-1.png" alt="images\450-1.png" /></a> <a href=""><img src="images\450-2.png" alt="images\450-2.png" /></a><br /><br /><a href=""><img src="images\450-3.png" alt="images\450-3.png" /></a><br /></div><div class='page'><h1 class='title level-3'>加壳信息查询</h1><br/>apktool <br /><a href=""><img src="images\449-1.png" alt="images\449-1.png" /></a><br /><br />GDA<br /><a href=""><img src="images\449-2.png" alt="images\449-2.png" /></a><br />使用360加固，bugly service即app崩溃分析服务，这里使用腾讯提供的bugly service服务<br /><br /></div><div class='page'><h1 class='title level-3'>加壳造成的影响</h1><br/>无法访问入口类： <br />如果apk加壳，则可能无法访问其入口类，即对应dex被保护起来了<br />或者apk存在反反编译策略，从而导致反编译失败</div><div class='page'><h1 class='title level-3'>类加载器</h1><br/>安卓的davik和artu虚拟机均是JVM的一种实现，davik和artu虚拟基于寄存器实现，该点和JVM有所不同<br /><br />java中的类加载器<br /><a href=""><img src="images\465-1.png" alt="images\465-1.png" /></a><br /><br />java中类加载器的加载顺序和继承关系<br />bootstrap classloader -》extention classloader -》appclassloader-》自定义类加载器从上往下是父类与子类的关系<br />具体加载顺序为从父类到子类<br /><a href=""><img src="images\465-2.png" alt="images\465-2.png" /></a><br /><br />java类加载器的双亲委派特性<br /><a href=""><img src="images\465-3.png" alt="images\465-3.png" /></a><br /><br />jvm以及安卓虚拟机中类加载的时机<br />隐式加载：类不是由开发人员自己加载的<br />显示加载：在反射过程中用到的频率极高，即LoadClass()和forName()两个API<br /><a href=""><img src="images\465-4.png" alt="images\465-4.png" /></a><br /><br />java反射机制<br /><a href=""><img src="images\465-5.png" alt="images\465-5.png" /></a><br /><br />jvm中类加载的步骤<br /><a href=""><img src="images\465-6.png" alt="images\465-6.png" /></a><br /><br />安卓中的类加载器<br /> <a href=""><img src="images\465-7.png" alt="images\465-7.png" /></a><br /> <br /> 安卓中8种classloader的区别 <br />BootClassLoader与java中Bootstrap classloader作用相同，用于预加载某些常用的类，使用了单例模式，从而保证仅需加载一次核心API类库<br /><br />BaseDexClassLoader是关键的classloader，包含加载dex的大部分逻辑<br /><br />app从点击到进入第一个activity，app中的类均由pathclassloader进行加载<br /><br />pathclassloader是安卓四大组件等系统类的默认加载器<br /><br />APP加固中用到最多的是DexClassLoader，可以加载任意目录下的文件（甚至是网络上或sdcard上）<br /><br /><a href=""><img src="images\465-8.png" alt="images\465-8.png" /></a><br /><br /><br /><br /><br /></div><div class='page'><h1 class='title level-4'>BaseDexClassLoader</h1><br/><a href=""><img src="images\558-1.png" alt="images\558-1.png" /></a><br /><br />继承自ClassLoader<br /><a href=""><img src="images\558-2.png" alt="images\558-2.png" /></a></div><div class='page'><h1 class='title level-4'>ClassLoader</h1><br/>查看安卓8.0	<br /><a href=""><img src="images\557-1.png" alt="images\557-1.png" /></a><br />搜索classloader类<br /><a href=""><img src="images\557-2.png" alt="images\557-2.png" /></a><br /><br /><a href=""><img src="images\557-3.png" alt="images\557-3.png" /></a><br /></div><div class='page'><h1 class='title level-4'>DexClassLoader</h1><br/><a href=""><img src="images\559-1.png" alt="images\559-1.png" /></a><br /><br /><a href=""><img src="images\559-2.png" alt="images\559-2.png" /></a></div><div class='page'><h1 class='title level-4'>InMemoryDexClassLoader</h1><br/><a href=""><img src="images\562-1.png" alt="images\562-1.png" /></a><br /><br /><a href=""><img src="images\562-2.png" alt="images\562-2.png" /></a><br />加载内存中的字节流作为dex，可以用于将壳代码解密后的内存数据作为dex进行调用，避免了将dex直接作为文件进行加载</div><div class='page'><h1 class='title level-4'>PathClassloader</h1><br/><a href=""><img src="images\561-1.png" alt="images\561-1.png" /></a><br /><a href=""><img src="images\561-2.png" alt="images\561-2.png" /></a></div><div class='page'><h1 class='title level-4'>确定加载入口类的CladdLoader</h1><br/>输出当前activity的classloader及其父classloader<br /><a href=""><img src="images\563-1.png" alt="images\563-1.png" /></a><br /><br />即<br /><a href=""><img src="images\563-2.png" alt="images\563-2.png" /></a><br /><br /><a href=""><img src="images\563-3.png" alt="images\563-3.png" /></a>·<br />代码执行，根据logcat输出，MainActivity的classloader为PathClassLoader，后者的父类为BootClassLoader，且BootClassLoader为根节点，不再有父类，说明从点击app图标开始到MainActivity显示，PathClassLoader和BootClassLoader通过双亲委派原理加载了入口类<br /></div><div class='page'><h1 class='title level-4'>通过DexClassLoader实现sd卡上的dex动态加载</h1><br/>实现一个插件，通过DexClassLoader加载sdcard上的dex（可以是明文或密文的），并进一步调用其中的某个方法<br />常用于插件化热修复<br /><a href=""><img src="images\564-1.png" alt="images\564-1.png" /></a><br /><br />DexClassLoader类的定义<br /><a href=""><img src="images\564-2.png" alt="images\564-2.png" /></a><br /><br />这里构造函数的参数 dexPath可以是dex、apk、zip文件的路径，<br />第二个参数表示优化目录，当加载apk或zip时，表示odex文件存储路径，<br />第三个参数表示lib库所在目录，如果该dex未用到so文件，可以为空<br />第四个参数表示父ClassLoader类<br /><br />生成一个被调用的dex<br /><a href=""><img src="images\564-3.png" alt="images\564-3.png" /></a><br /><br />将生成的dex存放在sdcard目录下<br /><a href=""><img src="images\564-4.png" alt="images\564-4.png" /></a><br /><br />项目中添加读写sdcard的权限<br /><a href=""><img src="images\564-5.png" alt="images\564-5.png" /></a><br /><br />使用DexClassLoader调用dex中的类及其函数<br /><a href=""><img src="images\564-6.png" alt="images\564-6.png" /></a><br /><br />logcat输出，说明函数调用成功<br /><a href=""><img src="images\564-7.png" alt="images\564-7.png" /></a><br /><br />通过以上方法，仅能调用另一个dex中的普通函数，对于另一个函数中的acticity、service等四大组件无法调用，因为四大组件相关类是由PathClassLoader进行加载，而当前是采用DexClassLoader加载dex，所以在framework层的组件生命周期管理过程中，无法找到四大组件的信息，此时需要针对classloader进行修正，也是所有壳递交控制权前要做的工作，即classloader的修正，如果没有该步骤，app无法运行<br /><br /></div><div class='page'><h1 class='title level-3'>识别加壳技术</h1><br/><a href=""><img src="images\571-1.png" alt="images\571-1.png" /></a><br /><a href=""><img src="images\571-2.png" alt="images\571-2.png" /></a><br /><a href=""><img src="images\571-3.png" alt="images\571-3.png" /></a><br /></div><div class='page'><h1 class='title level-4'>VMP与dex2c</h1><br/>vmp核心原理是dalvik和art解释器，即对smali流的解释执行过程，即壳自己用jni实现了解释器<br />为了避免被定位到解释器取指译码的过程，一般会加ollvm混淆<br />vmp与dex2c特征：java函数的native化<br /><a href=""><img src="images\574-1.png" alt="images\574-1.png" /></a><br /><br />dex2c核心原理是编译原理，与传统编译原理不同，传统编译原理通过语法词法分析生成二进制文件，dex2c目标是生成c/c++文件<br />dex2c开源项目：DCC<br /><a href=""><img src="images\574-2.png" alt="images\574-2.png" /></a><br /></div><div class='page'><h1 class='title level-5'>demo</h1><br/>vmp壳的demoADVMP<br /><a href=""><img src="images\575-1.png" alt="images\575-1.png" /></a><br /><br />advmp中的解释器源码<br /><a href=""><img src="images\575-2.png" alt="images\575-2.png" /></a><br /><br />dex2cdemo:DCC<br /><a href=""><img src="images\575-3.png" alt="images\575-3.png" /></a><br />dcc具体使用见看雪高级研修视频 课时4</div><div class='page'><h1 class='title level-4'>函数抽取</h1><br/>特征：反编译后函数体内容无效<br /><a href=""><img src="images\572-1.png" alt="images\572-1.png" /></a><br /><br /></div><div class='page'><h1 class='title level-4'>混合型壳</h1><br/><a href=""><img src="images\576-1.png" alt="images\576-1.png" /></a></div><div class='page'><h1 class='title level-4'>整体加固</h1><br/>dex整体加固的特征：反编译工具无法找到dex入口类<br /><a href=""><img src="images\573-1.png" alt="images\573-1.png" /></a></div><div class='page'><h1 class='title level-3'>脱壳思路</h1><br/>dex整体加壳<br /><a href=""><img src="images\577-1.png" alt="images\577-1.png" /></a><br /><br />函数抽取，fart优越性就在于针对函数抽取壳的解决方案<br /><a href=""><img src="images\577-2.png" alt="images\577-2.png" /></a><br /><br />vmp以及dex2c<br /><a href=""><img src="images\577-3.png" alt="images\577-3.png" /></a></div><div class='page'><h1 class='title level-3'>一代壳通用解决方案</h1><br/>详细过程见看雪安卓高研课时5<br />整体脱壳思路<br />脱壳点：出现了加载dex的起始地址的代码位置，根据dex起始地址，可以进行脱壳<br />针对脱壳点，需要修改安卓源码并重新编译，从而在脱壳点的位置输出所需信息<br /><br /><br />dalvik脱壳点<br /><a href=""><img src="images\578-1.png" alt="images\578-1.png" /></a><br /><a href=""><img src="images\578-2.png" alt="images\578-2.png" /></a><br /><br /><br />详细过程见看雪安卓高研课时6<br />art脱壳点<br /><a href=""><img src="images\578-3.png" alt="images\578-3.png" /></a><br /><a href=""><img src="images\578-4.png" alt="images\578-4.png" /></a><br /><a href=""><img src="images\578-5.png" alt="images\578-5.png" /></a><br /><a href=""><img src="images\578-6.png" alt="images\578-6.png" /></a><br /><br /></div><div class='page'><h1 class='title level-3'>自动化脱壳工具</h1><br/></div><div class='page'><h1 class='title level-4'>ApkShelling</h1><br/><a href="https://github.com/OakChen/ApkShelling">https://github.com/OakChen/ApkShelling</a></div><div class='page'><h1 class='title level-4'>使用FART脱壳</h1><br/>看雪2w班<br />fart针对代码抽取类型的壳，存在脚本可以自动修复<br /><a href=""><img src="images\446-1.png" alt="images\446-1.png" /></a> <br /><br /><a href=""><img src="images\446-2.png" alt="images\446-2.png" /></a><br /><br />如果遇到抽取壳，可以使用fart脱壳得到的同名bin文件修复对应的dex文件<br />需要使用python脚本，下图中python脚本为python2.7（该脚本作者github上提供了）<br />使用方法（最终将结果输出到了txt文件中）：<br />python fart.py -d dex文件绝对路径 -i 对应bin文件绝对路径 &gt;&gt;result.txt<br /><br />修复后输出的txt文件，指示了修复了哪些函数<br /><a href=""><img src="images\446-3.png" alt="images\446-3.png" /></a></div><div class='page'><h1 class='title level-5'>fart脱壳哪吒手机app</h1><br/>通过方法剖析，发现app控车按钮点击与该类有关，但是使用frida-dexdump以及apkshelling均为将该类脱壳<br /><a href=""><img src="images\545-1.png" alt="images\545-1.png" /></a><br /><br />使用fart进行脱壳，在其中搜索关键类的类名，从而确定其所在的dex文件<br /><a href=""><img src="images\545-2.png" alt="images\545-2.png" /></a></div><div class='page'><h1 class='title level-5'>脱壳示例</h1><br/>使用真机，将包含fart的rom刷入指定型号的机型<br /><a href=""><img src="images\447-1.png" alt="images\447-1.png" /></a><br /><br />安装app<br /><a href=""><img src="images\447-2.png" alt="images\447-2.png" /></a><br /><br />一般fart会将脱壳结果保存在sdcard目录下，如果app不存在读写sdcard目录的权限，则可以修改fart,将脱壳得到的dex文件保存到/data/data/包名 目录下<br /><br />进入/data/data/包名目录，然后手机端运行被脱壳apk，之后查看该目录，得到脱壳后的dex<br /><a href=""><img src="images\447-3.png" alt="images\447-3.png" /></a><br /><br />脱壳得到的dex中包含了系统库中的app，所以需要找到要分析的dex<br />找到要分析的apk的入口类名，使用grep在脱壳结果中搜索，找到存在入口类名的dex名<br /><a href=""><img src="images\447-4.png" alt="images\447-4.png" /></a><br /><a href=""><img src="images\447-5.png" alt="images\447-5.png" /></a><br /><br />得到对应的dex，进一步进行分析<br /><a href=""><img src="images\447-6.png" alt="images\447-6.png" /></a><br /><a href=""><img src="images\447-7.png" alt="images\447-7.png" /></a><br /><br />jadx等工具无法打开脱壳得到的dex文件，是因为脱壳得到的dex文件前8字节的魔数被抹去<br /><a href=""><img src="images\447-8.png" alt="images\447-8.png" /></a><br /><br />找打正常的dex文件，取魔数并赋值回去<br /><a href=""><img src="images\447-9.png" alt="images\447-9.png" /></a><br /><br />脱壳得到的dex中onCreate函数因为被VMP化所以导致没有反编译成功<br /><a href=""><img src="images\447-10.png" alt="images\447-10.png" /></a></div><div class='page'><h1 class='title level-4'>使用Frida - DEXDump简单脱壳</h1><br/><a href="https://blog.csdn.net/freeking101/article/details/107555372">使用 Frida - DEXDump 进行 apk 脱壳_freeking101的博客-CSDN博客</a><br /><a href="https://github.com/hluwa/FRIDA-DEXDump">hluwa/FRIDA-DEXDump: Fast search and dump dex on memory. (github.com)</a><br /></div><div class='page'><h1 class='title level-2'>文件格式</h1><br/><br /></div><div class='page'><h1 class='title level-3'>dex</h1><br/>dex 文件格式参考 Android 官方网址 https://source.android.com/devices/tech/dalvik/dex-format 中的说明或者查看官方源码</div><div class='page'><h1 class='title level-2'>物联网APP分析</h1><br/>分析方向<br /><a href=""><img src="images\375-1.png" alt="images\375-1.png" /></a><br /></div><div class='page'><h1 class='title level-2'>小技巧</h1><br/><br /></div><div class='page'><h1 class='title level-3'>base.apk</h1><br/>miui12版本下，长按app，选择分享，可以发送一个base.apk给别人，此时的base.apk相比原apk可能少一些东西，可能并未加壳，所以可以用于分析<br /></div><div class='page'><h1 class='title level-3'>反编译工具无法打开dex</h1><br/>jadx等工具无法打开脱壳得到的dex文件，是因为脱壳得到的dex文件前8字节的魔数被抹去<br /><a href=""><img src="images\453-1.png" alt="images\453-1.png" /></a><br /><br />找打正常的dex文件，取魔数并赋值回去<br /><a href=""><img src="images\453-2.png" alt="images\453-2.png" /></a> </div><div class='page'><h1 class='title level-3'>获得手机app对应apk包</h1><br/>长按app图标，使用手机的分享功能<br /></div><div class='page'><h1 class='title level-3'>寻找历史版本app</h1><br/>	通过360手机助手可以下载指令app的历史版本，若当前版本app存在较强加密或功能受限，可以通过尝试旧版本从而绕过相关限制，<a href="中汽研实习--IVI_APP分析--分析哪吒控车app.html">实例：分析哪吒控车app</a><br /><a href=""><img src="images\163-1.png" alt="images\163-1.png" /></a><br /><br /></div><div class='page'><h1 class='title level-2'>协议分析</h1><br/>有时app加壳之后，对app进行抓包，可能无法抓到指定数据包，因为壳的存在，会将app正常的tcp、udp、http访问转换为自己实现的socket发送，因为socket包等数据结构是自己实现的，所以即使数据已经发送出去，但是无法被抓包软件识别，所以此时需要先脱壳<br /><br />具体抓包方式：通过bp、fiddler、charler，中间人攻击并通过wrieshark抓包<br /><br />协议分析<br />	搜索字符串 http: .cer等关键字</div><div class='page'><h1 class='title level-2'>阅读安卓源码</h1><br/>查看源码使用sourceinsight或androidstdio——》耗时且占用硬盘空间<br /><br />在线浏览安卓源码-国外镜像<br /><a href=""><img src="images\556-1.png" alt="images\556-1.png" /></a><br /><br />右侧为源代码相关目录，若不知道代码具体目录位置，可以选择select all<br />art：安卓runtime的实现，以c++为主<br />bionic：安卓c库<br />libcore：存储classloader等代码，该目录编译到手机上时是一个jar包的形式 core.jar<br />framework：存储安卓四大组件<br />查找ActivityThread类<br /><a href=""><img src="images\556-2.png" alt="images\556-2.png" /></a><br /><br /><br />在线浏览安卓源码-国内镜像<br /><a href=""><img src="images\556-3.png" alt="images\556-3.png" /></a><br /><br />查看classloader类<br /><a href=""><img src="images\556-4.png" alt="images\556-4.png" /></a><br /><br /><br /></div><div class='page'><h1 class='title level-2'>资料</h1><br/><br /></div><div class='page'><h1 class='title level-3'>安卓BLE开发</h1><br/><a href="https://www.jianshu.com/p/3a372af38103">https://www.jianshu.com/p/3a372af38103</a><br /><br /><h2>Service</h2><br />一个低功耗蓝牙设备可以定义许多 Service, Service 可以理解为一个功能的集合。设备中每一个不同的 Service 都有一个 128 bit 的 UUID 作为这个 Service 的独立标志。蓝牙核心规范制定了两种不同的UUID，一种是基本的UUID，一种是代替基本UUID的16位UUID。所有的蓝牙技术联盟定义UUID共用了一个基本的UUID：<br /> 0x0000xxxx-0000-1000-8000-00805F9B34FB<br /> 为了进一步简化基本UUID，每一个蓝牙技术联盟定义的属性有一个唯一的16位UUID，以代替上面的基本UUID的‘x’部分。例如，心率测量特性使用0X2A37作为它的16位UUID，因此它完整的128位UUID为：<br /> 0x00002A37-0000-1000-8000-00805F9B34FB<br /><br /><h2>Characteristic</h2><br />在 Service 下面，又包括了许多的独立数据项，我们把这些独立的数据项称作 Characteristic。同样的，每一个 Characteristic 也有一个唯一的 UUID 作为标识符。在 Android 开发中，建立蓝牙连接后，我们说的通过蓝牙发送数据给外围设备就是往这些 Characteristic 中的 Value 字段写入数据；外围设备发送数据给手机就是监听这些 Charateristic 中的 Value 字段有没有变化，如果发生了变化，手机的 BLE API 就会收到一个监听的回调。<br />更详细的内容可以参见<br /> <a href="https://link.jianshu.com?t=https://www.bluetooth.com/specifications/adopted-specifications">GATT Profile 简介</a><br /> <a href="https://link.jianshu.com?t=http://blog.chinaunix.net/uid-21411227-id-5750680.html">通用属性配置文件（GATT）及其服务，特性与属性介绍</a><br /> <a href="https://link.jianshu.com?t=https://www.bluetooth.com/specifications/generic-attributes-overview">GATT specification</a><br /> <a href="https://link.jianshu.com?t=https://www.bluetooth.com/specifications/gatt/services">GATT Services</a><br /> <a href="https://link.jianshu.com?t=http://blog.csdn.net/u013378580/article/details/52891462">蓝牙【GATT】协议介绍</a><br /></div><div class='page'><h1 class='title level-3'>安卓脱壳</h1><br/>fat作者的看雪文章<br /><a href=""><img src="images\448-1.png" alt="images\448-1.png" /></a><br /><br /><a href=""><img src="images\448-2.png" alt="images\448-2.png" /></a><br /><br /><a href=""><img src="images\448-3.png" alt="images\448-3.png" /></a><br /><br /><a href=""><img src="images\448-4.png" alt="images\448-4.png" /></a></div><div class='page'><h1 class='title level-3'>安卓系统启动</h1><br/><a href="https://www.jianshu.com/p/75039ea24937">https://www.jianshu.com/p/75039ea24937</a><br /><br />init.rc文件用于安卓启动系统服务</div></body></html>