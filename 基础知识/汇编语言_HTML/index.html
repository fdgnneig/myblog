<!doctype html><html>
    <head>
      <meta http-equiv="content-type" content="text/html; charset=utf-8">
      <title>sqliteNoteBook.ctb</title>
      <meta name="generator" content="CherryTree">
      <link rel="stylesheet" href="res/styles3.css" type="text/css" />
    </head>
    <body><div class='page'><h1 class='title level-1'>汇编语言</h1><br/><br /></div><div class='page'><h1 class='title level-2'>32位及64位arm</h1><br/>atm体系简介<br /><a href=""><img src="images\111-1.png" alt="images\111-1.png" /></a><br />	cpu架构：armv7a之前-》使用32位arm汇编，分为A32(ARM) T32(Thumb)两种，两者可以在编程值时混用<br />	cpu架构：armv8-》使用64位汇编 A64，该汇编兼容32位汇编，但是两者不能混用<br />	arm指令是定长的，x86指令是变长的</div><div class='page'><h1 class='title level-2'>ARM</h1><br/><br /></div><div class='page'><h1 class='title level-3'>内核版本与处理器版本</h1><br/><a href="https://www.cnblogs.com/aurain/p/12127173.html">ARM版本及系列</a><br /><strong>1 概述</strong><br />ARM是Advanced RISC Machine的缩写，它是一家微处理器行业的知名企业，该企业设计了大量高性能、廉价、耗能低的RISC （精简指令集）处理器，只设计芯片而不生产。它提供ARM技术知识产权（IP），将技术授权给世界上许多著名的半导体、软件和OEM厂商，并提供服务。<br />ARM版本分为两类，内核版本，处理器版本。内核版本，也即ARM架构，如ARMv1、ARMv5、ARMv7、ARMv8等。处理器版本，也即ARM处理器，如ARM1、ARM9、ARM11、ARM Cortex-A（A7、A9、A15），ARM Cortex-M（M1、M3、M4）、ARM Cortex-R，这个也是我们通常意义上所指的ARM版本。<br /><strong>2 版本</strong><br />目前，ARM版本信息如下表所示。<br /><table class="table"><tr><th>内核（架构）版本</th><th>处理器版本</th></tr><tr><td>ARMv1</td><td>ARM1</td></tr><tr><td>ARMv2</td><td>ARM2、ARM3</td></tr><tr><td>ARMv3</td><td>ARM6、ARM7</td></tr><tr><td>ARMv4</td><td>StrongARM、ARM7TDMI、ARM9TDMI</td></tr><tr><td>ARMv5</td><td>ARM7EJ、ARM9E、ARM10E、XScale</td></tr><tr><td>ARMv6</td><td>ARM11、ARM Cortex-M</td></tr><tr><td>ARMv7</td><td>ARM Cortex-A、ARM Cortex-M、ARM Cortex-R</td></tr><tr><td>ARMv8</td><td>ARM Cortex-A30、ARM Cortex-A50、ARM Cortex-A70</td></tr></table><br /><strong>3 Cortex-A系列</strong><br />Cortex-A，代表先进的意义（Advanced），目标是以最佳功耗实现最高性能，主要应用领域包括汽车、工业、医学、调制解调器、存储等。Cortex-A也是目前应用最广的处理器版本。<br />该系列处理器主要包括Cortex-A5、Cortex-A7、Cortex-A8、Cortex-A9、Cortex-A15、Cortex-A17、Cortex-A32、Cortex-A35、Cortex-A53、Cortex-A57、Cortex-A72、Cortex-A73。Cortex-A8只支持单核。其中，Cortex-A5、Cortex-A7、Cortex-A8、Cortex-A9、Cortex-A15、Cortex-A17基于ARMv7-A架构；Cortex-A32、Cortex-A35、Cortex-A53、Cortex-A57、Cortex-A72、Cortex-A73基于ARMv8-A架构，Cortex-A32为32位结构，其他支持64位结构。<br />Cortex-A处理器从高到低可排序为：Cortex-A73、Cortex-A72、Cortex-A57、Cortex-A53、Cortex-A35、Cortex-A32、Cortex-A17、Cortex-A15、Cortex-A7、Cortex-A9、Cortex-A8、Cortex-A5。<br /><strong>4 Cortex-M系列</strong><br />Cortex-M，代表微处理器的意义（Microcontrollers），目标是最节能的嵌入式设备，主要应用领域包括汽车、能源网、医学、嵌入式、智能卡、智能设备。传感器融合、穿戴设备等。<br />该系列处理器主要包括Cortex-M0、Cortex-M0+、Cortex-M3、Cortex-M4、Cortex-M7、Cortex-M23、Cortex-M33、Cortex-M35P。<br /><strong>5 Cortex-R系列</strong><br />Cortex-R，代表实时的意义（Real-Time），目标是实时任务处理，主要应用领域包括汽车、相机、工业、医学等。<br />该系列处理器主要包括Cortex-R4、Cortex-R5、Cortex-R7、Cortex-R8、Cortex-R52、Cortex-A17。<br /><strong>6 ARM11系列</strong><br />         主要应用在高可靠性和实时嵌入式应用领域，主要包括ARM11MPCore、ARM1176、ARM1156、ARM1136。<br /><strong>7 ARM9系列</strong><br />         主要针对嵌入式实时应用，主要包括ARM926EJ-S、ARM946E-S和 ARM968E-S。<br /><strong>8 ARM7系列</strong><br />         主要针对某些简单的32位设备，作为目前较旧的一个系列，ARM7处理器已经不建议继续在新品中使用。主要包括ARM7TDMI-S（ARMv4T架构）和ARM7EJ-S（ARMv5TEJ架构）。<br /><br /></div><div class='page'><h1 class='title level-3'>运行模式</h1><br/>共9种，这里仅列7种<br /><a href=""><img src="images\91-1.png" alt="images\91-1.png" /></a><br /><br />armv7的处理器模式<br /><a href=""><img src="images\91-2.png" alt="images\91-2.png" /></a><br /><a href=""><img src="images\91-3.png" alt="images\91-3.png" /></a><br />FIQ：中断发生时要保存的数据量比较大，比如产生异常<br />IRQ：正常的中断，比如系统调用<br /><br />处理模式的切换<br />	处理器模式可以通过软件控制、外部中断、异常过程进行切换<br />	用户模式下，通过产生异常处理，进行处理器模式的切换<br />	每种异常模式均有对应的一组寄存器，保证进入用户模式进入异常模式，用户模式中寄存器不被破坏<br />	系统模式与用户模式寄存器相同，不适用异常模式下相应寄存器组，从而保证异常中断的任务状态不被破坏<br /><br />从用户模式中进入内核需要调用svc，从而陷入内核</div><div class='page'><h1 class='title level-3'>大小端</h1><br/><a href=""><img src="images\90-1.png" alt="images\90-1.png" /></a><br />注意虽然arm支持小端、大端模式，但是安卓中都是小端<br /></div><div class='page'><h1 class='title level-3'>运行状态</h1><br/>arm运行状态<br /><a href=""><img src="images\92-1.png" alt="images\92-1.png" /></a><br /><br />进入不同状态<br /><a href=""><img src="images\92-2.png" alt="images\92-2.png" /></a><br /><br /><a href=""><img src="images\92-3.png" alt="images\92-3.png" /></a>	<br />	执行arm指令时，当正确读取R15值时，寄存器值为当前指令地址+8字节<br />		相当于指向当前指令下两条指令的地址<br />	执行thumb指令时，当正确读取R15值时，寄存器值为当前指令地址+4字节<br />		相当于指向当前指令下两条指令的地址<br />	无论是arm指令还是thumb指令，指令长度一定义2字节的倍数，这就导致指令的地址，即pc寄存器取出的地址值一定时偶数的，即地址的最低bit位为0<br />	如果给pc寄存器赋值，则程序会跳转执行对应地址中的指令，如果跳转后要执行的指令为arm指令，则可以直接给pc指令赋值为偶数地址，即目标arm指令的实际地址，如果跳转后要执行的指令为thumb指令，则赋值给pc寄存器的地址需要为奇数，等于对应thumb指令地址+1，只有这样才能保证跳转后，程序执行thumb指令<br />		具体实例为后面IDA远程调试并bin文件</div><div class='page'><h1 class='title level-3'>寄存器</h1><br/><h1>arm模式下工作寄存器</h1><br /><a href=""><img src="images\93-1.png" alt="images\93-1.png" /></a><br />不分组寄存器(R0-R7)<br />分组寄存器(R8-R14)<br />r13：栈顶<br />r14：返回地址<br />r15：pc<br />user模式转为FIQ模式时，CPSR寄存器会保存user模式下的运行环境<br /><br /><br /><h1>thumb模式下工作寄存器</h1><br /><a href=""><img src="images\93-2.png" alt="images\93-2.png" /></a><br /><br /><h1>对应关系</h1><br /><a href=""><img src="images\93-3.png" alt="images\93-3.png" /></a><br /><br />不同模式下寄存器命名差异<br />命名相同的寄存器<br />		R0-R7<br />		CPSR<br />命名不同的寄存器<br />		Thumb状态下：FP  、 IP  、 SP  、 LR  、PC<br />		对应ARM状态：R11、R12、R13、R14、R15<br /><br /><h1>未备份寄存器R0~R7</h1><br />	系统没有指定专门的用途<br />	所有处理器模式下均指同一个物理寄存器<br />	可以用于任何使用通用寄存器的场景下<br />	不同处理器模式下使用可能会造成数据破坏<br />	<br /><h1>备份寄存器R8~R14</h1><br />	R8~r12<br />		每个寄存器对应两个不同的物理寄存器，不同的处理器模式，使用不同的物理寄存器<br />		系统不做特殊用途要求<br />		中断处理时使用R8~R14，可以加快程序处理<br />	R13 R14<br />		每个寄存器对应6个物理寄存器，用户和系统模式共用一个，其他五种处理器模式对应其专门的物理寄存器<br />		命名格式<br />		<a href=""><img src="images\93-4.png" alt="images\93-4.png" /></a>		<br />		R13<br />			ARM中使用R13作为栈指针，不强制，也可以使用其他寄存器作为栈指针<br />			Thunb强制使用R13作为栈指针<br />			应用程序初始化R13，使其指向不同处理器模式对应的栈，处理器模式切换时，将使用到的寄存器保存在R13指向的栈空间中，之后可以出栈恢复数据，从而保证不同处理器模式下运行环境不被破坏<br />		R14<br />			链接寄存器<br />			特殊作用<br />				用于保存当前子程序返回地址<br />				异常中断发生时，对应的R14被设置为该异常模式将要返回的地址<br />				可以作为通用寄存器<br />			注意实际arm汇编函数中，函数返回地址可能存放在LR链接寄存器中，可能存放在堆栈中（比如该函数需要用到比较多的寄存器，所以占用lr寄存器），甚至可以自己开辟一块内存存放返回地址，根据函数实现的不同而不同<br />			<br />			注意实际arm汇编函数中，函数返回地址可能存放在LR链接寄存器中，可能存放在堆栈中（比如该函数需要用到比较多的寄存器，所以占用lr寄存器），根据函数实现的不同而不同<br />			<br /><h1>程序计数器 PC也称R15</h1><br />	一般可以作用通用寄存器，但那时部分指令使用R15有限制<br />	执行arm指令时，当正确读取R15值时，寄存器值为当前指令地址+8字节<br />		相当于指向当前指令下两条指令的地址<br />	执行thumb指令时，当正确读取R15值时，寄存器值为当前指令地址+4字节<br />		相当于指向当前指令下两条指令的地址<br />	当成功向R15中写入值时，程序跳转到该地址执行指令<br />		<a href=""><img src="images\93-5.png" alt="images\93-5.png" /></a><br />		<a href=""><img src="images\93-6.png" alt="images\93-6.png" /></a><br />		<br /><h1>程序状态寄存器（CPSR SPSR）</h1><br />	两者结构一致<br />	CPSR<br />		当前程序状态寄存器<br />		所有处理器模式中都对应同一个物理寄存器<br />		<a href=""><img src="images\93-7.png" alt="images\93-7.png" /></a><br />		cpsr状态寄存器，该寄存器中的控制位是不能直接修改的<br />		控制位t用于指定当前执行的是Thumb指令还是ARM指令<br />		注意c表示无符号数是否进位，v表示有符号数是否溢出<br />	SPSR<br />		备份程序状态寄存器<br />		除了用户模式和系统模式，其他处理器模式均对应一个特定物理寄存器<br />			用户模式和系统模式访问SPSR，会造成不可预知的问题<br />		异常中断发生时，用于保存当前程序状态寄存器内容<br />		异常中断程序退出时，用于恢复当前程序状态寄存器内容<br />	结构<br />		<a href=""><img src="images\93-8.png" alt="images\93-8.png" /></a><br />			条件标志位<br />				<a href=""><img src="images\93-9.png" alt="images\93-9.png" /></a><br />				<a href=""><img src="images\93-10.png" alt="images\93-10.png" /></a><br />			Q标志位<br />				<a href=""><img src="images\93-11.png" alt="images\93-11.png" /></a><br />			CPSR中的控制位<br />				<a href=""><img src="images\93-12.png" alt="images\93-12.png" /></a><br />				<a href=""><img src="images\93-13.png" alt="images\93-13.png" /></a><br />			其他位用于将来ARM版本的扩展，应用程序中不应该使用<br />		</div><div class='page'><h1 class='title level-3'>流水线操作</h1><br/><a href=""><img src="images\94-1.png" alt="images\94-1.png" /></a><br /><br />armv9之后转为5级流水线<br /></div><div class='page'><h1 class='title level-3'>执行流程</h1><br/><br /><a href=""><img src="images\108-1.png" alt="images\108-1.png" /></a><br />ARM体系程序执行流程<br />	正常执行<br />		ARM PC+4字节<br />		Thumb PC+2字节<br />	通过跳转指令该改变执行流程<br />		B<br />			跳转<br />		BL<br />			跳转并保存返回地址<br />		BX<br />			跳转，切换程序状态为Thumb<br />		BLX<br />			跳转，保存返回地址，切换程序状态为Thumb<br />	通过异常中断改变程序执行流程<br />		发生异常中断，程序跳转到中断异常处理函数执行<br />		进入异常处理函数前-》保存被中断程序执行现场<br />		退出异常处理函数前-》恢复被中断程序执行现场</div><div class='page'><h1 class='title level-3'>传参与调用约定</h1><br/><h1>ARM传参与调用约定</h1><br /><a href="https://blog.csdn.net/darmao/article/details/60779974">arm汇编函数调用参数传递规则_darmao的博客-CSDN博客_arm汇编参数传递</a><br />       <h3>1. 子程序通过寄存器R0~R3来传递参数. 这时寄存器可以记作: A0~A3 , 被调用的子程序在返回前无需恢复寄存器R0~R3的内容.</h3><br /><h3>     2. 在子程序中,使用R4~R11来保存局部变量,这时寄存器R4~R11可以记作: V1~V8 .如果在子程序中使用到V1~V8的某些寄存器,子程序进入时必须保存这些寄存器的值,在返回前必须恢复这些寄存器的值,对于子程序中没有用到的寄存器则不必执行这些操作.在THUMB程序中，通常只能使用寄存器R4~R7来保存局部变量.</h3><br /><h3>     3.寄存器R12用作子程序间scratch寄存器,记作ip; 在子程序的连接代码段中经常会有这种使用规则.</h3><br /><h3>     4. 寄存器R13用作数据栈指针,记做SP,在子程序中寄存器R13不能用做其他用途. 寄存器SP在进入子程序时的值和退出子程序时的值必须相等.</h3><br /><h3>     5. 寄存器R14用作连接寄存器,记作lr ; 它用于保存子程序的返回地址,如果在子程序中保存了返回地址,则R14可用作其它的用途.</h3><br /><h3>     6. 寄存器R15是程序计数器,记作PC ; 它不能用作其他用途.</h3><br /><br />arm32函数的调用约定 ：fastcall<br />	r0用于保存函数返回值<br />	<a href=""><img src="images\95-1.png" alt="images\95-1.png" /></a><br />	在进行系统调用时（陷入linux内核），所有的的参数通过r0~r6直接传递，r7中保存系统调用号</div><div class='page'><h1 class='title level-3'>异常与中断</h1><br/>ARM体系的异常中断<br />	异常中断按优先级被先后处理<br />	异常中断类型和含义<br />	<a href=""><img src="images\109-1.png" alt="images\109-1.png" /></a><br />	ARM处理器对异常中断的响应过程<br />	<a href=""><img src="images\109-2.png" alt="images\109-2.png" /></a>	<br />	ARM处理器从中断程序中返回<br />	<a href=""><img src="images\109-3.png" alt="images\109-3.png" /></a>	</div><div class='page'><h1 class='title level-3'>存储系统</h1><br/><a href=""><img src="images\110-1.png" alt="images\110-1.png" /></a><br /><a href=""><img src="images\110-2.png" alt="images\110-2.png" /></a><br />ARM体系中的存储系统<br />	存储空间<br />		地址空间可以为2^32个8位字节<br />		地址空间可以为2^30个32位字单元<br />			地址的低两位为0x0b00，地址为A的字单元包括地址为A A+1 A+2 A+3四个字节单元的内容<br />		ARMv4以上版本中，地址空间可以为2^31个16位半字单元<br />			地址的最低位为0x0b0，地址为A的半字单元包括地址为A A+1两个字节单元的内容<br />		存储空间的内存地址均为32位无符号整数，可以进行常规整数运算，运算结果出现上溢或下溢时，地址会发生卷绕<br />	存储器格式<br />		x86中的大小端<br />			大端<br />				数据高位保存在内存低地址，数据低位保存在内存高地址<br />			小端<br />				数据高位保存在内存高地址，数据低位保存在内存低地址<br />					x86采用小端存储<br />		ARM中存储方法与之类似，分大小端<br />		<a href=""><img src="images\110-3.png" alt="images\110-3.png" /></a>	<br />		<a href=""><img src="images\110-4.png" alt="images\110-4.png" /></a>		<br />	非对齐的存储访问操作<br />		通常字单元的地址是字对齐的，地址低两位为0x0b00，半字单元的地址是半字对齐的，地址低两位为0xb0，如果没有遵守以上规则，称为非对齐存储访问操作<br />		非对齐的指令预取操作<br />		<a href=""><img src="images\110-5.png" alt="images\110-5.png" /></a>	<br />		非对齐数据的访问操作<br />		<a href=""><img src="images\110-6.png" alt="images\110-6.png" /></a>	<br />	指令预取和自修改代码<br />		指令预取<br />			cpu执行当前指令的同时，可以从存储器中预取其后若干条指令，具体预取多少条指令，取决于不同ARM的实现方式<br />			预期的指令不一定会被执行，当当前指令发生异常中断或执行跳转时，预取指令会被抛弃<br />				程序跳转的预测算法根据不同ARM实现的不同而不同<br />		自修改代码<br />			代码执行过程中可能修改自身<br />		以上两者结合可能出现问题<br />			当指令自修改将已经预取的指令进行修改，可能造成执行错误</div><div class='page'><h1 class='title level-3'>指令</h1><br/><h1>详细资料见<br /></h1><a href="file://D:\CherryTreeNoteBook\技术思维导图\15pb日常笔记\ARM相关\ARM体系结构与编程\ARM体系结构与编程1.xmind">ARM体系结构与编程1.xmind</a></div><div class='page'><h1 class='title level-4'>指令格式</h1><br/>ARM指令格式：<br />	内存结构<br />	<a href=""><img src="images\98-1.png" alt="images\98-1.png" /></a>	<br />	指令结构<br />	A32指令高4bit均为条件标志位，用于指定该指令什么情况下执行，因为cond一般均为无条件执行，即条件标志位为al (1110),所以顺序执行的arm指令均已0xe开头<br />	<a href=""><img src="images\98-2.png" alt="images\98-2.png" /></a>	<br />	<br />Thumb指令结构<br /><a href=""><img src="images\98-3.png" alt="images\98-3.png" /></a><br /></div><div class='page'><h1 class='title level-4'>指令条件码域</h1><br/>	指令条件码域cond<br />	ARM中大部分指令都是有条件执行的，根据CPSR寄存器中的数据决定是否执行特定指令，条件满足时执行指令，条件不满足时该指令被当作NOP，处理器进行判断中断请求等操作，之后执行下一条指令<br />	条件码域在内存中共4位，可以标识16种不同的特定条件<br />	<a href=""><img src="images\112-1.png" alt="images\112-1.png" /></a></div><div class='page'><h1 class='title level-4'>指令长度</h1><br/>ARM状态<br />		执行32位字对齐的ARM指令  字对齐<br />Thumb状态<br />		执行16位字对齐的Thumb指令  半字对齐<br />		<br /></div><div class='page'><h1 class='title level-4'>arm栈指令</h1><br/><h1>栈的类型</h1><br />栈地址的增长方向：<br />ARM将向高地址增长的栈称为递增栈（Descendent Stack），将向低地址增长的栈称为递减栈（Acendant Stack）<br />栈指针的指向位置：<br />ARM将栈指针指向栈顶元素位置的栈称为满栈（Full Stack），将栈指针指向即将入栈的元素位置的栈称为空栈（Empty Stack）<br /><a href=""><img src="images\100-1.png" alt="images\100-1.png" /></a><br /><br /><h1>栈存取指令</h1><br />	STMFD<br />	LDMFD	<br />	栈操作指令分解为两步微指令：数据存取和栈指针移动。这两步操作的先后顺序和栈指针的移动方式由栈的类型决定。<br />	栈操作指令分解为两步微指令<br />	<a href=""><img src="images\100-2.png" alt="images\100-2.png" /></a><br />	<br /><h1>使用举例</h1><br />虽然ARM的栈类型和相关的操作指令比较繁琐，但是实际上最常用的还是和x86指令集相同的栈类型：栈向低地址方向增长，且栈指针指向栈顶元素的位置，即ARM的FD栈。因此最常见的ARM栈指令操作是STMFD和LDMFD。<br /><a href=""><img src="images\100-3.png" alt="images\100-3.png" /></a><br /><a href=""><img src="images\100-4.png" alt="images\100-4.png" /></a><br /><br /><br /><br /><br /></div><div class='page'><h1 class='title level-4'>缓冲区读写指令</h1><br/>缓冲区读写指令<br />	<a href=""><img src="images\101-1.png" alt="images\101-1.png" /></a><br />	ARM中存在一组缓冲区操作指令和栈指令是一一对应的，他们完成相同的功能。这些指令含义的区别来源于对存取操作的缓冲区指针地址增长方向，以及存取操作和缓冲区指针移动的先后顺序决定的。这个和前面描述的栈类型的分类原则十分相似。</div><div class='page'><h1 class='title level-4'>跳转指令</h1><br/><a href=""><img src="images\102-1.png" alt="images\102-1.png" /></a><br /><h1>跳转指令</h1><br />	跳转指令，又称分支指令，它可以改变指令序列的执行流程，ARM中有两种方式可以实现程序跳转<br />		一种是使用跳转指令直接跳转<br />		另一种是给PC寄存器直接赋值实现跳转<br />	<br /><h2>跳转指令有4条：</h2><br /><h2>B跳转指令</h2><br /><br /><h2>BL 带链接的跳转指令</h2><br />			BL{cond} label	：当执行BL指令时，如果条件满足，ARM处理器会首先将当前指令的下一条指令的地址拷贝到R14(LR)寄存器中，然后再跳转到label指定的地址处继续执行。<br />			BL指令，通常用于调用子程序，在子程序的尾部，可以通过MOV PC, LR 返回到主程序中。<br />			示例：BNE LABEL	---&gt; 表示条件码Z=0时跳转到LABEL处执行。<br /><br /><h2>BX带状态切换的跳转指令</h2><br />			BX{cond} Rm	：当执行BX指令时，如果条件满足，ARM处理器会判断Rm的[0]位是否为1，如果为1则跳转时自动将CPSR寄存器的T标志位置位，并将目标地址处的代码解释为Thumb代码来执行，即处理器会切换到Thumb状态；<br />             反之，如果Rm的[0]位为0，则跳转时自动将CPSR寄存器的T标志位复位，并将目标地址处的代码解释为ARM代码来执行，即处理器切换到ARM状态。<br />			示例：<br />    ......<br />   	ADR R0, thumbcode+1<br />    BX R0            @跳转到thumbcode处执行，并将处理器切换为Thumb状态<br />   	thumbcode:<br />   .code 16<br />   .......<br /><br /><h2>BLX带链接和状态切换的跳转指令</h2><br />			BLX{cond} Rm	：BLX指令集合了BL和BX的功能，如果条件满足，ARM处理器除了设置链接寄存器LR外，还根据Rm的[0]位的值来切换处理器状态。<br /></div><div class='page'><h1 class='title level-4'>存储器访问指令</h1><br/><a href=""><img src="images\103-1.png" alt="images\103-1.png" /></a><br />LDM STM LDR STR四条指令中<br />	带LD 即load 即数据从内存加载到寄存器中<br />	带ST 即store 即数据从寄存器保存到内存中<br />	无论是load还是store，主语都是寄存器，load为寄存器加载数据，store为寄存器保存数据<br />	<br />存储器访问指令[内存地址]<br />	单寄存器-存储单元<br />		LDR<br />			LDR，用于从存储器中加载数据到寄存器中<br />			指令格式：<br />	LDR{type}{cond} Rd, label<br />	LDRD{cond} Rd, Rd2, label<br />				type：指明了操作的数据大小，它的取值如表6-3所示。<br />				<a href=""><img src="images\103-2.png" alt="images\103-2.png" /></a><br />				cond：为执行条件，其取值如表6-2所示。<br />				<a href=""><img src="images\103-3.png" alt="images\103-3.png" /></a><br />				Rd：目标寄存器，把存储器中数据存到的寄存器<br />				label：为要读取的内存地址。它的表示方法有三种：<br />					直接偏移量，如 LDR R8，[R9, #04]、LDR R8，[R9], #04<br />					寄存器偏移，如 LDR R8，[R9, R10, #04]<br />					相对PC的偏移，如 LDR R8, label1<br />				LDRD：一次加载双字的数据，将数据加载到Rd与Rd2寄存器中。<br />示例：<br />	LDRD R0, R1, label2	---&gt; 从标号label2指向的内存地址中加载两个字的数据到R0与R1寄存器中。<br />		STR<br />			STR，将寄存器中的数据存储到指定内存地址的存储单元中。<br />			指令格式：<br />	STR{type}{cond} Rd, label<br />	STRD{cond} Rd, Rd2, label<br />				注：STR和LDR指令格式相同，只是type中SB也SH对STR无效。<br />			示例：<br />	STR R0, [R2, #04]	---&gt; 将R0寄存器的数据存储到R2+4所指向的存储单元。<br />	寄存器列表-存储单元<br />		LDM<br />			LDM，可以从指定的存储单元加载多个数据到一个寄存器列表。<br />			指令格式：<br />	LDM{addr_mode}{cond} Rn{!} reglist<br />				addr_mode：取值如表6-4所示。<br />				<a href=""><img src="images\103-4.png" alt="images\103-4.png" /></a><br />				cond：为6-2所示的执行条件<br />				Rn：为基地址寄存器，用于存储初始地址。<br />				！：为可选后缀。如果有！，则最终地址将写回到Rn寄存器中。<br />				reglist：为用来存储数据的寄存器列表，用大括号括起来。<br />					寄存器列表可以是多个连续的寄存器，多个连续的寄存器用“-”连接，如R0-R3表示连续的寄存器R0至R3寄存器列表；<br />					如果多个寄存器不是连续的，则用“，”逗号将它们分割开来，如｛R0, R1, R7｝<br />			示例：<br />	LDMIA R0!, {R1-R3}	---&gt; 依次加载R0指向的存储单元的数据到R1，R2，R3寄存器。<br />		STM<br />			STM，将一个寄存器列表的数据存储到指定的存储单元。<br />			指令格式：<br />	STM{addr_mode}{cond} Rn{!} reglist<br />				addr_mode：取值如表6-4所示。<br />				<a href=""><img src="images\103-5.png" alt="images\103-5.png" /></a><br />				cond：为6-2所示的执行条件<br />				Rn：为基地址寄存器，用于存储初始地址。<br />				！：为可选后缀。如果有！，则最终地址将写回到Rn寄存器中。<br />				reglist：为用来存储数据的寄存器列表，用大括号括起来。<br />					寄存器列表可以是多个连续的寄存器，多个连续的寄存器用“-”连接，如R0-R3表示连续的寄存器R0至R3寄存器列表；<br />					如果多个寄存器不是连续的，则用“，”逗号将它们分割开来，如｛R0, R1, R7｝<br />			示例：<br />	STMDB R0!, {R3-R6，R11}	---&gt; 依次将R11，R6-R3寄存器的内容存储到R0指向的存储单元。<br />	STMFD SP!, {R3-R7}	---&gt; 依次将R7-R3寄存器的内容压入栈，功能等价于STMDB SP!, {R3-R7}。<br />	寄存器-满递减栈<br />		PUSH<br />			PUSH，将寄存器数据推入满递减栈。<br />			PUSH指令格式：<br />	PUSH{cond} reglist<br />			示例：<br />	PUSH {R0, R4-R7}	---&gt; 将R7-R4，R0寄存器中的数据依次入栈<br />		POP<br />			POP，从满递减栈中弹出数据到寄存器。<br />			POP指令格式：<br />	POP{cond} reglist<br />			示例：<br />	POP {R0, R4-R7}	---&gt; 将数据弹出栈依次放到R0，R4-R7寄存器<br />	寄存器与存储器间数据交换<br />		SWP<br />			SWP，寄存器与存储器间数据交换。<br />			SWP指令格式：<br />	SWP{B}{cond} Rd, Rm, [Rn]<br />				B，是可选的字节，若有B，则交换字节，否则交换32位的字。<br />				cond为表6-2所示的执行条件<br />				<a href=""><img src="images\103-6.png" alt="images\103-6.png" /></a><br />				Rd：要从存储器中加载数据的寄存器<br />				Rm：要写入数据到存储器的寄存器<br />				Rn：为需要进行数据交换的存储器地址。<br />					Rn不能与Rd和Rm相同。<br />					如果Rd与Rm相同，可实现单个寄存器与存储器的数据交换。<br />			示例：<br />	SWP R1, R1, [R0]	---&gt; 将R1寄存器与R0指向的存储单元的内容进行交换。<br />	SWP R1, R2, [R0]	---&gt; 从R0指向的存储单元读取一个字节存入R1(高24位清零)，然后将R2寄存器的字节内容存储到该存储单元。</div><div class='page'><h1 class='title level-4'>数据处理指令</h1><br/><a href=""><img src="images\104-1.png" alt="images\104-1.png" /></a><br /><a href=""><img src="images\104-2.png" alt="images\104-2.png" /></a><br /><a href=""><img src="images\104-3.png" alt="images\104-3.png" /></a><br />数据处理指令<br />	数据处理指令，主要是对寄存器与寄存器之间数据进行操作。<br />比较指令不需要S后缀，它们会直接影响状态标志，其它3类数据处理指令可选择使用S后缀，来决定是否影响状态标志。<br />	数据处理指令包括4类<br />		数据传输指令<br />			MOV<br />				MOV指令是ARM指令集中使用最频繁的指令，功能是将8位的立即数或源寄存器的内容传送到目标寄存器中。<br />				指令格式：<br />	MOV{cond}{S} Rd,operand2<br />				示例：<br />	MOV R0, #8	---&gt; R0=8<br />	MOV R0, R1	---&gt; R0 = R1<br />	MOVS R2, R1, LSL #2	---&gt; R2=R1*4	影响标志位<br />			MVN<br />				MVN为数据非传输指令，功能是将8位的立即数或源寄存器的内容按位取反后传送到目标寄存器中。<br />				指令格式：<br />	MVN{cond}{S} Rd,operand2<br />				示例：<br />	MVN R0, #0xFF	---&gt; R0=0xFFFFFF00<br />	MVN R1, R2		---&gt; 将R2寄存器数据取反后存入R1寄存器中<br />		算术运算指令<br />			加<br />				ADD<br />					加法指令的功能：是将Rn寄存器与operand2的值相加，结果保存到Rd寄存器。<br />					指令格式：<br />	ADD{cond}{S} Rd, Rn, operand2<br />					示例：<br />	ADD R0, R1, #2		---&gt; R0=R1+#2<br />	ADDS R0, R1, R2	---&gt; R0=R1+R2,	影响标志位<br />	ADD R0, R1, LSL #3	---&gt; R0=R1*8<br />				ADC<br />					带进位加法指令的功能：是将Rn寄存器加上operand2的值，再加上CPSR寄存器的条件标志位C的值，最后将结果保存到Rd寄存器。<br />					指令格式：<br />	ADC{cond}{S} Rd, Rn, operand2<br />					示例：<br />	ADDS R0, R0, R2	<br />	ADC R1, R1, R3		---&gt; 两条指令完成64位加法，(R1, R0) = (R1, R0) + (R3, R2)<br />			减<br />				SUB<br />					指令格式：<br />	SUB{cond}{S} Rd, Rn, operand2<br />					示例：<br />	SUB R0, R1, #4		---&gt; R0=R1-4	<br />	SUBS R0, R1, R2	---&gt; R0=R1-R2, 影响标志位<br />				RSB<br />					功能：逆向减法指令，用operand2减去Rn寄存器的值，将结果保存到Rd寄存器。<br />					指令格式：<br />	RSB{cond}{S} Rd, Rn, operand2<br />					示例：<br />	RSB R0, R1, #1234	---&gt; R0=#1234-R1	<br />	RSB R0, R1		---&gt; R0=-R1<br />				SBC<br />					带进位减法指令的功能：是将Rn寄存器减去operand2的值，再减去CPSR寄存器的条件标志位C的值，最后将结果保存到Rd寄存器。<br />					指令格式：<br />	SBC{cond}{S} Rd, Rn, operand2<br />					示例：<br />	SUBS R0, R0, R2	<br />	SBC R1, R1, R3		---&gt; 两条指令完成64位减法，(R1, R0) = (R1, R0) - (R3, R2)<br />				RSC<br />					带进位逆向减法指令的功能：是用operand2减去Rn寄存器的值，再减去CPSR寄存器的条件标志位C的值，最后将结果保存到Rd寄存器。<br />					指令格式：<br />	RSC{cond}{S} Rd, Rn, operand2<br />					示例：<br />	RSBC R2, R0, #0<br />	RSC R3, R1, #0		---&gt; 两条指令完成64位数取反，(R3, R2) = -(R1, R0)<br />			乘<br />				MUL<br />					32位乘法指令：是将Rm寄存器与Rn寄存器的值相乘，结果的低32位保存到Rd寄存器。<br />					指令格式：<br />	MUL{cond}{S} Rd, Rm, Rn<br />					示例：<br />	MUL R0, R1, R2		---&gt; R0=R1*R2<br />	MULS R0, R2, R3		---&gt; R0=R2*R3	影响CPSR的N位和Z位<br />				MLS<br />					MLS指令：是将Rm寄存器与Rn寄存器的值相乘，然后再用Ra寄存器的值减去乘积，最后将所得结果的低32位保存到Rd寄存器。<br />					指令格式：<br />	MLS{cond}{S} Rd, Rm, Rn, Ra		---&gt; Rd=Ra-(Rm*Rn)<br />					示例：<br />	MLS R0, R1, R2, R3		---&gt; R0=(R3-R1*R2)的结果的低32<br />				MLA<br />					MLA指令：是将Rm寄存器与Rn寄存器的值相乘，然后再用Ra寄存器的值加上乘积，最后将所得结果的低32位保存到Rd寄存器。<br />					指令格式：<br />	MLA{cond}{S} Rd, Rm, Rn, Ra		---&gt; Rd=Ra+(Rm*Rn)<br />					示例：<br />	MLA R0, R1, R2, R3		---&gt; R0=(R3-R1*R2)的结果的低32<br />				UMULL<br />					UMULL指令：是将Rm寄存器与Rn寄存器的值作为无符号数相乘，然后将结果的低32位存入RdLo寄存器，高32位存入RdHi寄存器。<br />					指令格式：<br />	UMULL{cond}{S} RdLo, ,RdHi, Rm, Rn		---&gt; (RdHi, RdLo)=Rm*Rn<br />					示例：<br />	UMULL R0, R1, R2, R3		---&gt; (R0, R1)=R2*R3<br />				UMLAL<br />					UMLAL指令：是将Rm寄存器与Rn寄存器的值作为无符号数相乘，然后将64位的结果与RdHi、RdLo组成的64位数相加，结果的低32位存入RdLo寄存器，高32位存入RdHi寄存器。<br />					指令格式：<br />	UMLAL{cond}{S} RdLo, ,RdHi, Rm, Rn		---&gt; (RdHi, RdLo)=Rm*Rn + (RdHi, RdLo)<br />					示例：<br />	UMLAL R0, R1, R2, R3		---&gt; (R0, R1)=R2*R3 + (R0, R1)<br />				SMULL<br />					SMULL指令：是将Rm寄存器与Rn寄存器的值作为有符号数相乘，然后将结果的低32位存入RdLo寄存器，高32位存入RdHi寄存器。<br />					指令格式：<br />	SMULL{cond}{S} RdLo, ,RdHi, Rm, Rn		---&gt; (RdHi, RdLo)=Rm*Rn<br />					示例：<br />	SMULL R0, R1, R2, R3		---&gt; (R0, R1)=R2*R3<br />				SMLAL<br />					SMLAL指令：是将Rm寄存器与Rn寄存器的值作为有符号数相乘，然后将64位的结果与RdHi、RdLo组成的64位数相加，结果的低32位存入RdLo寄存器，高32位存入RdHi寄存器。<br />					指令格式：<br />	SMLAL{cond}{S} RdLo, ,RdHi, Rm, Rn		---&gt; (RdHi, RdLo)=Rm*Rn + (RdHi, RdLo)<br />					示例：<br />	SMLAL R0, R1, R2, R3		---&gt; (R0, R1)=R2*R3 + (R0, R1)<br />				SMLAD<br />					SMLAD指令：是将Rm寄存器的低半字与Rn寄存器的低半字相乘，然后将Rm寄存器的高半字与Rn寄存器的高半字相乘，最后将两个乘积与Ra寄存器的值相加并将结果存入Rd寄存器。<br />					指令格式：<br />	SMLAD{cond}{S} Rd, Rm, Rn, Ra		---&gt; (RdHi, RdLo)=Ra + [(RmLo*RnLo) + (RmHi*RnHi)]<br />				SMLSD<br />					SMLSD指令：是将Rm寄存器的低半字与Rn寄存器的低半字相乘，然后将Rm寄存器的高半字与Rn寄存器的高半字相乘，接着使用第一个乘积减去第二个乘积，最后将所得的差值与Ra寄存器的值相加并将结果存入Rd寄存器。<br />					指令格式：<br />	SMLSD{cond}{S} Rd, Rm, Rn, Ra		---&gt; (RdHi, RdLo)=Ra + [(RmLo*RnLo) - (RmHi*RnHi)]<br />			除<br />				SDIV<br />					SDIV指令：为有符号除法指令<br />					指令格式：<br />	SDIV{cond}{S} Rd, Rm, Rn		---&gt; Rd=Rm/Rn<br />					示例：<br />	SDIV R0, R1, R2		---&gt; R0=R1/R2<br />				UDIV<br />					UDIV指令：为无符号除法指令<br />					指令格式：<br />	UDIV{cond}{S} Rd, Rm, Rn		---&gt; Rd=Rm/Rn<br />					示例：<br />	UDIV R0, R1, R2		---&gt; R0=R1/R2<br />		逻辑运算指令<br />			逻辑与<br />				AND<br />					AND 逻辑与指令：。<br />					指令格式：<br />	AND{cond}{S} Rd, Rn, operand2<br />					示例：<br />	AND R0, R0, #1		---&gt; 用来检测R0的最低位<br />				BIC<br />					BIC 位清除指令：将operand2的值取反，然后将结果与Rn寄存器的值做与操作，结果保存到Rd寄存器中。<br />					指令格式：<br />	BIC{cond}{S} Rd, Rn, operand2<br />					示例：<br />	BIC R0, R0, #0x0F		---&gt; 将R0的低四位清0，其余位保持不变<br />			逻辑或<br />				ORR<br />					ORR 逻辑或指令：。<br />					指令格式：<br />	ORR{cond}{S} Rd, Rn, operand2<br />					示例：<br />	ORR R0, R0, #0x0F		---&gt; 保留R0的低四位，其余位清0<br />			异或<br />				EOR<br />					EOR 异或指令：相同为0，相异为1。<br />					指令格式：<br />	EOR{cond}{S} Rd, Rn, operand2<br />					示例：<br />	EOR R0, R0, R0		---&gt; R0的值置0<br />			移位<br />				ASR<br />					ASR 算术右移指令：将Rm寄存器中的值算术右移operand2位，并使用符号位填充空位，移位的结果保存到Rd寄存器中。<br />					指令格式：<br />	ASR{cond}{S} Rd, Rm, operand2<br />					示例：<br />	ASR R0, R1, #2		---&gt; 将R1寄存器中的值作为有符号数右移2位后赋值给R0寄存器。<br />				LSL<br />					LSL 逻辑左移指令：将Rm寄存器中的值逻辑左移operand2位，并空位补0，移位的结果保存到Rd寄存器中。<br />					指令格式：<br />	LSL{cond}{S} Rd, Rm, operand2<br />					示例：<br />	LSL R0, R1, #2		---&gt; R0=R1*4<br />				LSR<br />					LSR 逻辑右移指令：将Rm寄存器中的值逻辑右移operand2位，空位补0，移位的结果保存到Rd寄存器中。<br />					指令格式：<br />	LSR{cond}{S} Rd, Rm, operand2<br />					示例：<br />	LSR R0, R1, #2		---&gt; R0=R1/4<br />				ROR<br />					ROR 循环右移指令：将Rm寄存器中的值循环右移operand2位，寄存器右边移出的位补到左边空位，移位的结果保存到Rd寄存器中。<br />					指令格式：<br />	ROR{cond}{S} Rd, Rm, operand2<br />					示例：<br />	ROR R0, R1, #1		---&gt; 将R1寄存器中的值的最低位移动到最高位<br />				RRX<br />					RRX 带扩展的循环右移指令：将Rm寄存器中的值循环右移1位，寄存器最高位用标志位的值填充，移位的结果保存到Rd寄存器中。<br />					指令格式：<br />	RRX{cond}{S} Rd, Rm, operand2<br />					示例：<br />	RRX R1, R1		---&gt; 将R1寄存器中的值右移移位，最高位用标志位填充<br />		比较指令<br />			CMP<br />				CMP 使用Rn寄存器减去operand2的值，这与SUBS指令功能相同，但是CMP指令不保存计算结果，仅根据比较结果设置标志位。<br />				指令格式：<br />	CMP{cond} Rn, operand2<br />				示例：<br />	CMP R0, #0		---&gt; 判断R0寄存器的值是否为0<br />			CMN<br />				CMN 将operand2的值加到Rn寄存器上，这与ADDS指令功能相同，但是CMN指令不保存计算结果，仅根据比较结果设置标志位。<br />				指令格式：<br />	CMN{cond} Rn, operand2<br />				示例：<br />	CMN R0, R1		---&gt; 判断R0寄存器的值是否为0<br />			TST<br />				TST 位测试指令：将Rn寄存器的值和operand2的值进行与操作，这与ANDS指令功能相同，但是TST指令不保存计算结果，仅根据比较结果设置标志位。<br />				指令格式：<br />	TST{cond} Rn, operand2<br />				示例：<br />	TST R0, #1		---&gt; 判断R0寄存器最低位的值是否为0<br />			TEQ<br />				TEQ 将Rn寄存器的值和operand2的值进行异或操作，这与EORS指令功能相同，但是TEQ指令不保存计算结果，仅根据比较结果设置标志位。<br />				指令格式：<br />	TEQ{cond} Rn, operand2<br />				示例：<br />	TEQ R0, R1		---&gt; 判断R0寄存器的值和R1寄存器的值是否相等。<br />	其它指令<br />		SWI<br />			SWI 软中断指令：用于产生软中断，从而实现从用户模式到管理模式的切换。<br />			指令格式：<br />	SWI{cond}, immed_24<br />				immed_24：为24位的中断号<br />				注释：在Android的系统中，系统功能调用为0号中断，使用R7寄存器存放系统调用号。<br />	使用R0-R3寄存器来传递系统调用的前4个参数，对于大于4个参数的调用，剩余参数采用堆栈来传递。<br />			示例：调用exit(0)的汇编代码如下<br />	MOV R0, #0		---&gt; 参数0<br />	MOV R7, #1		---&gt; 系统功能号1为exit<br />	SWI #0			---&gt; 执行exit(0)<br />		NOP<br />			NOP 空操作指令：该指令仅用于空操作或字符对齐。<br />			指令格式：只有一个操作码NOP<br />		MRS<br />			MRS 为读取状态寄存器指令<br />			指令格式：<br />	MRS Rd, psr<br />				psr的取值可以是<br />					CPSR<br />					SPSR<br />			示例：<br />	MRS R0, CPSR		---&gt; 读取CPSR寄存器到R0寄存器中 <br />		MSR<br />			MSR 为写状态寄存器指令<br />			指令格式：<br />	MSR Rd, psr_fields, operand2<br />				psr的取值可以是<br />					CPSR<br />					SPSR<br />				field：指定传送的区域，它的取值如表6-5所示<br />				<a href=""><img src="images\104-4.png" alt="images\104-4.png" /></a><br />					<br />			示例：<br />	MSR R0, CPSR		---&gt; 读取CPSR寄存器到R0寄存器中 <br />	BIC R0, R0, #0x80	---&gt; 清楚R0寄存器第7位<br />	MSR CPSR_c, R0	---&gt; 开启IRQ中断<br />	MOV PC, LR		---&gt; 子程序返回</div><div class='page'><h1 class='title level-4'>字长</h1><br/>	在计算机领域, 对于某种特定的计算机设计而言，字是用于表示其自然的数据单位的术语。在这个特定计算机中，字是其用来一次性处理事务的一个固定长度的位（bit）组。一个字的位数（即字长）是计算机系统结构中的一个重要特性。”<br />X86中字为16个bit位，双字为32bit位<br />ARM中字为32个bit位</div><div class='page'><h1 class='title level-4'>指令实例</h1><br/><a href="file://D:\CherryTreeNoteBook\技术思维导图\麦洛科菲\安卓\安卓-3.xmind">麦洛科菲安卓3</a></div><div class='page'><h1 class='title level-3'>编译arm原生程序</h1><br/><a href=""><img src="images\105-1.png" alt="images\105-1.png" /></a></div><div class='page'><h1 class='title level-3'>寻址方式</h1><br/><a href=""><img src="images\106-1.png" alt="images\106-1.png" /></a><br /><h1>详细资料见<br /></h1><a href="file://D:\CherryTreeNoteBook\技术思维导图\15pb日常笔记\ARM相关\ARM体系结构与编程\ARM体系结构与编程1.xmind">ARM体系结构与编程1.xmind</a><br /><br />ARM处理器寻址方式<br />	处理器寻址方式：是指通过指令中给出的地址码字段来寻找真是操作数地址的方式。<br />	ARM处理器支持的9种寻址方式<br />		立即寻址<br />			直接寻址：指令中后面的地址码部分为立即数(即常量或常数)。<br />			立即寻址多用于给寄存器赋值，并且立即数只能用于源操作数字段。<br />			立即数以“#”作为前缀<br />			示例：mov R0, #123		---&gt; R0=123<br />		寄存器寻址<br />			寄存器寻址中，操作数的值在寄存器中，指令执行时直接从寄存器中取值进行操作。<br />			示例：mov R0, R1		---&gt; R0=R1<br />		寄存器移位寻址<br />			ARM指令集特有的寻址方式，和寄存器寻址类似，只是在操作前需要对源寄存器操作数进行移位操作。<br />			寄存器移位寻址支持五种移位操作<br />				LSL：逻辑左移，移位后寄存器空出的低位补0。<br />				LSR：逻辑右移，移位后寄存器空出的高位补0。<br />				ASR：算术右移，移位过程中符号位保持不变，如果源操作数为正数，移位后寄存器空出的高位补0，否则补1。<br />				ROR：循环右移，移位后移出的低位填补到空出的高位。<br />				RRX：带扩展的循环右移，操作数右移一位，移位空出的高位用C标志的值填充。<br />				示例：MOV R0, R1, LSL #2		---&gt; R0=R1&lt;&lt;2 =R1*2*2<br />		寄存器间接寻址<br />			寄存器间接寻址中，地址码给出的寄存器是操作数的地址指针，所需要的操作数保存在寄存器指定地址的存储单元中<br />			示例：LDR R0, [R1]	---&gt; 将R1寄存器的数值作为地址，取出此地址中的值赋给R0寄存器。<br />		基址寻址<br />			基址寻址，是将地址码给出的基址寄存器与偏移量相加，形成操作数的有效地址，所需要的操作数保存在有效地址指向的存储单元中。<br />			基址寻址，多用于查表、数组访问等操作<br />			示例：LDR R0, [R1, #-4]	---&gt; 将R1寄存器中的值减4作为地址，取出此地址的值赋给R0寄存器。<br />		多寄存器寻址<br />			多寄存器寻址，一条指令最多可以完成16个通用寄存器值的传送。<br />			示例：LDMIA R0, {R1, R2, R3, R4}	---&gt;LDM是数据加载指令，指令的后缀IA表示每次执行完加载操作后R0寄存器的值自增1个字，ARM指令集中，一个字表示的是一个32位的数值。<br />					R1=[R0],	R2=[R0+#4],	R3=[R0+#8],	R4=[R0+#12]<br />		栈寻址<br />			栈寻址，是ARM处理器特有的第二种寻址方式，栈寻址需要使用特定的指令来完成。<br />			栈寻址指令<br />				LDMFA/STMFA<br />				LDMEA/STMEA<br />				LDMFD/STMFD<br />				LDMED/STMED<br />				注：LDM和STM为指令前缀，表示多寄存器寻址，即一次可以传送多个寄存器值；<br />FA、EA、FD、ED为指令后缀，表示栈的类型。<br />			示例：<br />	STMFD SP!, {R1-R7, LR}	将LR，R7-R1依次入栈，多用于子进程中保存现场。<br />	LDMFD SP!, {R1-R7, LR}	数据出栈，依次存入LR，R7-R1，多用于子进程中恢复现场。<br />		块拷贝寻址<br />			块拷贝寻址，实现连续地址数据，从存储器的某个位置拷贝到另一个位置。<br />			块拷贝寻址的指令有<br />				LDMIA/STMIA<br />				LDMDA/STMDA<br />				LDMIB/STMIB<br />				LDMDB/STMDB<br />				注：LDM和STM为指令前缀，表示多寄存器寻址，即一次可以传送多个寄存器值；<br />IA、DA、IB、DB为指令后缀，表示栈的类型。<br />			示例：<br />	LDMIA R0!, {R1-R3}	@从R0寄存器指向的存储单元中读取3个字到R1-R3寄存器。<br />	STMIA R0!, {R1-R3}	@将寄存器R3-R1的内容依次存入到R0存储器指向的存储单元。<br />		相对寻址<br />			相对寻址，是基址寻址的一种变通，由程序计数器 PC 提供基准地址，指令中的地址符号作为偏移量，将两者相加以后得到操作数的有效地址。<br />			示例：<br />	BL NEXT<br />	......<br />NEXT:<br />	......<br />注释：BL NEXT是跳到NEXT标号处执行。这里的BL采用的就是相对寻址，标号NEXT就是偏移量。</div><div class='page'><h1 class='title level-2'>ARM64</h1><br/><br /></div><div class='page'><h1 class='title level-3'>兼容性</h1><br/>armv8中兼容32位程序和64位程序，系统中有不同而libs和进程兼容32、64位程序<br />		<a href=""><img src="images\114-1.png" alt="images\114-1.png" /></a><br />		<a href=""><img src="images\114-2.png" alt="images\114-2.png" /></a></div><div class='page'><h1 class='title level-3'>架构</h1><br/>armv8a架构<br />	整体分为el0~el3<br />	<a href=""><img src="images\115-1.png" alt="images\115-1.png" /></a><br />		从用户模式中进入内核需要调用svc，但是不能直接调用到最底层，需要从上到下一层一层调用下来，实践中hvp可以不同实现，所以可以从el1直接调用到el3</div><div class='page'><h1 class='title level-3'>寄存器</h1><br/><a href=""><img src="images\116-1.png" alt="images\116-1.png" /></a></div><div class='page'><h1 class='title level-3'>传参与调用约定</h1><br/><a href=""><img src="images\117-1.png" alt="images\117-1.png" /></a><br />64位中普通函数调用方法和系统函数调用方法是一致的，均使用x0-x7传参，这一点与32位arm不同<br />之所以系统调用时多使用寄存器传递参数而不是用栈传递参数是因为用户层与内核层各自有其对应的堆栈，也有各自的sp指针</div><div class='page'><h1 class='title level-3'>指令</h1><br/><a href=""><img src="images\118-1.png" alt="images\118-1.png" /></a><br /><br />BR BLR指令常在got表跳转的汇编中看到<br /><a href=""><img src="images\118-2.png" alt="images\118-2.png" /></a><br /><br />从用户模式中进入内核需要调用svc，但是不能直接调用到最底层，需要从上到下一层一层调用下来，实践中hvp可以不同实现，所以可以从el1直接调用到el3<br /><a href=""><img src="images\118-3.png" alt="images\118-3.png" /></a><br /><br />指令手册<br />	<a href=""><img src="images\118-4.png" alt="images\118-4.png" /></a><br /><br />指令实例<br />	<a href="file://D:\CherryTreeNoteBook\技术思维导图\麦洛科菲\安卓\安卓-3.xmind">麦洛科菲安卓3</a><br />	<br />	实例分析<br />	64位arm中编译出来的两个so文件实际上是一样的，因为64位arm指令没有thumb和arm之分<br />	<a href=""><img src="images\118-5.png" alt="images\118-5.png" /></a><br />	函数开头<br />	<a href=""><img src="images\118-6.png" alt="images\118-6.png" /></a><br />	函数结尾<br />	<a href=""><img src="images\118-7.png" alt="images\118-7.png" /></a><br />	调用函数<br />	<a href=""><img src="images\118-8.png" alt="images\118-8.png" /></a><br />	<a href=""><img src="images\118-9.png" alt="images\118-9.png" /></a><br />	条件跳转指令B.cond<br />	<a href=""><img src="images\118-10.png" alt="images\118-10.png" /></a><br />	</div><div class='page'><h1 class='title level-2'>mips</h1><br/>相关思维导图：<a href="file://D:\CherryTreeNoteBook\技术思维导图\物联网安全\物联网安全1-MIPS架构初探.xmind">物联网mips架构初探</a></div><div class='page'><h1 class='title level-3'>MIPS版本</h1><br/><a href=""><img src="images\121-1.png" alt="images\121-1.png" /></a></div><div class='page'><h1 class='title level-3'>基本特点</h1><br/><a href=""><img src="images\123-1.png" alt="images\123-1.png" /></a></div><div class='page'><h1 class='title level-3'>大小端</h1><br/><a href=""><img src="images\124-1.png" alt="images\124-1.png" /></a></div><div class='page'><h1 class='title level-3'>寄存器</h1><br/><a href=""><img src="images\125-1.png" alt="images\125-1.png" /></a><br />一共有32个寄存器<br />r0（$zero）寄存器始终为0，如果需要将立即数移动到某个寄存器，可以直接和0进行相加，或者当数据需要和0比较时，而可以直接跟r0进行比较<br />r1($at)主要留给编译器使用<br />r2-r3($v0-$v1)存储表达式或者是函数的返回值（反汇编中对应$v0 $v1,syscall指令根据$v0值的不同调用不同函数）<br />r4-r7($a0-$a3)用于存放函数参数，当函数参数数量大于4个，才使用栈传参<br />r8-r15($t0-$t7)以及r24-r25($8-$9)：临时寄存器，使用之后不会保存相应执行结果<br />r16-r23($s0-$s7)：也是临时寄存器，但是可以用于保存执行结果，比如将r8-r15中的数据保存到r16-r23中进行保存<br />r26-r27($k0-$k1)：系统相关寄存器，例如中断相关<br />r28($gp)：全局指针寄存器<br />r29($sp)：指向栈顶<br />r30($fp)：指向栈底<br />r31($ra)：保存返回地址，返回地址数据也会保存在栈中<br />浮点数寄存器（为加快浮点数运算）<br />f0~f31</div><div class='page'><h1 class='title level-3'>流水线</h1><br/><a href=""><img src="images\126-1.png" alt="images\126-1.png" /></a></div><div class='page'><h1 class='title level-3'>寻址方式</h1><br/><a href=""><img src="images\127-1.png" alt="images\127-1.png" /></a><br /><a href=""><img src="images\127-2.png" alt="images\127-2.png" /></a><br /><a href=""><img src="images\127-3.png" alt="images\127-3.png" /></a><br /><a href=""><img src="images\127-4.png" alt="images\127-4.png" /></a><br /><a href=""><img src="images\127-5.png" alt="images\127-5.png" /></a><br /><a href=""><img src="images\127-6.png" alt="images\127-6.png" /></a></div><div class='page'><h1 class='title level-3'>指令</h1><br/><br /></div><div class='page'><h1 class='title level-4'>指令格式</h1><br/><a href=""><img src="images\128-1.png" alt="images\128-1.png" /></a><br /><br />opcode解析<br /><a href=""><img src="images\128-2.png" alt="images\128-2.png" /></a><br /><a href=""><img src="images\128-3.png" alt="images\128-3.png" /></a></div><div class='page'><h1 class='title level-4'>具体指令</h1><br/><a href=""><img src="images\130-1.png" alt="images\130-1.png" /></a><br />左移<br /><a href=""><img src="images\130-2.png" alt="images\130-2.png" /></a><br /><br /><a href=""><img src="images\130-3.png" alt="images\130-3.png" /></a><br /><br />跳转<br /><a href=""><img src="images\130-4.png" alt="images\130-4.png" /></a><br /><br />取数据<br /><a href=""><img src="images\130-5.png" alt="images\130-5.png" /></a><br /><br /></div><div class='page'><h1 class='title level-3'>环境搭建与交叉编译</h1><br/><a href=""><img src="images\131-1.png" alt="images\131-1.png" /></a><br /><a href=""><img src="images\131-2.png" alt="images\131-2.png" /></a><br />相关思维导图：<a href="file://D:\CherryTreeNoteBook\技术思维导图\物联网安全\物联网安全1-MIPS架构初探.xmind">物联网mips架构初探</a></div><div class='page'><h1 class='title level-2'>X64</h1><br/></div><div class='page'><h1 class='title level-3'>函数调用规则</h1><br/><h2>x64 调用约定</h2><br /><h3>在 x86 模式下，有三种常用调用约定，cdecl (C规范) / stdcall(WinAPI默认) / fastcall 函数调用约定。</h3><br /><h3>而在 x64 模式下，调用约定只有一种，就是 fastcall，但是 Windows 下和 Linux 下还是略有不同的，下面分别介绍。</h3><br /><br /><h1>windows</h1><br /><br /><h3>3.1 Windows 下的 x64</h3><br /><h3>一些细节：</h3><br />• Windows 的 x64 下只有一种函数调用约定，即 __fastcall ，其他调用约定的关键字会被忽略，也就是说 ABI 只有 __fastcall ；<br />• 一个函数在调用时，前四个参数是从左至右依次存放于 RCX、RDX、R8、R9 寄存器里面，剩下的参数通过栈传递，从右至左顺序入栈；<br />• 如果是 int f(double a, double b, double c, double d, double e, double f) 这样的函数，前四个浮点类型参数从左到右由 XMM0，XMM1，XMM2，XMM3 依次传递，剩下的参数通过栈传递，从右至左顺序入栈；<br />• 调用者负责在栈上分配32字节的“shadow space”，用于存放那四个存放调用参数的寄存器的值（亦即前四个调用参数）；<br />• 小于64位(bit)的参数传递时高位并不填充零（例如只传递ecx），也就是说结构体或union如果大小是1，2，4，8字节，用值传递（相应的寄存器），大于8字节(64位)必须按照地址（指针）传递；<br />• 被调用函数的返回值是64位以内（包括64位）的整形或指针时，则返回值会被存放于RAX；<br />• 如果返回值是浮点值，则返回值存放在XMM0；<br />• 更大的返回值(比如结构体)，由调用方在栈上分配空间，并由 RCX 持有该空间的指针并传递给被调用函数，因此整型参数使用的寄存器依次右移一格，实际只可以利用 RDX，R8，R9，3个寄存器，其余参数通过栈传递。函数调用结束后，RAX 返回该空间的指针（即函数调用开始时的 RCX 值）。<br />• 调用者 (caller) 负责清理栈，被调用函数 (callee) 不用清栈，可是为什么有时候我们看到调用者 (caller) 也没有清栈呢？后面会讲；<br />• 除了 RCX，RDX，R8，R9 以外，RAX，R10，R11 和 XMM5，XMM6 也是“易挥发”的，不用特别保护，其余寄存器需要保护。（x86下只有 eax, ecx, edx 是易挥发的）<br />• 栈需要16字节对齐，“call”指令会入栈一个8字节的函数返回地址（函数调用指令后的下一个指令的地址）（注：即函数调用前原来的RIP指令寄存器的值），这样一来，栈就对不齐了（因为RCX、RDX、R8、R9四个寄存器刚好是32个字节，是16字节对齐的，现在多出来了8个字节）。所以，所有非叶子结点调用的函数，都必须调整栈RSP的地址为16n+8，来使栈对齐。<br />• 对于 R8～R15 寄存器，我们可以使用 r8, r8d, r8w, r8b 分别代表 r8 寄存器的64位、低32位、低16位和低8位。<br /><br /><h3> </h3><br /><h3>关于 Windows x64 的调用约定，可以参考微软的官方文档：</h3><br /><a href="https://docs.microsoft.com/zh-cn/cpp/build/x64-calling-convention?view=vs-2017">x64 调用约定</a><br /><a href="https://docs.microsoft.com/zh-cn/cpp/build/x64-calling-convention?view=vs-2017">https://docs.microsoft.com/zh-cn/cpp/build/x64-calling-convention?view=vs-2017</a><br /><h3> </h3><br /><h3>一些其他要注意的小问题：</h3><br />◇ 另外一些小问题要注意，AMD64不支持 push 32bit 寄存器的指令，push 和 pop 都要用64位寄存器，即 push rbx ，不能使用 push ebx 。<br />◇ 另外要补充的一点是，在一般情况下，x64 平台的 RBP 栈基指针被废弃掉，只作为普通寄存器来用，所有的栈操作都通过 RSP 指针来完成。<br /><h3> </h3><br /><h3>关于有时候我们看到调用者 (caller) 也没有清栈的原因：</h3><br /><h3>　　都说 x64 下 __fastcall 由调用者 (caller) 清理栈区空间。但是我们有时候发现 main() 函数或被 main() 函数调用的函数中，没有清理子函数栈空间的过程呢？</h3><br /><h3>　　这是由于 64 位平台下栈区空间开辟问题导致。我在CSDN上看到这样一句话：与通过 PUSH 和 POP 指令在堆栈中显式添加和移除参数的 x86 编译器不同，x64 模式下，编译器会预留足够的堆栈空间，以调用最大目标函数（参数方法）所使用的任何内容。随后，在调用子函数时，它重复使用相同的堆栈区域来设置这些参数，从而实现不用调用者 (caller) 反复清栈的过程。</h3><br /><h3>　　这句话什么意思呢？它的意思就是我们在 x64 模式下一开始系统会为 main() 函数开辟一个很大的栈区，但是 main() 函数并未消耗掉这么大的栈区空间，这时候怎么办呢？子函数就会还继续利用 main() 函数的预留的栈区空间，所以 main() 函数或其他被 main() 调用的函数，并不用对子函数栈区空间进行清理。</h3><br /><br />~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br /><br /><h1>linux</h1><br /><br /><h3>3.2 Linux 下的 x64</h3><br /><h3>调用约定细节：</h3><br />• Linux 下的调用约定叫做 “System V AMD64 ABI”，此约定主要在 Solaris，GNU/Linux，FreeBSD 和其他非微软OS上使用；<br />• Linux 的 x64 下也只有一种函数调用约定，即 __fastcall ，其他调用约定的关键字会被忽略，也就是说 ABI 只有 __fastcall ；<br />• 一个函数在调用时，如果参数个数小于等于 6 个时，前 6 个参数是从左至右依次存放于 RDI，RSI，RDX，RCX，R8，R9 寄存器里面，剩下的参数通过栈传递，从右至左顺序入栈；<br />• 如果参数个数大于 6 个时，前 5 个参数是从左至右依次存放于 RDI，RSI，RDX，RCX，RAX 寄存器里面，剩下的参数通过栈传递，从右至左顺序入栈；<br />• 对于系统调用，使用 R10 代替 RCX；<br />• XMM0 ~ XMM7 用于传递浮点参数；<br />• 小于64位(bit)的参数传递时高位并不填充零（例如只传递ecx），也就是说结构体或union如果大小是1，2，4，8字节，用值传递（相应的寄存器），大于8字节(64位)必须按照地址（指针）传递；<br />• 被调用函数的返回值是64位以内（包括64位）的整形或指针时，则返回值会被存放于 RAX，如果返回值是128位的，则高64位放入 RDX；<br />• 如果返回值是浮点值，则返回值存放在XMM0；<br />• 更大的返回值(比如结构体)，由调用方在栈上分配空间，并由 RCX 持有该空间的指针并传递给被调用函数，因此整型参数使用的寄存器依次右移一格，实际只可以利用 RDI，RSI，RDX，R8，R9，5个寄存器，其余参数通过栈传递。函数调用结束后，RAX 返回该空间的指针（即函数调用开始时的 RCX 值）。<br />• 可选地，被调函数推入 RBP，以使 caller-return-rip 在其上方8个字节，并将 RBP 设置为已保存的 RBP 的地址。这允许遍历现有堆栈帧，通过指定GCC的 -fomit-frame-pointer 选项可以消除此问题。<br />• 调用者 (caller) 负责清理栈，被调用函数 (callee) 不用清栈；<br />• 除了 RDI，RSI，RDX，RCX，R8，R9 以外，RAX，R10，R11 也是“易挥发”的，不用特别保护，其余寄存器需要保护。<br />• 在调用 call 指令之前，必须保证堆栈是16字节对齐的；<br />• 对于 R8～R15 寄存器，我们可以使用 r8, r8d, r8w, r8b 分别代表 r8 寄存器的64位、低32位、低16位和低8位。</div><div class='page'><h1 class='title level-3'>寄存器情况</h1><br/><a href=""><img src="images\1035-1.png" alt="images\1035-1.png" /></a><br /><br /></div><div class='page'><h1 class='title level-2'>精简指令集与复杂指令集</h1><br/><a href=""><img src="images\122-1.png" alt="images\122-1.png" /></a><br /><a href=""><img src="images\122-2.png" alt="images\122-2.png" /></a>	<br /></div></body></html>