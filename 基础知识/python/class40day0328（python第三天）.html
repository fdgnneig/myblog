<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<meta content="text/css" http-equiv="Content-Style-Type">
<title>class40day0328（python第三天）</title>
</head>
<body>
<h1 align="center" class="root">
<a name="6lk8rgq1d05cq0bpqc96uv63a7">class40day0328（python第三天）</a>
</h1>
<div align="center" class="globalOverview">
<img src="class40day0328%EF%BC%88python%E7%AC%AC%E4%B8%89%E5%A4%A9%EF%BC%89_files/images/class40day0328%EF%BC%88python%E7%AC%AC%E4%B8%89%E5%A4%A9%EF%BC%89.jpg"></div>
<h2 class="topic">
<a name="5st9jsusihf93i3a0a60r8vnif">复习</a>
</h2>
<h3 class="topic">
<a name="7jmohtbv79r148fc8btef1cbkd">&nbsp;python如何定义类,如何实例化类</a>
</h3>
<h3 class="topic">
<a name="2bl0gifij5dg72v4klpskuqa60">&nbsp;&nbsp;class OBJ (objcet):&#13;
	def _init_(self):&#13;
		pass&#13;
obj = OBJ()	</a>
</h3>
<h3 class="topic">
<a name="55i98fchf5fgq0t0mhrvngli4o">&nbsp;python中的构造析构</a>
</h3>
<h3 class="topic">
<a name="6pecovqct4oir9h3en44ihomr4">&nbsp;&nbsp;def _init_(self):&#13;
	pass</a>
</h3>
<h3 class="topic">
<a name="6peifs816eponocta2ce6tue3f">&nbsp;&nbsp;def _del_(selff):&#13;
	pass</a>
</h3>
<h3 class="topic">
<a name="0mb6q5mr63fr4tihlrksnngsgs">&nbsp;python中的成员方法</a>
</h3>
<h3 class="topic">
<a name="1101tf8cd59kl1trqn994qdvdq">&nbsp;&nbsp;成员方法</a>
</h3>
<h3 class="topic">
<a name="4lrnvqsh9oalqv4k4ocm1hn5ce">&nbsp;&nbsp;&nbsp;def fun(self):</a>
</h3>
<h3 class="topic">
<a name="1lhdqq85rn3jash741h1j5tjaa">&nbsp;&nbsp;类方法</a>
</h3>
<h3 class="topic">
<a name="2gr5clk9b4hehujs8f847v3jo3">&nbsp;&nbsp;&nbsp;@classmethod&#13;
def fun2(cls):&#13;
	pass</a>
</h3>
<h3 class="topic">
<a name="3d07g2plfhm24rp2pi04fqu5fh">&nbsp;&nbsp;&nbsp;&nbsp;一般cls不需要传参</a>
</h3>
<h3 class="topic">
<a name="13ruhdr18jbtokfvo69jqpd50m">&nbsp;&nbsp;静态方法</a>
</h3>
<h3 class="topic">
<a name="27afc55o2b9qrfaj2ck4fn4p1v">&nbsp;&nbsp;&nbsp;@staticmethod&#13;
def fun3():&#13;
	pass</a>
</h3>
<h3 class="topic">
<a name="2d6mqi2sqcncepjiievk6h28ct">&nbsp;python使用什么方法规定私有成员</a>
</h3>
<h3 class="topic">
<a name="77eracsvrqgrvr4a8qv03gt260">&nbsp;&nbsp;在数据属性或方法名前面加_,表示这个数据是属性或方法是私有的，但是可以访问</a>
</h3>
<h3 class="topic">
<a name="5jfnf1igrt1sooeemsr7kvg5on">&nbsp;&nbsp;通过在加上__实现一定程度上的私有</a>
</h3>
<h3 class="topic">
<a name="6lh2bcv3ftq8bvc6s4op0mg5nv">&nbsp;异常处理</a>
</h3>
<h3 class="topic">
<a name="0ca510u02kh0cfpciprqsc6gi2">&nbsp;&nbsp;try:&#13;
	pass&#13;
except Exception as msg:&#13;
	print(msg)&#13;
</a>
</h3>
<h3 class="topic">
<a name="1eidtumm7fcil0mlkpvufkomnj">&nbsp;lambda表达式</a>
</h3>
<h3 class="topic">
<a name="2pm2ln9eids5vu6ujc7rqr5beq">&nbsp;&nbsp;lambda:x,y:x*y</a>
</h3>
<h3 class="topic">
<a name="0j0j7ke282f5o5msv5m7aop675">&nbsp;&nbsp;&nbsp;:前面是参数，后面是返回值</a>
</h3>
<h3 class="topic">
<a name="5hv2a10u9qqkr63cjj14nl3d2m">&nbsp;遍历文件的方法</a>
</h3>
<h3 class="topic">
<a name="7tfl114ocs033jvnf8autcict7">&nbsp;&nbsp;os.listdir(路径)</a>
</h3>
<h2 class="topic">
<a name="6sddvt5ukmi9vclng0i1chm4jd">python多线程</a>
</h2>
<h3 class="topic">
<a name="7vgh1448t7bei6utqkt6tnfmo4">&nbsp;通过threading模块支持多线程</a>
</h3>
<h3 class="topic">
<a name="2ivn6b6b2c0r198lrn2hl1lbho">&nbsp;启动多线程，即创建一个thread对象，创建过程中指定一个起始函数，之后调用start函数</a>
</h3>
<h3 class="topic">
<a name="5vqrpivcfs42f3tosn4v648inf">&nbsp;创建线程代码</a>
</h3>
<h3 class="topic">
<a name="0tspfhgg0c21ob0k2rhit46g9d">&nbsp;&nbsp;导入threading包</a>
</h3>
<h3 class="topic">
<a name="05a9rke1skkjjmpt1a47ha9d8c">&nbsp;&nbsp;&nbsp;import threading</a>
</h3>
<h3 class="topic">
<a name="3142uvmi0p7dm2hl9l8c0pidg4">&nbsp;&nbsp;创建回调函数，创建Thread类对象，设置回调函数名，设置线程名称（python中每一个线程都有名字，可以通过线程类获得）</a>
</h3>
<h3 class="topic">
<a name="40fkson7bvkec35nduqu871694">&nbsp;&nbsp;&nbsp;t=threading.Thread(target=loop,name='LoopThread')#创建线程</a>
</h3>
<h3 class="topic">
<a name="63p8m151dbmu987cud2uoi682a">&nbsp;&nbsp;启动线程</a>
</h3>
<h3 class="topic">
<a name="2tkafds3sckff7p0vct4mdmr8p">&nbsp;&nbsp;&nbsp;t.strat()</a>
</h3>
<h3 class="topic">
<a name="4d9rlup0qtc60jager26enkr5q">&nbsp;&nbsp;在主线程中等待子线程结束</a>
</h3>
<h3 class="topic">
<a name="6ei195lld6eqlch3s450e6lrfl">&nbsp;&nbsp;&nbsp;t.join()</a>
</h3>
<h3 class="topic">
<a name="3a62ei7l1n1r4qp8q09bc7536l">&nbsp;&nbsp;import threading&#13;
import time&#13;
&#13;
g_number=0&#13;
&#13;
def loop:#创建线程回调函数&#13;
	n = 0&#13;
	while n&lt;10000:&#13;
		global g_number  #回调函数中使用全局变量需要先声明&#13;
		g_number=g_number+1&#13;
		print("线程名为%s&gt;&gt;%s"%(threading.current_thread().name,n))#打印子线程的线程名&#13;
		time.sleep(1)&#13;
&#13;
t=threading.Thread(target=loop,name='LoopThread')#创建线程&#13;
t.start() #开启线程&#13;
&#13;
for i in range(0,10000):&#13;
	print("线程名为%s&gt;&gt;%s"%(threading.current_thread().name,n))	#打印主线程的线程名&#13;
	time.sleep(0.5)&#13;
&#13;
t.join()#直到子线程执行完毕，该函数返回</a>
</h3>
<h3 class="topic">
<a name="0pm1so4gkiehkaot4n5m65n8lq">&nbsp;向线程回调函数传递参数代码</a>
</h3>
<h3 class="topic">
<a name="5aaesq5roqrk94fqa6tsj6u53k">&nbsp;&nbsp;为回调函数设置变长参数</a>
</h3>
<h3 class="topic">
<a name="7ecmpd0h9do6fi7avm3m9qm493">&nbsp;&nbsp;&nbsp;def loop(*arg)&#13;
	print(arg)</a>
</h3>
<h3 class="topic">
<a name="00l2s8d0rqgojscq7j9p1qlg07">&nbsp;&nbsp;在创建线程的时候，以元组方式给回调函数传参</a>
</h3>
<h3 class="topic">
<a name="65nrnurv0coc8qq8207hh119l2">&nbsp;&nbsp;&nbsp;t=threading.Thread(name="15pb",target=loop,args=(1,2,3,4))#以元组的方式进行向回调函数进行传参</a>
</h3>
<h3 class="topic">
<a name="21v2ph7u7a8o1prg6cvsv1j87r">&nbsp;线程同步代码</a>
</h3>
<h3 class="topic">
<a name="4dg47bcls34fh63h27bhgvevja">&nbsp;&nbsp;在多线程访问全局变量g_number，需要在线程回调函数中声明该变量为全局变量，这和win32中是一样的</a>
</h3>
<h3 class="topic">
<a name="0u77h670jspptqkj08kf37ih63">&nbsp;&nbsp;&nbsp;global g_number</a>
</h3>
<h3 class="topic">
<a name="51lt8b0gll0meqmglhvl8ongk9">&nbsp;&nbsp;定义锁类的对象</a>
</h3>
<h3 class="topic">
<a name="4uhdkguq7jrvijecbvsajm76br">&nbsp;&nbsp;&nbsp;lock=threading.Lock()</a>
</h3>
<h3 class="topic">
<a name="622epoe21ugfheh0o6qpakcbek">&nbsp;&nbsp;在需要保护的代码之前获取锁，当多线程执行到这里的时候，只有一个线程能执行，执行保护代码结束后，释放锁</a>
</h3>
<h3 class="topic">
<a name="0bq521m7gc309q1231f1gk0icf">&nbsp;&nbsp;&nbsp;lock=threading.Lock()  #定义一个锁&#13;
def loop:#创建线程回调函数&#13;
	n = 0&#13;
	while n&lt;10000:&#13;
		global g_number  #回调函数中使用全局变量需要先声明&#13;
		lock.acquire()#获取锁&#13;
		g_number=g_number+1 #被保护的代码，该行代码执行完之前，只有一个线程能执行该函数&#13;
		lock.release()#释放锁&#13;
		print("线程名为%s&gt;&gt;%s"%(threading.current_thread().name,n))#打印子线程的线程名&#13;
		time.sleep(1)</a>
</h3>
<h3 class="topic">
<a name="55ib0f88seaog3fpep79afnhsp">&nbsp;&nbsp;会不会造成死锁呢？</a>
</h3>
<h2 class="topic">
<a name="7vhfv7ujllr83s5om5emgan61l">python网络编程</a>
</h2>
<h3 class="topic">
<a name="6bpnos0aqm85cpa46jbck7cpcs">&nbsp;python中网络编程也是基于socket的</a>
</h3>
<h3 class="topic">
<a name="6o2rgjf39jcgh2g8delk4rk9r0">&nbsp;python中自带网络编程模块，通过该模块中的类定义对象以及使用类方法，可以进行网络编程</a>
</h3>
<h3 class="topic">
<a name="7ctl3gf1cads28j2aim3eba9i6">&nbsp;服务端代码</a>
</h3>
<h3 class="topic">
<a name="7hdpimtrjmj61feq8vth1ebo9o">&nbsp;&nbsp;导入模块</a>
</h3>
<h3 class="topic">
<a name="0spsgl9gkeodhqea54v5gftqni">&nbsp;&nbsp;&nbsp;import socket</a>
</h3>
<h3 class="topic">
<a name="2hfu2htaau9bisat2lnq5d4ndo">&nbsp;&nbsp;创建套接字</a>
</h3>
<h3 class="topic">
<a name="3lp4ralunsdffkeflvjhol1b0e">&nbsp;&nbsp;&nbsp;sSock=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</a>
</h3>
<h3 class="topic">
<a name="47mgc7kogga1lag2vm8n98u7iq">&nbsp;&nbsp;&nbsp;&nbsp;指定协议族为因特网协议族</a>
</h3>
<h3 class="topic">
<a name="7tbqgp3152u8on466pfvtaopq6">&nbsp;&nbsp;&nbsp;&nbsp;指定套接字类型为流式套接字（即面向连接的套接字）</a>
</h3>
<h3 class="topic">
<a name="148atqjlsbod7pi9umbde6as1u">&nbsp;&nbsp;&nbsp;&nbsp;最后一个参数为0，默认为tcp类型给连接</a>
</h3>
<h3 class="topic">
<a name="4t0qh92jdgaro0eah7pqus2t6m">&nbsp;&nbsp;&nbsp;该函数不加参任何数默认生成的也是tcp链接</a>
</h3>
<h3 class="topic">
<a name="7stl5ilp2fjj6s9klc4r1tpt5t">&nbsp;&nbsp;绑定ip和端口</a>
</h3>
<h3 class="topic">
<a name="0shkn9hr4g5fi0893c00pk8igc">&nbsp;&nbsp;&nbsp;bind</a>
</h3>
<h3 class="topic">
<a name="21ojdvd9udg7mlb1tepl67sbcr">&nbsp;&nbsp;&nbsp;&nbsp;参数是一个元组，元组中包括地址和端口</a>
</h3>
<h3 class="topic">
<a name="32dh2s463345r0qrasa61qnf93">&nbsp;&nbsp;&nbsp;&nbsp;address=("127.0.0.1",12345)&#13;
sSocket.bind(address)</a>
</h3>
<h3 class="topic">
<a name="1diksj0nrasmlf5k89hqpo65f5">&nbsp;&nbsp;&nbsp;&nbsp;或sSocket.bind(("127.0.0.1",12345))</a>
</h3>
<h3 class="topic">
<a name="2vovs2mk46dtbi42n4jvlsdrmq">&nbsp;&nbsp;监听</a>
</h3>
<h3 class="topic">
<a name="3hq3p7pq2umhvgkjhjaipkqlca">&nbsp;&nbsp;&nbsp;sSocket.listen()</a>
</h3>
<h3 class="topic">
<a name="4u9sdq2aet80vclmh64fvjod45">&nbsp;&nbsp;&nbsp;参数为一次性可以连接多少个客户端</a>
</h3>
<h3 class="topic">
<a name="6cqiag8cqbu3qb6jme7sr417vq">&nbsp;&nbsp;等待链接</a>
</h3>
<h3 class="topic">
<a name="477e9sugep9nb14201kopsp349">&nbsp;&nbsp;&nbsp;cSocket,addrs=sSocket.accept()</a>
</h3>
<h3 class="topic">
<a name="02ae41u5c90p1b3a8kehab3pho">&nbsp;&nbsp;&nbsp;该函数返回一个元组，元组中包括客户端socket和ip，将两者分别赋值为cSocket和addrs</a>
</h3>
<h3 class="topic">
<a name="6esremi2mbemt3tqmqrrcgjdar">&nbsp;&nbsp;&nbsp;之后需要向客户端发送消息或接收来自客户端的消息，需要使用客户端cSocket调用相应函数</a>
</h3>
<h3 class="topic">
<a name="6pc3k3mg2rm0vdr7pu5482a6o8">&nbsp;&nbsp;收发数据</a>
</h3>
<h3 class="topic">
<a name="7ckln2oumr2ndhqpso32t4e896">&nbsp;&nbsp;&nbsp;inStr=input("&gt;&gt;&gt;")&#13;
cSocket.send(str(inStr).encode('utf-8'))</a>
</h3>
<h3 class="topic">
<a name="43o5b6b8g91bap5h06766gnm57">&nbsp;&nbsp;&nbsp;&nbsp;保存用户输入，并将输入发送到客户端</a>
</h3>
<h3 class="topic">
<a name="5djngr1dc6lhgv9nsbnhhprcil">&nbsp;&nbsp;&nbsp;&nbsp;为什么这里要用str()</a>
</h3>
<h3 class="topic">
<a name="59jqmeqll1clbasqrvlecegu28">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里使用str()是为了将数据转成字符串类型，从而方便调用encode函数</a>
</h3>
<h3 class="topic">
<a name="76rkhgvbhgch59pinc5h5dv793">&nbsp;&nbsp;&nbsp;&nbsp;为什么这里要用encode('ctf-8')</a>
</h3>
<h3 class="topic">
<a name="2bpcbuk05ifij8qoiqid9pv1b9">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以utf-8的方式进行编码</a>
</h3>
<h3 class="topic">
<a name="7j8jgsg3khuncsreekbj1o3ktc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为客户端中的默认编码方式为utf-8，所以发送的时候使用utf-8进行编码，方便客户端直接显示</a>
</h3>
<h3 class="topic">
<a name="6sagfqe2g51ugks690qosj40jf">&nbsp;&nbsp;&nbsp;print(cSocket.recv(1024).decode('utf-8'))</a>
</h3>
<h3 class="topic">
<a name="2d0jff0iir4saimiqh0rur0t1v">&nbsp;&nbsp;&nbsp;&nbsp;接收1024个字节的数据，以utf-8的方式解码显示</a>
</h3>
<h3 class="topic">
<a name="4u766n10uu8ti8lfvf04frjad9">&nbsp;&nbsp;&nbsp;在程序中，用户输入的是字符串，如果需要网络传输需要编码成为utf-8的格式</a>
</h3>
<h3 class="topic">
<a name="3sd7dda4tbgve97l3rmagum5og">&nbsp;&nbsp;&nbsp;当程序接收到网络传输的utf-8，需要将器解码为字符串，进行显示</a>
</h3>
<h3 class="topic">
<a name="7u3lt1i3rm4dcru1ddk0vj5be2">&nbsp;&nbsp;&nbsp;python3中不是默认编码方式就是utf-8吗？</a>
</h3>
<h3 class="topic">
<a name="5sp96nrjuasebgucodplq8qms7">&nbsp;&nbsp;&nbsp;python与windows的网络信息交互应该如何进行</a>
</h3>
<h3 class="topic">
<a name="6oc544ckhq6ijima6u1i8p7rbl">&nbsp;&nbsp;关闭套接字</a>
</h3>
<h3 class="topic">
<a name="3nq51se6lmc4ke9nemanla9q5n">&nbsp;&nbsp;&nbsp;sSocket.close()</a>
</h3>
<h3 class="topic">
<a name="4hgr8g7tgl4p3dhg6me2ecnm5e">&nbsp;&nbsp;&nbsp;cSocket.close()</a>
</h3>
<h3 class="topic">
<a name="30djo6ol6i19dogtitleh4ki0c">&nbsp;&nbsp;可以与c++客户端通讯的代码</a>
</h3>
<h3 class="topic">
<a name="6shqr5urgo8oj0theeh66bnt7u">&nbsp;&nbsp;&nbsp;import socket&#13;
&#13;
sSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)&#13;
address = ("0.0.0.0", 10086)&#13;
sSocket.bind(address)&#13;
sSocket.listen()&#13;
cSocket, addr = sSocket.accept()&#13;
&#13;
#print("客户端上线%d"%(addr))&#13;
#因为python中的字符串不是以\0为结尾，所以需要直接发送给c++端的字符串需要加上\0,从而方便c++显示&#13;
cSocket.send(str('欢迎\0').encode('GBK'))&#13;
&#13;
while True:&#13;
    # 这里因为c++端通过char类型的缓冲取存储数据，发送到pythong端就需要使用GBK的方式解码才能显示&#13;
    print(cSocket.recv(1024).decode('GBK'))&#13;
    inStr = input("&gt;&gt;&gt;")&#13;
    cSocket.send(str(inStr).encode('GBK'))&#13;
&#13;
#cSocket.close()当使用while循环进行数据收发的时候，死循环下面的语句均不会执行到，所以无法使用cSocket调用close方法</a>
</h3>
<h3 class="topic">
<a name="6o4hsj8o7hqcfsmlfegcgqil2d">&nbsp;客户端代码</a>
</h3>
<h3 class="topic">
<a name="3rripp0c1tt4ae9g8hes8p6pb1">&nbsp;&nbsp;导包</a>
</h3>
<h3 class="topic">
<a name="5ku6lmjc1j3c9vi8ghrg4fa701">&nbsp;&nbsp;&nbsp;import socket</a>
</h3>
<h3 class="topic">
<a name="08tponbnsjlm1n93o6julhlekn">&nbsp;&nbsp;创建套接字</a>
</h3>
<h3 class="topic">
<a name="0b8va2k676igit2nqgm3qccfb8">&nbsp;&nbsp;&nbsp;csocket=socket.socket()</a>
</h3>
<h3 class="topic">
<a name="0hla8kmmj6nar39s5e2v15nqkp">&nbsp;&nbsp;发起连接</a>
</h3>
<h3 class="topic">
<a name="3pm6nkcrns6diakqi33khdnhl2">&nbsp;&nbsp;&nbsp;address=("127.0.0.1",12345)&#13;
csocket.connect(address)</a>
</h3>
<h3 class="topic">
<a name="36tmqblem32mtmvpenjjcghr82">&nbsp;&nbsp;&nbsp;&nbsp;这里如果不同主机进行通讯，需要将ip 端口设置为服务端ip和端口号</a>
</h3>
<h3 class="topic">
<a name="29nal8c8f33l8dh70iokdo5v3p">&nbsp;&nbsp;收发数据</a>
</h3>
<h3 class="topic">
<a name="3t8vhksf9ido86tnfapad08g1d">&nbsp;&nbsp;&nbsp;inStr=input("&gt;&gt;&gt;")&#13;
csocket.send(str(inStr),encode('utf-8'))</a>
</h3>
<h3 class="topic">
<a name="4jabull8c865s450ocq8cvqpjf">&nbsp;&nbsp;&nbsp;&nbsp;这里只能发送字节流，故发送ascii，所以为了发送中文，所以需要在发送端将字节流以utf-8编码(encode('utf-8'))，然后再服务端使用utf-8解码(decode('utf-8'))</a>
</h3>
<h3 class="topic">
<a name="29eui3b51tgh57kpbls443jh8e">&nbsp;&nbsp;&nbsp;print(csocket.recv(1024).decode('ctf-8'))</a>
</h3>
<h3 class="topic">
<a name="5h2u36fb9keqj3ufjfl6dnjefm">&nbsp;&nbsp;&nbsp;&nbsp;接收1024个字节的数据，以utf-8的方式解码显示</a>
</h3>
<h3 class="topic">
<a name="0ddcq3a93npp0g3ekvnlpciec1">&nbsp;&nbsp;关闭</a>
</h3>
<h3 class="topic">
<a name="30shrcsirs8bt80rdk402n4u6l">&nbsp;&nbsp;&nbsp;csocket.close()</a>
</h3>
<h3 class="topic">
<a name="2an0ljpjv46ocprvrk9us50b06">&nbsp;&nbsp;在客户端中，需要将数据的接收与发送分成两个线程进行，一边接收，一边发送</a>
</h3>
<h3 class="topic">
<a name="38kq6je9e9mootg0oe5ruvag6n">&nbsp;混合编程中的编码问题</a>
</h3>
<h3 class="topic">
<a name="4m1hrrmtcdaj10hdi4br8sgugc">&nbsp;&nbsp;使用模块可以查看字符串的编码方式</a>
</h3>
<h3 class="topic">
<a name="65a4tseqct667qjo8de0n5pgti">&nbsp;&nbsp;&nbsp;import chardet</a>
</h3>
<h3 class="topic">
<a name="5t6oh5gai4vs9ochtil56cpfmv">&nbsp;&nbsp;&nbsp;chardet.detect("hello",encode("utf-8"))</a>
</h3>
<h3 class="topic">
<a name="186hgaltojvqc9tnvb6a75ph1l">&nbsp;&nbsp;&nbsp;可以看到对应字符串的编码方式</a>
</h3>
<h3 class="topic">
<a name="2rg1f1tf75q9a94i6u71fmctki">&nbsp;&nbsp;python3.0</a>
</h3>
<h3 class="topic">
<a name="11vk09oiqi2vak575ucuh2i4qe">&nbsp;&nbsp;&nbsp;byte 表示二进制字节流</a>
</h3>
<h3 class="topic">
<a name="6q307lu9rifoat5uahd7hu41jv">&nbsp;&nbsp;&nbsp;str 表示字符串</a>
</h3>
<h3 class="topic">
<a name="5espm4venfnu055304aosvs9hm">&nbsp;&nbsp;&nbsp;python3中默认使用UTF-8编码，使用str和bytes区分文本字符和二进制数据</a>
</h3>
<h3 class="topic">
<a name="7ibn02un390okbhojuj9l4au1s">&nbsp;&nbsp;字节流是一个数据串，没有任何实际意义，只是计算机存储的一段数据</a>
</h3>
<h3 class="topic">
<a name="1o0lkji00h6nq9kjnqvb19dju2">&nbsp;&nbsp;字符串是根据不同的编码方式，将一段数据解释成可以理解的一段文字</a>
</h3>
<h3 class="topic">
<a name="0a5o566dfarvdqg50b8rgbh0vk">&nbsp;&nbsp;编码是什么？编码就是把一个字符用一个二进制来表示。</a>
</h3>
<h3 class="topic">
<a name="5ids0c12ntv9vcp2pqlduuup8h">&nbsp;&nbsp;&nbsp;即encode，将字符串转换为二进制流  在python3中将str转成bytes</a>
</h3>
<h3 class="topic">
<a name="1l6or5ji0c2fr9b0q6mfvjpu7r">&nbsp;&nbsp;&nbsp;&nbsp;python3中str类有encode()方法没有decode方法，用于从字符串向比特流的编码</a>
</h3>
<h3 class="topic">
<a name="0pmf9k9m65luhqn40j34g8n95l">&nbsp;&nbsp;&nbsp;该过程常发生在发送数据的过程中，将特定编码方式的字符串根据接收端能够接收的编码格式编码成为二进制流</a>
</h3>
<h3 class="topic">
<a name="2153qm1gf5t5vsu9vgt1vv4c0j">&nbsp;&nbsp;解码就是存在一个二进制，根据解码规则，找到对应的字符</a>
</h3>
<h3 class="topic">
<a name="2362vlcivaclknji83gdocle46">&nbsp;&nbsp;&nbsp;即decode，将二进制流转换为字符串，在python3中将byte转为str</a>
</h3>
<h3 class="topic">
<a name="5c84pjer35s7s95cb77400p101">&nbsp;&nbsp;&nbsp;&nbsp;python3中bytes类有decode()方法，没有encode方法，用于从比特流向字符串的解码</a>
</h3>
<h3 class="topic">
<a name="4qkt3aes0bi8ldqeiivv5mb74g">&nbsp;&nbsp;&nbsp;该过程查常发生在接收数据的过程中，接收到了一段二进制流，需要转换为可以显示的字符串，就需要使用与该二进制流的编码方式对应的解码规则进行解码</a>
</h3>
<h3 class="topic">
<a name="7itta4et8cmoosvh8alihmqn7m">&nbsp;&nbsp;一段程序中的任何内容都使用一种特定的编码方式，</a>
</h3>
<h3 class="topic">
<a name="179fnm10v8m51h31ad4dvcttqs">&nbsp;&nbsp;&nbsp;python3中默认使用utf-8的编码方式</a>
</h3>
<h3 class="topic">
<a name="78q8r0fjaejfid1mija003juci">&nbsp;&nbsp;&nbsp;c++中的char类型数据使用GBK编码方式</a>
</h3>
<h3 class="topic">
<a name="5li27aiqne9ml3a9hhcf5t8ufo">&nbsp;&nbsp;&nbsp;c++中wchar_t类型数据使用UTF-16编码方式</a>
</h3>
<h3 class="topic">
<a name="234ggb1go88ogoc52vtv7njumq">&nbsp;&nbsp;使用不同的编码系统的网络环境直接通讯，容易出现编码混乱问题</a>
</h3>
<h3 class="topic">
<a name="2783kojoe6uuqu8uchi1eta7se">&nbsp;&nbsp;当c++程序和python程序进行通讯时</a>
</h3>
<h3 class="topic">
<a name="14mchi1g99qq3jqjuresg7611g">&nbsp;&nbsp;&nbsp;c++接收数据，python发送数据</a>
</h3>
<h3 class="topic">
<a name="41t5ta72672fovrno5vgimrj7t">&nbsp;&nbsp;&nbsp;&nbsp;c++使用char类型缓冲区存储接收，并打印接收到的内容，说明c++是通过GBK的方式对接受到的比特流进行解码，则在python端发送数据的时候，需要将python中的字符串（原本是使用python默认的编码方式utf-8编码的）使用GBK的方式进行编码，即发送数据的时候会看到encode(GBK)</a>
</h3>
<h3 class="topic">
<a name="3mm6fmo3scq71stsfloucrt1t6">&nbsp;&nbsp;&nbsp;&nbsp;同理c++使用wchar_t类型缓冲区接收收到数据，python需要通过UTF-16的方式对要发送的数据进行编码</a>
</h3>
<h3 class="topic">
<a name="79a5ic3oeqc8ev5ndlt0d7hnan">&nbsp;&nbsp;&nbsp;c++发送数据，python接收数据</a>
</h3>
<h3 class="topic">
<a name="42luf0sbq3q9jn0ht1phegk81g">&nbsp;&nbsp;&nbsp;&nbsp;因为c++无法指定以何种方式对需要发送的数据进行编码，所以c++发送的数据只有两种编码方式</a>
</h3>
<h3 class="topic">
<a name="61cnhj76bjsm3p5ojk9nhjqjca">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用char作为存储输出字符串的缓冲区时，发送的数据是用GBK进行编码的</a>
</h3>
<h3 class="topic">
<a name="6gm5nbpphcofc4ej02mb6e2bqi">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此时python中如果需要显示接收到的数据，需要用GBK方式解码 即decode(GBK)</a>
</h3>
<h3 class="topic">
<a name="1b703nm8l81n2csmff7rirluri">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用wchar_t作为存储输出字符串的缓冲区时，发送的数据是用UTF-16进行编码的</a>
</h3>
<h3 class="topic">
<a name="0ufknirl3ne2msj9c7drkt7dlg">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此时python中如果需要显示接收到的数据，需要用UTF-16方式解码 即decode(UTF-16)</a>
</h3>
<h3 class="topic">
<a name="1c4o1dlr5lhthfkkksr3mt9lla">&nbsp;&nbsp;相关博文</a>
</h3>
<h3 class="topic">
<a href="https://www.cnblogs.com/xiaobingqianrui/p/9870480.html" name="6js1vclbhbgsumpga2pfr1d76r">&nbsp;&nbsp;&nbsp;https://www.cnblogs.com/xiaobingqianrui/p/9870480.html</a>
</h3>
<h2 class="topic">
<a name="4u1ceab84r4a21th2n4ua45c7p">密码学</a>
</h2>
<h3 class="topic">
<a name="6lhtii2a4heguevh4f1cne5var">&nbsp;简介</a>
</h3>
<h3 class="topic">
<a name="6os4j0cbs5buipjdojms7f9r1i">&nbsp;&nbsp;对称加密</a>
</h3>
<h3 class="topic">
<a name="2g3tu7vi7p9mudhq5f4gslbah1">&nbsp;&nbsp;&nbsp;加密密钥==解密密钥</a>
</h3>
<h3 class="topic">
<a name="7f8khgsbt2n3trs3tvojmg1cdc">&nbsp;&nbsp;非对称加密</a>
</h3>
<h3 class="topic">
<a name="6j9p0ct6vkda31656jgvm0kekc">&nbsp;&nbsp;&nbsp;加密密钥!=解密密钥</a>
</h3>
<h3 class="topic">
<a name="1eje52p18sot0pogus13g98mum">&nbsp;&nbsp;算法</a>
</h3>
<h3 class="topic">
<a name="197c2s5go13k2poj83oi67r0c7">&nbsp;&nbsp;&nbsp;加密算法</a>
</h3>
<h3 class="topic">
<a name="047ut7hlhcga6ptsh86p24upd4">&nbsp;&nbsp;&nbsp;解密算法</a>
</h3>
<h3 class="topic">
<a name="41epriqvosacbn4r2al2fi3sj4">&nbsp;&nbsp;其他密码技术</a>
</h3>
<h3 class="topic">
<a name="428a6tj5v0vc7n9kjlm1l6460l">&nbsp;&nbsp;&nbsp;单项散列函数</a>
</h3>
<h3 class="topic">
<a name="7hbhr6o80e5tv17vn99bfrio4g">&nbsp;&nbsp;&nbsp;&nbsp;常用于计算文件信息的散列值，文件被修改，散列值会发生变化</a>
</h3>
<h3 class="topic">
<a name="6vn9ctl5j0hu8p3cthvkb7sj2u">&nbsp;&nbsp;&nbsp;数字签名</a>
</h3>
<h3 class="topic">
<a name="7ftj2tv2ss87j0e4u2sut6j193">&nbsp;&nbsp;&nbsp;&nbsp;将特定的数字加入到文件中，数字通过加密算法</a>
</h3>
<h3 class="topic">
<a name="7lk4bpesk747hap5d0ao08lhfd">&nbsp;&nbsp;隐写术和数字水印</a>
</h3>
<h3 class="topic">
<a name="6p5vphteg8lqola6olefapeut1">&nbsp;&nbsp;&nbsp;隐写术：在数据中隐藏信息，如果能够搞清嵌入消息的方法，就可以弄清消息内容</a>
</h3>
<h3 class="topic">
<a name="618p9ka7m8dmnjvj5gf9b31ftv">&nbsp;&nbsp;&nbsp;&nbsp;类比藏头诗</a>
</h3>
<h3 class="topic">
<a name="3f68mtseutprd0pkpqh62q0quc">&nbsp;&nbsp;&nbsp;数字水印</a>
</h3>
<h3 class="topic">
<a name="769n6j2oj4j6s0mct04os3grtm">&nbsp;&nbsp;&nbsp;&nbsp;将相关信息嵌入到文件中</a>
</h3>
<h3 class="topic">
<a name="2khkabpboc6rgbofgk4ha5hi72">&nbsp;&nbsp;凯撒密码</a>
</h3>
<h3 class="topic">
<a name="1b8bl68mnjgp1p4sn324tr123c">&nbsp;&nbsp;&nbsp;平移算法</a>
</h3>
<h3 class="topic">
<a name="4gfn1uij3048mfldqi0u15tigk">&nbsp;&nbsp;&nbsp;密钥就是移动的位数</a>
</h3>
<h3 class="topic">
<a name="7pmh9o5t9nkg6pol014fjug2bk">&nbsp;&nbsp;简单替换密码</a>
</h3>
<h3 class="topic">
<a name="0ghm8ean1moj9e02f44i13u4te">&nbsp;&nbsp;&nbsp;将26个字母的每一个字母替换为另一个字母</a>
</h3>
<h3 class="topic">
<a name="6utpme4tq75inr6a2kjssjvnoh">&nbsp;&nbsp;&nbsp;暴力破解需要破解26的阶乘次，目前算力条件下无法破界</a>
</h3>
<h3 class="topic">
<a name="15pd6kvf4gtf9ol78lads6f8i2">&nbsp;&nbsp;&nbsp;使用频率分析可以进行破解</a>
</h3>
<h3 class="topic">
<a name="0c61uldtvv2u6qce73eohbe92e">&nbsp;&nbsp;&nbsp;&nbsp;分析密文中每个字母的使用频率</a>
</h3>
<h3 class="topic">
<a name="01ik336njjv52pldi0hr1e9199">&nbsp;&nbsp;&nbsp;通过逆向得到密钥表</a>
</h3>
<h3 class="topic">
<a name="6qg2oo5ome6o1gkja6e42mc450">&nbsp;&nbsp;&nbsp;跳舞的小人密码</a>
</h3>
<h3 class="topic">
<a name="1ttpugbhsi5ror9fohl1mfls5i">&nbsp;&nbsp;维吉尼亚密码</a>
</h3>
<h3 class="topic">
<a name="2229c3mtm755ir8ge5tguqrjsj">&nbsp;&nbsp;&nbsp;用来掩盖字母的使用频率</a>
</h3>
<h3 class="topic">
<a name="2md7nv74aim7lg79tsmqt858mi">&nbsp;&nbsp;&nbsp;需要对应的密码本</a>
</h3>
<h3 class="topic">
<a name="325rrtoi097f941ah52mak9oc7">&nbsp;&nbsp;德国二战恩尼格玛密码机</a>
</h3>
<h3 class="topic">
<a name="1bk3a1dqgjsmrr4ilgpqh23hba">&nbsp;Base64编码</a>
</h3>
<h3 class="topic">
<a name="7l7slsp5lra0rju1rqfsee58ig">&nbsp;&nbsp;使用64个字母表示64种状态</a>
</h3>
<h3 class="topic">
<a name="3vi0johooqef5frqmhsmfg4iao">&nbsp;&nbsp;64个字母分别是大写字母、小写字母、0~9</a>
</h3>
<h3 class="topic">
<a name="6pjcel4nl33kg3oomlrikscr31">&nbsp;&nbsp;使用6个二进制位表示一个状态，每一个状态表示一个一字母</a>
</h3>
<h3 class="topic">
<a name="1invbscghp26n8e13en6ja7bcl">&nbsp;&nbsp;对于不满64</a>
</h3>
<h3 class="topic">
<a name="2l429fnudvdpf31duuas8nrugr">&nbsp;&nbsp;python中有一个base64库</a>
</h3>
<h3 class="topic">
<a name="0aen5ipbmntscksndf1gkitfp8">&nbsp;&nbsp;&nbsp;import base64&#13;
buff=base64.b64encode(b"buff")&#13;
print()</a>
</h3>
<h3 class="topic">
<a name="5sbh89a830eligi12l6vinlt2d">&nbsp;散列算法</a>
</h3>
<h3 class="topic">
<a name="2r61o91eekfb1h83rqjsi9p2cc">&nbsp;&nbsp;就是常说的hash算法</a>
</h3>
<h3 class="topic">
<a name="43dja2vnulb8dnmafue4kdmnfc">&nbsp;&nbsp;将任意长度的二进制值映射为较短的固定长度的二进制值</a>
</h3>
<h3 class="topic">
<a name="2ae56adrv02bbian2o5krq18j1">&nbsp;&nbsp;hash算法是不可逆的</a>
</h3>
<h3 class="topic">
<a name="6u35h1j2bj8al9tvntgl2v0suo">&nbsp;&nbsp;常见的hash算法</a>
</h3>
<h3 class="topic">
<a name="65qsf5c50derknpvtef3ahgs21">&nbsp;&nbsp;&nbsp;MD5(消息摘要算法第五版)</a>
</h3>
<h3 class="topic">
<a name="4unslski3fu76ik3adl4pdlirv">&nbsp;&nbsp;&nbsp;&nbsp;长32位，由字母和数字组成</a>
</h3>
<h3 class="topic">
<a name="0t9vi1kns52olhl78kjrdo7tej">&nbsp;&nbsp;&nbsp;&nbsp;常用于确保消息的完整性</a>
</h3>
<h3 class="topic">
<a name="3fkcqcc6imln04smfji0bbt7nu">&nbsp;&nbsp;&nbsp;&nbsp;特点</a>
</h3>
<h3 class="topic">
<a name="7a4jvuj9p00ui2993jqd28isli">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;压缩性</a>
</h3>
<h3 class="topic">
<a name="5pr3e6dj863min9dkrh9i9ivar">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;容易计算</a>
</h3>
<h3 class="topic">
<a name="5elpn6nu2qj2p6v981fn37kchr">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;抗修改性</a>
</h3>
<h3 class="topic">
<a name="6vqo49kj2hoftfctorii8m3i89">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;抗弱碰撞</a>
</h3>
<h3 class="topic">
<a name="3lo76t2gpgs575fmcu72nqi9e7">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;已知源数据和md5，找到生成相同md5的数据</a>
</h3>
<h3 class="topic">
<a name="46bfh5vcat81iheba8g3tof8j3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;抗强碰撞</a>
</h3>
<h3 class="topic">
<a name="7i2312gi3t8t29gioeptmlsv9n">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l</a>
</h3>
<h3 class="topic">
<a name="1c6n7pcr2tcfbk91u5ogtmr8o6">&nbsp;&nbsp;&nbsp;&nbsp;破解</a>
</h3>
<h3 class="topic">
<a name="0lt8fhc0ug2agdeqf965094275">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;算法不可逆，只能暴力破解</a>
</h3>
<h3 class="topic">
<a name="2gk4lc3cpt2fvm7erqo3j2cm20">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;碰撞破解</a>
</h3>
<h3 class="topic">
<a name="6il227ov7pvgnhda0v7knqu6d4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;密码库破解</a>
</h3>
<h3 class="topic">
<a name="3kedkqivdml2vceabc5906itbn">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用泄露的密码库制成彩虹表</a>
</h3>
<h3 class="topic">
<a name="1pfubjjfehneqg1h13d81mgn1b">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在彩虹表中查询</a>
</h3>
<h3 class="topic">
<a name="00rva4jnm467d10v3i7g8u7hvb">&nbsp;&nbsp;&nbsp;&nbsp;使用python计算md5</a>
</h3>
<h3 class="topic">
<a name="32rc6s5k6dugi3akm71996hepo">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;import hashlib&#13;
md5=hashlib.md5()&#13;
md5.update(b"hello")&#13;
print(md5.hex。。。。。。。)</a>
</h3>
<h3 class="topic">
<a name="1ddm4hslmqcdm39e6rj1n1g3f4">&nbsp;&nbsp;&nbsp;SHA-1</a>
</h3>
<h3 class="topic">
<a name="600do2rsrh5leciuchnhb9igu3">&nbsp;&nbsp;&nbsp;SHA-256</a>
</h3>
<h3 class="topic">
<a name="1nkq91j2tv4rv1nb3e7pbckmv8">&nbsp;对称加密</a>
</h3>
<h3 class="topic">
<a name="7i0p51l1hs65s22tarlr2u6fu3">&nbsp;&nbsp;DES加密与解密</a>
</h3>
<h3 class="topic">
<a name="0gf49qnbalgknibkclf5bv9lhq">&nbsp;&nbsp;一次性只能加密64bit内容，加密的密文也是64位</a>
</h3>
<h3 class="topic">
<a name="5a0vknpb508vk41575s1vdlvi9">&nbsp;&nbsp;使用一种密钥足够长且算法上没有弱点对称密码可以保证文件的机密性</a>
</h3>
<h3 class="topic">
<a name="4s9haiulo5o91elo2rfoonlnbp">&nbsp;&nbsp;&nbsp;密钥足够长用于保证不被暴力破解</a>
</h3>
<h3 class="topic">
<a name="41nakone1r7bbcqlv8m3133uvr">&nbsp;&nbsp;&nbsp;算法上没有弱点保证不被其他方式破解</a>
</h3>
<h3 class="topic">
<a name="2vdt6dutdm0jean1jel37hqans">&nbsp;分组密码的模式</a>
</h3>
<h3 class="topic">
<a name="72g8si127k5169aakkm8jpnu6t">&nbsp;&nbsp;ECB</a>
</h3>
<h3 class="topic">
<a name="371tdo3qcpu61k72rmc7l0ou6d">&nbsp;&nbsp;&nbsp;电子密码本</a>
</h3>
<h3 class="topic">
<a name="344dvvb541f2of0ktu0987a22d">&nbsp;&nbsp;&nbsp;直接加密，分别得到多个密文分组，明文分组与密文分组是一对一的</a>
</h3>
<h3 class="topic">
<a name="6r5haibqb361m0q1vm8oh7cf4t">&nbsp;&nbsp;&nbsp;子主题 3</a>
</h3>
<h3 class="topic">
<a name="7i6dmqtsvks0hj8oc0svdlj162">&nbsp;&nbsp;CBC</a>
</h3>
<h3 class="topic">
<a name="7jvbnamvn0g6j6d5e285oc6gn9">&nbsp;&nbsp;&nbsp;密码分组连接模式</a>
</h3>
<h3 class="topic">
<a name="6pp1j3ql76g9j1977dkf9gh4ke">&nbsp;&nbsp;&nbsp;将前一组的内容作为下一组异或处理的条件</a>
</h3>
<h3 class="topic">
<a name="349mbgi0peod84qca92c75vf6j">&nbsp;&nbsp;CFB</a>
</h3>
<h3 class="topic">
<a name="39ehpdnrggm2cqadg2mlvph10k">&nbsp;&nbsp;&nbsp;密文反馈模式</a>
</h3>
<h3 class="topic">
<a name="6m81ft1g34qa6odijfibk17r0j">&nbsp;&nbsp;&nbsp;yu</a>
</h3>
<h3 class="topic">
<a name="3e3rkovk890p53hvsgrhajlr57">&nbsp;&nbsp;OFB</a>
</h3>
<h3 class="topic">
<a name="3p821ohhv1p61dm8t80i0nqdn0">&nbsp;&nbsp;&nbsp;输出反馈模式</a>
</h3>
<h3 class="topic">
<a name="05sqptorslu2o2r67ddiklno76">&nbsp;&nbsp;&nbsp;子主题 2</a>
</h3>
<h3 class="topic">
<a name="0sn5lsgd539t696m781lags80e">&nbsp;&nbsp;CTR</a>
</h3>
<h3 class="topic">
<a name="19nu41sd4qsr2b25pepl8g0ncj">&nbsp;&nbsp;&nbsp;计数器模式</a>
</h3>
<h3 class="topic">
<a name="14bcsbvpg48fluvrj531mtqrmc">&nbsp;&nbsp;特点</a>
</h3>
<h3 class="topic">
<a name="3n08k4nb1v8mksr70r62a0fil6">&nbsp;&nbsp;&nbsp;每次只能处理特定长度的一块数据的一类密码</a>
</h3>
<h3 class="topic">
<a name="743omhpjspf9183sakl2t4pmsf">&nbsp;公钥密码与rsa</a>
</h3>
<h3 class="topic">
<a name="5k4q4d7t9npk9g39ikjc04p82t">&nbsp;&nbsp;解密的密钥与加密的密钥不是同一个</a>
</h3>
<h3 class="topic">
<a name="1jaalr4n1f9e6cuknmh3copml5">&nbsp;&nbsp;加密与解密的规则是不同的，只要两种规则间存在对应关系即可，避免直接传递密钥</a>
</h3>
<h3 class="topic">
<a name="0tl5jtlkl1gf5a5qhif99nd2j3">&nbsp;&nbsp;&nbsp;甲方生成了公钥和私钥，私钥自己保留，公钥发公布出去</a>
</h3>
<h3 class="topic">
<a name="0p3gbign4m6cuhcaallf9cl6i6">&nbsp;&nbsp;&nbsp;乙方使用公钥加密，密文只有私钥持有者才可以解密</a>
</h3>
<h3 class="topic">
<a name="42padkv4h467387pdbicpckd1c">&nbsp;&nbsp;第一个公钥密码：rsa算法</a>
</h3>
<h3 class="topic">
<a name="4dmckri1g3tptu5su968qrgfs2">&nbsp;&nbsp;&nbsp;密钥越长，越难破解</a>
</h3>
<h3 class="topic">
<a name="32bp16p6oaqhtfgmgsibf7cmbl">&nbsp;&nbsp;特点</a>
</h3>
<h3 class="topic">
<a name="469jcbv23qjftrjom0off7u3cs">&nbsp;&nbsp;&nbsp;由解密者生成密钥对，将私钥自己保存，公钥发送给明文持有方，后者使用公钥生成密文，传递给解密者</a>
</h3>
<h3 class="topic">
<a name="6d9sae5fl4d0tmgeau3hihnmq3">&nbsp;&nbsp;成立条件</a>
</h3>
<h3 class="topic">
<a name="079envk9a99f6ptnt4jiqt4vqu">&nbsp;&nbsp;&nbsp;明文=密文与私钥计算</a>
</h3>
<h3 class="topic">
<a name="4reqhmfubl53o7jjphgn75pf8k">&nbsp;&nbsp;&nbsp;密文=明文与公钥计算</a>
</h3>
<h3 class="topic">
<a name="3m1atumvaprralfi7ka81upgim">&nbsp;&nbsp;rsa算法原理</a>
</h3>
<h3 class="topic">
<a name="43ser54me5805uivf15qqg4hr5">&nbsp;&nbsp;&nbsp;取模</a>
</h3>
<h3 class="topic">
<a name="14gpkimm4tlp1fk7da584dvvfj">&nbsp;&nbsp;&nbsp;&nbsp;正向计算简单</a>
</h3>
<h3 class="topic">
<a name="2qi6aehe59vee98slea6c9m86j">&nbsp;&nbsp;&nbsp;&nbsp;逆向计算难</a>
</h3>
<h3 class="topic">
<a name="7gm7ospqb00cfsji8db54aft75">&nbsp;&nbsp;&nbsp;明文的e次方对n取模得到密文</a>
</h3>
<h3 class="topic">
<a name="6id52tm0gtqk3hi55ml93s5l66">&nbsp;&nbsp;&nbsp;&nbsp;公钥是e和n</a>
</h3>
<h3 class="topic">
<a name="2lhnp28ogs4iirlja0vpie0bov">&nbsp;&nbsp;&nbsp;密文的d次方对n取模得到明文</a>
</h3>
<h3 class="topic">
<a name="5dgo16q04r9hvbir6rki558jdt">&nbsp;&nbsp;&nbsp;&nbsp;私钥是d和n</a>
</h3>
<h3 class="topic">
<a name="0eb6p55gcgpl5j9pm37v2rp2t3">&nbsp;&nbsp;密钥生成步骤</a>
</h3>
<h3 class="topic">
<a name="3gd55hstubtpm9nkb1nba91dod">&nbsp;&nbsp;&nbsp;求n</a>
</h3>
<h3 class="topic">
<a name="6m9u6b9ibrea0h4eik6lnqn8c3">&nbsp;&nbsp;&nbsp;&nbsp;n=p*q</a>
</h3>
<h3 class="topic">
<a name="5ofjj9cvjltl58rd4qosciqk4p">&nbsp;&nbsp;&nbsp;&nbsp;pq是两个很大的质数，如果太小会容易被破解</a>
</h3>
<h3 class="topic">
<a name="5o5ejpt8n3tgqaoaj4ebvuo09v">&nbsp;&nbsp;&nbsp;求l</a>
</h3>
<h3 class="topic">
<a name="41i9enho9i77l2ed7qpqpdj6ip">&nbsp;&nbsp;&nbsp;&nbsp;l是p-1，q-1的最小公倍数</a>
</h3>
<h3 class="topic">
<a name="49ojhgbmdp0gv49js5gddkg8n1">&nbsp;&nbsp;&nbsp;求e</a>
</h3>
<h3 class="topic">
<a name="21ousvbim9cp43evdui0im3d77">&nbsp;&nbsp;&nbsp;&nbsp;书上有</a>
</h3>
<h3 class="topic">
<a name="0g6fo6v0dlt1rs4lg5sto6gdge">&nbsp;&nbsp;&nbsp;求d</a>
</h3>
<h3 class="topic">
<a name="3bo3hppocc6ogqjiggep6ir3b7">&nbsp;&nbsp;&nbsp;&nbsp;书上有</a>
</h3>
<h3 class="topic">
<a name="28lanr8621j33muinlnrgkogqc">&nbsp;&nbsp;&nbsp;最终要保证e*d mod l=1，则可以保证使用e加密的密文可以使用d进行解密</a>
</h3>
<h3 class="topic">
<a name="0jvdv2q92r36qapm5l2jnu30cr">&nbsp;&nbsp;破解方法</a>
</h3>
<h3 class="topic">
<a name="476e94c53dm5m3l9atkbrp7h9j">&nbsp;&nbsp;&nbsp;通过明文获取</a>
</h3>
<h3 class="topic">
<a name="19gqa39cbvjao44bvm4st3bia6">&nbsp;&nbsp;&nbsp;暴力破解</a>
</h3>
<h3 class="topic">
<a name="3a28vvv2jjdh3nc3fkaggqfoeh">&nbsp;&nbsp;&nbsp;质因数分解</a>
</h3>
<h3 class="topic">
<a name="4b3sl3clbm4ba9ljemlghqa0ur">&nbsp;&nbsp;&nbsp;中间人攻击</a>
</h3>
<h3 class="topic">
<a name="6i7dg9v7cqhlast2no9qg4sr8t">&nbsp;&nbsp;&nbsp;&nbsp;在公钥传递过程中对公钥进行拦截修改</a>
</h3>
<h3 class="topic">
<a name="1bb9sq5dfdapjdi187n4jfsftk">&nbsp;&nbsp;&nbsp;&nbsp;使用自己的公钥替代数据接收者的公钥，中间人攻击者自己生成公钥和私钥，将自己的公钥发送给数据发送者</a>
</h3>
<h3 class="topic">
<a name="2o1r8q33a29g6m0qq0f07jm9ij">&nbsp;&nbsp;缺点</a>
</h3>
<h3 class="topic">
<a name="3o8d61ril0vltsdbedckgdo9cr">&nbsp;&nbsp;&nbsp;产生密钥很麻烦，难以做到一次一密</a>
</h3>
<h3 class="topic">
<a name="0u8nnnsccm5cjhu0qnai7cgbom">&nbsp;&nbsp;&nbsp;rsa一般只对少量的数据进行加密，对于大量数据的加密，还是依靠对称加密</a>
</h3>
<h3 class="topic">
<a name="36ov2oe4ada2havdl7lpg5q680">&nbsp;&nbsp;其他公钥密码</a>
</h3>
<h3 class="topic">
<a name="0e98jp6pduq0o46ak9jdkoa1db">&nbsp;&nbsp;&nbsp;椭圆曲线密码</a>
</h3>
<h3 class="topic">
<a name="6uj6j4ji4hg9bl5eedjbcpm4fm">&nbsp;书的内容除了rsa算法是非对称加密，其余的都是对称加密</a>
</h3>
<h3 class="topic">
<a name="5lgi6j4kki0vlcu8924fakgfsv">&nbsp;</a>
</h3>
<p class="topicImage">
<img src="class40day0328%EF%BC%88python%E7%AC%AC%E4%B8%89%E5%A4%A9%EF%BC%89_files/71j5nphrulloaljpcbjv0olvv0.png"></p>
<h3 class="topic">
<a name="28o2jvpks8jl5ac1k9tfqlcto6">&nbsp;&nbsp;</a>
</h3>
<p class="topicImage">
<img src="class40day0328%EF%BC%88python%E7%AC%AC%E4%B8%89%E5%A4%A9%EF%BC%89_files/73s2mmnk858aslttltksl86rtb.png"></p>
</body>
</html>
