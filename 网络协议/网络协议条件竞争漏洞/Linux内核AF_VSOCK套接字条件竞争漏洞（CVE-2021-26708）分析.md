- 核心原理
  - 枷锁前，vsk->transport已经赋值到transport变量中，这里产生了一个引用，然后才进行lock_sock(sk)将sk锁定。但是vsk->transport会在多处被调用甚至被释放，这就有可能通过条件竞争造成Use After Free。
  - 即存在变量被多个位置调用甚至释放，但该变量的赋值在在加锁前完成，故多个进程可以在加锁前修改该变量的值，从而让其他进程引用修改后的错误值，造成uaf
- 触发过程
  - 首先找到修改或释放关键变量的位置，找到有一处，可以释放该变量，从而确定释放该关键变量的调用路径
  - 其次找到使用该关键变量的路径，是对关键变量进行解引用
  - 由于该关键变量未被锁定，所以先调用关键变量释放路径，将关键变量释放，之后调用关键变量引用逻辑，从而造成uaf