<!doctype html><html>
    <head>
      <meta http-equiv="content-type" content="text/html; charset=utf-8">
      <title>sqliteNoteBook.ctb</title>
      <meta name="generator" content="CherryTree">
      <link rel="stylesheet" href="res/styles3.css" type="text/css" />
    </head>
    <body><div class='page'><h1 class='title level-1'>ADA_logics_fuzz_course</h1><br/></div><div class='page'><h1 class='title level-2'>1_Introduction to fuzzing</h1><br/>官方提供的笔记中不少代码存在错误，尽量以此处翻译过的为准</div><div class='page'><h1 class='title level-3'>1_课程介绍</h1><br/></div><div class='page'><h1 class='title level-3'>2_Course introduction _ ADA Logics</h1><br/>libfuzzer是开源的fuzz引擎，由llvm社区维护，libfuzz常用于测试谷歌源代码<br /><br />llvm：编译器工具链<br />   	 <br />libfuzzer具有可扩展性，可以自主修改<br /><br />fuzz参数的选择具有经验性，具体参数如何使fuzz起作用并不是很清楚的<br /><br /><h2>fuzz于其他程序分析技术不同的点</h2><br />快速构造大量输出并进行执行<br />具有扩展性，基本上适用于所有可执行程序<br />具有可重现性，只要发现了crash，就可以重现<br />具有易用性，相较于其他程序分析工具<br />    <br /><h1>第一篇关于fuzz的论文及其下载地址</h1><br /><a href=""><img src="images\870-1.png" alt="images\870-1.png" /></a><br /><br /><h1>fuzz在社区进一步发展（05年之前）</h1><br /><a href=""><img src="images\870-2.png" alt="images\870-2.png" /></a><br /><br /><h2>现代fuzz发展</h2><br /><a href=""><img src="images\870-3.png" alt="images\870-3.png" /></a> <br /><br /><h1>fuzz可以获得的bug类型</h1><br />传统：通过crash程序从而获得内存损坏类bug，此时问题在于，不是所有bug均会触发crash，并且实际的bug可能和对应的crash相距甚远，从而需要大量调试，从而分析崩溃<br /><br />最近fuzz的发展集中于如何发现不导致crash的bug，即在程序崩溃之前捕获导致程序崩溃的异常 ，从而非常容易的定位到基于堆栈的缓冲器溢出、use-after-free、double-free、有符号数溢出<br /><br /><h1>可以被fuzz的代码类型</h1><br />传统来说：解析器类型的代码是fuzz的首要目标<br />最近的fuzz：结构感知类fuzz提升了fuzz适用范围，使得fuzz数据结构和stareful application（有状态程序）成为可能，从而使得fuzz各个层面的程序成为可能，即fuzz程序内部逻辑<br /><a href=""><img src="images\870-4.png" alt="images\870-4.png" /></a><br />    <br /><h1>一个典型的源码fuzz的步骤</h1><br /><a href=""><img src="images\870-5.png" alt="images\870-5.png" /></a><br /><br />工业界关注的是如何将fuzz紧密结合到开发的整个周期中，使得fuzz与test平级<br /></div><div class='page'><h1 class='title level-3'>3_Fuzzing overview _ ADA Logics</h1><br/>fuzz类型总览<br /><a href=""><img src="images\871-1.png" alt="images\871-1.png" /></a><br /><br /><h1>fuzz核心算法</h1><br />1、随机生成数据<br />2、将数据输入目标程序，如果crash，则记录<br />3、回到第一步<br /><br /><h1>fuzz核心组件</h1><br />随机生成器<br />crash捕获<br /><br />以上两部分均是研究重点，且可以有不同的实现方式<br />即如何生成可以触发crash的随机数据，即优化随机生成<br />如何在程序运行期间观测不同类型的错误状态，即优化bug观测<br />以上两者不存在绝对答案，更多时候需要在两种优化间进行平衡与妥协<br /><br /><h1>fuzz执行目标程序的方法</h1><br />1、fuzz进程与目标程序进程相分离，即拥有两个进程（fuzzer&amp;target）<br />在每轮fuzz循环，fuzzer均会单独拉起一个目标程序进程，并进行随机输入<br />2、fuzz进程与目标进程在同一进程 <br />即fuzz逻辑与目标程序在同一个进程中执行，该方法也叫in-memory fuzzing<br />该方法被libfuzz使用，好处在于无需每次重启一个目标程序进程，坏处在于若目标进程crash，则fuzz也会crash，两者在同一进程<br /><br /><h1>随机生成</h1><br />基于单个数据的的随机生成（例如通过/dev/random）在一些情况下起作用，但不是最有效的，更有效的随机生成方法是：<br />基于模板的随机生成（genertion-based）<br />基于变异的随机生成（multation-based）<br /><br /><h1>基于模板的随机生成</h1><br />基于一种特定的数据结构，即基于语法的fuzzing，如果有指定语法的结构化定义，则可以根据该定义生成符合该语法的输入<br />例如：如果有pdf文件的数据结构，则可以产生大量pdf文件用于作为测试输入<br /><br /><h1>基于变异的随机生成</h1><br />根据已有的输入数据进行突变，并作为输入<br />可能的突变方向<br />修改种子单个bit<br />修改种子整个字节<br />种子中任意位置插入任意数据<br />种子中插入随机ascii字符<br />种子中插入随机ascii字符串<br />复制种子内容并插入随机在任意位置<br />移除种子任意位置的字节数据 <br /><br /><h1>基于变异的随机生成</h1>-构建语料库<br />从构建语料库开始，准备进行fuzz，通过该方法，发送给目标程序的输入数据（即种子语料库）的随机性会大幅降低<br /><br /><h1>在基于变异的fuzz基础上，推出了基于进化的fuzz</h1><br />核心思想是根据某种准则，选择出最强的种子，让该种子进一步变异<br />需要监控目标程序的执行情况，根据执行情况决定种子的生成<br />监控目标程序不仅要监控crash情况，还要监控目标程序元数据（用于判断种子好坏）<br />fuzzer需要能力判断该种子的好坏<br />libfuzzer即基于进化fuzz<br /><br /><h1>基于覆盖反馈的fuzz：一种基于进化的fuzz的实现</h1><br />进化指标是代码覆盖率，该方法显著降低了fuzz种子的样本空间，从而提升了效率<br />算法demo<br />pairs：对<br /><a href=""><img src="images\871-2.png" alt="images\871-2.png" /></a><br />解剖图<br />instrumentation步骤致力于将将目标程序进行处理，从而使其可以返回代码覆盖率等信息<br /><a href=""><img src="images\871-3.png" alt="images\871-3.png" /></a><br /><br /><h1>测量代码覆盖率</h1><br />如何衡量代码覆盖率会涉及的很多不同的概念（即有多种方式衡量代码覆盖率）：<br />独特的函数执行集合作为代码覆盖率？<br />独特的基本块执行集合作为代码覆盖率？<br />执行的代码行数作为代码覆盖率？<br />基本块之间转移的独特序列作为代码覆盖率？<br /><br />不同fuzz使用不容的代码覆盖率标准<br /><br />代码覆盖率的测量方法需要在监控颗粒度与性能开销之间权衡，监控粒度越高，性能开销越大，例如通过基本块之间的转移序列衡量代码覆盖率，其监控粒度大于以具体函数执行测量代码覆盖率<br /><br />即最终代码覆盖率的测量方法依赖于经验观察<br /><br /><h1>处理目标程序，获得代码覆盖率</h1><br />两种方法：<br />有源码时在编译过程中处理目标程序<br />即通过扩展编译器功能，实现在源代码中插入代码逻辑，收集代码覆盖率，libfuzzer（依赖llvm扩展编译器功能）和afl（依赖gcc和llvm扩展编译器功能 ）<br /><br /><br />无源码时在二进制文件运行期间处理目标程序<br />即使用二进制动态处理技术，相关框架：PIN、DynamicRio<br />此类框架可用于对二进制文件进行运行时检测<br /><br /><a href=""><img src="images\871-4.png" alt="images\871-4.png" /></a><br /><br />编译时处理目标文件的示例<br />插入的函数用于记录覆盖率，其使用单个参数，以该指令所在内存地址作为参数<br /><a href=""><img src="images\871-5.png" alt="images\871-5.png" /></a><br />反编译版<br /><a href=""><img src="images\871-6.png" alt="images\871-6.png" /></a><br /><br /><br /><br /><br /><br /><br /></div><div class='page'><h1 class='title level-2'>2_Libfuzzer</h1><br/></div><div class='page'><h1 class='title level-3'>1_Introducing LibFuzzer</h1><br/></div><div class='page'><h1 class='title level-4'>1_Introduction to LibFuzzer _ ADA Logics</h1><br/>libfuzzer最初支持c\c++程序，目前支持了更多的语言，例如Rust<br />libfuzzer依赖clang和clang++进行编译 <br />libfuzzer是进程内fuzz，即libfuzzer与被fuzz程序在同一进程<br />即fuzz的输入变异、种子文件输入、目标程序执行均位于同一进程<br />libfuzzer虽然是一个库，但其提供了main函数，也就要求目标程序不能提供main函数，即目标程序为库函数 <br /><br />libfuzzer使用重点在于编写Fuzz Driver，Fuzz Driver将libfuzzer core提供的字节序列作为输入，通过编写代码，使用libfuzzer core提供的字节序列调用目标程序中的被测函数<br /><br />libfuzzer core中实现了种子选择，种子变异，接受目标程序反馈等一系列逻辑<br /><a href=""><img src="images\877-1.png" alt="images\877-1.png" /></a><br /><br />编写Fuzz Driver可以与目标程序使用相同的基础代码，也可以单独实现代码逻辑<br />实际操作过程中，我们需要将目标程序和自己实现的fuzz drive保存在同一源代码中，之后使用clang进行编译，生成的可执行文件仅需运行，即可进行fuzz<br /><a href=""><img src="images\877-2.png" alt="images\877-2.png" /></a><br /><br /><h1>编写fuzz drive</h1><br />两个参数：data size<br />data表示种子数据，由fuzzer core提供<br />size表示data的元素数量，因为data是uint8的指针（即指向8bit的数据），size就是种子数据的字节数<br />该函数总是需要返回0<br /><a href=""><img src="images\877-3.png" alt="images\877-3.png" /></a> <br /><br /><h1>libfuzzer示例：针对strlen函数</h1><br />该测试中，libfuzzer测试strlen函数，该函数期望一个null结尾的字符串作为参数，故LLVMFuzzerTestOneInput函数中申请内存空间，将data拷贝到该内存，并在结尾设置null，并将处理后的字符串传给strlen函数<br /><a href=""><img src="images\877-4.png" alt="images\877-4.png" /></a><br /><br /><h1>libfuzzer示例：针对NodeJS函数</h1><br /><a href=""><img src="images\877-5.png" alt="images\877-5.png" /></a><br /><br /><h1>libfuzzer示例：针对json解释器函数</h1><br />被fuzz的函数为json::parse(),该函数参数类型为c++标准字符串，所以使用std::string input()函数将data转为字符串<br /><a href=""><img src="images\877-6.png" alt="images\877-6.png" /></a><br /><br /><h1>libfuzzer的使用挑战</h1><br />使用Clang-instrumentation编译目标程序是指编译过程中使用-fsanitize=fuzzer参数，与之类似的参数为<br />-fsanitize=fuzzer-no-link(该参数具体功能待查)<br /><br />编写fuzzdrive时主要工作<br />将随机数据包装为目标程序锁所期待的数据结构<br />初始化一些数据结构，该数据结构是目标程序入口点所期待的<br />每次执行fuzz时，均需重置目标程序状态（因为libfuzzer是in memory fuzzer，所以上一次程序执行结果会影响下次的fuzz测试），具体需要解决目标程序中全局变量造成的影响等<br /><a href=""><img src="images\877-7.png" alt="images\877-7.png" /></a><br /><br /><h1>关于-fsanitize=fuzzer-no-link</h1><br /><a href="PWN--FUZZ--libfuzzer--资料.html">libfuzz资料</a><br />如果修改大型项目的CFLAGS，它也编译需要自己的主符号的可执行文件，则可能需要在不链接的情况下仅请求检测：clang -fsanitize=fuzzer-no-link mytarget.c 然后通过在链接阶段传入-fsanitize = fuzzer，可以将libFuzzer链接到所需的驱动程序。</div><div class='page'><h1 class='title level-4'>2_Introduction to LibFuzzer_官方笔记翻译</h1><br/><h1>LibFuzzer介绍</h1><br /><h2>LibFuzzer概况</h2><br />LibFuzzer是集成到Clang和LLVM编译器基础结构中的基于源的模糊器。 这意味着为了模糊目标应用程序，您需要拥有目标应用程序的源代码以及能够使用Clang编译器对其进行编译。<br /><br />使用LibFuzzer的好处在于，它提供了使应用程序模糊化的许多必要机制，并且基本上，作为LibFuzzer的用户，我们唯一需要构建的就是针对目标应用程序的模糊化部分。 用技术术语来说，LibFuzzer是一个用于模糊其他代码库的代码库，我们所要提供的是LibFuzzer库和我们所针对的库之间的接口。 该接口只是一个小型C / C ++应用程序，我们有时将其称为“模糊驱动程序”。 下图将其可视化：<br /><br /><a href=""><img src="images\878-1.png" alt="images\878-1.png" /></a><br /><br />由于LibFuzzer依赖于Clang和LLVM基础架构，因此我们需要使用必要的LLVM扩展名安装Clang。 自5.0.0版（可追溯到2017年9月）开始，LibFuzzer一直是LLVM每个主要发行版的一部分，在此之前它已作为外部扩展发行。 因此，在大多数情况下，只需通过获取Clang编译器即可完成LibFuzzer的获取。<br /><br /><h2>安装LibFuzzer</h2><br />LibFuzzer与现代版本的Clang（自6.0起）捆绑在一起，因此安装LibFuzzer的最简单方法是简单地安装最新版本的Clang。 在下面的Dockerfile中，这正是我们要做的事情，因为我们通过安装Clang版本8安装了LibFuzzer。<br /><br /><h2>Docker中安装LibFuzzer</h2><br />为了简化LibFuzzer的使用并且不破坏主机系统上的编译器链，在Docker环境中操作很方便。 为此，我们创建了一个Docker映像，以方便使用模糊测试器。  Dockerfile可在此处下载，其外观如下：<br /><div class="codebox"><div class="codebox">#&nbsp;Install&nbsp;basic&nbsp;Ubuntu&nbsp;dependencies<br />FROM&nbsp;ubuntu:20.04<br />ENV&nbsp;DEBIAN_FRONTEND&nbsp;noninteractive<br />RUN&nbsp;apt-get&nbsp;update&nbsp;&amp;&amp;&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;apt-get&nbsp;upgrade&nbsp;-y&nbsp;&amp;&amp;&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;apt-get&nbsp;install&nbsp;-y&nbsp;libc6-dev&nbsp;binutils&nbsp;&amp;&amp;&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;apt-get&nbsp;autoremove&nbsp;-y<br /><br />#&nbsp;Now&nbsp;install&nbsp;basic&nbsp;setup.<br />RUN&nbsp;dpkg&nbsp;--add-architecture&nbsp;i386&nbsp;&amp;&amp;&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;apt-get&nbsp;update&nbsp;&amp;&amp;&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;apt-get&nbsp;install&nbsp;-y&nbsp;software-properties-common&nbsp;&amp;&amp;&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;add-apt-repository&nbsp;ppa:git-core/ppa&nbsp;&amp;&amp;&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;apt-get&nbsp;update&nbsp;&amp;&amp;&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;apt-get&nbsp;install&nbsp;-y&nbsp;\<br />	binutils-dev&nbsp;\<br />	build-essential&nbsp;\<br />	curl&nbsp;\<br />	git&nbsp;\<br />	jq&nbsp;\<br />	libc6-dev-i386&nbsp;\<br />	subversion&nbsp;\<br />	zip<br /><br />#&nbsp;Install&nbsp;our&nbsp;pythons<br />RUN&nbsp;apt-get&nbsp;install&nbsp;python&nbsp;-y<br /><br />#&nbsp;Install&nbsp;clang<br />RUN&nbsp;apt-get&nbsp;install&nbsp;clang-8&nbsp;-y<br /><br />#&nbsp;Create&nbsp;symbolic&nbsp;links&nbsp;for&nbsp;the&nbsp;tools&nbsp;that&nbsp;we&nbsp;will&nbsp;often&nbsp;use.<br />RUN&nbsp;ln&nbsp;-s&nbsp;/usr/bin/clang-8&nbsp;/usr/bin/clang<br />RUN&nbsp;ln&nbsp;-s&nbsp;/usr/bin/clang++-8&nbsp;/usr/bin/clang++<br />RUN&nbsp;ln&nbsp;-s&nbsp;/usr/bin/llvm-profdata-8&nbsp;/usr/bin/llvm-profdata<br />RUN&nbsp;ln&nbsp;-s&nbsp;/usr/bin/llvm-cov-8&nbsp;/usr/bin/llvm-cov<br /><br />#&nbsp;Install&nbsp;the&nbsp;bsdmainutils&nbsp;for&nbsp;tools&nbsp;like&nbsp;hexdump<br />RUN&nbsp;apt-get&nbsp;install&nbsp;bsdmainutils<br /><br />#&nbsp;Install&nbsp;VIM&nbsp;for&nbsp;easy&nbsp;editing<br />RUN&nbsp;apt-get&nbsp;update<br />RUN&nbsp;apt-get&nbsp;install&nbsp;vim&nbsp;-y<br /><br />#&nbsp;Setup&nbsp;directory&nbsp;where&nbsp;we&nbsp;can&nbsp;work<br />ENV&nbsp;WORK=/work<br />ENV&nbsp;MISC=/misc<br />RUN&nbsp;mkdir&nbsp;-p&nbsp;$WORK&nbsp;$MISC&nbsp;&amp;&amp;&nbsp;chmod&nbsp;a+rwx&nbsp;$WORK&nbsp;$MISC</div></div><br /><br />构造docker镜像<br /><h3>sudo docker build --tag libfuzzer_1 .</h3><br />上面的命令假定您位于带有docker映像的文件夹中,即.表示Dockfile位于当前目录下<br />以下命令启动Docker映像：<br /><h3>sudo docker run -it libfuzzer_1 /bin/bash</h3><br /><br />关于<a href="Docker--Dockerfile.html">Dockerfile</a><br /><br /><h2>LibFuzzer driver</h2><br />如上所述，为了使用LibFuzzer对目标应用程序进行模糊测试，我们要做的核心任务是编写将Fuzzer Dirve，该程序将LibFuzzer Core连接至目标应用程序。 Fuzzer Dirve只是LibFuzzer核心将使用随机数据的不同缓冲区一次又一次调用的单个函数。 空的模糊驱动程序外观如下所示：<br /><br /><strong><h3>empty_driver.c</h3></strong><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdint.h&gt;<br />#include&nbsp;&lt;stdio.h&gt;<br /><br />int&nbsp;LLVMFuzzerTestOneInput(const&nbsp;uint8_t&nbsp;*Data,&nbsp;size_t&nbsp;Size)&nbsp;{&nbsp;&nbsp;<br />/*&nbsp;Fuzz&nbsp;driver&nbsp;implementation&nbsp;*/&nbsp;<br />	return&nbsp;0；<br />}&nbsp;</div></div><br /><br />名为LLVMFuzzerTestOneInput的函数是模糊器驱动程序的入口点，这是LibFuzzer内核使用随机数据调用的函数。 因此，实现这一职能的主体是我们的责任，<span style="color:#ff0000;">注意该函数总是需要返回0</span>。<br /><br /><span style="color:#ff0000;">注意要使用该函数需要包含两个头文件</span><strong><span style="color:#ff0000;">stdint.h、stdio.h</span></strong><span style="color:#ff0000;">，原因在于该函数参数使用了uint8_t、size_t两种数据类型</span><br /><br />为了编译fuzzer，我们需要给clang编译器加上-fsanitize = fuzzer标志。 然后，这将生成一个简单的可执行文件，即我们的模糊器，这意味着模糊器是一个独立的可执行文件：<br /><a href=""><img src="images\878-2.png" alt="images\878-2.png" /></a><br />以上输出显示<br /><span style="color:#ff0000;">cov：是模糊器在目标程序中进行的覆盖。 这大致对应于模糊器种子执行的基本块数。 这是所有运行的唯一基本块的总集合，因此，在模糊测试运行期间，cov只会增加或保持不变，而不会减少。 在上面的示例中，输出表示模糊器仅观察到一个基本块，这是正确的，因为LLVMFuzzerTestOneInput仅显示单个return语句。<br /><br />exec / s是每秒的模糊迭代次数。 在上面的示例中，这意味着模糊器每秒执行大约4百万次迭代。该迭代次数即LLVMFuzzerTestOneInput函数执行的次数<br /><br />rss：fuzz运行时所占用的内存</span><br /><br /><br />上面的示例显示了我们如何将LibFuzzer内核连接到fuzz drive。 即LibFuzzer核心包含main函数，然后LibFuzzer核心将调用名为LLVMFUzzerTestOneInput的函数。 下一个问题是如何将fuzz drive连接到目标应用程序。 为了说明这种情况的简单情况，请考虑以下小型C程序：<br />simple_driver2.c<br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdint.h&gt;<br />#include&nbsp;&lt;stdio.h&gt;<br /><br /><br />int&nbsp;attack_me(char&nbsp;*buffer,&nbsp;int&nbsp;size)<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(size&nbsp;!=&nbsp;4)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(buffer[0]&nbsp;!=&nbsp;&#39;A&#39;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(buffer[1]&nbsp;!=&nbsp;&#39;B&#39;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;2;<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(buffer[2]&nbsp;!=&nbsp;&#39;C&#39;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;3;<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(buffer[3]&nbsp;!=&nbsp;&#39;D&#39;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;4;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br />}<br /><br />int&nbsp;LLVMFuzzerTestOneInput(const&nbsp;uint8_t&nbsp;*Data,&nbsp;size_t&nbsp;Size)&nbsp;<span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Fuzz&nbsp;driver&nbsp;implementation&nbsp;*/<br />&nbsp;&nbsp;&nbsp;&nbsp;attack_me((char*)Data,&nbsp;Size);<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />在上面的源代码中，我们认为函数Attack_me是我们打算模糊的目标代码。 该函数采用两个参数，一个char缓冲区和一个用于指示缓冲区中元素数量的大小。 然后，它检查大小是否为4，如果不是，则返回0。此后，它会通过缓冲区的前四个字符，以观察它们是否包含ABCD字符。<br /><br />fuzz drive本身只是将来自LibFuzzer核心的数据直接传递给Attack_me函数。 因此，这实际上是最简单的模糊驱动程序，但是，随着您开始学习模糊驱动程序，您可以在许多情况下使用这种模糊驱动程序。 编译并运行以上源代码将为我们提供以下结果：<br /><a href=""><img src="images\878-3.png" alt="images\878-3.png" /></a><br /><br />在这种情况下，我们可以在输出中看到很多新内容。 首先，我们可以看到cov变量增加到8，并且在达到8后停止增加。但是，它在几秒钟内也达到8，这意味着它可以毫无问题地探索所有不同的代码块。<br /><br /><h2>LibFuzzer corpus</h2><br />LibFuzzer能够保存探索程序新部分的每个测试用例，我们称其为模糊处理语料库。 保留语料库非常有用，如果停止了模糊测试活动，则可以使用它在以后的阶段恢复模糊测试活动。 除此之外，语料库有时还可以揭示有关程序的有趣内容，因为语料库中的每个测试用例都显示了程序的输入，迫使程序以与其他测试用例略有不同的方式执行。<br /><br />为了显示模糊测试语料库的有用性，请考虑以下包含模糊测试器的C代码：<br /><a href="http://target.cc/">target.cc</a><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;stdlib.h&gt;<br />#include&nbsp;&lt;stdint.h&gt;<br /><br />int&nbsp;magic_check(char&nbsp;*buf)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(buf[0]&nbsp;!=&nbsp;&#39;F&#39;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(buf[1]&nbsp;!=&nbsp;&#39;U&#39;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(buf[2]&nbsp;!=&nbsp;&#39;Z&#39;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(buf[3]&nbsp;!=&nbsp;&#39;Z&#39;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br />}<br /><br />int<br />consistency_check(char&nbsp;*buf,&nbsp;int&nbsp;size)<br />{<br />&nbsp;&nbsp;&nbsp;if&nbsp;(size&nbsp;&lt;&nbsp;30)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;<br /><br />&nbsp;&nbsp;&nbsp;int&nbsp;consistency_val&nbsp;=&nbsp;0;<br />&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;size;&nbsp;i++)<br />&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;consistency_val&nbsp;+=&nbsp;(int)buf[i];<br />&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;if&nbsp;(consistency_val&nbsp;!=&nbsp;0x1443)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;<br />&nbsp;&nbsp;&nbsp;return&nbsp;0;<br />}<br /><br />int&nbsp;final_check(char&nbsp;*buffer)<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;buffer&nbsp;+=&nbsp;4;<br />&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;buffer_val&nbsp;=&nbsp;*(int*)buffer;<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(buffer_val&nbsp;!=&nbsp;0xaabbccdd)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br />}<br /><br />int<br />attack_me(char&nbsp;*buffer,&nbsp;int&nbsp;size)<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(size&nbsp;&lt;&nbsp;4)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(magic_check(buffer)&nbsp;!=&nbsp;0)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(consistency_check(buffer,&nbsp;size)&nbsp;!=&nbsp;0)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(final_check(buffer)&nbsp;!=&nbsp;0)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br />}<br /><br />int&nbsp;LLVMFuzzerTestOneInput(const&nbsp;uint8_t&nbsp;*data,&nbsp;size_t&nbsp;size)<br /><span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;attack_me((char*)data,&nbsp;size);<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br />上面的模糊器针对的是Attack_me函数，而且Attack_me函数本身调用了三个不同的函数，每个函数的目的都是对输入进行验证检查。 对于每个函数，如果输入验证成功，则给定函数将返回0，<span style="color:#ff0000;">实际来看，当输入满足第一、第二个函数的验证要求后，一定无法满足第三个函数的验证要求（final_check），所以libfuzzer无法达到attack_me函数最后一条return0指令</span><br /><br />第一个输入验证检查magic_check仅检查缓冲区的前四个字符是否对应于“ FUZZ”。 如果输入缓冲区的所有字符加起来等于0x1443，则第二个输入验证函数Consistency_check进行验证；如果输入缓冲区的前四个字节与整数0xaabbccdd相对应，则第三个验证函数final_check进行检查。 这些检查中的每一项检查都越来越困难，我们希望使用覆盖率可视化来确定我们的模糊器能够执行代码的哪些部分。<br /><br />为了对它运行模糊器，我们首先用clang编译它：<br /><br /><h3>$ clang -fsanitize=fuzzer target.c -o fuzzer</h3><br /><br />然后，我们可以像通常使用./fuzzer一样简单地运行它。 但是，这次我们将首先创建一个单独的目录，其中包含所有测试用例，每个测试用例在进行模糊测试时都会探索程序的新部分。 然后，我们将该目录的路径作为模糊器的第一个参数：<br /><a href=""><img src="images\878-4.png" alt="images\878-4.png" /></a><br /><br />Corpus目录包含一组文件，其中每个文件代表一个探索程序新部分的输入：<br /><a href=""><img src="images\878-5.png" alt="images\878-5.png" /></a><br /><br />现在，我们可以通过提供类似的目录作为模糊测试活动的第一个参数来从已有的语料库中恢复模糊测试活动：<br /><a href=""><img src="images\878-6.png" alt="images\878-6.png" /></a><br /><br /><h1>LibFuzzer的变异</h1><br />Libfuzzer共有十种默认突变策略。 它还有两个可选的附加突变策略，仅在向模糊器提供字典时才使用，并且我们将在本课程的后面部分讨论字典。 十种默认突变策略都非常原始，以下列表总结了每种策略：<br /><br />• <strong>EraseBytes</strong>: 从种子中删除一组字节。 将最大去除一半的种子。<br />• <strong>InsertByte</strong>:在种子的随机位置插入一个随机字节。<br />• <strong>InsertRepeatedBytes</strong>: 重复插入同一字节多次。 请注意，此处将优先级赋予0x00和0xff，并且这些字节之一将是一半时间选择的字节。<br />• <strong>ChangeByte</strong>: 在种子中的随机位置选择一个字节，并将其替换为随机字节。<br />• <strong>ChangeBit</strong>: 在种子中的任意位置选择一个字节，然后用1bit数据XoRs在该字节中的单个bit。<br />• <strong>ShuffleBytes</strong>: 通过std :: shuffle对种子中的随机字节序列进行重新排序。  ChangeASCIIInt：扫描种子，以查找与整数表示形式对应的ASCII字符的首次出现。 然后将这些ASCII字符转换为实际整数，并通过简单的算术运算（例如： 增加/减少，除以2或乘以2或将其替换为随机数。 然后继续将整数转换为ASCII字符并覆盖最初找到的ASCII字符。<br />• <strong>ChangeBinInt</strong>: 将种子中的随机位置解释为1,2,4或8个字节的整数，然后基于简单的按位算术对该字节进行突变。<br />• <strong>CopyPart</strong>: 将字节从种子的一部分复制到种子的另一部分。<br />• <strong>CrossOver</strong>: 与CopyPart密切相关，但是诱变策略不是从自己的种子中复制数据，而是将数据从随机整数复制到种子上。<br /><br />如果您想在源代码中看到突变策略的实现，则将它们全部放在此文件中：<a href="https://github.com/llvm/llvm-project/blob/master/compiler-rt/lib/fuzzer/FuzzerMutate.cpp">https://github.com/llvm/llvm-project/blob/master/compiler-rt/lib/fuzzer/FuzzerMutate.cpp</a><h3>.</h3> 每个执行突变的功能的名称都是以Mutate_为前缀的突变名称。 因此，用于EraseBytes突变的函数的名称由Mutate_EraseBytes给出。 例如，请考虑在模糊数据中插入一个随机字节的变异函数：<br /><div class="codebox"><div class="codebox">size_t&nbsp;MutationDispatcher::Mutate_InsertByte(uint8_t&nbsp;*Data,&nbsp;size_t&nbsp;Size,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;MaxSize)&nbsp;<span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;if&nbsp;(Size&nbsp;&gt;=&nbsp;MaxSize)&nbsp;return&nbsp;0;<br />&nbsp;&nbsp;size_t&nbsp;Idx&nbsp;=&nbsp;Rand(Size&nbsp;+&nbsp;1);<br />&nbsp;&nbsp;//&nbsp;Insert&nbsp;new&nbsp;value&nbsp;at&nbsp;Data[Idx].<br />&nbsp;&nbsp;memmove(Data&nbsp;+&nbsp;Idx&nbsp;+&nbsp;1,&nbsp;Data&nbsp;+&nbsp;Idx,&nbsp;Size&nbsp;-&nbsp;Idx);<br />&nbsp;&nbsp;Data[Idx]&nbsp;=&nbsp;RandCh(Rand);<br />&nbsp;&nbsp;return&nbsp;Size&nbsp;+&nbsp;1;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br />该函数将随机数据，其当前大小以及突变后可以达到的最大大小作为输入。 这样，突变函数的目标是在MaxSize参数的偏移量之内修改数据缓冲区中的内容。 在上面的Mutate_InsertByte示例中，该函数仅在参数的随机索引处插入一个新的随机字节。 注意，使用Rand（）生成随机索引，并使用RandCh（）函数生成随机字节。</div><div class='page'><h1 class='title level-4'>3_Demonstration of Libfuzzer - 1 _ ADA Logics</h1><br/>安装docker环境<br /><a href=""><img src="images\882-1.png" alt="images\882-1.png" /></a><br /><br />启动镜像并调用镜像的bash，从而获得镜像的shell<br /><a href=""><img src="images\882-2.png" alt="images\882-2.png" /></a><br /><br />编写fuzz drive<br /><a href=""><img src="images\882-3.png" alt="images\882-3.png" /></a><br /><br />编译fuzz drive，与常规编译的区别仅在于-fsanitize=fuzzer<br /><a href=""><img src="images\882-4.png" alt="images\882-4.png" /></a><br />运行fuzz drive<br /><span style="color:#ff0000;">new表示libfuzzer在目标程序中发现了新的基本块<br />new一行最右侧会显变异策略，正是通过该变异策略才发现了对应的基本块<br />pulse显示当前并未发现新的基本代码块<br />cov表示发现的基本代码块数量<br />exec/s表示LLVMFuzzerTestOneInput()函数每秒执行的次数</span><br /><a href=""><img src="images\882-5.png" alt="images\882-5.png" /></a></div><div class='page'><h1 class='title level-4'>4_Demonstration of Libfuzzer - 2 _ ADA Logics</h1><br/>在fuzz drive中加入红框中的代码，即在目标函数最后使用assert(0);，即使用断言函数终止程序执行<br /><a href=""><img src="images\883-1.png" alt="images\883-1.png" /></a><br />assert()断言函数，用于在调试过程中捕捉程序错误，这里可以将assert(0);看作程序中的bug，fuzz drive执行到这里会报错<br />原型<br />#include &lt;assert.h&gt;<br />void assert( int expression );<br />assert的作用是计算表达式 expression ，如果其值为假（即为0），那么它先向stderr打印一条出错信息，然后通过调用 abort 来终止程序运行。<br /><br />编译上述源码，并执行可执行文件，发现当fuzz drive通过所有判断条件执行到函数后，程序crash，并输出了此时的回调堆栈<br /><br />此时图中仅输出了attack_me函数的调用，未给出详细的代码行号，原因在于编译fuzz dirve时没有保留调试符号<br /><br />图中输出了在可执行文件的第20行执行了assert(0)的断言<br /><a href=""><img src="images\883-2.png" alt="images\883-2.png" /></a><br /><br />如果想要assert(0)输出更详细的信息，需要在编译时保留调试符号，即增加 -g，注意-g参数的位置<br />clang -g -fsanitize=fuzzer fuzz_intro.c<br /><a href=""><img src="images\883-3.png" alt="images\883-3.png" /></a><br />重新编译后运行，发现调用栈信息更加详尽<br /><br /><br />在asset的输出中，可以找到导致本次崩溃的测试用例，<span style="color:#ff0000;">该用例可以作为参数，跟在fuzzer可执行文件后，从而重现crash的场景</span><br /><a href=""><img src="images\883-4.png" alt="images\883-4.png" /></a><br /><br /> 查看该文件的内容，发现的确是ABCD<br /><a href=""><img src="images\883-5.png" alt="images\883-5.png" /></a> <br /><br /><br /></div><div class='page'><h1 class='title level-4'>5_Demonstration of Libfuzzer exploration and corpus _ ADA Logics</h1><br/><h1>libfuzzer测试用例的生成</h1><br />被fuzz的目标程序<br /><a href=""><img src="images\889-1.png" alt="images\889-1.png" /></a><br /><br />在fuzz drive执行时指定一个目录作为参数，可以将libfuzzer运行过程中所有触发新路径的测试用例保存下来<br /><a href=""><img src="images\889-2.png" alt="images\889-2.png" /></a><br /><br />当libfuzzer输出的cov达到29时，停止fuzz，查看对应目录，发现26个用于触发新路径的测试用例<br /><a href=""><img src="images\889-3.png" alt="images\889-3.png" /></a><br /><br />遍历输出所有测试用例内容的脚本<br /><a href=""><img src="images\889-4.png" alt="images\889-4.png" /></a><br /><br /><br /><h1>使用已有的语料库开始进行fuzz</h1><br />可以将fuzz过程分为若干独立阶段，每阶段可以使用上一阶段生产的语料库，而不用从头开始<br />直接将语料库目录作为第一个参数，可以快速覆盖大量目标代码<br /><a href=""><img src="images\889-5.png" alt="images\889-5.png" /></a><br /><br /><br /></div><div class='page'><h1 class='title level-3'>2_Libfuzzer fuzzers</h1><br/></div><div class='page'><h1 class='title level-4'>1_LibFuzzerTemplateFuzzers_and_examples</h1><br/><h1>LibFuzzer模板模糊器和示例</h1><br />我们模糊的应用程序的复杂性差异很大。 类似地，应用程序期望的输入变化很大，范围从简单的数据块到高度结构化的输入，例如 具有数据完整性校验和的PNG图像等。 在本节中，我们将为期望一系列通用输入的目标提供模板模糊器，这些模板通常仅需添加几行代码就足以创建有效的模糊器。 我们可以通过本节中介绍的模板模糊器来模糊许多目标应用程序，因此重要的是不要低估它们的功能。 然后，我们将在课程后期详细介绍如何为期望高度结构化输入目标开发模糊器。<br /><br /><h1>Fuzzer用于：任意数据输入</h1><br /><br />我们介绍的第一个模糊器只是将任意字节序列传递给目标API的模糊器，模板模糊器的外观如下：<br /><br /><div class="codebox"><div class="codebox">int&nbsp;LLVMFuzzerTestOneInput(const&nbsp;uint8_t&nbsp;*data,&nbsp;size_t&nbsp;size)<span style="color:#000000;font-weight:400">{</span><br />	SOME_API(data,&nbsp;size);<br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />该模糊器简单地将LibFuzzer提供的随机数据传递给给定的api SOME_API，该API期望字节的缓冲区和缓冲区的大小。 即使在诸如libc之类的通用实用程序库中，也有许多函数示例期望此类输入。<br />例如，memchr需要三个参数，并具有以下函数签名void * memchr（const void * s，int c，size_t n）;，其中第一个参数s是随机数据的缓冲区，第二个参数c是 将在缓冲区中搜索的整数，n是将在其中搜索的s缓冲区中的字节数。 因此，用于memchr函数的模糊器如下：<br /><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;string.h&gt;<br />#include&nbsp;&lt;stdint.h&gt;<br /><br />int&nbsp;LLVMFuzzerTestOneInput(const&nbsp;uint8_t&nbsp;*data,&nbsp;size_t&nbsp;size)<span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Pass&nbsp;the&nbsp;random&nbsp;data&nbsp;to&nbsp;memchr<br />&nbsp;&nbsp;&nbsp;&nbsp;memchr(data,&nbsp;123,&nbsp;size);<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />编译此模糊器将为我们提供以下结果：<br /><a href=""><img src="images\892-1.png" alt="images\892-1.png" /></a><br /><br />模糊器的输出表明，该模糊器每秒执行大约三到四百万次执行。 <span style="color:#ff0000;">模糊器覆盖率没有增加的原因是因为libc目标代码不是使用-fsanitize = fuzzer-no-link编译的，而是仅使用模糊检测工具编译了实际的模糊器。</span><br /><br /><h1>Fuzzer适用于：空终止的字符串输入</h1><br />第二个模板模糊器用于仅接受以空终止的字符串作为输入的API。 在这种情况下，我们要做的是在随机数据后附加一个空字节，为此，我们可以在每次运行中使用简单的内存分配：<br /><br /><div class="codebox"><div class="codebox">int&nbsp;LLVMFuzzerTestOneInput(const&nbsp;uint8_t&nbsp;*data,&nbsp;size_t&nbsp;size)<span style="color:#000000;font-weight:400">{</span><br />	char&nbsp;*new_str&nbsp;=&nbsp;(char&nbsp;*)malloc(size+1);<br />	if&nbsp;(new_str&nbsp;==&nbsp;NULL){<br />		return&nbsp;0;<br />	}<br />	memcpy(new_str,&nbsp;data,&nbsp;size);<br />	new_str[size]&nbsp;=&nbsp;&#39;\0&#39;;<br /><br />	/*&nbsp;Insert&nbsp;fuzzer&nbsp;contents&nbsp;here&nbsp;*/<br /><br />	/*&nbsp;-&nbsp;end&nbsp;of&nbsp;fuzzer&nbsp;contents&nbsp;&nbsp;-&nbsp;*/<br /><br />	free(new_str);<br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />在libc代码库中再次找到这种模糊器的示例。<br /><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;stdlib.h&gt;<br />#include&nbsp;&lt;string.h&gt;<br />#include&nbsp;&lt;stdint.h&gt;<br /><br />int&nbsp;LLVMFuzzerTestOneInput(const&nbsp;uint8_t&nbsp;*data,&nbsp;size_t&nbsp;size)<span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*new_str&nbsp;=&nbsp;(char&nbsp;*)malloc(size+1);<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(new_str&nbsp;==&nbsp;NULL){<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;memcpy(new_str,&nbsp;data,&nbsp;size);<br />&nbsp;&nbsp;&nbsp;&nbsp;new_str[size]&nbsp;=&nbsp;&#39;\0&#39;;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Fuzz&nbsp;strlen<br />&nbsp;&nbsp;&nbsp;&nbsp;strlen(new_str);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;free(new_str);<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />编译并运行此模糊器将为我们提供以下内容：<br /><br /><a href=""><img src="images\892-2.png" alt="images\892-2.png" /></a><br /><br />类似于之前的libc代码不会使用工具进行编译以计算fuzzer的覆盖范围，但是，fuzzer的输出向我们显示了它每秒执行超过四百万次迭代。<br /><br /><h1>Fuzzer用于：基于文件的输入</h1><br /><br />常见的情况是，您要进行模糊处理的目标API将文件作为输入，而对这种类型的目标进行模糊处理的方法只是在每次模糊测试迭代中将数据写入文件中。 以下模板使您可以执行此操作：<br /><br /><div class="codebox"><div class="codebox">int<br />LLVMFuzzerTestOneInput(const&nbsp;uint8_t&nbsp;*data,&nbsp;size_t&nbsp;size)<br /><span style="color:#000000;font-weight:400">{</span><br />	char&nbsp;filename[256];<br />	sprintf(filename,&nbsp;&quot;/tmp/libfuzzer.%d&quot;,&nbsp;getpid());<br /><br />	FILE&nbsp;*fp&nbsp;=&nbsp;fopen(filename,&nbsp;&quot;wb&quot;);<br />	if&nbsp;(!fp)<br />		return&nbsp;0;<br />	fwrite(data,&nbsp;size,&nbsp;1,&nbsp;fp);<br />	fclose(fp);<br /><br />	/*&nbsp;Insert&nbsp;fuzzer&nbsp;contents&nbsp;here&nbsp;*/<br /><br />	/*&nbsp;-&nbsp;end&nbsp;of&nbsp;fuzzer&nbsp;contents&nbsp;&nbsp;-&nbsp;*/<br /><br />	unlink(filename);<br /><br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br />注意unlink()函数表示根据文件名删除文件<br />模糊测试器仅在每次迭代中创建一个临时文件，然后您便可以对目标进行模糊测试，例如 parse_file（filename）;。 这样的一个示例是对具有以下函数签名的stat函数进行模糊处理：int stat（const char * pathname，struct stat * statbuf）;。 该函数需要一个文件名和一个指向stat结构的指针。 我们可以在目标函数中使用以下模糊器：<br /><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;stdint.h&gt;<br /><br />#include&nbsp;&lt;sys/types.h&gt;<br />#include&nbsp;&lt;sys/stat.h&gt;<br />#include&nbsp;&lt;unistd.h&gt;<br /><br />int<br />LLVMFuzzerTestOneInput(const&nbsp;uint8_t&nbsp;*data,&nbsp;size_t&nbsp;size)<br /><span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;filename[256];<br />&nbsp;&nbsp;&nbsp;&nbsp;sprintf(filename,&nbsp;&quot;/tmp/fuzzer_test.%d&quot;,&nbsp;getpid());<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;FILE&nbsp;*fp&nbsp;=&nbsp;fopen(filename,&nbsp;&quot;wb&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!fp)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;fwrite(data,&nbsp;size,&nbsp;1,&nbsp;fp);<br />&nbsp;&nbsp;&nbsp;&nbsp;fclose(fp);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Fuzz&nbsp;target&nbsp;function<br />&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;stat&nbsp;statbuf;<br />&nbsp;&nbsp;&nbsp;&nbsp;stat(filename,&nbsp;&amp;statbuf);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;unlink(filename);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />编译此模糊器并运行生成的二进制文件会给我们以下结果：<br /><br /><a href=""><img src="images\892-3.png" alt="images\892-3.png" /></a><br /><br /><h1>Fuzzer用于：CPP字符串作为输入</h1><br /><br />如果您要模糊的目标是用CPP编写的并且接受字符串，则以下模板可用于设置这样的模糊器。<br /><br /><div class="codebox"><div class="codebox">extern&nbsp;&quot;C&quot;&nbsp;int&nbsp;LLVMFuzzerTestOneInput(const&nbsp;uint8_t&nbsp;*data,&nbsp;size_t&nbsp;size)<br /><span style="color:#000000;font-weight:400">{</span><br />	std::string&nbsp;input(reinterpret_cast&lt;const&nbsp;char*&gt;(data),&nbsp;size);<br /><br />	/*&nbsp;Insert&nbsp;fuzzer&nbsp;contents&nbsp;here&nbsp;*/<br /><br />	/*&nbsp;-&nbsp;end&nbsp;of&nbsp;fuzzer&nbsp;contents&nbsp;&nbsp;-&nbsp;*/<br /><br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />模糊器仅将数据包装在CPP字符串中，然后可以将该字符串用作目标应用程序中某些API的参数。 考虑以下示例，在此示例中，我们仅在CPP字符串上调用length（）：<br /><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;iostream&gt;<br /><br />extern&nbsp;&quot;C&quot;&nbsp;int&nbsp;LLVMFuzzerTestOneInput(const&nbsp;uint8_t&nbsp;*data,&nbsp;size_t&nbsp;size)<br /><span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;std::string&nbsp;input(reinterpret_cast&lt;const&nbsp;char*&gt;(data),&nbsp;size);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Simply&nbsp;fuzz&nbsp;the&nbsp;length()&nbsp;function.<br />&nbsp;&nbsp;&nbsp;&nbsp;input.length();<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />编译并运行此模糊器将为我们提供以下结果：<br /><br /><a href=""><img src="images\892-4.png" alt="images\892-4.png" /></a><br /><br />下面的代码是一个更完整的示例，其中我们创建了一个简单的函数，该函数计算输入字符串中A的数量<br /><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;iostream&gt;<br /><br />int&nbsp;count_chars(const&nbsp;std::string&nbsp;&amp;s)<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;count&nbsp;=&nbsp;0;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(char&nbsp;const&nbsp;&amp;c:&nbsp;s)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(c&nbsp;==&nbsp;&#39;A&#39;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count++;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;count;<br />}<br /><br />extern&nbsp;&quot;C&quot;&nbsp;int&nbsp;LLVMFuzzerTestOneInput(const&nbsp;uint8_t&nbsp;*data,&nbsp;size_t&nbsp;size)<br /><span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::string&nbsp;s(reinterpret_cast&lt;const&nbsp;char*&gt;(data),&nbsp;size);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count_chars(s);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><h1>Fuzzer：基于非字节的随机数据</h1><br /><br />例如目标函数参数不是char*，而是其他类型的数据，如int、int*等<br /><br />上面的示例全部显示了模板模糊器，它们在将随机缓冲区传递给目标函数之前不对其进行任何处理或对其进行有限的处理。 但是，并不是所有的目标函数都接受缓冲区，而是某些函数期望基于非缓冲区的数据，例如 整数或类似。<br /><br />考虑以下snprintf的模糊器：<br /><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;stdlib.h&gt;<br />#include&nbsp;&lt;string.h&gt;<br />#include&nbsp;&lt;stdint.h&gt;<br /><br />int&nbsp;LLVMFuzzerTestOneInput(const&nbsp;uint8_t&nbsp;*data,&nbsp;size_t&nbsp;size)<span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(size&nbsp;!=&nbsp;4)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Fuzz&nbsp;atoi<br />&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;target[20];<br />&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;x&nbsp;=&nbsp;*(int&nbsp;*)data;<br />&nbsp;&nbsp;&nbsp;&nbsp;snprintf(&nbsp;target,&nbsp;4,&nbsp;&quot;%d&quot;,&nbsp;x&nbsp;);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />编译并运行此模糊器将为我们提供以下结果：<br /><br /><a href=""><img src="images\892-5.png" alt="images\892-5.png" /></a><br /><br /></div><div class='page'><h1 class='title level-4'>2_Demonstration of template fuzzers _ ADA Logics</h1><br/><h1>当目标函数参数为c++字符串</h1><br />如果使用了c++版的LLVMFuzzerTestOneInput函数，（比如目标函数期望参数为c++字符串）<br /><a href=""><img src="images\893-1.png" alt="images\893-1.png" /></a><br /><br />则应使用clang+编译fuzz drive<br /><a href=""><img src="images\893-2.png" alt="images\893-2.png" /></a><br /><br /><h1> 当目标函数参数不基于单个字节时</h1><br />下图中缓冲区中的字符解释为整数指针，通过解引用得到一个int类型整数，并传给目标函数<br /><a href=""><img src="images\893-3.png" alt="images\893-3.png" /></a></div><div class='page'><h1 class='title level-4'>3_NodeJS http-parser fuzzer _ ADA Logics</h1><br/><a href="https://github.com/nodejs/http-parser">https://github.com/nodejs/http-parser</a><br />目标开源程序，该程序是一个c语言实现的http解析器，解析逻辑位于http_parser.c<br />fuzz代码位于fuzzer文件夹下<br /><a href=""><img src="images\894-1.png" alt="images\894-1.png" /></a><br /><br /><h1>如何确定被fuzz的函数</h1><br /><br />项目中test.c文件是项目的示例文件，打开该文件，找到如下函数<br />该函数中http_parser_parser_url函数在test_on_overflow_parser_url内被调用，且被调用之前不存在复杂调用逻辑，说明调用http_parser_parser_url较为简单，且http_parser_parser_url函数参数为char字符串及其长度，可以轻易将libfuzzer提供的随机数组转换为该函数参数<br /><a href=""><img src="images\894-2.png" alt="images\894-2.png" /></a><br /><br />在http_parser.c源码中搜索http_parser_parser_url函数，发现该函数仅在注释以及函数定义的位置出现，说明该函数没有被源码中其他函数调用，该函数很可能直接向外提供完整功能，即该函数直接被使用该lib的外部代码调用，故该函数为理想的fuzz目标<br /><a href=""><img src="images\894-3.png" alt="images\894-3.png" /></a><br /><br /><br />fuzzer文件夹下包括两个文件，分别用于fuzzer解析器和url<br /><a href=""><img src="images\894-4.png" alt="images\894-4.png" /></a><br /><br />fuzz_url.c中的代码，构建fuzz时参考了test.c文件中调用http_parser_parser_url函数的方法<br /><a href=""><img src="images\894-5.png" alt="images\894-5.png" /></a><br /><br />将项目克隆到本地，使用clang编译fuzzer目录中的fuzzer_url.c文件，报错提示未找到http_parser.h文件，故使用-I .命令指示当前目录，从而给出http_parser.h文件路径<br /><br /><a href=""><img src="images\894-6.png" alt="images\894-6.png" /></a><br /><br />使用-I .参数之后，继续编译，报错未定义引用 http_parser_url_init以及http_parser_parser_url，原因在于编译过程中我们未引用http_parser.c文件<br /><a href=""><img src="images\894-7.png" alt="images\894-7.png" /></a><br /><br />编译过程中引用http_parser.c文件，编译成功  fuzz_parser.c编译方法相同<br /><a href=""><img src="images\894-8.png" alt="images\894-8.png" /></a><br /><br /><br />fuzz_parser.c文件中，fuzz的目标函数为http_parser_execute<br /><a href=""><img src="images\894-9.png" alt="images\894-9.png" /></a> <br /><br />查看项目中示例代码test.c的main函数，main函数中看到大量test_simple_type函数，该函数参数为字符串，这使得该函数成为fuzz的潜在目标，说明在寻找fuzz的目标函数时，可以根据参数的性质，确定那些函数容易被fuzz<br /><a href=""><img src="images\894-10.png" alt="images\894-10.png" /></a><br /><br />找到test_simple_type函数的定义，该函数依次调用parser_init函数和parser函数<br /><a href=""><img src="images\894-11.png" alt="images\894-11.png" /></a><br /><br />parser_init函数基本作用是调用http_parser_init函数，且其参数为enum，说明该函数的参数是一个常量，该函数易于被调用<br /><a href=""><img src="images\894-12.png" alt="images\894-12.png" /></a><br /><br />parser函数基本作用就是调用http_parser_execute函数<br /><a href=""><img src="images\894-13.png" alt="images\894-13.png" /></a><br /><br />http_parser_execute第二个参数也可以在示例代码test.c中找到，是一个静态结构体<br /><a href=""><img src="images\894-14.png" alt="images\894-14.png" /></a><br /><br />分析库代码源码http_parser_execute函数仅在注释以及函数定义的位置出现，说明该函数直接供外部代码调用，是fuzz的理想目标<br /><br />所以据此分析，可以构造针对http_parser_execute函数的fuzz<br /><br /><br />寻找fuzz的目标函数<br />1、lib库中未被其他库内函数调用的函数，此类函数一般被使用该库的外部函数调用且能完成独立功能，可以看作库的入口点，在fuzz库代码时，优先fuzz此类函数<br />2、函数参数符合libfuzzer调用要求的函数，例如若函数参数为字符串及其长度，则该函数已于被fuzz<br />3、当分析一个函数时，需要分析其参数的来源，找到该参数的被定义的位置，以及定义完成后首次被使用的位置， 一般可以通过分析库代码的源码实现<br />4、如果目标函数参数中既有数据缓冲区指针，也有数据长度参数，则无需设置数据缓冲区以null结尾，因为函数会根据数据长度参数使用缓冲区数据<br /><a href="PWN--FUZZ--ADA_logics_fuzz_course--2_Libfuzzer--2_Libfuzzer_fuzzers--8_Simple_Libfuzzer_2.html">实例参考</a><br />5、同样如果目标函数参数中仅有缓冲区指针，没有数据长度参数，则此时可以设置数据缓冲区以null结尾，即将目标函数看作以c语言字符串作为参数，<a href="PWN--FUZZ--ADA_logics_fuzz_course--2_Libfuzzer--2_Libfuzzer_fuzzers--7_Simple_Libfuzzer_1.html">实例参考</a><br /><br /><br /><br /><br /><br /><br /></div><div class='page'><h1 class='title level-4'>4_Compiling_a_fuzzer</h1><br/><h1>一步编译fuzzer</h1><br /><br /><span style="color:#2b2b2b;">simple_fuzzer.c</span>文件中代码如下：<br /><br /><code><span style="color:#9b9b9b;">#include </span></code><code><span style="color:#d69d85;">&lt;stdio.h&gt;</span></code><code><br /><br /></code><code><span style="color:#569cd6;">int</span></code><code><span style="color:#232323;"> attack_me(</span></code><code><span style="color:#569cd6;">char</span></code><code><span style="color:#232323;"> *buf, </span></code><code><span style="color:#569cd6;">int</span></code><code><span style="color:#232323;"> buf_size)<br /></span></code><code>{<br />    </code><code><span style="color:#569cd6;">if</span></code><code> (buf_size &lt; </code><code><span style="color:#47285c;">5</span></code><code>)<br />    {<br />        </code><code><span style="color:#569cd6;">return</span></code><code> </code><code><span style="color:#47285c;">0</span></code><code>;<br />    }<br />    </code><code><span style="color:#569cd6;">if</span></code><code> (buf[</code><code><span style="color:#47285c;">0</span></code><code>] != </code><code><span style="color:#d69d85;">&#39;S&#39;</span></code><code>) </code><code><span style="color:#569cd6;">return</span></code><code> 0;<br />    </code><code><span style="color:#569cd6;">if</span></code><code> (buf[</code><code><span style="color:#47285c;">1</span></code><code>] != </code><code><span style="color:#d69d85;">&#39;U&#39;</span></code><code>) </code><code><span style="color:#569cd6;">return</span></code><code> 0;<br />    </code><code><span style="color:#569cd6;">if</span></code><code> (buf[</code><code><span style="color:#47285c;">2</span></code><code>] != </code><code><span style="color:#d69d85;">&#39;C&#39;</span></code><code>) </code><code><span style="color:#569cd6;">return</span></code><code> 0;<br />    </code><code><span style="color:#569cd6;">if</span></code><code> (buf[</code><code><span style="color:#47285c;">3</span></code><code>] != </code><code><span style="color:#d69d85;">&#39;C&#39;</span></code><code>) </code><code><span style="color:#569cd6;">return</span></code><code> 0;<br />    </code><code><span style="color:#569cd6;">if</span></code><code> (buf[</code><code><span style="color:#47285c;">4</span></code><code>] != </code><code><span style="color:#d69d85;">&#39;!&#39;</span></code><code>) </code><code><span style="color:#569cd6;">return</span></code><code> 0;<br />    </code><code><span style="color:#569cd6;">if</span></code><code> (buf[</code><code><span style="color:#47285c;">5</span></code><code>] != </code><code><span style="color:#d69d85;">&#39;!&#39;</span></code><code>) </code><code><span style="color:#569cd6;">return</span></code><code> 0;<br /><br />    </code><code><span style="color:#569cd6;">return</span></code><code> </code><code><span style="color:#47285c;">1</span></code><code>;<br />} <br /><br /></code><code><span style="color:#569cd6;">int</span></code><code><span style="color:#232323;"> LLVMFuzzerTestOneInput(</span></code><code><span style="color:#569cd6;">const</span></code><code><span style="color:#232323;"> </span></code><code><span style="color:#569cd6;">uint8_t</span></code><code><span style="color:#232323;"> *data, </span></code><code><span style="color:#569cd6;">size_t</span></code><code><span style="color:#232323;"> size)<br /></span></code><code>{<br />    attack_me(data, size);<br />    </code><code><span style="color:#569cd6;">return</span></code><code> </code><code><span style="color:#47285c;">0</span></code><code>;<br />}<br /><br /></code>simple_fuzzer.c文件中目标函数以及libfuzzer入口点函数同时存在，所以可以一步直接将其编译为可执行文件<code><br /></code><br />clang -fsanitize=fuzzer simple_fuzzer.c<br /><br /><br /><br /></div><div class='page'><h1 class='title level-4'>5_Compiling_a_fuzzer_in_two_steps</h1><br/><h1>两步编译fuzzer</h1><br /><br />有如下三个文件<br />target.c------------------------------------------------------------------<br /><code><br /></code><code><span style="color:#9b9b9b;">#include </span></code><code><span style="color:#d69d85;">&lt;stdio.h&gt;</span></code><code><br /></code><code><span style="color:#9b9b9b;">#include </span></code><code><span style="color:#d69d85;">&quot;target.h&quot;</span></code><code><br /><br /></code><code><span style="color:#569cd6;">int</span></code><code><span style="color:#232323;"> attack_me(</span></code><code><span style="color:#569cd6;">char</span></code><code><span style="color:#232323;"> *buf, </span></code><code><span style="color:#569cd6;">int</span></code><code><span style="color:#232323;"> buf_size)<br /></span></code><code>{<br />    </code><code><span style="color:#569cd6;">if</span></code><code> (buf_size &lt; </code><code><span style="color:#47285c;">5</span></code><code>)<br />    {<br />        </code><code><span style="color:#569cd6;">return</span></code><code> </code><code><span style="color:#47285c;">0</span></code><code>;<br />    }<br />    </code><code><span style="color:#569cd6;">if</span></code><code> (buf[</code><code><span style="color:#47285c;">0</span></code><code>] != </code><code><span style="color:#d69d85;">&#39;S&#39;</span></code><code>) </code><code><span style="color:#569cd6;">return</span></code><code> 1;<br />    </code><code><span style="color:#569cd6;">if</span></code><code> (buf[</code><code><span style="color:#47285c;">1</span></code><code>] != </code><code><span style="color:#d69d85;">&#39;U&#39;</span></code><code>) </code><code><span style="color:#569cd6;">return</span></code><code> 2;<br />    </code><code><span style="color:#569cd6;">if</span></code><code> (buf[</code><code><span style="color:#47285c;">2</span></code><code>] != </code><code><span style="color:#d69d85;">&#39;C&#39;</span></code><code>) </code><code><span style="color:#569cd6;">return</span></code><code> 3;<br />    </code><code><span style="color:#569cd6;">if</span></code><code> (buf[</code><code><span style="color:#47285c;">3</span></code><code>] != </code><code><span style="color:#d69d85;">&#39;C&#39;</span></code><code>) </code><code><span style="color:#569cd6;">return</span></code><code> 4;<br />    </code><code><span style="color:#569cd6;">if</span></code><code> (buf[</code><code><span style="color:#47285c;">4</span></code><code>] != </code><code><span style="color:#d69d85;">&#39;!&#39;</span></code><code>) </code><code><span style="color:#569cd6;">return</span></code><code> 5;<br />    </code><code><span style="color:#569cd6;">if</span></code><code> (buf[</code><code><span style="color:#47285c;">5</span></code><code>] != </code><code><span style="color:#d69d85;">&#39;!&#39;</span></code><code>) </code><code><span style="color:#569cd6;">return</span></code><code> 6;<br /><br />    </code><code><span style="color:#569cd6;">return</span></code><code> </code><code><span style="color:#47285c;">1</span></code><code>;<br />}<br /><br /></code><br />target.h------------------------------------------------------------------<br /><code><span style="color:#569cd6;">int</span></code><code><span style="color:#232323;"> attack_me(</span></code><code><span style="color:#569cd6;">char</span></code><code><span style="color:#232323;"> *buf, </span></code><code><span style="color:#569cd6;">int</span></code><code><span style="color:#232323;"> buf_size)</span></code><code>;<br /><br /></code>fuzzer.c------------------------------------------------------------------<br /><code><span style="color:#9b9b9b;">#include </span></code><code><span style="color:#d69d85;">&quot;target.h&quot;</span></code><code><br /></code><strong><code>#include &lt;stdint.h&gt;</code></strong><code><br /></code><strong><code>#include &lt;stdio.h&gt;</code></strong><code><br /><br /></code><code><span style="color:#569cd6;">int</span></code><code><span style="color:#232323;"> LLVMFuzzerTestOneInput(</span></code><code><span style="color:#569cd6;">const</span></code><code><span style="color:#232323;"> </span></code><code><span style="color:#569cd6;">uint8_t</span></code><code><span style="color:#232323;"> *data, </span></code><code><span style="color:#569cd6;">size_t</span></code><code><span style="color:#232323;"> size)<br /></span></code><code>{<br />    attack_me(data, size);<br />    </code><code><span style="color:#569cd6;">return</span></code><code> </code><code><span style="color:#47285c;">0</span></code><code>;<br />}<br /></code><br />因为fuzz drive与目标程序不在同一个文件，所以此时需要分两步编译fuzz<br />第一步将目标文件编译为中间文件，注意参数-fsanitize=fuzzer-no-link，且需要使用-c从而中间文件，否则报main函数缺失错误<br /> clang -fsanitize=fuzzer-no-link -c target.c -o target.o<br /><br />第二部将中间文件与fuzz drive编译在一起，完成链接过程<br />clang -fsanitize=fuzzer fuzzer.c target.o -o fuzzer</div><div class='page'><h1 class='title level-4'>6_Compiling_a_fuzzer_via_make</h1><br/>通过Make编译一个fuzzer<br /><br />simple_fuzzer.c<br /><code><span style="color:#9b9b9b;">#include </span></code><code><span style="color:#d69d85;">&lt;stdio.h&gt;</span></code><code><br />#include &lt;stdint.h&gt;<br /></code><code><span style="color:#569cd6;">int</span></code><code><span style="color:#232323;"> attack_me(</span></code><code><span style="color:#569cd6;">char</span></code><code><span style="color:#232323;"> *buf, </span></code><code><span style="color:#569cd6;">int</span></code><code><span style="color:#232323;"> buf_size)<br /></span></code><code>{<br />    </code><code><span style="color:#569cd6;">if</span></code><code> (buf_size &lt; </code><code><span style="color:#47285c;">5</span></code><code>)<br />    {<br />        </code><code><span style="color:#569cd6;">return</span></code><code> </code><code><span style="color:#47285c;">0</span></code><code>;<br />    }<br />    </code><code><span style="color:#569cd6;">if</span></code><code> (buf[</code><code><span style="color:#47285c;">0</span></code><code>] != </code><code><span style="color:#d69d85;">&#39;S&#39;</span></code><code>) </code><code><span style="color:#569cd6;">return</span></code><code> 0;<br />    </code><code><span style="color:#569cd6;">if</span></code><code> (buf[</code><code><span style="color:#47285c;">1</span></code><code>] != </code><code><span style="color:#d69d85;">&#39;U&#39;</span></code><code>) </code><code><span style="color:#569cd6;">return</span></code><code> 0;<br />    </code><code><span style="color:#569cd6;">if</span></code><code> (buf[</code><code><span style="color:#47285c;">2</span></code><code>] != </code><code><span style="color:#d69d85;">&#39;C&#39;</span></code><code>) </code><code><span style="color:#569cd6;">return</span></code><code> 0;<br />    </code><code><span style="color:#569cd6;">if</span></code><code> (buf[</code><code><span style="color:#47285c;">3</span></code><code>] != </code><code><span style="color:#d69d85;">&#39;C&#39;</span></code><code>) </code><code><span style="color:#569cd6;">return</span></code><code> 0;<br />    </code><code><span style="color:#569cd6;">if</span></code><code> (buf[</code><code><span style="color:#47285c;">4</span></code><code>] != </code><code><span style="color:#d69d85;">&#39;!&#39;</span></code><code>) </code><code><span style="color:#569cd6;">return</span></code><code> 0;<br />    </code><code><span style="color:#569cd6;">if</span></code><code> (buf[</code><code><span style="color:#47285c;">5</span></code><code>] != </code><code><span style="color:#d69d85;">&#39;!&#39;</span></code><code>) </code><code><span style="color:#569cd6;">return</span></code><code> 0;<br /><br />    </code><code><span style="color:#569cd6;">return</span></code><code> </code><code><span style="color:#47285c;">1</span></code><code>;<br />} <br /><br /></code><code><span style="color:#569cd6;">int</span></code><code><span style="color:#232323;"> LLVMFuzzerTestOneInput(</span></code><code><span style="color:#569cd6;">const</span></code><code><span style="color:#232323;"> </span></code><code><span style="color:#569cd6;">uint8_t</span></code><code><span style="color:#232323;"> *data, </span></code><code><span style="color:#569cd6;">size_t</span></code><code><span style="color:#232323;"> size)<br /></span></code><code>{<br />    attack_me(data, size);<br />    </code><code><span style="color:#569cd6;">return</span></code><code> </code><code><span style="color:#47285c;">0</span></code><code>;<br />}<br /></code><br />Makefile<br /><div class="codebox"><div class="codebox">all:&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;clang&nbsp;${CFLAGS}&nbsp;simple_fuzzer.c&nbsp;-o&nbsp;simple_fuzzer</div></div><code><br /></code><br />编译之前需要使用export函数将设置环境变量值CFLAGS<br /> export CFLAGS= -fsanitize=fuzzer<br /><br />编译<br />make<br /><br /></div><div class='page'><h1 class='title level-4'>7_Simple_Libfuzzer_1</h1><br/>如果函数参数中仅有缓冲区指针，没有数据长度参数，则此时可以设置数据缓冲区以null结尾，即将目标函数看作以c语言字符串作为参数<br /><br />target.h<code><br /></code><code><span style="color:#569cd6;">int</span></code><code><span style="color:#232323;"><br />parse_complex_data(</span></code><code><span style="color:#569cd6;">char</span></code><code><span style="color:#232323;"> *data_buf)<br /></span></code><code>{<br />    ...<br />    ...<br />}<br /></code><br />fuzzer.c<br /><code><span style="color:#9b9b9b;">#include </span></code><code><span style="color:#d69d85;">&lt;stdlib.h&gt;</span></code><code><br /></code><code><span style="color:#9b9b9b;">#include </span></code><code><span style="color:#d69d85;">&lt;stdio.h&gt;</span></code><code><br /></code><code><span style="color:#9b9b9b;">#include </span></code><code><span style="color:#d69d85;">&quot;target.h&quot;</span></code><code><br /><br /></code><code><span style="color:#569cd6;">extern</span></code><code> </code><code><span style="color:#d69d85;">&quot;C&quot;</span></code><code> </code><code><span style="color:#569cd6;">int</span></code><code><span style="color:#232323;"> LLVMFuzzerTestOneInput(</span></code><code><span style="color:#569cd6;">const</span></code><code><span style="color:#232323;"> </span></code><code><span style="color:#569cd6;">uint8_t</span></code><code><span style="color:#232323;"> *data, </span></code><code><span style="color:#569cd6;">size_t</span></code><code><span style="color:#232323;"> size)<br /></span></code><code>{<br />    </code><code><span style="color:#569cd6;">char</span></code><code> *null_terminated = </code><code><span style="color:#4ec9b0;">malloc</span></code><code>(size+</code><code><span style="color:#47285c;">1</span></code><code>);<br />    </code><code><span style="color:#4ec9b0;">memcpy</span></code><code>(null_terminated, data, size);<br />    null_terminated[size] = </code><code><span style="color:#d69d85;">&#39;\0&#39;</span></code><code>;<br /><br />    </code><em><code><span style="color:#57a64a;">// Insert code below here</span></code></em><code><br />    parse_complex_data(null_terminated)<br />    </code><em><code><span style="color:#57a64a;">// Insert code above here. </span></code></em><code><br />    <br />    </code><code><span style="color:#4ec9b0;">free</span></code><code>(null_terminated);<br />    </code><code><span style="color:#569cd6;">return</span></code><code> </code><code><span style="color:#47285c;">0</span></code><code>;<br />}<br /></code><br /></div><div class='page'><h1 class='title level-4'>8_Simple_Libfuzzer_2</h1><br/>如果目标函数参数中既有数据缓冲区指针，也有数据长度参数，则无需设置数据缓冲区以null结尾，因为函数会根据数据长度参数使用缓冲区数据<br /><br />target.h <br /><code><br /></code><code><span style="color:#569cd6;">int</span></code><code><span style="color:#232323;"> check_first_char(</span></code><code><span style="color:#569cd6;">char</span></code><code><span style="color:#232323;"> c)<br /></span></code><code>{<br />    </code><code><span style="color:#569cd6;">if</span></code><code> (c == </code><code><span style="color:#d69d85;">&#39;A&#39;</span></code><code>)<br />        </code><code><span style="color:#569cd6;">return</span></code><code> </code><code><span style="color:#47285c;">0</span></code><code>;<br />    </code><code><span style="color:#569cd6;">return</span></code><code> </code><code><span style="color:#47285c;">1</span></code><code>;<br />}<br /><br /></code><code><span style="color:#569cd6;">int</span></code><code><span style="color:#232323;"> check_second_char(</span></code><code><span style="color:#569cd6;">char</span></code><code><span style="color:#232323;"> d)<br /></span></code><code>{<br />    </code><code><span style="color:#569cd6;">if</span></code><code> (d == </code><code><span style="color:#d69d85;">&#39;B&#39;</span></code><code>)<br />        </code><code><span style="color:#569cd6;">return</span></code><code> </code><code><span style="color:#47285c;">0</span></code><code>;<br />    </code><code><span style="color:#569cd6;">return</span></code><code> </code><code><span style="color:#47285c;">1</span></code><code>;<br />}<br /><br /></code><code><span style="color:#569cd6;">int</span></code><code><span style="color:#232323;"><br />read_buf(</span></code><code><span style="color:#569cd6;">char</span></code><code><span style="color:#232323;"> *buf, </span></code><code><span style="color:#569cd6;">int</span></code><code><span style="color:#232323;"> size)<br /></span></code><code>{<br />    </code><code><span style="color:#569cd6;">if</span></code><code> (size &lt; </code><code><span style="color:#47285c;">5</span></code><code>)<br />        </code><code><span style="color:#569cd6;">return</span></code><code> </code><code><span style="color:#47285c;">1</span></code><code>;<br /><br />    </code><code><span style="color:#569cd6;">if</span></code><code> (check_first_char(buf[</code><code><span style="color:#47285c;">0</span></code><code>]) == </code><code><span style="color:#47285c;">0</span></code><code> &amp;&amp; check_second_char(buf[</code><code><span style="color:#47285c;">1</span></code><code>]) == </code><code><span style="color:#47285c;">0</span></code><code>)<br />        </code><code><span style="color:#569cd6;">return</span></code><code> </code><code><span style="color:#47285c;">0</span></code><code>;<br />    </code><code><span style="color:#569cd6;">return</span></code><code> </code><code><span style="color:#47285c;">1</span></code><code>;<br /><br />}<br /></code><br />fuzzer.c<br /><code><span style="color:#9b9b9b;">#include </span></code><code><span style="color:#d69d85;">&lt;stdlib.h&gt;</span></code><code><br /></code><code><span style="color:#9b9b9b;">#include </span></code><code><span style="color:#d69d85;">&lt;stdio.h&gt;</span></code><code><br /></code><code><span style="color:#9b9b9b;">#include </span></code><code><span style="color:#d69d85;">&quot;target.h&quot;</span></code><code><br /><br /></code><code><span style="color:#569cd6;">int</span></code><code><span style="color:#232323;"> LLVMFuzzerTestOneInput(</span></code><code><span style="color:#569cd6;">const</span></code><code><span style="color:#232323;"> </span></code><code><span style="color:#569cd6;">uint8_t</span></code><code><span style="color:#232323;"> *data, </span></code><code><span style="color:#569cd6;">size_t</span></code><code><span style="color:#232323;"> size)<br /></span></code><code>{<br />    </code><em><code><span style="color:#57a64a;">// Insert code below here</span></code></em><code><br />   	read_buf(data,size);<br />    </code><em><code><span style="color:#57a64a;">// Insert code above here.</span></code></em><code><br /><br />    </code><code><span style="color:#569cd6;">return</span></code><code> </code><code><span style="color:#47285c;">0</span></code><code>;<br />}<br /></code></div><div class='page'><h1 class='title level-3'>3_Sanitizers</h1><br/></div><div class='page'><h1 class='title level-4'>1_Sanitizers_Introduction</h1><br/><h1>Sanitizers Introduction</h1><br /><br />传统上，模糊器用于查找导致目标应用程序崩溃的应用程序错误。 但是，许多错误不会导致崩溃无条件地发生，并且经常需要特殊的事件序列才能使错误真正使系统崩溃。<br /><br />最重要的是，该错误仍可以触发而不会发生任何崩溃。 考虑例如基于堆的缓冲区溢出的情况。 基于堆的缓冲区溢出（可以从堆上给定缓冲区访问1个字节的索引）不太可能导致崩溃，因为堆上缓冲区之后的第一个字节仍然是内存中的有效地址 。<br /><br />因此，即使我们可以自然地访问内存而不会导致应用程序崩溃，但仍然存在溢出，这在某些情况下可能会导致破坏性的结果和完全的远程代码执行。 在本节中，我们将研究消毒剂的概念，这些技术使我们能够在错误发生时立即捕获错误。<br /><br />LLVM带有以下消毒剂集：<br />• Address sanitizer<br />• Undefinied behavior sanitizer<br />• Memory sanitizer<br />• Leak sanitizer<br />• Thread sanitizer<br />• Data-flow sanitizer<br /><br />在下面的内容中，我们将介绍其中的前四个，因为它们是模糊测试中最相关的四个<br /></div><div class='page'><h1 class='title level-4'>2_Sanitizer practical demonstration _ ADA Logics</h1><br/>Address Sanitizer分析off-by-one漏洞<br />sanitize会分别显示<br />漏洞类型以及触发漏洞是各寄存器的值<br />之后显示漏洞发生时的调用栈情况<br />发生溢出的字节位于一个5字节内存空间右侧<br /><a href=""><img src="images\909-1.png" alt="images\909-1.png" /></a><br /><br />程序在检测到off-by-one漏洞之后，会保存对应测试用例在当前目录，使用该测试用例作为参数运行fuzzer，可以重现漏洞场景<br /><a href=""><img src="images\909-2.png" alt="images\909-2.png" /></a><br /><br /><br />空指针引用示例代码<br /><a href=""><img src="images\909-3.png" alt="images\909-3.png" /></a><br /><br />不适用sanitizer进行编译，运行fuzzer后也能立刻得到报错，报错显示该类错误可以使用<br />Undefined Behavior Sanitizer进行检测<br /><a href=""><img src="images\909-4.png" alt="images\909-4.png" /></a><br /><br />按理说这里应当使用Unberfined Behavior Sanitizer，即-fsanitize=fuzzer,undefined<br />但实际上这里使用了Address Sanitizer，但仍能显示空指针引用错误<br /><a href=""><img src="images\909-5.png" alt="images\909-5.png" /></a><br /><br /><br />内存泄露检测<br /><a href=""><img src="images\909-6.png" alt="images\909-6.png" /></a><br /><br />如果当前fuzzer正在运行address sanitizer，而不想检测程序内存泄露漏洞，则可以在fuzzer后面增加参数<br />即 -detect_leak<br /><a href=""><img src="images\909-7.png" alt="images\909-7.png" /></a></div><div class='page'><h1 class='title level-4'>3_Sanitizers_Notes</h1><br/><h1>Sanitizers Notes</h1><br /><h3>In this section we will discuss the sanitizers:</h3><br />1. Address Sanitizer (ASan)<br />2. Undefined behavior sanitizer (UBSan)<br />3. Memory Sanitizer (MSan)<br />4. Leak Sanitizer (LSan)<br /><br /><br /><h2>Address sanitizer (ASan)</h2><br />地址清理器检测与内存对象有关的错误以及此类对象的无效使用。 这包括以下错误类：<br /><br />• Out-of-bounds memory accesses on heap, stack and globals.（对堆，栈和全局变量的越界内存访问。）<br />• Use-after-free<br />• Use-after-return<br />• Use-after-scope<br />• Double-free<br />• Memory leaks<br /><br /><h3>To compile address sanitizer into a target, we need to include </h3><code>-fsanitize=address</code><h3> as a command line flag during compilation.</h3><br /><br /><h3>ASan example 1 - memory-out-of-bounds read</h3><br /><br /><h3>Consider the following source code:</h3><br /><br />target.h<br /><div class="codebox"><div class="codebox">int&nbsp;attack_me(char&nbsp;*buf,&nbsp;int&nbsp;buf_size)<br /><span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(buf_size&nbsp;&lt;&nbsp;5)<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(buf[0]&nbsp;!=&nbsp;&#39;S&#39;)&nbsp;return&nbsp;0;<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(buf[1]&nbsp;!=&nbsp;&#39;U&#39;)&nbsp;return&nbsp;0;<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(buf[2]&nbsp;!=&nbsp;&#39;C&#39;)&nbsp;return&nbsp;0;<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(buf[3]&nbsp;!=&nbsp;&#39;C&#39;)&nbsp;return&nbsp;0;<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(buf[4]&nbsp;!=&nbsp;&#39;!&#39;)&nbsp;return&nbsp;0;<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(buf[5]&nbsp;!=&nbsp;&#39;!&#39;)&nbsp;return&nbsp;0;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />Attack_me函数接受指向字符串的指针以及指示字符串大小的整数参数，这是许多C函数的常用函数接口。 该函数首先检查缓冲区的大小是否小于5，如果小于5，则返回0。但是，如果缓冲区的大小等于或大于5，则函数继续检查缓冲区的字符。 字符串，直到索引号5，并且字符串的第一个字符等于SUCC！ 然后该函数返回1，否则返回0。<br /><br />但是，此代码中有一个错误，它是一个超出范围的内存读取。 我们可以结合使用模糊器和地址清除器来发现此错误，但是，没有使用地址清除器就无法发现此错误。 考虑以下针对上述功能的模糊器：<br /><br />fuzz.c<br /><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;stdlib.h&gt;<br />#include&nbsp;&lt;stdint.h&gt;<br /><br />#include&nbsp;&quot;target.h&quot;<br /><br />int&nbsp;LLVMFuzzerTestOneInput(const&nbsp;uint8_t&nbsp;*data,&nbsp;size_t&nbsp;size)<span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;attack_me((char*)data,&nbsp;size);<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />编译该代码并按常规方式对其进行模糊处理，我们得到以下结果：<br /><br /><a href=""><img src="images\910-1.png" alt="images\910-1.png" /></a><br /><br />模糊器将继续运行，并且不会检测到任何崩溃或类似事件，从而使我们确信源代码没有错误。 但是，如果我们运行相同的实验，但是在启用了地址清理器的情况下编译了目标源代码，则将得到以下结果：<br /><br /><a href=""><img src="images\910-2.png" alt="images\910-2.png" /></a><br /><br />在此运行中，发生了非常不同的行为！ 我们从地址清理器收到一条消息，描述发生了错误，消息的第一部分指示了特定的错误：<br /><br /><a href=""><img src="images\910-3.png" alt="images\910-3.png" /></a><br /><br /><br /><h3>ASan example 2 - Double-free</h3><br /><br /><h3>Consider the following source code:</h3><br /><br /><h3>target.h</h3><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;string.h&gt;<br /><br />//&nbsp;Expects&nbsp;a&nbsp;null-terminated&nbsp;string.<br />void&nbsp;attack_me(char&nbsp;*input_buf)<br /><span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;buf_len&nbsp;=&nbsp;strlen(input_buf);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*dynamic_string&nbsp;=&nbsp;malloc(buf_len+1);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dynamic_string[buf_len]&nbsp;=&nbsp;&#39;\0&#39;;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(strcmp(input_buf,&nbsp;&quot;Succ!&quot;)&nbsp;==&nbsp;0)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(dynamic_string);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(dynamic_string);<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />如果输入的字符串等于“ Succ！”，则上述函数将执行双重释放错误。 具体来说，如果输入字符串是“ Succ！” 那么变量dynamic_string将被释放两次：一次在第12行，一次在第15行。我们可以使用我们的常规模糊器对以null结尾的字符串进行模糊处理：<br /><br /><h3>fuzz.c</h3><br /><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;stdlib.h&gt;<br />#include&nbsp;&lt;stdint.h&gt;<br /><br />#include&nbsp;&quot;target.h&quot;<br /><br />int&nbsp;LLVMFuzzerTestOneInput(const&nbsp;uint8_t&nbsp;*data,&nbsp;size_t&nbsp;size)<span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*new_str&nbsp;=&nbsp;(char&nbsp;*)malloc(size+1);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(new_str&nbsp;==&nbsp;NULL){<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(new_str,&nbsp;data,&nbsp;size);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_str[size]&nbsp;=&nbsp;&#39;\0&#39;;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attack_me(new_str);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(new_str);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />编译此代码并在不使用地址清理程序的情况下对其进行模糊处理，我们得到以下结果：<br /><br /><a href=""><img src="images\910-4.png" alt="images\910-4.png" /></a><br /><br />编译此代码并使用地址清理器对其进行模糊处理，我们得到以下结果：<br /><br /><a href=""><img src="images\910-5.png" alt="images\910-5.png" /></a><br /><br /><br /><h2>Undefined behavior sanitizer (UBSan)</h2><br />未定义行为清理器可以检测以下漏洞<br />1、使用未对齐或空指针<br />2、有符号整数溢出<br />3、目标数据转换为浮点数、浮点数转换为目标数据、目标数据与浮点数相互转换，可能导致目标数据溢出<br /><br />要将未定义的行为清理器编译到我们的目标中，我们需要使用-fsanitize = undefined编译器标志。<br /><br /><br /><h3>UBSan example - signed integer overflow</h3><br /><h3>To observe the behavior of UBSan consider the following piece of code:</h3><br /><br /><h3>target.h</h3><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;string.h&gt;<br /><br />//&nbsp;Expects&nbsp;null-terminated&nbsp;string<br />int&nbsp;attack_me(char&nbsp;*buf)<br /><span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;val&nbsp;=&nbsp;0x7fffffff;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(strlen(buf)&nbsp;!=&nbsp;4)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(buf[0]&nbsp;==&nbsp;&#39;B&#39;&nbsp;&amp;&amp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf[1]&nbsp;==&nbsp;&#39;U&#39;&nbsp;&amp;&amp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf[2]&nbsp;==&nbsp;&#39;G&#39;)&nbsp;{<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;+=&nbsp;(int)strlen(buf);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;val;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;val;<br /><span style="color:#000000;font-weight:400">}</span></div></div>	<br /><br />上面的函数接受以null终止的字符串作为输入，并且该字符串等效于“ BUG”。 那么字符串的长度将被添加到本地val变量中。 但是，val变量是一个初始化为0x7fffffff的有符号整数，这意味着如果将大于零的数字添加到该变量，则该变量将导致有符号整数溢出。 有符号整数溢出本身不会引起任何错误，但是，它们通常是导致错误在执行的较晚时间发生的原因，并且在整个历史上，有符号整数溢出都导致了一些最讨厌的错误。<br /><br /><h3>We can use the following fuzzer to attack this code:</h3><br /><br /><div class="codebox"><div class="codebox">int&nbsp;LLVMFuzzerTestOneInput(const&nbsp;uint8_t&nbsp;*data,&nbsp;size_t&nbsp;size)<span style="color:#000000;font-weight:400">{</span><br />	char&nbsp;*new_str&nbsp;=&nbsp;(char&nbsp;*)malloc(size+1);<br />	if&nbsp;(new_str&nbsp;==&nbsp;NULL){<br />		return&nbsp;0;<br />	}<br />	memcpy(new_str,&nbsp;data,&nbsp;size);<br />	new_str[size]&nbsp;=&nbsp;&#39;\0&#39;;<br /><br />	attack_me(new_str);<br /><br />	free(new_str);<br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><h3>Compiling the code without sanitizer and running the fuzzer produces the following result:</h3><br /><br /><a href=""><img src="images\910-6.png" alt="images\910-6.png" /></a><br /><br /><h3>Compiling the code with sanitizer and running the fuzzer produces the following result:</h3><br /><br /><a href=""><img src="images\910-7.png" alt="images\910-7.png" /></a><br /><br /><h2>Memory Sanitizer (MSan)</h2><br />内存清理程序用于捕获未初始化的内存读取的使用情况，这意味着它可以捕获读取内存且未初始化内存的所有情况。 因此，未初始化的内存读取不是ASAN检测到的越界读取，而是可以导致更严重错误的非崩溃错误。<br /><br />要将内存清理程序编译到目标中，我们需要使用-fsanitize = memory编译器标志。 <br /><br /><h3>MSan example - read of unitialised memory</h3><br /><br /><h3>msan_example.cc</h3> （cc表示该源代码为c++，需要使用clang++编译）<br /><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;stdlib.h&gt;<br /><br />int&nbsp;main(int&nbsp;argc,&nbsp;char**&nbsp;argv)&nbsp;<span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;int*&nbsp;a&nbsp;=&nbsp;new&nbsp;int[10];<br />&nbsp;&nbsp;a[5]&nbsp;=&nbsp;0;<br />&nbsp;&nbsp;if&nbsp;(a[argc])<br />&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;xx\n&quot;);<br />&nbsp;&nbsp;return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />我们将不会为这个示例开发一个模糊器，因为MSan的行为类似于我们将模糊与消毒剂结合在一起的其他示例。 相反，我们只是将源代码编译为常规应用程序并直接运行即可：<br /><br /><a href=""><img src="images\910-8.png" alt="images\910-8.png" /></a><br /><br />在这种情况下，我们可以简单地观察运行应用程序的错误报告，还可以观察到消毒剂和模糊器是两个单独的实体。 特别是，我们可以在不使用消毒剂的情况下编译我们的模糊器和目标代码，并且还可以在启用消毒剂但没有任何模糊性的情况下编译给定的代码库。<br /><br /><h2>Leak Sanitizer (LSan)</h2><br />Leak Sanitizer用于捕获发生内存泄漏的任何时间，并且可以与Address Sanitizer结合使用，也可以单独使用。<br /><br /><h3>LSan example - memory leak</h3><br /><br /><h3>Consider the following source code:</h3><br /><br />target.h<br /><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdlib.h&gt;<br />#include&nbsp;&lt;string.h&gt;<br /><br />int<br />attack_me_lsan(char&nbsp;*buf)<br /><span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*p;<br />&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;=&nbsp;malloc(10);<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(strcmp(buf,&nbsp;&quot;Succ!&quot;))<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Leak&nbsp;the&nbsp;allocated&nbsp;buffer<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;=&nbsp;NULL;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;else<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(p);<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />内存泄漏是要捕获的重要错误，但是，某些应用程序受内存泄漏的影响可能较小。 例如，与执行时间较长的应用程序（例如浏览器）相比，瞬态应用程序（即，执行时间短的应用程序，例如binutils应用程序）不担心内存泄漏。 为此，如果要模糊具有大量内存泄漏的应用程序，则应避免使用泄漏清理程序，而应该捕获更严重的错误，这是适当的。<br /><br /><h3>We can create a simple fuzzer for the above example:</h3><br /><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;stdlib.h&gt;<br />#include&nbsp;&lt;string.h&gt;<br /><br />#include&nbsp;&quot;target.h&quot;<br /><br />int&nbsp;LLVMFuzzerTestOneInput(const&nbsp;uint8_t&nbsp;*data,&nbsp;size_t&nbsp;size)<span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*new_str&nbsp;=&nbsp;(char&nbsp;*)malloc(size+1);<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(new_str&nbsp;==&nbsp;NULL){<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;memcpy(new_str,&nbsp;data,&nbsp;size);<br />&nbsp;&nbsp;&nbsp;&nbsp;new_str[size]&nbsp;=&nbsp;&#39;\0&#39;;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;attack_me(new_str);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;free(new_str);<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><h3>Then we can compile and run the sample which gives us the output:</h3><br /><a href=""><img src="images\910-9.png" alt="images\910-9.png" /></a><br /><br />然后，我们可以在启用了地址清理程序的情况下对其进行编译（其中包含泄漏清理程序）<br /><br /><a href=""><img src="images\910-10.png" alt="images\910-10.png" /></a><br /><br />自然，如果要分析目标的错误，最合适的选择是修复内存泄漏。 但是，这可能并不总是经济，理想或可行的，并且由于这些原因，Libfuzzer带有一个选项，可以在启动模糊器时使用-detect_leaks = 0标志来抑制这些警告。 注意，我们不必重新编译模糊器或目标代码。<br /><br /><a href=""><img src="images\910-11.png" alt="images\910-11.png" /></a><br /><br />总结<br /><a href=""><img src="images\910-12.png" alt="images\910-12.png" /></a><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /></div><div class='page'><h1 class='title level-4'>4_Sanitizer_example_finding heartbleed</h1><br/><h1>使用sanitizer发现心脏流血漏洞</h1><br />现在，我们已经看到了sanitizer的工作原理，在这一点上，有必要真正了解sanitizer和fuzz组合的强大功能。 因此，在此示例中，我们将介绍如何结合使用LibFuzzer和Address Sanitizer查找Heartbleed错误。<br /><br />首先，我们将模糊器放置在名为target.cc的文件中<br /><br /><a href="http://target.cc/">target.cc</a><br /><br /><div class="codebox"><div class="codebox">//&nbsp;Copyright&nbsp;2016&nbsp;Google&nbsp;Inc.&nbsp;All&nbsp;Rights&nbsp;Reserved.<br />//&nbsp;Licensed&nbsp;under&nbsp;the&nbsp;Apache&nbsp;License,&nbsp;Version&nbsp;2.0&nbsp;(the&nbsp;&quot;License&quot;);<br />#include&nbsp;&lt;openssl/ssl.h&gt;<br />#include&nbsp;&lt;openssl/err.h&gt;<br />#include&nbsp;&lt;assert.h&gt;<br />#include&nbsp;&lt;stdint.h&gt;<br />#include&nbsp;&lt;stddef.h&gt;<br /><br />SSL_CTX&nbsp;*Init()&nbsp;{<br />&nbsp;&nbsp;SSL_library_init();<br />&nbsp;&nbsp;SSL_load_error_strings();<br />&nbsp;&nbsp;ERR_load_BIO_strings();<br />&nbsp;&nbsp;OpenSSL_add_all_algorithms();<br />&nbsp;&nbsp;SSL_CTX&nbsp;*sctx;<br />&nbsp;&nbsp;assert&nbsp;(sctx&nbsp;=&nbsp;SSL_CTX_new(TLSv1_method()));<br />&nbsp;&nbsp;/*&nbsp;These&nbsp;two&nbsp;file&nbsp;were&nbsp;created&nbsp;with&nbsp;this&nbsp;command:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;openssl&nbsp;req&nbsp;-x509&nbsp;-newkey&nbsp;rsa:512&nbsp;-keyout&nbsp;server.key&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-out&nbsp;server.pem&nbsp;-days&nbsp;9999&nbsp;-nodes&nbsp;-subj&nbsp;/CN=a/<br />&nbsp;&nbsp;*/<br />&nbsp;&nbsp;assert(SSL_CTX_use_certificate_file(sctx,&nbsp;&quot;runtime/server.pem&quot;,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SSL_FILETYPE_PEM));<br />&nbsp;&nbsp;assert(SSL_CTX_use_PrivateKey_file(sctx,&nbsp;&quot;runtime/server.key&quot;,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SSL_FILETYPE_PEM));<br />&nbsp;&nbsp;return&nbsp;sctx;<br />}<br />extern&nbsp;&quot;C&quot;&nbsp;int&nbsp;LLVMFuzzerTestOneInput(const&nbsp;uint8_t&nbsp;*Data,&nbsp;size_t&nbsp;Size)&nbsp;<span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;static&nbsp;SSL_CTX&nbsp;*sctx&nbsp;=&nbsp;Init();<br />&nbsp;&nbsp;SSL&nbsp;*server&nbsp;=&nbsp;SSL_new(sctx);<br />&nbsp;&nbsp;BIO&nbsp;*sinbio&nbsp;=&nbsp;BIO_new(BIO_s_mem());<br />&nbsp;&nbsp;BIO&nbsp;*soutbio&nbsp;=&nbsp;BIO_new(BIO_s_mem());<br />&nbsp;&nbsp;SSL_set_bio(server,&nbsp;sinbio,&nbsp;soutbio);<br />&nbsp;&nbsp;SSL_set_accept_state(server);<br />&nbsp;&nbsp;BIO_write(sinbio,&nbsp;Data,&nbsp;Size);<br />&nbsp;&nbsp;SSL_do_handshake(server);<br />&nbsp;&nbsp;SSL_free(server);<br />&nbsp;&nbsp;return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />其次，我们创建一个名为runtime的目录，并在该目录中放置两个文件：<br /><br /><h3>server.key</h3><br /><br /><div class="codebox"><div class="codebox">-----BEGIN&nbsp;PRIVATE&nbsp;KEY-----<br />MIIBVAIBADANBgkqhkiG9w0BAQEFAASCAT4wggE6AgEAAkEA1AdZNDVOA9cXm97f<br />erp1bukz2kohjToJS6Ma8fOb36VV9lQGmDNsJanXFiqafOgV+kh1HXqZ3l1I0JmZ<br />71b+QQIDAQABAkAHGfPn5r0lLcgRpWZQwvv56f+dmQwEoeP7z4uwfNtEo0JcRD66<br />1WRCvx3LE0VbNeaEdNmSPiRXhlwIggjfrBi9AiEA9UusPBcEp/QcPGs96nQQdQzE<br />fw4x0HL/eSV3qHimT6MCIQDdSAiX4Ouxoiwn/9KhDMcZXRYX/OPzj6w8u1YIH7BI<br />ywIgSozbJdAhHCJ2ym4VfUIVFl3xAmSAA0hQGLOocE1qzl0CIQDRicOxZmhqBiKA<br />IgznOn1StEYWov+MhRFZVSBLgw5gbwIgJzOlSlu0Y22hEUsLCKyHBrCAZZHcZ020<br />20pfogmQYn0=<br />-----END&nbsp;PRIVATE&nbsp;KEY-----</div></div><br /><br /><h3>server.pem</h3><br /><br /><div class="codebox"><div class="codebox">-----BEGIN&nbsp;CERTIFICATE-----<br />MIIBYTCCAQugAwIBAgIJAMPQQtUHkx+KMA0GCSqGSIb3DQEBCwUAMAwxCjAIBgNV<br />BAMMAWEwHhcNMTYwOTI0MjIyMDUyWhcNNDQwMjA5MjIyMDUyWjAMMQowCAYDVQQD<br />DAFhMFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBANQHWTQ1TgPXF5ve33q6dW7pM9pK<br />IY06CUujGvHzm9+lVfZUBpgzbCWp1xYqmnzoFfpIdR16md5dSNCZme9W/kECAwEA<br />AaNQME4wHQYDVR0OBBYEFCXtEo9rkLuKGSlm0mFE4Yk/HDJVMB8GA1UdIwQYMBaA<br />FCXtEo9rkLuKGSlm0mFE4Yk/HDJVMAwGA1UdEwQFMAMBAf8wDQYJKoZIhvcNAQEL<br />BQADQQCnldOnbdNJZxBO/J+979Urg8qDp8MnlN0979AmK1P5/YzPnAF4BU7QTOTE<br />imS5qZ0MvziBa81nVlnnFRkIezcD<br />-----END&nbsp;CERTIFICATE-----</div></div><br /><br />然后，我们上移一个目录并执行以下步骤：<br /><br /><div class="codebox"><div class="codebox">#&nbsp;Get&nbsp;the&nbsp;openssl&nbsp;source&nbsp;code<br />git&nbsp;clone&nbsp;https://github.com/openssl/openssl.git<br />cd&nbsp;openssl<br />git&nbsp;checkout&nbsp;OpenSSL_1_0_1f<br /><br /><br />#&nbsp;Compile&nbsp;it&nbsp;with&nbsp;fuzzer&nbsp;set&nbsp;up<br />export&nbsp;CC=&quot;clang&nbsp;-fsanitize=fuzzer-no-link,address&quot;<br />./config<br />make&nbsp;clean<br />make<br /><br />#&nbsp;Compile&nbsp;the&nbsp;fuzzer<br />clang++&nbsp;-fsanitize=fuzzer,address&nbsp;-DCERT_PATH=&quot;$PWD/../&quot;&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;../target.cc&nbsp;libssl.a&nbsp;libcrypto.a&nbsp;-Iinclude/&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-o&nbsp;fuzzer<br /><br />#&nbsp;Ensure&nbsp;the&nbsp;key/cert&nbsp;is&nbsp;the&nbsp;right&nbsp;one<br />rm&nbsp;-rf&nbsp;runtime<br />cp&nbsp;-rf&nbsp;../runtime&nbsp;.<br /></div></div><br /><br />上面的命令将放置一个名为fuzzer的文件，执行该fuzzer后，我们将获得类似于以下内容的输出：<br /><br /><a href=""><img src="images\911-1.png" alt="images\911-1.png" /></a><br /><br />上面的输出显示了Heartbleed堆溢出漏洞。 我们将不详细讨论该漏洞本身，因为该漏洞在其他很多地方都涉及。 但是，该示例表明，只需花费很少的精力，我们就可以成功捕获高危安全漏洞。<br /><br />访问未初始化内存bug示例<br /><a href=""><img src="images\911-2.png" alt="images\911-2.png" /></a><br /><br />使用Memory Sanitizer检测<br /><a href=""><img src="images\911-3.png" alt="images\911-3.png" /></a><br /></div><div class='page'><h1 class='title level-4'>注意点</h1><br/>address sanitizer是最常用的sanitizer<br />部分项目中将address sanitizer编译到可执行文件中是很困难的，表现在编译失败</div><div class='page'><h1 class='title level-3'>4_RealWorld walkthroughs</h1><br/></div><div class='page'><h1 class='title level-4'>1_Introducing_Libcaca_fuzzing</h1><br/><h1>针对进行Libcaca模糊测试</h1><br />在课程的这一点上，我们已经使用LibFuzzer涵盖了模糊测试的必要组件，这些组件使我们能够实际发现实际项目中的错误。 因此，下一个有意义的步骤是将所有这些技术结合在一起，针对给定的项目发起模糊测试，在接下来的几个视频中，我们将做到这一点。 具体来说，接下来的几段视频将对Libcaca项目进行全面的模糊测试。<br /><br />Libcaca是一个用于在命令行上生成彩色ASCII艺术的项目，尽管它已经开发了十多年，而且一些大型工具（例如VLC）也依赖于它，但它主要是一个玩具项目。 我们努力的目标是从项目开始重新设计，然后逐步开发模糊测试器，并发现该工具中是否存在任何错误。  Libcaca项目的源代码可在以下位置找到：https：//github.com/cacalabs/libcaca。<br /><br />为了完成LibCaca的完整模糊测试活动，以下视频将显示步骤：<br /><br />   如何编译项目并详细观察其编译步骤。<br />   如何使用Clang以及必要的仪器和消毒剂支持来编译项目。<br />   如何为项目构建第一个模糊器。<br />   如何试验和改进模糊器。<br />   如何在项目中检测错误并对该错误进行根本原因分析</div><div class='page'><h1 class='title level-4'>2_From start to bugs with libcaca - 1 _ ADA Logics</h1><br/>fuzz目标<br /><a href=""><img src="images\915-1.png" alt="images\915-1.png" /></a><br /><br />克隆整个项目，并查看项目的结构<br />其中caca目录中的caca.c疑似保存核心代码，怀疑是fuzz的对象<br />example目录疑似保存调用该库的示例代码<br /><a href=""><img src="images\915-2.png" alt="images\915-2.png" /></a><a href=""><img src="images\915-3.png" alt="images\915-3.png" /></a><br /><br />开源lib项目中常存在使用该lib的示例代码，为了进行fuzz需要关注此类代码，例如项目中的example等项目，此类示例代码会用很简洁的方式调用lib库，所以很容易将其转为fuzzer <br /> <br />example目录中.c文件很可能是调用caca共享库的应用的源码<br /><a href=""><img src="images\915-4.png" alt="images\915-4.png" /></a><br /><br />下一步，着重于如何正确编译代码，如果lib库很复杂，编译过程可能很复杂<br />查看readme寻找相关编译信息，根据readme，首先如果是通过git获取的源码，需要运行bootstrap脚本从而生成配置信息文件，之后运行配置信息文件，最后make<br /><a href=""><img src="images\915-5.png" alt="images\915-5.png" /></a><br /><br />运行bootstrap脚本，显示automake缺失，安装automake，此时apt会将应用安装到docker镜像中<br /> <a href=""><img src="images\915-6.png" alt="images\915-6.png" /></a><br /> <br /> 再次运行bootstrap，显示缺少libtool，则安装libtool<br /> <a href=""><img src="images\915-7.png" alt="images\915-7.png" /></a><br /> <br /> 再次运行，pkg-config缺失，同样进行安装<br /> <a href=""><img src="images\915-8.png" alt="images\915-8.png" /></a><br /> <br /> 再次运行bootstrap，运行完成后发现目录中出现configure程序<br /> <a href=""><img src="images\915-9.png" alt="images\915-9.png" /></a><br /> <br /> 根据readme要求，运行configure程序<br /> <a href=""><img src="images\915-10.png" alt="images\915-10.png" /></a><br /> <br /> configure运行完毕后，目录下出现Makefile文件，则根据readme，使用meke命令进行编译<br /> <a href=""><img src="images\915-11.png" alt="images\915-11.png" /></a><a href=""><img src="images\915-12.png" alt="images\915-12.png" /></a><br /> <br /> make执行完毕，理应获得一系列可执行文件，进入example目录，发现可执行文件<br /> 此类可执行文件在源码中不存在，是make之后产生的<br /> <a href=""><img src="images\915-13.png" alt="images\915-13.png" /></a><br /> <br /> 运行一个示例可执行文件<br /> <a href=""><img src="images\915-14.png" alt="images\915-14.png" /></a><br /> <br /> <br /> 此时需要弄清编译过程中使用的flag，从而让-fsanitize增加到编译选项中<br /> 执行make clean，该指令清除上次的make命令所产生的object文件（后缀为“.o”的文件）及可执行文件，一般在进行多次make之前，均需要清除上一次make指令所产生的.o和可执行文件，从而保证正确编译 详见<a href="linux--linux命令积累--make.html">make</a><br /> <a href=""><img src="images\915-15.png" alt="images\915-15.png" /></a><br /> <br /> 重新编译，使用make V=1命令，从而显示所有实际执行的编译指令<br /> <a href=""><img src="images\915-16.png" alt="images\915-16.png" /></a><br /> <br /> 输出的命令中可以看到针对执行.c文件的gcc编译、链接过程，但是此类指令使用gcc进行编译，而我们的目的是使用clang进行编译，所以需要将编译使用的gcc替换为clang<br /> <a href=""><img src="images\915-17.png" alt="images\915-17.png" /></a><br /> <br /> 再次使用make clean清理上次编译过程中生成的中间文件和可执行文件<br /> make脚本使用环境变量指定c/c++的编译器，通过export修改环境变量可以更换编译器<br /> 修改环境变量之后，重新运行configure，重新生成makefile文件 <br /> <a href=""><img src="images\915-18.png" alt="images\915-18.png" /></a><br /> <br /> 重新执行make v=1，发现编译器已经被替换为clang<br /> <a href=""><img src="images\915-19.png" alt="images\915-19.png" /></a><br /> <br /> 运行example文件夹下的示例程序text，正常运行，说明clang编译项目可行<br /> <br /> 下一步将-fsanitize=fuzzer-no-link加入到lib库的编译过程，此时因为仅仅编译lib库，lib库中没有增加fuzzer逻辑，所以需要先将lib单独编译为so文件，之后fuzzer编译时再与fuzer链接<br /><a href=""><img src="images\915-20.png" alt="images\915-20.png" /></a> <br /><br />使用make clean清理<br />运行configure重新生成makefile文件<br />重新编译 make v=1<br />重新编译后发现 clang和-fsanitizer已经被加入编译，通常来说，编译过程中使用正确的flag是很不容易的（即使用-fsanitize作为flag编译项目很可能失败）<br /><a href=""><img src="images\915-21.png" alt="images\915-21.png" /></a><br /><br />尝试运行示例程序，发现程序正常运行，说明编译用到flag是正确的<br /><a href=""><img src="images\915-22.png" alt="images\915-22.png" /></a><br /><br />下一步需要构造fuzzer并编译，这一步通常参考示例文件，复用其对libcaca库的调用方式<br /><br />选择text示例程序，因为该程序看上去足够简单并且与运行速度很快，合适根据该示例代码编写fuzzer<br /><a href=""><img src="images\915-23.png" alt="images\915-23.png" /></a><br /><br />查看text.c文件源码，代码声明了buffer和len变量，疑似缓冲区指针与其长度，适合libfuzz直接传递参数，并且caca_import_canvas_from_memory函数调用过程中参数&quot;text&quot;字符可能指示了该源码对应可执行文件text<br /><br />caca_import_canvas_from_memory函数前三个参数中，第一个参数可以直接生成，二三个参数分别为字符串指针与字符串长度，说明该函数适合于进行fuzz测试<br /><a href=""><img src="images\915-24.png" alt="images\915-24.png" /></a><br /><br />根据text.c源码分析，caca_import_canvas_from_memory函数调用完成后，还需要调用一些释放函数，估计堆空间内存释放有关，写fuzzer时该部分内容也需要被考虑<br /><a href=""><img src="images\915-25.png" alt="images\915-25.png" /></a><br /><br />下一步需要确定text该可执行文件是如何被编译，从而为编译fuzzer打下基础<br />首先make clean清理<br />make命令重新编译，但此时将输出重定向到txt文件方便后期分析<br /><a href=""><img src="images\915-26.png" alt="images\915-26.png" /></a><br /><br />less分析txt文件，使用/可以进行搜索，此时搜索text.c，发现如下内容<br />以下若干命令中，使用到了codec目录下的text.c，并且命令输出的文件与text.o无关，所以应当与可执行文件text无关<br /><a href=""><img src="images\915-27.png" alt="images\915-27.png" /></a><br />下面这部分命令将text.c编译为text.o，是构造text的关键命令<br /><a href=""><img src="images\915-28.png" alt="images\915-28.png" /></a><br /><br />此时搜搜text.o，查看其是如何被进一步处理的<br />搜索结果如下，<br />其中1、4部分仅仅用于显示下一条要执行的指令，分别对应实际执行的指令2、5<br />可以看到1中显示了指令2中所有参数的格式，而2才是实际执行的指令，相似情况也存在于4、5指令中<br />指令3也是实际执行的指令，并且该指令的输出中包括了text.o<br />故实际上用于将text.o编译为text的指令仅有3、5，其余部分可以不要<br /><a href=""><img src="images\915-29.png" alt="images\915-29.png" /></a><br /><br />此时进入example目录，创建能够编译fuzzer的脚本z_fuzz_build.sh，之所以选择example目录，是因为我们是根据text的编译过程构造fuzz的编译过程，而text的源码以及可执行文件均生成在example文件中，所以其编译text的指令也是基于example目录的<br /><a href=""><img src="images\915-30.png" alt="images\915-30.png" /></a><br /><br />将上文中3、5两部分编译指令写入脚本<br /><a href=""><img src="images\915-31.png" alt="images\915-31.png" /></a><br /><br /> 修改指令，将红框中的部分去掉，从而得到两条clang指令，其中第一条指令将text.c编译为text.o，第二条指令将text.o链接libcaca，在.libs目录生成可执行文件text<br /> <a href=""><img src="images\915-32.png" alt="images\915-32.png" /></a><br /> <br /> 给z_fuzz_build.sh赋予执行权限，并将.libs目录下已有的text删除，重新执行z_fuzz_build.sh，看是否能成功编译text，如果编译成功，会在.libs目录下重新生成text文件<br /> <a href=""><img src="images\915-33.png" alt="images\915-33.png" /></a><br /> <br />编写fuzzer，首先拷贝text.c文件中main函数的前半部分，经过修改，从而完成fuzzer对被fuzz函数的调用<br /><a href=""><img src="images\915-34.png" alt="images\915-34.png" /></a><br /><br />创建text_fuzz.c，将代码拷贝进去，同时根据text.c增加对pig的释放函数<br /><a href=""><img src="images\915-35.png" alt="images\915-35.png" /></a><br /><br />再次基础上将mian函数修改为LLVMFuzzerTestOneInput<br /><a href=""><img src="images\915-36.png" alt="images\915-36.png" /></a><br /><br />修改z_fuzz_build.sh，将原先的所有text改为text_fuzz，并且需要将第二条编译指令的fsanitizer修改为fuzzer，因为此时text_fuzz.c中没有main函数，需要使用libfuzzer中main函数，同时可以将第二条指令的-o 参数修改为text_fuzz，从而将可执行文件生成在当前目录<br /><a href=""><img src="images\915-37.png" alt="images\915-37.png" /></a><br /><br />运行z_fuzz_build.sh脚本编译fuzzer<br /><a href=""><img src="images\915-38.png" alt="images\915-38.png" /></a><br /><br />运行该fuzzer，显示加载libcaca的时候出错<br /><a href=""><img src="images\915-39.png" alt="images\915-39.png" /></a><br /><br />根据z_fuzz_build.sh脚本，libcaca.so位于../caca/.lib目录下<br />使用find命令在上级目录中搜索.so文件，通过export将libcaca目录增加到lib库文件目录环境变量中，注意$PWD表示当前目录，故之后运行fuzzer也需要在当前目录进行<br /> <a href=""><img src="images\915-40.png" alt="images\915-40.png" /></a><br /> <br />之后运行fuzzer，发现fuzzer运行正常，之后的步骤中需要结合sanitizer，其中最重要的就是address sanitizer，同时可以针对libfuzze写更多的fuzzer，从而覆盖libfuzzer攻击面<br /><br /><br /> <br /><br /><br /><br /> <br /> <br /> <br /> <br /><br /><br /><br /><br /></div><div class='page'><h1 class='title level-4'>3_From start to bugs with libcaca - 2 _ ADA Logics</h1><br/>以之前的工作为基础，持续推进fuzz发现漏洞，主要有两个思路<br />1、编译过程中加入sanitize，最常用的是address sanitizer<br />2、针对更多的函数编写fuzzer<br /><br />查看当前cflags以及cxxflags的值<br /><a href=""><img src="images\916-1.png" alt="images\916-1.png" /></a><br /><br />执行make clean清理本次编译结果<br /><br />使用export修改环境变量<br /><a href=""><img src="images\916-2.png" alt="images\916-2.png" /></a><br /><br />运行configure程序，生成makefile文件<br /><br />运行make v=1，确定sanitizer被加入到编译选项中<br /><a href=""><img src="images\916-3.png" alt="images\916-3.png" /></a><br /><br />编译完成后，尝试运行text等示例，从而判断编译成功<br /><br />将address sanitizer加入到fuzzer编译脚本中<br /><a href=""><img src="images\916-4.png" alt="images\916-4.png" /></a><br /><br />运行脚本，得到fuzzer可执行文件<br /><br />运行fuzzer，发现cov到120后不再增长，且没有异常，这说明被fuzz函数可能没有bug，所以需要修改现有fuzzer或创建新fuzzer，从而fuzz新函数<br /><br />修改现有fuzzer的主要思路是修改被fuzz函数的参数<br />第一次修改仅将caca_create_canvas函数的参数从(0,0) 改为(10,10)<br /><a href=""><img src="images\916-5.png" alt="images\916-5.png" /></a><br /><br />重新编译fuzzer，运行fuzzer，此时fuzzer的cov达到132时就不再增长，虽无bug出现，但代码覆盖率相较之前有所提高<br /> <a href=""><img src="images\916-6.png" alt="images\916-6.png" /></a><br /> <br />此时再次将caca_create_canvas函数参数修改为(100,100)，并重新编译，运行fuzzer，发现代码覆盖率最终仍未132，且无bug触发，说明参数从10到100并未对fuzz效果有影响<br /><br />尝试修改caca_import_canvas_from_memory函数参数从而提升fuzz效果<br />通过在libcaca源码中搜索该函数，查看该函数在libcaca内部有哪些被调用方式<br /><a href=""><img src="images\916-7.png" alt="images\916-7.png" /></a><a href=""><img src="images\916-8.png" alt="images\916-8.png" /></a><br /><br />搜索结果中，进入caca/codec/import.v文件，找到caca_import_canvas_from_memory函数实现<br />根据函数实现，第四个参数format可能有五种情况，均可在fuzz测试时使用<br /><a href=""><img src="images\916-9.png" alt="images\916-9.png" /></a><br /><br />将fuzzer中caca_import_canvas_from_memory函数最后一个参数改为caca，并重新编译，运行，<br /><a href=""><img src="images\916-10.png" alt="images\916-10.png" /></a><br /><br />发现存在堆溢出，根据输出，bug出现在sscanu32函数中，该函数尝试读取四字节的数据，根据函数名，该函数左右可能为根据指针，读取32位无符号整数并转为unsigned int，而指针指向了未分配内存，从而导致bug<br /><a href=""><img src="images\916-11.png" alt="images\916-11.png" /></a><br /><br />查看sscanu32函数（通过fuzzer输出可以确定该函数位于import.c文件，其32行为bug产生位置，即memcpy）<br /><a href=""><img src="images\916-12.png" alt="images\916-12.png" /></a><br /><a href=""><img src="images\916-13.png" alt="images\916-13.png" /></a><br /><br />根据调用栈，定位sscanu32在import.c335行的位置被调用<br /><a href=""><img src="images\916-14.png" alt="images\916-14.png" /></a><br /><a href=""><img src="images\916-15.png" alt="images\916-15.png" /></a><br /><br />向上追溯，其关键参数buf为import_caca函数直接传入，并未验证有效性，传给sscanu32函数，从而导致bug<br />即import函数的两个参数data与size，当sscanu32函数使用data+4+16+f*32作为参数时，应当判断size是否小于（data+4+16+f*32）+4，若小于，则在sscanu32函数中就会读取未分配的堆空间内存<br /><a href=""><img src="images\916-16.png" alt="images\916-16.png" /></a><br /><br />分析导致溢出的输入<br /><a href=""><img src="images\916-17.png" alt="images\916-17.png" /></a><br /><br />可以使用crash文件作为参数，多次调用fuzzer，从而以验证bug可以稳定触发<br /><br />为了验证该bug的确是caca_import_create_canvas函数的&quot;caca&quot;参数导致的，将caca_create_canvas参数改回(0,0)，重新编译并运行<br /><a href=""><img src="images\916-18.png" alt="images\916-18.png" /></a><br /><br />发现报错信息与之前的不同，out of memory的错误<br /><a href=""><img src="images\916-19.png" alt="images\916-19.png" /></a><br /><br />再次运行fuzzer，得到与之前相同函数的堆溢出bug，从而证明caca_create_canvas参数为(0,0)时也能触发bug，说明caca_import_create_canvas函数的&quot;caca&quot;参数是导致bug的变量<br /><a href=""><img src="images\916-20.png" alt="images\916-20.png" /></a><br /><br /><br />此时已经确定caca_import_create_canvas函数使用参数&quot;caca&quot;时会导致bug，此时若去掉fuzz中的address sanitizer，如果溢出真实存在，则fuzz可能会以不一样的bug形式显示出来<br /><br />修改环境变量，删除address sanitizer<br /><a href=""><img src="images\916-21.png" alt="images\916-21.png" /></a><br /><br />修改fuzzer的编译脚本，去除address sanitizer<br /><a href=""><img src="images\916-22.png" alt="images\916-22.png" /></a><br /><br />make clean清理<br /><br />configure重新生成makefile<br /><br />make V=1重新编译lib<br /><br />运行脚本重新编译fuzzer<br />此时caca_import_create_canvas函数使用参数&quot;caca&quot;，caca_create_canvsa(0,0)<br /><br />运行fuzzer，根据结果产生异常的函数仍为sscanu32，但sscanu32函数是在import.c的336行被调用的，之前存在address sanitizer时，sscanu32被错误调用的位置在import.c的335行<br /><a href=""><img src="images\916-23.png" alt="images\916-23.png" /></a><br /><a href=""><img src="images\916-24.png" alt="images\916-24.png" /></a><br /><br />以上说明，该bug在address sanitizer存在时，在import.c335行的位置被检测到堆溢出，实际上该bug会在import.c 336行的位置实际造成crash<br /><br /><br /><br /> <br /> <br /><br /><br /><br /><br /> <br /><br /><br /><br /><br /><br /><br /><br /></div><div class='page'><h1 class='title level-4'>4_Libcaca_fuzzing</h1><br/><h1>Libcaca fuzzing</h1><br /><br />在本讲义中，我们将介绍在Libcaca中进行模糊测试和运行的基本步骤，我们将忽略视频中涉及的所有中间步骤，而是纯粹着眼于模糊测试和运行的确切步骤。<br /><br /><h2>Building Libcaca with the fuzzer-specific compiler flags</h2><br /><br />模糊Libcaca的第一步是从Github克隆源代码存储库：<br /><br /><h3>$ git clone </h3><a href="https://github.com/cacalabs/libcaca">https://github.com/cacalabs/libcaca</a><br /><br />然后，我们设置正确的编译器环境标志：<br /><br /><div class="codebox"><div class="codebox">$&nbsp;export&nbsp;CC=clang<br />$&nbsp;export&nbsp;CXX=clang++<br />$&nbsp;export&nbsp;CFLAGS=&quot;-fsanitize=fuzzer-no-link,address&quot;<br />$&nbsp;export&nbsp;CXXFLAGS=&quot;-fsanitize=fuzzer-no-link,address&quot;</div></div><br /><br />然后，我们执行以下命令来实际构建Libcaca库：<br /><br /><div class="codebox"><div class="codebox">$&nbsp;cd&nbsp;libcaca<br />$&nbsp;apt-get&nbsp;install&nbsp;automake&nbsp;libtool&nbsp;pkg-config&nbsp;-y<br />$&nbsp;./bootstrap<br />$&nbsp;./configure<br />$&nbsp;make<br />$&nbsp;cd&nbsp;examples</div></div><br /><br />至此，libcaca库已编译完毕，我们应该有示例文件可以测试。 要验证这一点，请执行以下命令：<br /><br /><h3>$ ./examples/text</h3><br /><br /><h1>Compiling the Libcaca fuzzer</h1><br /><br />下一步是创建我们的模糊器，然后以Libcaca对其存储库示例进行处理的相同方式对其进行编译。 我们将使用以下受libcaca文本示例启发的模糊器：<br /><br /><h3>text_fuzz.c</h3><br /><br /><div class="codebox"><div class="codebox">#include&nbsp;&quot;config.h&quot;<br />#include&nbsp;&lt;string.h&gt;<br />#include&nbsp;&lt;stdlib.h&gt;<br />#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&quot;caca.h&quot;<br /><br />int&nbsp;LLVMFuzzerTestOneInput(const&nbsp;uint8_t&nbsp;*data,&nbsp;size_t&nbsp;size)<br /><span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;caca_canvas_t&nbsp;*pig;<br />&nbsp;&nbsp;&nbsp;&nbsp;pig&nbsp;=&nbsp;caca_create_canvas(10,&nbsp;10);<br />&nbsp;&nbsp;&nbsp;&nbsp;caca_import_canvas_from_memory(pig,&nbsp;data,&nbsp;size,&nbsp;&quot;text&quot;);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;caca_free_canvas(pig);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />我们将模糊器放置在examples / text_fuzz.c中，然后使用以下两个命令编译模糊器<br /><br /><div class="codebox"><div class="codebox">$&nbsp;clang&nbsp;-DHAVE_CONFIG_H&nbsp;-I.&nbsp;-I..&nbsp;-I../caca&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;-fsanitize=address,fuzzer-no-link&nbsp;-DOPTIMISE_SLANG_PALETTE=1&nbsp;-g&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;-fno-strength-reduce&nbsp;-fomit-frame-pointer&nbsp;-Wall&nbsp;-Wpointer-arith&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;-Wcast-align&nbsp;-Wcast-qual&nbsp;-Wstrict-prototypes&nbsp;-Wshadow&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;-Waggregate-return&nbsp;-Wmissing-prototypes&nbsp;-Wnested-externs&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;-Wsign-compare&nbsp;-MT&nbsp;-MD&nbsp;-MP&nbsp;-MF&nbsp;$depbase.Tpo&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;-c&nbsp;-o&nbsp;text_fuzz.o&nbsp;text_fuzz.c<br /><br />$&nbsp;clang&nbsp;-fsanitize=address,fuzzer&nbsp;-g&nbsp;-fno-strength-reduce&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;-fomit-frame-pointer&nbsp;-Wall&nbsp;-Wpointer-arith&nbsp;-Wcast-align&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;-Wcast-qual&nbsp;-Wstrict-prototypes&nbsp;-Wshadow&nbsp;-Waggregate-return&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;-Wmissing-prototypes&nbsp;-Wnested-externs&nbsp;-Wsign-compare&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;-o&nbsp;text_fuzz&nbsp;text_fuzz.o&nbsp;&nbsp;../caca/.libs/libcaca.so</div></div><br /><br />在构建Libcaca时，我们通过查看make命令的输出来提取上述命令。 我们添加的两个命令的唯一部分是将fuzzer编译为目标代码时的-fsanitize = fuzzer-no-link，address和链接fuzzer时的-fsanitize = fuzzer，address。 链接Libfuzzer程序时，我们始终需要使用-fsanitize = fuzzer。 运行上面的两个命令后，我们将看到作为程序text_fuzz创建的模糊器。<br /><br />在运行模糊器之前，我们要做的最后一件事是确保libcaca.so位于我们的库路径中。 假设我们在examples文件夹中，那么以下命令将完成此工作：<br /><br /><h3>$ export LD_LIBRARY_PATH=&quot;$PWD/../caca/.libs/&quot;</h3><br /><br />此时，我们可以启动我们的模糊器并观察输出：<br /><br /><a href=""><img src="images\917-1.png" alt="images\917-1.png" /></a><br /><br />在运行模糊器一段时间后，我们看不到代码中发生的任何错误。 但是，模糊器的更多基础代码我们将模糊器的源代码更改为以下代码：<br /><br /><h3>text_fuzz.c</h3><br /><br /><div class="codebox"><div class="codebox">#include&nbsp;&quot;config.h&quot;<br />#include&nbsp;&lt;string.h&gt;<br />#include&nbsp;&lt;stdlib.h&gt;<br />#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&quot;caca.h&quot;<br /><br />int&nbsp;LLVMFuzzerTestOneInput(const&nbsp;uint8_t&nbsp;*data,&nbsp;size_t&nbsp;size)<br /><span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;caca_canvas_t&nbsp;*pig;<br />&nbsp;&nbsp;&nbsp;&nbsp;pig&nbsp;=&nbsp;caca_create_canvas(10,&nbsp;10);<br />&nbsp;&nbsp;&nbsp;&nbsp;caca_import_canvas_from_memory(pig,&nbsp;data,&nbsp;size,&nbsp;&quot;caca&quot;);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;caca_free_canvas(pig);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />我们以完全相同的方式编译应用程序，然后执行启动新的模糊测试器：<br /><br /><a href=""><img src="images\917-2.png" alt="images\917-2.png" /></a><br /><br />运行模糊器约10-20秒，发现函数sscanu32和行号32的import.c文件内部发生溢出。<br /><br /><br /><br /><br /><br /><br /><br /><br /></div><div class='page'><h1 class='title level-3'>5_Assignment</h1><br/></div><div class='page'><h1 class='title level-4'>1_Libfuzzer_Assignment</h1><br/><h1>Libfuzzer作业</h1><br />作业准则：要求您完成以下定义的问题，并提交包含答案的单个ZIP文件。  zipfile应该包含每个问题的文件夹，并且在给定文件夹内应该是回答给定问题所必需的文件。<br /><br />设置说明：问题围绕着编写模糊测试的问题。 我们强烈建议您在Docker映像中执行此操作，因为这会使设置更加容易，并且为您安装了所有依赖项。 您提交的文件也必须在下面的Docker映像中运行。 因此，我们使用以下Docker文件：<br />这里的dockerfile与2.1中的差不多<br /><h3>Dockerfile</h3><br /><div class="codebox"><div class="codebox">#&nbsp;Install&nbsp;basic&nbsp;Ubuntu&nbsp;dependencies<br />FROM&nbsp;ubuntu:20.04<br />ENV&nbsp;DEBIAN_FRONTEND&nbsp;noninteractive<br />RUN&nbsp;apt-get&nbsp;update&nbsp;&amp;&amp;&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;apt-get&nbsp;upgrade&nbsp;-y&nbsp;&amp;&amp;&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;apt-get&nbsp;install&nbsp;-y&nbsp;libc6-dev&nbsp;binutils&nbsp;&amp;&amp;&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;apt-get&nbsp;autoremove&nbsp;-y<br /><br />#&nbsp;Now&nbsp;install&nbsp;basic&nbsp;setup.<br />RUN&nbsp;dpkg&nbsp;--add-architecture&nbsp;i386&nbsp;&amp;&amp;&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;apt-get&nbsp;update&nbsp;&amp;&amp;&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;apt-get&nbsp;install&nbsp;-y&nbsp;software-properties-common&nbsp;&amp;&amp;&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;add-apt-repository&nbsp;ppa:git-core/ppa&nbsp;&amp;&amp;&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;apt-get&nbsp;update&nbsp;&amp;&amp;&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;apt-get&nbsp;install&nbsp;-y&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binutils-dev&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;build-essential&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;curl&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;git&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jq&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;libc6-dev-i386&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subversion&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zip&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wget<br /><br />#&nbsp;Install&nbsp;our&nbsp;pythons<br />RUN&nbsp;apt-get&nbsp;install&nbsp;python&nbsp;-y<br /><br />#&nbsp;Install&nbsp;clang<br />RUN&nbsp;apt-get&nbsp;install&nbsp;clang-8&nbsp;-y<br /><br />#&nbsp;Create&nbsp;symbolic&nbsp;links&nbsp;for&nbsp;the&nbsp;tools&nbsp;that&nbsp;we&nbsp;will&nbsp;often&nbsp;use.<br />RUN&nbsp;ln&nbsp;-s&nbsp;/usr/bin/clang-8&nbsp;/usr/bin/clang<br />RUN&nbsp;ln&nbsp;-s&nbsp;/usr/bin/clang++-8&nbsp;/usr/bin/clang++<br />RUN&nbsp;ln&nbsp;-s&nbsp;/usr/bin/llvm-profdata-8&nbsp;/usr/bin/llvm-profdata<br />RUN&nbsp;ln&nbsp;-s&nbsp;/usr/bin/llvm-cov-8&nbsp;/usr/bin/llvm-cov<br /><br />#&nbsp;Install&nbsp;VIM&nbsp;for&nbsp;easy&nbsp;editing<br />RUN&nbsp;apt-get&nbsp;install&nbsp;vim&nbsp;-y<br /><br />#&nbsp;Setup&nbsp;directory&nbsp;where&nbsp;we&nbsp;can&nbsp;work<br />ENV&nbsp;WORK=/work<br />ENV&nbsp;MISC=/misc<br />RUN&nbsp;mkdir&nbsp;-p&nbsp;$WORK&nbsp;$MISC&nbsp;&amp;&amp;&nbsp;chmod&nbsp;a+rwx&nbsp;$WORK&nbsp;$MISC<br /><br />WORKDIR&nbsp;$WORK</div></div><br /><br />要为上述文件创建Docker映像，请在放置Docker文件的目录中使用以下命令，命名为Dockerfile：<br />sudo docker build --tag libfuzzer_1 .<br /><br />要在此Docker映像中启动shell，请使用以下命令：<br />sudo docker run -it libfuzzer_1 / bin / bash<br /><br /><br /><h2>Question 1: First fuzzer</h2><br />本练习中，要求您为以下目标代码编写fuzzer：<br /><h3>target.h</h3><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;stdlib.h&gt;<br />#include&nbsp;&lt;string.h&gt;<br /><br />/*<br />&nbsp;*&nbsp;Expects&nbsp;a&nbsp;null-terminated&nbsp;string&nbsp;and&nbsp;returns&nbsp;an&nbsp;integer.<br />&nbsp;*/<br />int&nbsp;attack_me(char&nbsp;*buffer)&nbsp;<span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(strlen(buffer)&nbsp;!=&nbsp;36)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(buffer[10]&nbsp;!=&nbsp;&#39;A&#39;&nbsp;&amp;&amp;&nbsp;buffer[20]&nbsp;!=&nbsp;&#39;B&#39;)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;cs&nbsp;=&nbsp;0;<br />&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;10;&nbsp;i++)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(buffer[i]&nbsp;==&nbsp;&#39;C&#39;)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cs++;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(cs&nbsp;&lt;&nbsp;2)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;2;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;idx&nbsp;=&nbsp;(int)buffer[25];<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(buffer[idx]&nbsp;!=&nbsp;&#39;D&#39;)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;-1;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;3;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />您的答案必须包括：<br />击中目标代码的Fuzzer的源代码<br />构造Fuzzer所需的命令一个文本文件<br />显示运行Fuzzer的输出（请在文件中最多限制200行，以防Fuzzer 输出更多）。<br /><br /><br />问题2：小型库的模糊处理：微型正则表达式和utf8<br />在本练习中，要求您对一组较小的库执行模糊测试。 目标是练习从零到使模糊测试针对目标运行的完整端到端过程。 对于以下每个目标，我们要求您完成以下步骤：<br />1、为目标代码创建模糊器<br />2、创建脚本以使用模糊器工具和地址消毒器工具<br />3、编译模糊器运行模糊器并保存输出<br /><br /><h3>The targets we ask you to attack are:</h3><br />• Tiny Regex: <a href="https://github.com/kokke/tiny-regex-c">https://github.com/kokke/tiny-regex-c</a><br />• utf8: <a href="https://github.com/sheredom/utf8.h">https://github.com/sheredom/utf8.h</a><br />• json-parser: <a href="https://github.com/udp/json-parser">https://github.com/udp/json-parser</a><br /><br />您的答案必须包括：<br />命中目标代码的模糊器的源代码<br />构建您的模糊器所需的命令<br />一个文本文件，显示运行模糊器的输出（如果您的模糊器输出更多，请限制文件中的行数最多为200行）。<br /><br />在此练习中要记住的重要一点是您正在处理实际项目。 在实际项目中进行操作时有许多怪异之处，它们是成功部署模糊测试的障碍，即它们是练习的一部分。<br /><br /><br /><h2>Question 3: Fuzzing Libcaca</h2><br />在本练习中，您需要扩展我们在演示视频中所做的Libcaca模糊测试。 要求您执行以下操作：<br /><br />1、扩展，以便为caca_import_canvas_from_memory的每个选项提供一个模糊测试器。 对于每个模糊器，显示至少60秒的运行或直到模糊器发现错误为止的编译和运行结果的命令<br /><br />2、创建一个编译所有模糊器的构建脚本。<br /><br />3、扩展现有的模糊器，以便它们调用的API不仅仅是caca_import_canvas_from_memory，也就是说，它们应该开始使用实际画布上的canvas。<br /><br />4、向您的武器库中添加一个针对caca_load_font函数的附加fuzzer。<br /><br />5、使用ASAN，MSAN和UBSAN等消毒器来编译您的模糊器，结果如何？<br /><br />您的答案必须包括：<br /><br />1、模糊器的源代码<br />2、生成和运行模糊器所必需的命令<br />3、一个文本文件，显示运行模糊器的输出（请在文件中限制每行最多200行，以防模糊器输出更多的行）。<br />4、一个文本文件，突出显示您发现的所有错误的详细信息。<br /><br />在此练习中要记住的重要一点是您正在处理实际项目。 在实际项目中进行操作时，会有很多怪癖，而这些怪怪是成功部署模糊测试的障碍，即它们是练习的一部分。<br /><br /><br /><br /><br /><br /><br /></div><div class='page'><h1 class='title level-2'>3_Efficient_and_effective_fuzzing</h1><br/></div><div class='page'><h1 class='title level-3'>1_Introduction_to_efficient_fuzzing</h1><br/></div><div class='page'><h1 class='title level-4'>1_Introduction_to_efficient_fuzzing</h1><br/><h1>高效模糊介绍</h1><br />fuzz可能是一个漫长的过程，许多工作都致力于提高fuzz效率。 这通常是一个迭代过程，在达到令人满意的状态之前可能需要执行几个步骤。 在本课程的这一部分中，我们将详细讨论如何执行有效的模糊测试，以及可以用来改善模糊测试的技术。 我们关注的主题是如何了解模糊器要击中目标应用程序的哪个部分，如何使用模糊测试工具测试应用程序，其中目标应用程序以高度结构化数据的形式输入。 我们将介绍以下技术：<br /><br />1. Seed selection<br />2. Fuzzer dictionaries<br />3. Code coverage<br /><br />我们在本节中介绍的所有技术，将使您能够模糊更多种多样的目标，并从发现的错误中获得更高的回报。</div><div class='page'><h1 class='title level-3'>2_Seed_selection_and_dictionaries</h1><br/></div><div class='page'><h1 class='title level-4'>1_Seed_selection_and_dictionaries</h1><br/><h1>种子选择和字典</h1><br /><br />在改善模糊性方面，有两种主要的处理方法。 首先，我们可以通过编程方式改进实际的模糊器，以便它们更有效地达到目标。这种改进称为结构感知的模糊测试，并将在本课程的后面部分进行介绍。改善模糊测试的第二种方法是，为模糊器提供种子输入，该输入具有目标应用程序期望的输入数据的性质，并且还提供了模糊器在生成数据时可以使用的关键字。在本节中，我们将通过提供更好的种子以及供模糊器使用的关键字来更深入地了解模糊器的覆盖范围。<br /><br /><br /><h1>Seed selection</h1><br />在一次引人入胜的攻势中，LibFuzzer不断建立一组语料库文件，以探索目标程序的不同部分。这样做的本质是LibFuzzer越探索目标程序，语料库文件就越类似于目标程序期望的输入。在解析器的上下文中尤其如此，因为在解析过程中输入越多，就解析器期望的数据而言，输入越“正确”。<br /><br />除了由LibFuzzer运行时生成的文件之外，我们还可以为LibFuzzer提供初始输入文件集。 这些文件称为种子文件。通常，提供种子文件的好处是，它允许LibFuzzer在代码覆盖率探索方面跳过很多处理，这些过程最终将语料库文件成形为结构上看起来像目标期望的输入的数据。在实践中，这可能会产生重大影响，并且选择要提供的种子文件可以完全改变模糊测试活动的结果。<br /><br />通常，我们可以将任何给定的文件作为种子提供给给定的模糊测试活动，也可以提供任意数量的种子文件。 但是，使用种子文件时，最常见的方法是：<br /><br />1、完全不提供种子文件，并让LibFuzzer自己完成工作。<br />2、提供格式正确的种子文件，即具有目标应用程序期望的结构的文件。<br />3、提供一个输入格式错误的种子文件。<br /><br />在下面的内容中，我们将观察种子选择对一组通用解析器的影响。<br /><br /><br /><h2>Fuzzing dictionaries</h2><br />除了选择种子外，我们还可以为Fuzzer提供一组关键字，Fuzzer在构造随机数据时应使用这些关键字。 这些关键字以字典的形式出现。 考虑以下字典示例：<br /><br /><div class="codebox"><div class="codebox"><br />#&nbsp;Lines&nbsp;starting&nbsp;with&nbsp;<span style="color:#00117f;font-weight:400">&#39;#&#39;</span>&nbsp;<span style="color:#ff9d00;font-weight:700">and</span>&nbsp;empty&nbsp;lines&nbsp;are&nbsp;ignored.<br /><br />#&nbsp;Adds&nbsp;alpha&nbsp;to&nbsp;the&nbsp;dictionary<br />keyword1=<span style="color:#3ad900;font-weight:400">&quot;alpha&quot;</span><br /><br />#&nbsp;Adds&nbsp;gamma&nbsp;to&nbsp;the&nbsp;dictionary<br />keyword2=<span style="color:#3ad900;font-weight:400">&quot;gamma&quot;</span><br /><br />#&nbsp;Adds&nbsp;<span style="color:#3ad900;font-weight:400">&quot;gamma&quot;</span>&nbsp;(with&nbsp;quotes)&nbsp;to&nbsp;the&nbsp;dictionary<br />keyword3=<span style="color:#3ad900;font-weight:400">&quot;\&quot;gamma\&quot;&quot;</span><br /><br />#&nbsp;We&nbsp;dont&nbsp;ned&nbsp;to&nbsp;have&nbsp;a&nbsp;name&nbsp;<span style="color:#ff9d00;font-weight:700">for</span>&nbsp;the&nbsp;keyword&nbsp;<span style="color:#ff9d00;font-weight:700">or</span>&nbsp;an&nbsp;assignment<br />#&nbsp;Adds&nbsp;delta&nbsp;to&nbsp;the&nbsp;dictionary<br />delta<br /><br />#&nbsp;Adds&nbsp;the&nbsp;raw&nbsp;hex&nbsp;values&nbsp;AB&nbsp;<span style="color:#ff9d00;font-weight:700">and</span>&nbsp;CD&nbsp;to&nbsp;the&nbsp;dictionary<br />keyword5=<span style="color:#3ad900;font-weight:400">&quot;\xAB\xCD&quot;</span></div></div><br /><br />Libfuzzer使用词典的方式只是在模糊测试例程中包含一种变异策略，该策略仅将字典中的单词插入种子中的任意位置。这样，将整个单词插入种子中，并且由于单词本身成为种子的一部分，因此随着模糊处理的进行，这些单词将通过常规的更改策略进行更改。这样，字典中的单词将首先完全按照字典中的描述插入，然后经受与种子其他任何部分相同的突变。<br /><br />Google在Github上维护了一个存储库，其中包含许多常用数据格式的词典集合。<br /><a href="https://github.com/google/fuzzing/tree/master/dictionaries">https://github.com/google/fuzzing/tree/master/dictionaries</a><br /><br />要告诉模糊器使用字典，我们唯一需要做的就是提供-dict命令行标志，后跟字典的文件路径。</div><div class='page'><h1 class='title level-4'>2_Seed selection in Xpdf _ ADA Logics</h1><br/>获取源码<br /><a href=""><img src="images\938-1.png" alt="images\938-1.png" /></a><br /><br />docker镜像中下载程序源码<br /><h3>wget --no-check-certificate https://dl.xpdfreader.com/xpdf-4.02.tar.gz </h3><br /><a href=""><img src="images\938-2.png" alt="images\938-2.png" /></a><br /><br />解压源码<br />tar -zxvf xpdf-4.02.tar.gz<br /><br />需要研究如何正常编译源码，并将我们需要的flags增加到编译过程中，<br />源码中INSTALL文件说明如何编译源码，且说明如果没有安装Qt库，程序也可以作为命令行工具正常执行，这是个好消息<br /> <a href=""><img src="images\938-3.png" alt="images\938-3.png" /></a><br /><br />创建build目录并进入该目录，同时安装程序所需软件包<br /><a href=""><img src="images\938-4.png" alt="images\938-4.png" /></a><br /><br /><a href=""><img src="images\938-5.png" alt="images\938-5.png" /></a><br /><br />根据cmakefile创建makefile，及执行cmake命令，此时需要指定../参数，因为cmakefile位于源码根目录<br /><a href=""><img src="images\938-6.png" alt="images\938-6.png" /></a><br /><br />运行make命令，进行编译，整个编译过程没有错误<br /><a href=""><img src="images\938-7.png" alt="images\938-7.png" /></a><br /><br />编译完成，删除build目录<br /><a href=""><img src="images\938-8.png" alt="images\938-8.png" /></a><br /><br />以上编译过程已经完成，此时需要研究编译过程中如何使用编译flag，即需要查看详细的编译过程<br />重新创建build目录，此时运行cmake时需要加指定flag，<br />-DCMAKE_VERBOSE_MAKEFILE：BOOL = ON<br />当该flag存在时，由cmake生成的makefile文件就允许使用make V=1从而输出详细编译信息<br /><a href=""><img src="images\938-9.png" alt="images\938-9.png" /></a><br /><br />运行make V=1开始编译项目，根据该命令的输出，可以判断编译命令大多用于编译lib库文件<br /><a href=""><img src="images\938-10.png" alt="images\938-10.png" /></a><br /><br />分析输出，发现主要编译过程为进入xpdf目录，使用c++将c文件编译为中间文件.o<br />我们的目标就是使用clang编译程序，并且编译过程中加入-fsanitizer相关flag<br /><a href=""><img src="images\938-11.png" alt="images\938-11.png" /></a><br /><br />删除build目录，准备重新编译<br /><a href=""><img src="images\938-12.png" alt="images\938-12.png" /></a><br /><br />修改环境变量，这里注意还需要修改LD变量，这表示将程序linker修改为clang++<br />之后重新运行cmake从而生成makefile文件<br /><a href=""><img src="images\938-13.png" alt="images\938-13.png" /></a><br /><br />运行make V=1命令，重新编译项目<br />查看编译输出，发现成功使用clang编译器以及对应flag<br /><a href=""><img src="images\938-14.png" alt="images\938-14.png" /></a><br /><br />此时一般思路是开发fuzz，然后将其与指定lib库链接，从而让fuzz调用lib中的函数进行测试<br />但根据分析此时未发现编译过程中生成了有用的lib库，说明项目原始编译过程不会讲目标程序编译为库代码<br /><a href=""><img src="images\938-15.png" alt="images\938-15.png" /></a>  <br /><br /><br />解决该问题的思路是修改cmake文件，从而将目标项目所有中间文件打包为一个静态lib库（.a文件）<br />xpdf目录-》CMakeLists.txt文件<br /><br />CMakeList.txt文件中声明了所有将会包含在xpdf库中的.cc文件（即c++文件）<br />此时需要保证将以下c++文件中的代码包含在一个静态库中<br /><a href=""><img src="images\938-16.png" alt="images\938-16.png" /></a><br /><br />为了达到以上目的，需要在上图add_library()函数下加上一行<br />该行cmake指令，在编译过程中生成静态库<br />testXpdfStatic表示输出文件名<br />STATIC 表示生成静态库<br />TARGET_OBJECTS表示生成静态库所需的所有代码，此时为xpdf_objs，即之前add_library()函数所定义的<br /><h3>add_library(testXpdfStatic STATIC $&lt;TARGET_OBJECTS:xpdf_objs&gt;)</h3><br /><a href=""><img src="images\938-17.png" alt="images\938-17.png" /></a><br /><br />在实际使用的源码中做修改<br /><a href=""><img src="images\938-18.png" alt="images\938-18.png" /></a><br /><br />重新创建build目录并cmake<br /><a href=""><img src="images\938-19.png" alt="images\938-19.png" /></a><br /><br />运行make V=1，从而得到一个静态库，其中保存所有xpdf中间文件<br />查看生成的静态库<br /><a href=""><img src="images\938-20.png" alt="images\938-20.png" /></a><br /><br />此时准备构建fuzzer，则需要确定攻击入口点<br />查看源码中是如何使用lib构建可执行文件的，可以关注加载pdf文件的实例程序<br /><br />程序编译过程中可以看到如下链接相关的输出，显示了通过链接生成了部分可执行文件<br />这说明此类程序（pdfimages、pdffonts）均使用了xpdf的库函数<br /><a href=""><img src="images\938-21.png" alt="images\938-21.png" /></a><br /><br /><a href=""><img src="images\938-22.png" alt="images\938-22.png" /></a><br /><br />查看xpdf目录，还能看到对应可执行文件<br /><a href=""><img src="images\938-23.png" alt="images\938-23.png" /></a><br /><br />根据分析，xpdf目录下存在大量大写字母开头的.cc文件，此类文件实现xpdf功能，构成了xpdf的lib库<br />xpdf目录也可见小写字母开头的.cc文件，此类文件对应pdffonts等示例可执行文件，可以根据此类代码创建fuzzer<br /><a href=""><img src="images\938-24.png" alt="images\938-24.png" /></a><a href=""><img src="images\938-25.png" alt="images\938-25.png" /></a><br /><br />查看pdfinfo.cc文件的main函数<br />该函数前两个参数说明该函数可以将文件名作为输入，将文件转为某种pdf文件的内部表示形式<br /><a href=""><img src="images\938-26.png" alt="images\938-26.png" /></a><br /><br />源码中分析main函数中关键变量的使用<br />filename来自外界输入，而根据filename生成了PDFDoC结构体doc，之后pdf信息的获取均通过doc，所以将随机数据传给PDFDoc结构体，并进一步通过doc调用各种函数成为了我们的fuzz策略<br /><a href=""><img src="images\938-27.png" alt="images\938-27.png" /></a><br /><br />之后通过doc对读入的pdf文件进行操作，这些逻辑是可供我们fuzz的<br /><a href=""><img src="images\938-28.png" alt="images\938-28.png" /></a><br /><br />综上，创建fuzzer 该fuzz，关键的代码为<br /><strong><span style="color:#ff9d00;">if</span></strong> (doc-&gt;isOk()){<br />        doc-&gt;getNumPages();<br />}<br /><br />以上代码用于调用xpdf的实际功能函数，从而发现更多的bug<br /><h3>fuzz_pdf.cc</h3><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdlib.h&gt;<br />#include&nbsp;&lt;string.h&gt;<br />#include&nbsp;&lt;stdint.h&gt;<br />#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;sys/types.h&gt;<br />#include&nbsp;&lt;unistd.h&gt;<br />#include&nbsp;&quot;PDFDoc.h&quot;<br />#include&nbsp;&quot;GlobalParams.h&quot;<br /><br />extern&nbsp;&quot;C&quot;&nbsp;int&nbsp;LLVMFuzzerTestOneInput(const&nbsp;uint8_t&nbsp;*data,&nbsp;size_t&nbsp;size)<br /><span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;filename[256];<br />&nbsp;&nbsp;&nbsp;&nbsp;sprintf(filename,&nbsp;&quot;/tmp/libfuzzer.%d&quot;,&nbsp;getpid());<br />&nbsp;&nbsp;&nbsp;&nbsp;FILE&nbsp;*fp&nbsp;=&nbsp;fopen(filename,&nbsp;&quot;wb&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!fp)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br />&nbsp;&nbsp;&nbsp;&nbsp;fwrite(data,&nbsp;size,&nbsp;1,&nbsp;fp);<br />&nbsp;&nbsp;&nbsp;&nbsp;fclose(fp);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Insert&nbsp;fuzzer&nbsp;contents&nbsp;here&nbsp;*/<br />&nbsp;&nbsp;&nbsp;&nbsp;globalParams&nbsp;=&nbsp;new&nbsp;GlobalParams(NULL);<br />&nbsp;&nbsp;&nbsp;&nbsp;globalParams-&gt;setErrQuiet(1);//not&nbsp;necessary<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;PDFDoc&nbsp;*doc&nbsp;=&nbsp;NULL;<br />&nbsp;&nbsp;&nbsp;&nbsp;doc&nbsp;=&nbsp;new&nbsp;PDFDoc(filename,&nbsp;NULL,&nbsp;NULL);<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(doc-&gt;isOk())<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;doc-&gt;getNumPages();<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Cleanup<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(doc&nbsp;!=&nbsp;NULL)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delete&nbsp;doc;<br />&nbsp;&nbsp;&nbsp;&nbsp;delete&nbsp;globalParams;<br />&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;-&nbsp;end&nbsp;of&nbsp;fuzzer&nbsp;contents&nbsp;&nbsp;-&nbsp;*/<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;cleanup&nbsp;temporary&nbsp;file<br />&nbsp;&nbsp;&nbsp;&nbsp;unlink(filename);<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />根据之前编译过程的输出，可以看到pdfinfo是如何被编译的，据此可以编写编译fuzzer的脚本<br />以下输出中，选中部分为CMake文件中add_library函数中的.cc文件所生成的中间文件，由于我们在cmake文件中进行了修改，所以此类中间文件均已被包含在我们生成的testXpdfStatic.a中间文件中<br /><a href=""><img src="images\938-29.png" alt="images\938-29.png" /></a><br /><br />最终用于编译fuzzer的命令行，其中-I参数用于指定源码中引用的头文件的搜索路径<br />生成了a.out的fuzer，该fuzzer可以正常运行<br /><a href=""><img src="images\938-30.png" alt="images\938-30.png" /></a><br /><br />从指定网址下载作为种子的pdf文件<br /><a href=""><img src="images\938-31.png" alt="images\938-31.png" /></a><br /><br />将示例pdf文件放入seed文件夹子<br /><a href=""><img src="images\938-32.png" alt="images\938-32.png" /></a><br /><br />创建两个语料库，用于显示有种子文件以及无种子文件时，产生的语料库的区别<br />首先在使用种子文件的情况下运行fuzzer<br /><a href=""><img src="images\938-33.png" alt="images\938-33.png" /></a><br /><br />输出显示，若不使用种子文件，则cov很难超过350，同时在语料库corpus_raw中生成了89个crash文件<br /><a href=""><img src="images\938-34.png" alt="images\938-34.png" /></a><br /><br /><a href=""><img src="images\938-35.png" alt="images\938-35.png" /></a><br /><br />此时使用种子文件，libfuzzer第一个命令行参数用于指定语料库，第二个参数用于指定种子文件所在目录<br />可以看到马上报错，并且cov来到了750 <br /><a href=""><img src="images\938-36.png" alt="images\938-36.png" /></a><br /><br />再次运行相同命令，可以看到cov大幅增长，并且报空指针引用错误<br />此时报错信息中未显示发生错误的代码在源码中的行数，原因为编译最初的静态库时没有使用-g，即未保存调试符号<br /><a href=""><img src="images\938-37.png" alt="images\938-37.png" /></a><br /><br />此时语料库中生成了58个测试用例，由于asan检测到报错，所以没有生成更多测试用例<br /><a href=""><img src="images\938-38.png" alt="images\938-38.png" /></a><br /><br /><br /><br /><br /><br /><br /></div><div class='page'><h1 class='title level-4'>3_Seed_selection_example_Xpdf</h1><br/><h1>种子选择示例：Xpdf</h1><br />在本节中，我们将通过一个示例，在该示例中，提供种子与不提供种子之间的差异非常大。我们的目标是Xpdf工具，您可以在这里访问它：<h3> </h3><a href="https://www.xpdfreader.com/">https://www.xpdfreader.com/</a>可以在下载页面上找到该工具的最新版本：<a href="https://www.xpdfreader.com/download.html">https://www.xpdfreader.com/download.html</a><br /><br />Xpdf主要是PDF解析器，查看器和工具包，因此是模糊测试的一个很好的目标。 但是，PDF格式也是一种复杂的数据格式，这意味着模糊器生成有效的PDF文件非常复杂，而这些文件在解析例程中将无法使用。因此，本讲义的目的是说明提供PDF文件作为种子时与不提供种子文件时，模糊结果的差异。<br /><br />要下载并安装该库：<br /><h3>wget --no-check-certificate https://dl.xpdfreader.com/xpdf-4.02.tar.gz <br />tar -zxvf xpdf-4.02.tar.gz</h3><br /><br /><br /><h2>Fuzzing xpdf</h2><br />该过程的第一步是为Xpdf实际建立一个模糊的环境。 为此，我们需要<br />（1）确保我们可以使用正确的编译器标记构建Xpdf，并且<br />（2）创建一个模糊器，以调用Xpdf的PDF解析例程。<br /><br /><h3>Setting up fuzz-build for Xpdf</h3><br />首先，我们需要安装Xpdf所需的软件包以进行安装：<br /><div class="codebox"><div class="codebox">$&nbsp;add-apt-repository&nbsp;ppa:rock-core/qt4<br />$&nbsp;apt&nbsp;update<br />$&nbsp;apt-get&nbsp;install&nbsp;-y&nbsp;make&nbsp;wget&nbsp;cmake&nbsp;libqt4-dev</div></div><br /><br />Xpdf的构建结构基于CMake，在这种情况下，我们要确保在构建项目时创建一个静态的Xpdf库。 因此，我们将更改文件xpdf / CMakeLists.txt，通过在源码中以下行<br /><br /><h3>#--- object files needed by XpdfWidget</h3><br /><br />的上一行插入如下行：<br /><br /><h3>add_library(testXpdfStatic STATIC $&lt;TARGET_OBJECTS:xpdf_objs&gt;)</h3><br /><br />即<br /><a href=""><img src="images\939-1.png" alt="images\939-1.png" /></a><br /><br />这将指示CMake构造一个名为testXpdfStatic.a的静态库，该库将是我们将模糊器链接到的库。<br /><br />下一步是确保设置了正确的环境变量，以便使用模糊器特定的标志编译该库。 为此，我们使用以下命令：<br /><br /><div class="codebox"><div class="codebox">$&nbsp;export&nbsp;CC=clang<br />$&nbsp;export&nbsp;CXX=clang++<br />$&nbsp;export&nbsp;LD=clang++<br />$&nbsp;export&nbsp;CFLAGS=&quot;-fsanitize=fuzzer-no-link,address&quot;<br />$&nbsp;export&nbsp;CXXFLAGS=&quot;-fsanitize=fuzzer-no-link,address&quot;</div></div><br /><br />至此，我们可以构建项目了。 为此，我们使用以下命令：<br /><br /><div class="codebox"><div class="codebox">$&nbsp;cd&nbsp;$ROOTPATH<br />$&nbsp;mkdir&nbsp;build<br />$&nbsp;cd&nbsp;build<br />$&nbsp;cmake&nbsp;../&nbsp;-DCMAKE_C_FLAGS=&quot;$CFLAGS&quot;&nbsp;-DCMAKE_CXX_FLAGS=&quot;$CXXFLAGS&quot;<br />$&nbsp;make</div></div><br /><br />默认情况下，使用CMake不能像以前一样使用make V = 1标志。 但是，编译器标志-DCMAKE_VERBOSE_MAKEFILE：BOOL = ON允许您通过CMake生成的Makefile中的make V = 1启用详细编译。<br /><br /><br /><h2>Creating a fuzzer for Xpdf</h2><br />下一步是创建适合Xpdf项目的模糊器。 此过程的第一步是确定潜在目标。我们将要构建的模糊器的灵感来自xpdf / pdfinfo.cc中的代码，尤其是主要功能的第一部分：<br /><br />pdfinfo.cc snippet<br /><div class="codebox"><div class="codebox">int&nbsp;main(int&nbsp;argc,&nbsp;char&nbsp;*argv[])&nbsp;{<br />&nbsp;&nbsp;PDFDoc&nbsp;*doc;<br />&nbsp;&nbsp;char&nbsp;*fileName;<br />&nbsp;&nbsp;GString&nbsp;*ownerPW,&nbsp;*userPW;<br />&nbsp;&nbsp;UnicodeMap&nbsp;*uMap;<br />&nbsp;&nbsp;Page&nbsp;*page;<br />&nbsp;&nbsp;Object&nbsp;info,&nbsp;xfa;<br />&nbsp;&nbsp;Object&nbsp;*acroForm;<br />&nbsp;&nbsp;char&nbsp;buf[256];<br /><br />&nbsp;&nbsp;........<br /><br />&nbsp;&nbsp;fileName&nbsp;=&nbsp;argv[1];<br /><br />&nbsp;&nbsp;//&nbsp;read&nbsp;config&nbsp;file<br />&nbsp;&nbsp;globalParams&nbsp;=&nbsp;new&nbsp;GlobalParams(cfgFileName);<br />&nbsp;&nbsp;if&nbsp;(textEncName[0])&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;globalParams-&gt;setTextEncoding(textEncName);<br />&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;.....<br /><br />&nbsp;&nbsp;//&nbsp;open&nbsp;PDF&nbsp;file<br />&nbsp;&nbsp;if&nbsp;(ownerPassword[0]&nbsp;!=&nbsp;&#39;\001&#39;)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;ownerPW&nbsp;=&nbsp;new&nbsp;GString(ownerPassword);<br />&nbsp;&nbsp;}&nbsp;else&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;ownerPW&nbsp;=&nbsp;NULL;<br />&nbsp;&nbsp;}<br />&nbsp;&nbsp;if&nbsp;(userPassword[0]&nbsp;!=&nbsp;&#39;\001&#39;)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;userPW&nbsp;=&nbsp;new&nbsp;GString(userPassword);<br />&nbsp;&nbsp;}&nbsp;else&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;userPW&nbsp;=&nbsp;NULL;<br />&nbsp;&nbsp;}<br />&nbsp;&nbsp;doc&nbsp;=&nbsp;new&nbsp;PDFDoc(fileName,&nbsp;ownerPW,&nbsp;userPW);<br />&nbsp;&nbsp;if&nbsp;(userPW)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;delete&nbsp;userPW;<br />&nbsp;&nbsp;}<br />&nbsp;&nbsp;if&nbsp;(ownerPW)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;delete&nbsp;ownerPW;<br />&nbsp;&nbsp;}<br />&nbsp;&nbsp;if&nbsp;(!doc-&gt;isOk())&nbsp;<span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;exitCode&nbsp;=&nbsp;1;<br />&nbsp;&nbsp;&nbsp;&nbsp;goto&nbsp;err2;<br />&nbsp;&nbsp;<span style="color:#000000;font-weight:400">}</span></div></div><br /><br />我们创建的模糊器只是用于文件输入模糊处理的模板模糊器的一小部分衍生产品。 我们最终得到的模糊器如下：<br /><br /><h3>fuzz_pdf.cc</h3><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdlib.h&gt;<br />#include&nbsp;&lt;string.h&gt;<br />#include&nbsp;&lt;stdint.h&gt;<br />#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;sys/types.h&gt;<br />#include&nbsp;&lt;unistd.h&gt;<br />#include&nbsp;&quot;PDFDoc.h&quot;<br />#include&nbsp;&quot;GlobalParams.h&quot;<br /><br />extern&nbsp;&quot;C&quot;&nbsp;int&nbsp;LLVMFuzzerTestOneInput(const&nbsp;uint8_t&nbsp;*data,&nbsp;size_t&nbsp;size)<br /><span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;filename[256];<br />&nbsp;&nbsp;&nbsp;&nbsp;sprintf(filename,&nbsp;&quot;/tmp/libfuzzer.%d&quot;,&nbsp;getpid());<br />&nbsp;&nbsp;&nbsp;&nbsp;FILE&nbsp;*fp&nbsp;=&nbsp;fopen(filename,&nbsp;&quot;wb&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!fp)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br />&nbsp;&nbsp;&nbsp;&nbsp;fwrite(data,&nbsp;size,&nbsp;1,&nbsp;fp);<br />&nbsp;&nbsp;&nbsp;&nbsp;fclose(fp);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Insert&nbsp;fuzzer&nbsp;contents&nbsp;here&nbsp;*/<br />&nbsp;&nbsp;&nbsp;&nbsp;globalParams&nbsp;=&nbsp;new&nbsp;GlobalParams(NULL);<br />&nbsp;&nbsp;&nbsp;&nbsp;globalParams-&gt;setErrQuiet(1);//not&nbsp;necessary<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;PDFDoc&nbsp;*doc&nbsp;=&nbsp;NULL;<br />&nbsp;&nbsp;&nbsp;&nbsp;doc&nbsp;=&nbsp;new&nbsp;PDFDoc(filename,&nbsp;NULL,&nbsp;NULL);<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(doc-&gt;isOk())<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;doc-&gt;getNumPages();<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Cleanup<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(doc&nbsp;!=&nbsp;NULL)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delete&nbsp;doc;<br />&nbsp;&nbsp;&nbsp;&nbsp;delete&nbsp;globalParams;<br />&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;-&nbsp;end&nbsp;of&nbsp;fuzzer&nbsp;contents&nbsp;&nbsp;-&nbsp;*/<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;cleanup&nbsp;temporary&nbsp;file<br />&nbsp;&nbsp;&nbsp;&nbsp;unlink(filename);<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />我们可以在此处观察到，除了必要的#include行之外，与模板模糊测试器不同的只有以下几行：<br /><h3>fuzz_pdf.cc snippet</h3><br /><br /><div class="codebox"><div class="codebox">&nbsp;&nbsp;&nbsp;&nbsp;globalParams&nbsp;=&nbsp;new&nbsp;GlobalParams(NULL);<br />&nbsp;&nbsp;&nbsp;&nbsp;globalParams-&gt;setErrQuiet(1);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;PDFDoc&nbsp;*doc&nbsp;=&nbsp;NULL;<br />&nbsp;&nbsp;&nbsp;&nbsp;doc&nbsp;=&nbsp;new&nbsp;PDFDoc(filename,&nbsp;NULL,&nbsp;NULL);<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(doc-&gt;isOk())<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;doc-&gt;getNumPages();<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Cleanup<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(doc&nbsp;!=&nbsp;NULL)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delete&nbsp;doc;<br />&nbsp;&nbsp;&nbsp;&nbsp;delete&nbsp;globalParams;</div></div><br /><br />我们可以使用以下命令来编译此模糊器：<br /><br /><div class="codebox"><div class="codebox">clang++&nbsp;fuzz_pdf.cc&nbsp;-fsanitize=fuzzer,address&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;./xpdf/libtestXpdfStatic.a&nbsp;./fofi/libfofi.a&nbsp;./goo/libgoo.a&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-I../&nbsp;-I../goo&nbsp;-I../fofi&nbsp;-I../xpdf&nbsp;-I.&nbsp;-g&nbsp;-o&nbsp;fuzz_pdf</div></div><br /><br /><br /><h2>Seed selection</h2><br />要为Xpdf建立良好的初始种子，我们需要一个小的PDF文件。 这个想法是，这个PDF文件将触发远远低于PDF解析例程的执行，并为模糊器提供了更多探索更多代码执行的可能性。<br /><br />我们将在这里使用简单的示例PDF文件作为模糊器的种子：<br /><br /><a href="http://www.africau.edu/images/default/sample.pdf">http://www.africau.edu/images/default/sample.pdf</a><br /><br />在上述情况下，如果在没有任何适当初始种子的情况下启动模糊器，则会得到以下输出：<br /><br /><div class="codebox"><div class="codebox">$&nbsp;mkdir&nbsp;PDF_SEEDS<br />$&nbsp;cd&nbsp;PDF_SEEDS<br />$&nbsp;wget&nbsp;http://www.africau.edu/images/default/sample.pdf<br />$&nbsp;cd&nbsp;../<br />$&nbsp;./fuzz_pdf&nbsp;./CORPUS_no_seed/<br />INFO:&nbsp;Seed:&nbsp;1378167629<br />INFO:&nbsp;Loaded&nbsp;1&nbsp;modules&nbsp;&nbsp;&nbsp;(19936&nbsp;inline&nbsp;8-bit&nbsp;counters):&nbsp;19936&nbsp;[0xafc700,&nbsp;0xb014e0),<br />INFO:&nbsp;Loaded&nbsp;1&nbsp;PC&nbsp;tables&nbsp;(19936&nbsp;PCs):&nbsp;19936&nbsp;[0x98b550,0x9d9350),<br />INFO:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;files&nbsp;found&nbsp;in&nbsp;./CORPUS_no_seed/<br />INFO:&nbsp;-max_len&nbsp;is&nbsp;not&nbsp;provided;&nbsp;libFuzzer&nbsp;will&nbsp;not&nbsp;generate&nbsp;inputs&nbsp;larger&nbsp;than&nbsp;4096&nbsp;bytes<br />INFO:&nbsp;A&nbsp;corpus&nbsp;is&nbsp;not&nbsp;provided,&nbsp;starting&nbsp;from&nbsp;an&nbsp;empty&nbsp;corpus<br />#2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;INITED&nbsp;cov:&nbsp;312&nbsp;ft:&nbsp;313&nbsp;corp:&nbsp;1/1b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;36Mb<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW_FUNC[1/1]:&nbsp;0x6a1320&nbsp;in&nbsp;Lexer::isSpace(int)&nbsp;(/work/xpdf-4.02/build/fuzz_pdf+0x6a1320)<br />#3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;318&nbsp;ft:&nbsp;322&nbsp;corp:&nbsp;2/2b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;39Mb&nbsp;L:&nbsp;1/1&nbsp;MS:&nbsp;1&nbsp;ChangeBit-<br />#15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;318&nbsp;ft:&nbsp;325&nbsp;corp:&nbsp;3/4b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;51Mb&nbsp;L:&nbsp;2/2&nbsp;MS:&nbsp;2&nbsp;ChangeByte-InsertByte-<br />#22&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;318&nbsp;ft:&nbsp;328&nbsp;corp:&nbsp;4/7b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;57Mb&nbsp;L:&nbsp;3/3&nbsp;MS:&nbsp;2&nbsp;ChangeByte-CMP-&nbsp;DE:&nbsp;&quot;..&quot;-<br />#27&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;318&nbsp;ft:&nbsp;330&nbsp;corp:&nbsp;5/11b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;62Mb&nbsp;L:&nbsp;4/4&nbsp;MS:&nbsp;5&nbsp;ChangeBit-EraseBytes-InsertByte-PersAutoDict-InsertByte-&nbsp;DE:&nbsp;&quot;..&quot;-<br />#55&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;320&nbsp;ft:&nbsp;332&nbsp;corp:&nbsp;6/15b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;88Mb&nbsp;L:&nbsp;4/4&nbsp;MS:&nbsp;3&nbsp;PersAutoDict-ChangeBit-InsertByte-&nbsp;DE:&nbsp;&quot;..&quot;-<br />#72&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;321&nbsp;ft:&nbsp;334&nbsp;corp:&nbsp;7/18b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;104Mb&nbsp;L:&nbsp;3/4&nbsp;MS:&nbsp;2&nbsp;ChangeBit-EraseBytes-<br />#86&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;322&nbsp;ft:&nbsp;335&nbsp;corp:&nbsp;8/22b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;117Mb&nbsp;L:&nbsp;4/4&nbsp;MS:&nbsp;4&nbsp;CopyPart-InsertByte-CrossOver-CMP-&nbsp;DE:&nbsp;&quot;7\x00&quot;-<br />#91&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;323&nbsp;ft:&nbsp;340&nbsp;corp:&nbsp;9/26b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;121Mb&nbsp;L:&nbsp;4/4&nbsp;MS:&nbsp;5&nbsp;ShuffleBytes-ChangeBit-ChangeBinInt-EraseBytes-CrossOver-<br />#102&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;323&nbsp;ft:&nbsp;342&nbsp;corp:&nbsp;10/28b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;131Mb&nbsp;L:&nbsp;2/4&nbsp;MS:&nbsp;1&nbsp;CrossOver-<br />#105&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;323&nbsp;ft:&nbsp;347&nbsp;corp:&nbsp;11/32b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;134Mb&nbsp;L:&nbsp;4/4&nbsp;MS:&nbsp;3&nbsp;CopyPart-ChangeBit-CrossOver-<br />#110&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;324&nbsp;ft:&nbsp;351&nbsp;corp:&nbsp;12/36b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;139Mb&nbsp;L:&nbsp;4/4&nbsp;MS:&nbsp;5&nbsp;CopyPart-CopyPart-CrossOver-ChangeByte-ShuffleBytes-<br />#119&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;324&nbsp;ft:&nbsp;352&nbsp;corp:&nbsp;13/40b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;147Mb&nbsp;L:&nbsp;4/4&nbsp;MS:&nbsp;4&nbsp;CrossOver-ChangeBit-CMP-CopyPart-&nbsp;DE:&nbsp;&quot;\x017&quot;-<br />#120&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;324&nbsp;ft:&nbsp;352&nbsp;corp:&nbsp;13/39b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;148Mb&nbsp;L:&nbsp;3/4&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#126&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;324&nbsp;ft:&nbsp;353&nbsp;corp:&nbsp;14/42b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;154Mb&nbsp;L:&nbsp;3/4&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#127&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;324&nbsp;ft:&nbsp;353&nbsp;corp:&nbsp;14/41b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;155Mb&nbsp;L:&nbsp;2/4&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#132&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;324&nbsp;ft:&nbsp;354&nbsp;corp:&nbsp;15/45b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;159Mb&nbsp;L:&nbsp;4/4&nbsp;MS:&nbsp;5&nbsp;ShuffleBytes-ChangeByte-ChangeBinInt-EraseBytes-CopyPart-<br />#168&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;324&nbsp;ft:&nbsp;354&nbsp;corp:&nbsp;15/43b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;193Mb&nbsp;L:&nbsp;2/4&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#185&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;324&nbsp;ft:&nbsp;357&nbsp;corp:&nbsp;16/47b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;185&nbsp;rss:&nbsp;209Mb&nbsp;L:&nbsp;4/4&nbsp;MS:&nbsp;2&nbsp;CrossOver-CrossOver-<br />#199&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;324&nbsp;ft:&nbsp;357&nbsp;corp:&nbsp;16/45b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;199&nbsp;rss:&nbsp;222Mb&nbsp;L:&nbsp;2/4&nbsp;MS:&nbsp;4&nbsp;EraseBytes-ShuffleBytes-ShuffleBytes-ChangeBinInt-<br />#244&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;324&nbsp;ft:&nbsp;359&nbsp;corp:&nbsp;17/49b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;244&nbsp;rss:&nbsp;263Mb&nbsp;L:&nbsp;4/4&nbsp;MS:&nbsp;5&nbsp;ChangeByte-CopyPart-CrossOver-CrossOver-ShuffleBytes-<br />#254&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;324&nbsp;ft:&nbsp;359&nbsp;corp:&nbsp;17/48b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;254&nbsp;rss:&nbsp;273Mb&nbsp;L:&nbsp;3/4&nbsp;MS:&nbsp;5&nbsp;ChangeBit-ChangeASCIIInt-ChangeByte-CopyPart-EraseBytes-<br />#277&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;324&nbsp;ft:&nbsp;362&nbsp;corp:&nbsp;18/52b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;277&nbsp;rss:&nbsp;294Mb&nbsp;L:&nbsp;4/4&nbsp;MS:&nbsp;3&nbsp;EraseBytes-ChangeBit-CrossOver-<br />#289&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;324&nbsp;ft:&nbsp;363&nbsp;corp:&nbsp;19/56b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;289&nbsp;rss:&nbsp;305Mb&nbsp;L:&nbsp;4/4&nbsp;MS:&nbsp;2&nbsp;CopyPart-CrossOver-<br />#320&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;324&nbsp;ft:&nbsp;363&nbsp;corp:&nbsp;19/55b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;320&nbsp;rss:&nbsp;334Mb&nbsp;L:&nbsp;3/4&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#330&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;326&nbsp;ft:&nbsp;365&nbsp;corp:&nbsp;20/57b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;330&nbsp;rss:&nbsp;343Mb&nbsp;L:&nbsp;2/4&nbsp;MS:&nbsp;5&nbsp;CopyPart-EraseBytes-CrossOver-PersAutoDict-EraseBytes-&nbsp;DE:&nbsp;&quot;\x017&quot;-<br />#351&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;326&nbsp;ft:&nbsp;365&nbsp;corp:&nbsp;20/56b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;351&nbsp;rss:&nbsp;362Mb&nbsp;L:&nbsp;1/4&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#353&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;327&nbsp;ft:&nbsp;366&nbsp;corp:&nbsp;21/60b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;353&nbsp;rss:&nbsp;364Mb&nbsp;L:&nbsp;4/4&nbsp;MS:&nbsp;2&nbsp;ChangeBit-ChangeByte-<br />#388&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;332&nbsp;ft:&nbsp;371&nbsp;corp:&nbsp;22/64b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;194&nbsp;rss:&nbsp;393Mb&nbsp;L:&nbsp;4/4&nbsp;MS:&nbsp;5&nbsp;EraseBytes-ShuffleBytes-ChangeBit-PersAutoDict-CrossOver-&nbsp;DE:&nbsp;&quot;..&quot;-<br />#394&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;332&nbsp;ft:&nbsp;372&nbsp;corp:&nbsp;23/68b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;197&nbsp;rss:&nbsp;393Mb&nbsp;L:&nbsp;4/4&nbsp;MS:&nbsp;1&nbsp;CopyPart-<br />#417&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;332&nbsp;ft:&nbsp;373&nbsp;corp:&nbsp;24/72b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;208&nbsp;rss:&nbsp;393Mb&nbsp;L:&nbsp;4/4&nbsp;MS:&nbsp;3&nbsp;ChangeBinInt-CrossOver-ChangeBinInt-<br />#429&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;332&nbsp;ft:&nbsp;373&nbsp;corp:&nbsp;24/71b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;214&nbsp;rss:&nbsp;394Mb&nbsp;L:&nbsp;3/4&nbsp;MS:&nbsp;2&nbsp;CopyPart-EraseBytes-<br />#430&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;332&nbsp;ft:&nbsp;374&nbsp;corp:&nbsp;25/75b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;215&nbsp;rss:&nbsp;394Mb&nbsp;L:&nbsp;4/4&nbsp;MS:&nbsp;1&nbsp;CrossOver-<br />#512&nbsp;&nbsp;&nbsp;&nbsp;pulse&nbsp;&nbsp;cov:&nbsp;332&nbsp;ft:&nbsp;374&nbsp;corp:&nbsp;25/75b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;256&nbsp;rss:&nbsp;395Mb<br />#645&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;332&nbsp;ft:&nbsp;375&nbsp;corp:&nbsp;26/81b&nbsp;lim:&nbsp;6&nbsp;exec/s:&nbsp;215&nbsp;rss:&nbsp;395Mb&nbsp;L:&nbsp;6/6&nbsp;MS:&nbsp;5&nbsp;ChangeBit-ChangeByte-ChangeBit-InsertByte-CrossOver-<br />#653&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;332&nbsp;ft:&nbsp;375&nbsp;corp:&nbsp;26/80b&nbsp;lim:&nbsp;6&nbsp;exec/s:&nbsp;217&nbsp;rss:&nbsp;395Mb&nbsp;L:&nbsp;2/6&nbsp;MS:&nbsp;3&nbsp;ChangeBit-ChangeByte-EraseBytes-<br />#703&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;332&nbsp;ft:&nbsp;376&nbsp;corp:&nbsp;27/86b&nbsp;lim:&nbsp;6&nbsp;exec/s:&nbsp;234&nbsp;rss:&nbsp;396Mb&nbsp;L:&nbsp;6/6&nbsp;MS:&nbsp;5&nbsp;CrossOver-CopyPart-CrossOver-ChangeBinInt-CrossOver-</div></div><br /><br /><br />但是，如果使用正确的种子启动完全相同的模糊器，则会得到以下输出：<br /><br /><div class="codebox"><div class="codebox">$&nbsp;./fuzz_pdf&nbsp;./CORPUS_with_seed/&nbsp;./PDF_SEEDS/<br />INFO:&nbsp;Seed:&nbsp;1708208234<br />INFO:&nbsp;Loaded&nbsp;1&nbsp;modules&nbsp;&nbsp;&nbsp;(19936&nbsp;inline&nbsp;8-bit&nbsp;counters):&nbsp;19936&nbsp;[0xafc700,&nbsp;0xb014e0),<br />INFO:&nbsp;Loaded&nbsp;1&nbsp;PC&nbsp;tables&nbsp;(19936&nbsp;PCs):&nbsp;19936&nbsp;[0x98b550,0x9d9350),<br />INFO:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;files&nbsp;found&nbsp;in&nbsp;./CORPUS_with_seed/<br />INFO:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;files&nbsp;found&nbsp;in&nbsp;./PDF_SEEDS/<br />INFO:&nbsp;-max_len&nbsp;is&nbsp;not&nbsp;provided;&nbsp;libFuzzer&nbsp;will&nbsp;not&nbsp;generate&nbsp;inputs&nbsp;larger&nbsp;than&nbsp;4096&nbsp;bytes<br />INFO:&nbsp;seed&nbsp;corpus:&nbsp;files:&nbsp;1&nbsp;min:&nbsp;3028b&nbsp;max:&nbsp;3028b&nbsp;total:&nbsp;3028b&nbsp;rss:&nbsp;33Mb<br />#2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;INITED&nbsp;cov:&nbsp;750&nbsp;ft:&nbsp;751&nbsp;corp:&nbsp;1/3028b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;37Mb<br />#4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;752&nbsp;ft:&nbsp;760&nbsp;corp:&nbsp;2/6056b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;41Mb&nbsp;L:&nbsp;3028/3028&nbsp;MS:&nbsp;2&nbsp;ChangeBinInt-ChangeByte-<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW_FUNC[1/5]:&nbsp;0x54c470&nbsp;in&nbsp;GlobalParams::getErrQuiet()&nbsp;(/work/xpdf-4.02/build/fuzz_pdf+0x54c470)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW_FUNC[2/5]:&nbsp;0x6126e0&nbsp;in&nbsp;error(ErrorCategory,&nbsp;long,&nbsp;char&nbsp;const*,&nbsp;...)&nbsp;(/work/xpdf-4.02/build/fuzz_pdf+0x6126e0)<br />#11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;762&nbsp;ft:&nbsp;825&nbsp;corp:&nbsp;3/9084b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;48Mb&nbsp;L:&nbsp;3028/3028&nbsp;MS:&nbsp;2&nbsp;CopyPart-ChangeBit-<br />#12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;762&nbsp;ft:&nbsp;827&nbsp;corp:&nbsp;4/12112b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;49Mb&nbsp;L:&nbsp;3028/3028&nbsp;MS:&nbsp;1&nbsp;ChangeBinInt-<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW_FUNC[1/3]:&nbsp;0x554790&nbsp;in&nbsp;XRef::getErrorCode()&nbsp;(/work/xpdf-4.02/build/fuzz_pdf+0x554790)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW_FUNC[2/3]:&nbsp;0x55fb90&nbsp;in&nbsp;Stream::getLine(char*,&nbsp;int)&nbsp;(/work/xpdf-4.02/build/fuzz_pdf+0x55fb90)<br />#14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;810&nbsp;ft:&nbsp;914&nbsp;corp:&nbsp;5/15140b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;52Mb&nbsp;L:&nbsp;3028/3028&nbsp;MS:&nbsp;2&nbsp;ChangeBit-CopyPart-<br />#16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;828&nbsp;ft:&nbsp;993&nbsp;corp:&nbsp;6/17Kb&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;54Mb&nbsp;L:&nbsp;3028/3028&nbsp;MS:&nbsp;2&nbsp;ChangeBit-CrossOver-<br />AddressSanitizer:DEADLYSIGNAL<br />=================================================================<br />==2711==ERROR:&nbsp;AddressSanitizer:&nbsp;SEGV&nbsp;on&nbsp;unknown&nbsp;address&nbsp;0x000000000000&nbsp;(pc&nbsp;0x00000052b90b&nbsp;bp&nbsp;0x7fffc538f1d0&nbsp;sp&nbsp;0x7fffc538f1b0&nbsp;T0)<br />==2711==The&nbsp;signal&nbsp;is&nbsp;caused&nbsp;by&nbsp;a&nbsp;READ&nbsp;memory&nbsp;access.<br />==2711==Hint:&nbsp;address&nbsp;points&nbsp;to&nbsp;the&nbsp;zero&nbsp;page.<br />&nbsp;&nbsp;&nbsp;&nbsp;#0&nbsp;0x52b90a&nbsp;in&nbsp;GList::getLength()&nbsp;(/work/xpdf-4.02/build/fuzz_pdf+0x52b90a)<br />&nbsp;&nbsp;&nbsp;&nbsp;#1&nbsp;0x5dac90&nbsp;in&nbsp;Catalog::~Catalog()&nbsp;(/work/xpdf-4.02/build/fuzz_pdf+0x5dac90)<br />&nbsp;&nbsp;&nbsp;&nbsp;#2&nbsp;0x554572&nbsp;in&nbsp;PDFDoc::setup2(GString*,&nbsp;GString*,&nbsp;int)&nbsp;(/work/xpdf-4.02/build/fuzz_pdf+0x554572)<br />&nbsp;&nbsp;&nbsp;&nbsp;#3&nbsp;0x55292b&nbsp;in&nbsp;PDFDoc::setup(GString*,&nbsp;GString*)&nbsp;(/work/xpdf-4.02/build/fuzz_pdf+0x55292b)<br />&nbsp;&nbsp;&nbsp;&nbsp;#4&nbsp;0x553204&nbsp;in&nbsp;PDFDoc::PDFDoc(char*,&nbsp;GString*,&nbsp;GString*,&nbsp;PDFCore*)&nbsp;(/work/xpdf-4.02/build/fuzz_pdf+0x553204)<br />&nbsp;&nbsp;&nbsp;&nbsp;#5&nbsp;0x52a4ec&nbsp;in&nbsp;LLVMFuzzerTestOneInput&nbsp;/work/xpdf-4.02/build/fuzz_pdf.cc:25:15<br />&nbsp;&nbsp;&nbsp;&nbsp;#6&nbsp;0x431f5a&nbsp;in&nbsp;fuzzer::Fuzzer::ExecuteCallback(unsigned&nbsp;char&nbsp;const*,&nbsp;unsigned&nbsp;long)&nbsp;(/work/xpdf-4.02/build/fuzz_pdf+0x431f5a)<br />&nbsp;&nbsp;&nbsp;&nbsp;#7&nbsp;0x431725&nbsp;in&nbsp;fuzzer::Fuzzer::RunOne(unsigned&nbsp;char&nbsp;const*,&nbsp;unsigned&nbsp;long,&nbsp;bool,&nbsp;fuzzer::InputInfo*,&nbsp;bool*)&nbsp;(/work/xpdf-4.02/build/fuzz_pdf+0x431725)<br />&nbsp;&nbsp;&nbsp;&nbsp;#8&nbsp;0x433749&nbsp;in&nbsp;fuzzer::Fuzzer::MutateAndTestOne()&nbsp;(/work/xpdf-4.02/build/fuzz_pdf+0x433749)<br />&nbsp;&nbsp;&nbsp;&nbsp;#9&nbsp;0x434425&nbsp;in&nbsp;fuzzer::Fuzzer::Loop(std::vector,&nbsp;std::allocator&nbsp;&gt;,&nbsp;fuzzer::fuzzer_allocator,&nbsp;std::allocator&nbsp;&gt;&nbsp;&gt;&nbsp;&gt;&nbsp;const&amp;)&nbsp;(/work/xpdf-4.02/build/fuzz_pdf+0x434425)<br />&nbsp;&nbsp;&nbsp;&nbsp;#10&nbsp;0x428db8&nbsp;in&nbsp;fuzzer::FuzzerDriver(int*,&nbsp;char***,&nbsp;int&nbsp;(*)(unsigned&nbsp;char&nbsp;const*,&nbsp;unsigned&nbsp;long))&nbsp;(/work/xpdf-4.02/build/fuzz_pdf+0x428db8)<br />&nbsp;&nbsp;&nbsp;&nbsp;#11&nbsp;0x44c4a2&nbsp;in&nbsp;main&nbsp;(/work/xpdf-4.02/build/fuzz_pdf+0x44c4a2)<br />&nbsp;&nbsp;&nbsp;&nbsp;#12&nbsp;0x7fb5fefd60b2&nbsp;in&nbsp;__libc_start_main&nbsp;(/lib/x86_64-linux-gnu/libc.so.6+0x270b2)<br />&nbsp;&nbsp;&nbsp;&nbsp;#13&nbsp;0x421b1d&nbsp;in&nbsp;_start&nbsp;(/work/xpdf-4.02/build/fuzz_pdf+0x421b1d)<br /><br />AddressSanitizer&nbsp;can&nbsp;not&nbsp;provide&nbsp;additional&nbsp;info.<br />SUMMARY:&nbsp;AddressSanitizer:&nbsp;SEGV&nbsp;(/work/xpdf-4.02/build/fuzz_pdf+0x52b90a)&nbsp;in&nbsp;GList::getLength()<br />==2711==ABORTING<br />MS:&nbsp;2&nbsp;ChangeBit-ShuffleBytes-;&nbsp;base&nbsp;unit:&nbsp;bfd009f500c057195ffde66fae64f92fa5f59b72<br />artifact_prefix=&#39;./&#39;;&nbsp;Test&nbsp;unit&nbsp;written&nbsp;to&nbsp;./crash-562b67121d666996510781048ba5047334e6a8f4</div></div><br /><br />与没有适当的种子相比，通过对具有适当种子的PDF解析器进行模糊处理，我们可以得出的两个主要观察结果是覆盖率显着提高，并且我们还在过程的早期发现了应用程序崩溃。因此，在这种情况下，种子的供应对整体fuzz体验有相当大的影响。<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /></div><div class='page'><h1 class='title level-4'>4_Seed selection and dictionary in Pugixml _ ADA Logics</h1><br/>目标项目<br /><a href=""><img src="images\941-1.png" alt="images\941-1.png" /></a><br /><br />该项目源码仅保存在三个文件中，每个文件中代码行数较多，有一定复杂性<br />该项目源代码集中于少数几个文件，适合被fuzz<br /><a href=""><img src="images\941-2.png" alt="images\941-2.png" /></a><br /><br />项目中test目录下存在测试程序，其中存在现成的fuzz程序<br />data_fuzz_parse、data_fuzz_xpath两个文件夹中保存两个fuzzer的种子文件<br /><a href=""><img src="images\941-3.png" alt="images\941-3.png" /></a><a href=""><img src="images\941-4.png" alt="images\941-4.png" /></a><br />.dict结尾的文件就是每个fuzzer对应的字典文件 <br /><a href=""><img src="images\941-5.png" alt="images\941-5.png" /></a><br /><br />项目的makefile文件中存在fuzz相关字眼<br />其中第一个fuzz_% 表示该makefile文件支持make fuzz_XXX的指令格式，从而编译具体的fuzz（例如fuzz_parse）<br />$(BUILD)/fuzz_%指令会调用后面的$(BUILD)/fuzz_%:test/fuzz_%.cpp src/pugixml.cpp等指令完成fuzzer的编译<br /> <br /><a href=""><img src="images\941-6.png" alt="images\941-6.png" /></a><br /><br />将项目克隆到本地<br /><br />输入make fuzz_parse指令，fuzz会被编译完成并开始运行，make fuzz_xpath与之类似<br /><a href=""><img src="images\941-7.png" alt="images\941-7.png" /></a><br /><br />此时build目录下对应目录包含fuzz运行过程中创建的语料库<br /><a href=""><img src="images\941-8.png" alt="images\941-8.png" /></a><br /><br />再次运行make fuzz_parse，可以从输出中找到makefile中编译该fuzzer的指令，拷贝下来<br /><a href=""><img src="images\941-9.png" alt="images\941-9.png" /></a><br /><br />单独运行编译指令，发现可以成功编译<br /><a href=""><img src="images\941-10.png" alt="images\941-10.png" /></a><br /><br />将fuzz_parse拷贝到项目根目录，方便操作<br /><br />同理可以运行编译命令从而编译fuzz_xpath<br /><a href=""><img src="images\941-11.png" alt="images\941-11.png" /></a><br /><br />创建两个语料库，一个用于有种子的情况，一个用于无种子的情况<br /><a href=""><img src="images\941-12.png" alt="images\941-12.png" /></a><br /><br />无种子情况下运行fuzzer 90秒<br /><a href=""><img src="images\941-13.png" alt="images\941-13.png" /></a><br /><br />运行完毕后，语料库中产生测试用例918个，cov大概455<br /><a href=""><img src="images\941-14.png" alt="images\941-14.png" /></a><br /><br />带种子文件运行fuzzer，运行完毕后cov为584，有了较大提高<br /><a href=""><img src="images\941-15.png" alt="images\941-15.png" /></a><br /><br />fuzz_xpath同理，不带种子，cov为399（这里corpus文件夹用错了，应当是corpus_xpath_without_seeds）<br />语料库中产生818个测试用例<br /><a href=""><img src="images\941-16.png" alt="images\941-16.png" /></a><br /><br />带种子运行fuzz_xpath ,cov421，语料库中生成858条用例<br /><a href=""><img src="images\941-17.png" alt="images\941-17.png" /></a><br /><br />创建两个文件夹，用于对比有字典和无字典情况下语料库的生成 <br /><a href=""><img src="images\941-18.png" alt="images\941-18.png" /></a><br /><br />带字典目录进行fuzz，cov为477，语料库生成1015个测试用例（相较于使用/不使用种子文件的情况均有较大改善）<br /><a href=""><img src="images\941-19.png" alt="images\941-19.png" /></a><br /><br />针对fuzz_parser做同样的事情，cov为607，语料库生成 1379个测试用例<br /><a href=""><img src="images\941-20.png" alt="images\941-20.png" /></a><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /></div><div class='page'><h1 class='title level-4'>5_Seed_selection_PugiXML</h1><br/><h1>Seed selection: PugiXML</h1><br /><br /><h3>In this section we will apply seed selection for TinyXML and Pugixml.</h3><br /><br /><h3>The first step is to glone the repository:</h3><br /><h3>git clone </h3><a href="https://github.com/zeux/pugixml">https://github.com/zeux/pugixml</a><br /><br />在这种情况下，Pugixml在路径中已经包含两个模糊器：tests / fuzz_xpath.cpp和tests / fuzz_parse.cpp。 这些模糊器都很简单，我们不需要深入了解库即可了解它们的作用：<br /><h3>fuzz_parser.cpp:</h3><br /><div class="codebox"><div class="codebox">#include&nbsp;&quot;../src/pugixml.hpp&quot;<br /><br />#include&nbsp;&lt;stdint.h&gt;<br /><br />extern&nbsp;&quot;C&quot;&nbsp;int&nbsp;LLVMFuzzerTestOneInput(const&nbsp;uint8_t&nbsp;*Data,&nbsp;size_t&nbsp;Size)<br /><span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;pugi::xml_document&nbsp;doc;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;doc.load_buffer(Data,&nbsp;Size);<br />&nbsp;&nbsp;&nbsp;&nbsp;doc.load_buffer(Data,&nbsp;Size,&nbsp;pugi::parse_minimal);<br />&nbsp;&nbsp;&nbsp;&nbsp;doc.load_buffer(Data,&nbsp;Size,&nbsp;pugi::parse_full);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />该模糊器将仅创建pugi :: xml_document类型的对象，并使用来自模糊器的数据填充该对象。  pugi :: xml_document类型只是PugiXML定义的XML文档的表示形式。 因此，此模糊器直接针对PugiXML的XML解析例程。<br /><br /><h3>fuzz_xpath.cpp:</h3><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdint.h&gt;<br />#include&nbsp;&lt;string.h&gt;<br /><br />extern&nbsp;&quot;C&quot;&nbsp;int&nbsp;LLVMFuzzerTestOneInput(const&nbsp;uint8_t&nbsp;*Data,&nbsp;size_t&nbsp;Size)<br /><span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;char*&nbsp;text&nbsp;=&nbsp;new&nbsp;char[Size&nbsp;+&nbsp;1];<br />&nbsp;&nbsp;&nbsp;&nbsp;memcpy(text,&nbsp;Data,&nbsp;Size);<br />&nbsp;&nbsp;&nbsp;&nbsp;text[Size]&nbsp;=&nbsp;0;<br /><br />#ifdef&nbsp;PUGIXML_NO_EXCEPTIONS<br />&nbsp;&nbsp;&nbsp;&nbsp;pugi::xpath_query&nbsp;q(text);<br />#else<br />&nbsp;&nbsp;&nbsp;&nbsp;try<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pugi::xpath_query&nbsp;q(text);<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;catch&nbsp;(pugi::xpath_exception&amp;)<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />#endif<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;delete[]&nbsp;text;<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />该模糊器以pugi :: xpath_query构造函数为目标，并具有两个设置，具体取决于项目是否编译有异常。 请注意，除了对pugi :: xpath_query的调用外，模糊器类似于我们的以null结尾的字符串的模板模糊器，但是它不是纯C代码，而是包含各种C ++代码构造。<br /><br />我们将编译这两个模糊器，以探索在有种子和无种子情况下运行它们之间的区别。 我们在以下代码中找到了在Makefile中编译这些模糊器的方法：<br /><br /><div class="codebox"><div class="codebox">fuzz_%:&nbsp;$(BUILD)/fuzz_%<br />&nbsp;&nbsp;&nbsp;&nbsp;@mkdir&nbsp;-p&nbsp;build/$@<br />&nbsp;&nbsp;&nbsp;&nbsp;$&lt;&nbsp;build/$@&nbsp;tests/data_fuzz_$*&nbsp;-max_len=1024&nbsp;-dict=tests/fuzz_$*.dict<br />...<br />...<br />$(BUILD)/fuzz_%:&nbsp;tests/fuzz_%.cpp&nbsp;src/pugixml.cpp<br />&nbsp;&nbsp;&nbsp;&nbsp;@mkdir&nbsp;-p&nbsp;$(BUILD)<br />&nbsp;&nbsp;&nbsp;&nbsp;$(CXX)&nbsp;$(CXXFLAGS)&nbsp;-fsanitize=address,fuzzer&nbsp;$^&nbsp;-o&nbsp;$@</div></div><br /><br />这些行用于构建和运行每个模糊器，因此，如果我们只是转到项目的根文件夹并运行以下命令：<br /><br /><h3>$</h3><h3> make fuzz_parse </h3><br /><h3>$</h3><h3> make fuzz_xpath</h3><br /><br />但是，由于makefile负责构建，运行和删除文件，因此我们将观察Make发出的用于编译模糊器的命令。 然后，我们将分别使用以下命令来编译模糊器：<br /><br /><div class="codebox"><div class="codebox">$&nbsp;clang++&nbsp;-g&nbsp;-Wall&nbsp;-Wextra&nbsp;-Werror&nbsp;-pedantic&nbsp;-Wundef&nbsp;-Wshadow&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;-Wcast-align&nbsp;-Wcast-qual&nbsp;-Wold-style-cast&nbsp;-Wdouble-promotion&nbsp;-std=c++11&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;-fsanitize=address,fuzzer&nbsp;tests/fuzz_xpath.cpp&nbsp;src/pugixml.cpp&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;-o&nbsp;build/make-clang++-debug-standard-c++11/fuzz_xpath<br /><br />$&nbsp;clang++&nbsp;-g&nbsp;-Wall&nbsp;-Wextra&nbsp;-Werror&nbsp;-pedantic&nbsp;-Wundef&nbsp;-Wshadow&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;-Wcast-align&nbsp;-Wcast-qual&nbsp;-Wold-style-cast&nbsp;-Wdouble-promotion&nbsp;-std=c++11&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;-fsanitize=address,fuzzer&nbsp;tests/fuzz_parse.cpp&nbsp;src/pugixml.cpp&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;-o&nbsp;build/make-clang++-debug-standard-c++11/fuzz_parse</div></div><br /><br />这会将模糊测试程序的可执行文件放在以下文件夹中：build / make-clang ++-debug-standard-c ++ 11 /，您可以如下所示：<br /><h3>$</h3><h3> ls  build/make-clang++-debug-standard-c++11/ <br />fuzz_parse  fuzz_xpath</h3><br /><br /><br /><h1>运行模糊器</h1><br />下一步是运行模糊器，并确定提供种子和不提供种子之间的区别。 为此，我们将首先创建几个文件夹，用于存储语料库，并为每个模糊器创建两个文件夹：<br /><h3>$</h3><h3> mkdir CORPUS_PARSE_CLEAN </h3><br /><h3>$</h3><h3> mkdir CORPUS_PARSE_WITH_SEED </h3><br /><h3>$</h3><h3> mkdir CORPUS_XPATH_CLEAN </h3><br /><h3>$</h3><h3> mkdir CORPUS_XPATH_WITH_SEED </h3><br /><br />fuzz_parse<br />此时，我们将启动没有任何种子的模糊器，并观察我们实现的覆盖范围：<br /><div class="codebox"><div class="codebox">$&nbsp;./build/make-clang++-debug-standard-c++11/fuzz_parse&nbsp;./CORPUS_PARSE_CLEAN<br />INFO:&nbsp;Seed:&nbsp;1149997003<br />INFO:&nbsp;Loaded&nbsp;1&nbsp;modules&nbsp;&nbsp;&nbsp;(4919&nbsp;inline&nbsp;8-bit&nbsp;counters):&nbsp;4919&nbsp;[0x64e6b0,&nbsp;0x64f9e7),&nbsp;<br />INFO:&nbsp;Loaded&nbsp;1&nbsp;PC&nbsp;tables&nbsp;(4919&nbsp;PCs):&nbsp;4919&nbsp;[0x605428,0x618798),&nbsp;<br />INFO:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;files&nbsp;found&nbsp;in&nbsp;./CORPUS_PARSE_CLEAN/<br />INFO:&nbsp;-max_len&nbsp;is&nbsp;not&nbsp;provided;&nbsp;libFuzzer&nbsp;will&nbsp;not&nbsp;generate&nbsp;inputs&nbsp;larger&nbsp;than&nbsp;4096&nbsp;bytes<br />INFO:&nbsp;A&nbsp;corpus&nbsp;is&nbsp;not&nbsp;provided,&nbsp;starting&nbsp;from&nbsp;an&nbsp;empty&nbsp;corpus<br />#2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;INITED&nbsp;cov:&nbsp;63&nbsp;ft:&nbsp;64&nbsp;corp:&nbsp;1/1b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;28Mb<br />#4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;69&nbsp;ft:&nbsp;70&nbsp;corp:&nbsp;2/2b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;28Mb&nbsp;L:&nbsp;1/1&nbsp;MS:&nbsp;2&nbsp;ShuffleBytes-ChangeBit-<br />#8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;69&nbsp;ft:&nbsp;72&nbsp;corp:&nbsp;3/4b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;28Mb&nbsp;L:&nbsp;2/2&nbsp;MS:&nbsp;4&nbsp;ChangeByte-ChangeByte-ShuffleBytes-InsertByte-<br />#12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;81&nbsp;ft:&nbsp;86&nbsp;corp:&nbsp;4/8b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;28Mb&nbsp;L:&nbsp;4/4&nbsp;MS:&nbsp;4&nbsp;EraseBytes-CopyPart-CopyPart-CMP-&nbsp;DE:&nbsp;&quot;\xff\xff&quot;-<br />#13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;83&nbsp;ft:&nbsp;88&nbsp;corp:&nbsp;5/12b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;28Mb&nbsp;L:&nbsp;4/4&nbsp;MS:&nbsp;1&nbsp;ShuffleBytes-<br />#22&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;87&nbsp;ft:&nbsp;92&nbsp;corp:&nbsp;6/16b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;28Mb&nbsp;L:&nbsp;4/4&nbsp;MS:&nbsp;4&nbsp;CrossOver-ChangeByte-ChangeBit-ChangeBinInt-<br />#34&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;88&nbsp;ft:&nbsp;93&nbsp;corp:&nbsp;7/20b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;28Mb&nbsp;L:&nbsp;4/4&nbsp;MS:&nbsp;2&nbsp;EraseBytes-CopyPart-<br />#80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;90&nbsp;ft:&nbsp;95&nbsp;corp:&nbsp;8/24b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;28Mb&nbsp;L:&nbsp;4/4&nbsp;MS:&nbsp;1&nbsp;ShuffleBytes-<br />#321&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;90&nbsp;ft:&nbsp;97&nbsp;corp:&nbsp;9/30b&nbsp;lim:&nbsp;6&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;28Mb&nbsp;L:&nbsp;6/6&nbsp;MS:&nbsp;1&nbsp;InsertRepeatedBytes-<br />#337&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;90&nbsp;ft:&nbsp;98&nbsp;corp:&nbsp;10/32b&nbsp;lim:&nbsp;6&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;28Mb&nbsp;L:&nbsp;2/6&nbsp;MS:&nbsp;1&nbsp;CopyPart-<br />#338&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;90&nbsp;ft:&nbsp;99&nbsp;corp:&nbsp;11/35b&nbsp;lim:&nbsp;6&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;29Mb&nbsp;L:&nbsp;3/6&nbsp;MS:&nbsp;1&nbsp;CopyPart-<br />#345&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;90&nbsp;ft:&nbsp;100&nbsp;corp:&nbsp;12/41b&nbsp;lim:&nbsp;6&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;29Mb&nbsp;L:&nbsp;6/6&nbsp;MS:&nbsp;2&nbsp;ChangeBinInt-CopyPart-<br />#590&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;91&nbsp;ft:&nbsp;101&nbsp;corp:&nbsp;13/45b&nbsp;lim:&nbsp;8&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;29Mb&nbsp;L:&nbsp;4/6&nbsp;MS:&nbsp;5&nbsp;ShuffleBytes-PersAutoDict-ChangeByte-ChangeBit-ChangeBit-&nbsp;DE:&nbsp;&quot;\xff\xff&quot;-<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW_FUNC[1/7]:&nbsp;0x56ee60&nbsp;in&nbsp;pugi::impl::(anonymous&nbsp;namespace)::is_little_endian()&nbsp;/work/seeds/pugixml2/pugixml/src/pugixml.cpp:1902<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW_FUNC[2/7]:&nbsp;0x572a90&nbsp;in&nbsp;bool&nbsp;pugi::impl::(anonymous&nbsp;namespace)::convert_buffer_generic&nbsp;&gt;(char*&amp;,&nbsp;unsigned&nbsp;long&amp;,&nbsp;void&nbsp;const*,&nbsp;unsigned&nbsp;long,&nbsp;pugi::impl::(anonymous&nbsp;namespace)::utf16_decoder)&nbsp;/work/seeds/pugixml2/pugixml/src/pugixml.cpp:2175<br />#642&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;110&nbsp;ft:&nbsp;120&nbsp;corp:&nbsp;14/51b&nbsp;lim:&nbsp;8&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;29Mb&nbsp;L:&nbsp;6/6&nbsp;MS:&nbsp;2&nbsp;ChangeBit-PersAutoDict-&nbsp;DE:&nbsp;&quot;\xff\xff&quot;-<br />...<br />...<br />...<br />#15715369&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;481&nbsp;ft:&nbsp;2309&nbsp;corp:&nbsp;979/134Kb&nbsp;lim:&nbsp;4096&nbsp;exec/s:&nbsp;32006&nbsp;rss:&nbsp;399Mb&nbsp;L:&nbsp;209/3988&nbsp;MS:&nbsp;2&nbsp;EraseBytes-CopyPart-<br />#15716270&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;481&nbsp;ft:&nbsp;2309&nbsp;corp:&nbsp;979/134Kb&nbsp;lim:&nbsp;4096&nbsp;exec/s:&nbsp;32008&nbsp;rss:&nbsp;399Mb&nbsp;L:&nbsp;385/3988&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#15729306&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;481&nbsp;ft:&nbsp;2309&nbsp;corp:&nbsp;979/134Kb&nbsp;lim:&nbsp;4096&nbsp;exec/s:&nbsp;31970&nbsp;rss:&nbsp;399Mb&nbsp;L:&nbsp;77/3988&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#15730640&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;481&nbsp;ft:&nbsp;2309&nbsp;corp:&nbsp;979/134Kb&nbsp;lim:&nbsp;4096&nbsp;exec/s:&nbsp;31972&nbsp;rss:&nbsp;399Mb&nbsp;L:&nbsp;124/3988&nbsp;MS:&nbsp;4&nbsp;ChangeByte-CopyPart-ChangeBinInt-EraseBytes-<br />#15732941&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;481&nbsp;ft:&nbsp;2309&nbsp;corp:&nbsp;979/134Kb&nbsp;lim:&nbsp;4096&nbsp;exec/s:&nbsp;31977&nbsp;rss:&nbsp;399Mb&nbsp;L:&nbsp;95/3988&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#15736367&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;481&nbsp;ft:&nbsp;2309&nbsp;corp:&nbsp;979/134Kb&nbsp;lim:&nbsp;4096&nbsp;exec/s:&nbsp;31984&nbsp;rss:&nbsp;399Mb&nbsp;L:&nbsp;78/3988&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#15737573&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;481&nbsp;ft:&nbsp;2309&nbsp;corp:&nbsp;979/134Kb&nbsp;lim:&nbsp;4096&nbsp;exec/s:&nbsp;31986&nbsp;rss:&nbsp;399Mb&nbsp;L:&nbsp;22/3988&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#15739079&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;481&nbsp;ft:&nbsp;2309&nbsp;corp:&nbsp;979/134Kb&nbsp;lim:&nbsp;4096&nbsp;exec/s:&nbsp;31989&nbsp;rss:&nbsp;399Mb&nbsp;L:&nbsp;214/3988&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br /></div></div><br /><br />在运行该应用程序大约15分钟后，我们得到了481总覆盖率。这没有任何初始种子，因此我们完全干净地运行了该过程。 现在，我们将启动相同的模糊器，但带有一组示例种子文件。 在这种情况下，由于我们正在使用XML解析器，因此我们唯一需要做的就是在启动模糊器时为其提供一组XML文件。  PugiXML的模糊器设置是经过精心设计的，它们已经在以下路径中提供了种子文件：tests / data_fuzz_parse /。 因此，要使用种子启动模糊器，请使用以下命令：<br /><br /><div class="codebox"><div class="codebox">$&nbsp;./build/make-clang++-debug-standard-c++11/fuzz_parse&nbsp;./CORPUS_PARSE_WITH_SEED&nbsp;./tests/data_fuzz_parse<br />INFO:&nbsp;Seed:&nbsp;2440988712<br />INFO:&nbsp;Loaded&nbsp;1&nbsp;modules&nbsp;&nbsp;&nbsp;(4919&nbsp;inline&nbsp;8-bit&nbsp;counters):&nbsp;4919&nbsp;[0x64e6b0,&nbsp;0x64f9e7),&nbsp;<br />INFO:&nbsp;Loaded&nbsp;1&nbsp;PC&nbsp;tables&nbsp;(4919&nbsp;PCs):&nbsp;4919&nbsp;[0x605428,0x618798),&nbsp;<br />INFO:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;files&nbsp;found&nbsp;in&nbsp;./CORPUS_PARSE_WITH_SEED<br />INFO:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;files&nbsp;found&nbsp;in&nbsp;./tests/data_fuzz_parse<br />INFO:&nbsp;-max_len&nbsp;is&nbsp;not&nbsp;provided;&nbsp;libFuzzer&nbsp;will&nbsp;not&nbsp;generate&nbsp;inputs&nbsp;larger&nbsp;than&nbsp;4096&nbsp;bytes<br />INFO:&nbsp;seed&nbsp;corpus:&nbsp;files:&nbsp;6&nbsp;min:&nbsp;22b&nbsp;max:&nbsp;700b&nbsp;total:&nbsp;2076b&nbsp;rss:&nbsp;27Mb<br />#7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;INITED&nbsp;cov:&nbsp;326&nbsp;ft:&nbsp;548&nbsp;corp:&nbsp;6/2076b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;29Mb<br />#9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;335&nbsp;ft:&nbsp;563&nbsp;corp:&nbsp;7/2362b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;29Mb&nbsp;L:&nbsp;286/700&nbsp;MS:&nbsp;2&nbsp;ChangeASCIIInt-EraseBytes-<br />#10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;335&nbsp;ft:&nbsp;563&nbsp;corp:&nbsp;7/2356b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;29Mb&nbsp;L:&nbsp;280/700&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;335&nbsp;ft:&nbsp;576&nbsp;corp:&nbsp;8/2608b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;29Mb&nbsp;L:&nbsp;252/700&nbsp;MS:&nbsp;2&nbsp;ChangeBinInt-EraseBytes-<br />#13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;346&nbsp;ft:&nbsp;590&nbsp;corp:&nbsp;9/3260b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;29Mb&nbsp;L:&nbsp;652/700&nbsp;MS:&nbsp;1&nbsp;CrossOver-<br />#14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;346&nbsp;ft:&nbsp;600&nbsp;corp:&nbsp;10/3398b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;29Mb&nbsp;L:&nbsp;138/700&nbsp;MS:&nbsp;1&nbsp;ChangeBinInt-<br />#16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;349&nbsp;ft:&nbsp;619&nbsp;corp:&nbsp;11/4050b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;29Mb&nbsp;L:&nbsp;652/700&nbsp;MS:&nbsp;2&nbsp;ChangeASCIIInt-CopyPart-<br />#18&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;349&nbsp;ft:&nbsp;626&nbsp;corp:&nbsp;12/4188b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;30Mb&nbsp;L:&nbsp;138/700&nbsp;MS:&nbsp;2&nbsp;ChangeByte-ChangeBinInt-<br />#19&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;351&nbsp;ft:&nbsp;649&nbsp;corp:&nbsp;13/4440b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;30Mb&nbsp;L:&nbsp;252/700&nbsp;MS:&nbsp;1&nbsp;CMP-&nbsp;DE:&nbsp;&quot;\x0a\x00&quot;-<br />#22&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;351&nbsp;ft:&nbsp;654&nbsp;corp:&nbsp;14/4692b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;30Mb&nbsp;L:&nbsp;252/700&nbsp;MS:&nbsp;3&nbsp;ChangeBinInt-ChangeBinInt-CMP-&nbsp;DE:&nbsp;&quot;\xff!&quot;-<br />#26&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;353&nbsp;ft:&nbsp;656&nbsp;corp:&nbsp;15/4944b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;30Mb&nbsp;L:&nbsp;252/700&nbsp;MS:&nbsp;4&nbsp;CrossOver-CopyPart-CopyPart-PersAutoDict-&nbsp;DE:&nbsp;&quot;\xff!&quot;-<br />#27&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;354&nbsp;ft:&nbsp;657&nbsp;corp:&nbsp;16/5082b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;30Mb&nbsp;L:&nbsp;138/700&nbsp;MS:&nbsp;1&nbsp;ShuffleBytes-<br />#28&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;354&nbsp;ft:&nbsp;665&nbsp;corp:&nbsp;17/5770b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;30Mb&nbsp;L:&nbsp;688/700&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#30&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;355&nbsp;ft:&nbsp;675&nbsp;corp:&nbsp;18/6431b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;30Mb&nbsp;L:&nbsp;661/700&nbsp;MS:&nbsp;2&nbsp;ChangeBit-EraseBytes-<br />....<br />....<br />#12587526&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;586&nbsp;ft:&nbsp;2934&nbsp;corp:&nbsp;1145/216Kb&nbsp;lim:&nbsp;4096&nbsp;exec/s:&nbsp;31390&nbsp;rss:&nbsp;369Mb&nbsp;L:&nbsp;91/3968&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#12588703&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;586&nbsp;ft:&nbsp;2934&nbsp;corp:&nbsp;1145/216Kb&nbsp;lim:&nbsp;4096&nbsp;exec/s:&nbsp;31393&nbsp;rss:&nbsp;369Mb&nbsp;L:&nbsp;50/3968&nbsp;MS:&nbsp;2&nbsp;ChangeBit-EraseBytes-<br />#12592410&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;586&nbsp;ft:&nbsp;2934&nbsp;corp:&nbsp;1145/216Kb&nbsp;lim:&nbsp;4096&nbsp;exec/s:&nbsp;31402&nbsp;rss:&nbsp;369Mb&nbsp;L:&nbsp;778/3968&nbsp;MS:&nbsp;2&nbsp;ChangeASCIIInt-EraseBytes-<br />#12593852&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;586&nbsp;ft:&nbsp;2934&nbsp;corp:&nbsp;1145/216Kb&nbsp;lim:&nbsp;4096&nbsp;exec/s:&nbsp;31406&nbsp;rss:&nbsp;369Mb&nbsp;L:&nbsp;3206/3968&nbsp;MS:&nbsp;2&nbsp;EraseBytes-CopyPart-<br />#12593938&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;586&nbsp;ft:&nbsp;2934&nbsp;corp:&nbsp;1145/216Kb&nbsp;lim:&nbsp;4096&nbsp;exec/s:&nbsp;31406&nbsp;rss:&nbsp;369Mb&nbsp;L:&nbsp;33/3968&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#12594844&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;586&nbsp;ft:&nbsp;2934&nbsp;corp:&nbsp;1145/216Kb&nbsp;lim:&nbsp;4096&nbsp;exec/s:&nbsp;31408&nbsp;rss:&nbsp;369Mb&nbsp;L:&nbsp;47/3968&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#12597036&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;586&nbsp;ft:&nbsp;2934&nbsp;corp:&nbsp;1145/216Kb&nbsp;lim:&nbsp;4096&nbsp;exec/s:&nbsp;31414&nbsp;rss:&nbsp;369Mb&nbsp;L:&nbsp;1954/3968&nbsp;MS:&nbsp;2&nbsp;ShuffleBytes-EraseBytes-<br />#12601493&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;586&nbsp;ft:&nbsp;2934&nbsp;corp:&nbsp;1145/216Kb&nbsp;lim:&nbsp;4096&nbsp;exec/s:&nbsp;31425&nbsp;rss:&nbsp;369Mb&nbsp;L:&nbsp;99/3968&nbsp;MS:&nbsp;2&nbsp;ChangeBit-EraseBytes-<br />#12601824&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;586&nbsp;ft:&nbsp;2934&nbsp;corp:&nbsp;1145/216Kb&nbsp;lim:&nbsp;4096&nbsp;exec/s:&nbsp;31425&nbsp;rss:&nbsp;369Mb&nbsp;L:&nbsp;28/3968&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#12605990&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;586&nbsp;ft:&nbsp;2934&nbsp;corp:&nbsp;1145/216Kb&nbsp;lim:&nbsp;4096&nbsp;exec/s:&nbsp;31358&nbsp;rss:&nbsp;369Mb&nbsp;L:&nbsp;279/3968&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#12606337&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;586&nbsp;ft:&nbsp;2934&nbsp;corp:&nbsp;1145/216Kb&nbsp;lim:&nbsp;4096&nbsp;exec/s:&nbsp;31359&nbsp;rss:&nbsp;369Mb&nbsp;L:&nbsp;119/3968&nbsp;MS:&nbsp;2&nbsp;ChangeBinInt-EraseBytes-<br />#12614833&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;586&nbsp;ft:&nbsp;2934&nbsp;corp:&nbsp;1145/216Kb&nbsp;lim:&nbsp;4096&nbsp;exec/s:&nbsp;31380&nbsp;rss:&nbsp;369Mb&nbsp;L:&nbsp;39/3968&nbsp;MS:&nbsp;1&nbsp;EraseBytes-</div></div><br /><br />这些结果是由于每个模糊器运行大约15分钟而产生的。<br /><br /><h3>fuzz_xpath</h3><br /><div class="codebox"><div class="codebox">$&nbsp;./build/make-clang++-debug-standard-c++11/fuzz_xpath&nbsp;./CORPUS_XPATH_CLEAN/<br />INFO:&nbsp;Seed:&nbsp;3602281464<br />INFO:&nbsp;Loaded&nbsp;1&nbsp;modules&nbsp;&nbsp;&nbsp;(4919&nbsp;inline&nbsp;8-bit&nbsp;counters):&nbsp;4919&nbsp;[0x64d6b0,&nbsp;0x64e9e7),&nbsp;<br />INFO:&nbsp;Loaded&nbsp;1&nbsp;PC&nbsp;tables&nbsp;(4919&nbsp;PCs):&nbsp;4919&nbsp;[0x6043e8,0x617758),&nbsp;<br />INFO:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;files&nbsp;found&nbsp;in&nbsp;./CORPUS_XPATH_CLEAN/<br />INFO:&nbsp;-max_len&nbsp;is&nbsp;not&nbsp;provided;&nbsp;libFuzzer&nbsp;will&nbsp;not&nbsp;generate&nbsp;inputs&nbsp;larger&nbsp;than&nbsp;4096&nbsp;bytes<br />INFO:&nbsp;A&nbsp;corpus&nbsp;is&nbsp;not&nbsp;provided,&nbsp;starting&nbsp;from&nbsp;an&nbsp;empty&nbsp;corpus<br />#2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;INITED&nbsp;cov:&nbsp;47&nbsp;ft:&nbsp;48&nbsp;corp:&nbsp;1/1b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;28Mb<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW_FUNC[1/14]:&nbsp;0x55b3a0&nbsp;in&nbsp;pugi::impl::(anonymous&nbsp;namespace)::xpath_ast_node::optimize(pugi::impl::(anonymous&nbsp;namespace)::xpath_allocator*)&nbsp;/work/seeds/pugixml2/pugixml/src/pugixml.cpp:11015<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW_FUNC[2/14]:&nbsp;0x55b5e0&nbsp;in&nbsp;pugi::impl::(anonymous&nbsp;namespace)::auto_deleter::release()&nbsp;/work/seeds/pugixml2/pugixml/src/pugixml.cpp:279<br />#5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;95&nbsp;ft:&nbsp;99&nbsp;corp:&nbsp;2/2b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;29Mb&nbsp;L:&nbsp;1/1&nbsp;MS:&nbsp;3&nbsp;ShuffleBytes-CopyPart-ChangeByte-<br />#6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;96&nbsp;ft:&nbsp;100&nbsp;corp:&nbsp;3/3b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;29Mb&nbsp;L:&nbsp;1/1&nbsp;MS:&nbsp;1&nbsp;ChangeByte-<br />#7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;97&nbsp;ft:&nbsp;101&nbsp;corp:&nbsp;4/4b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;29Mb&nbsp;L:&nbsp;1/1&nbsp;MS:&nbsp;1&nbsp;ChangeByte-<br />#8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;99&nbsp;ft:&nbsp;103&nbsp;corp:&nbsp;5/5b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;29Mb&nbsp;L:&nbsp;1/1&nbsp;MS:&nbsp;1&nbsp;ChangeByte-<br />#17&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;100&nbsp;ft:&nbsp;104&nbsp;corp:&nbsp;6/9b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;29Mb&nbsp;L:&nbsp;4/4&nbsp;MS:&nbsp;4&nbsp;CrossOver-ChangeBit-ChangeByte-ShuffleBytes-<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW_FUNC[1/1]:&nbsp;0x5adfc0&nbsp;in&nbsp;pugi::impl::(anonymous&nbsp;namespace)::xpath_parser::binary_op_t::binary_op_t(pugi::impl::(anonymous&nbsp;namespace)::ast_type_t,&nbsp;pugi::xpath_value_type,&nbsp;int)&nbsp;/work/seeds/pugixml2/pugixml/src/pugixml.cpp:11904<br />#18&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;105&nbsp;ft:&nbsp;119&nbsp;corp:&nbsp;7/13b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;29Mb&nbsp;L:&nbsp;4/4&nbsp;MS:&nbsp;1&nbsp;ShuffleBytes-<br />#27&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;105&nbsp;ft:&nbsp;119&nbsp;corp:&nbsp;7/11b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;29Mb&nbsp;L:&nbsp;2/4&nbsp;MS:&nbsp;4&nbsp;ShuffleBytes-CopyPart-CopyPart-EraseBytes-<br />#32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;105&nbsp;ft:&nbsp;120&nbsp;corp:&nbsp;8/13b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;30Mb&nbsp;L:&nbsp;2/4&nbsp;MS:&nbsp;5&nbsp;ShuffleBytes-ChangeBinInt-ShuffleBytes-CopyPart-CopyPart-<br />#35&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;106&nbsp;ft:&nbsp;121&nbsp;corp:&nbsp;9/15b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;30Mb&nbsp;L:&nbsp;2/4&nbsp;MS:&nbsp;3&nbsp;ChangeByte-CopyPart-InsertByte-<br />#36&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;107&nbsp;ft:&nbsp;122&nbsp;corp:&nbsp;10/19b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;30Mb&nbsp;L:&nbsp;4/4&nbsp;MS:&nbsp;1&nbsp;ChangeByte-<br />#43&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;110&nbsp;ft:&nbsp;125&nbsp;corp:&nbsp;11/20b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;30Mb&nbsp;L:&nbsp;1/4&nbsp;MS:&nbsp;2&nbsp;ShuffleBytes-ChangeByte-<br />#47&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;111&nbsp;ft:&nbsp;127&nbsp;corp:&nbsp;12/24b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;30Mb&nbsp;L:&nbsp;4/4&nbsp;MS:&nbsp;4&nbsp;ChangeBit-CrossOver-EraseBytes-InsertByte-<br />#52&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;112&nbsp;ft:&nbsp;128&nbsp;corp:&nbsp;13/26b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;30Mb&nbsp;L:&nbsp;2/4&nbsp;MS:&nbsp;5&nbsp;ChangeBit-ShuffleBytes-ChangeByte-CrossOver-ChangeByte-<br />#56&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;114&nbsp;ft:&nbsp;133&nbsp;corp:&nbsp;14/30b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;30Mb&nbsp;L:&nbsp;4/4&nbsp;MS:&nbsp;4&nbsp;ShuffleBytes-ChangeBit-ChangeBinInt-ChangeByte-<br />....<br />....<br />#15961977&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;394&nbsp;ft:&nbsp;2338&nbsp;corp:&nbsp;906/149Kb&nbsp;lim:&nbsp;4096&nbsp;exec/s:&nbsp;36694&nbsp;rss:&nbsp;520Mb&nbsp;L:&nbsp;35/3997&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#15968010&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;394&nbsp;ft:&nbsp;2338&nbsp;corp:&nbsp;906/149Kb&nbsp;lim:&nbsp;4096&nbsp;exec/s:&nbsp;36708&nbsp;rss:&nbsp;520Mb&nbsp;L:&nbsp;126/3997&nbsp;MS:&nbsp;3&nbsp;ChangeASCIIInt-ChangeByte-EraseBytes-<br />#15973089&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;394&nbsp;ft:&nbsp;2338&nbsp;corp:&nbsp;906/149Kb&nbsp;lim:&nbsp;4096&nbsp;exec/s:&nbsp;36719&nbsp;rss:&nbsp;520Mb&nbsp;L:&nbsp;213/3997&nbsp;MS:&nbsp;4&nbsp;CopyPart-ShuffleBytes-EraseBytes-CopyPart-<br />#15975030&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;394&nbsp;ft:&nbsp;2338&nbsp;corp:&nbsp;906/149Kb&nbsp;lim:&nbsp;4096&nbsp;exec/s:&nbsp;36639&nbsp;rss:&nbsp;520Mb&nbsp;L:&nbsp;24/3997&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#15977652&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;394&nbsp;ft:&nbsp;2338&nbsp;corp:&nbsp;906/149Kb&nbsp;lim:&nbsp;4096&nbsp;exec/s:&nbsp;36645&nbsp;rss:&nbsp;520Mb&nbsp;L:&nbsp;135/3997&nbsp;MS:&nbsp;2&nbsp;ChangeByte-EraseBytes-<br />#15982303&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;394&nbsp;ft:&nbsp;2339&nbsp;corp:&nbsp;907/149Kb&nbsp;lim:&nbsp;4096&nbsp;exec/s:&nbsp;36656&nbsp;rss:&nbsp;520Mb&nbsp;L:&nbsp;58/3997&nbsp;MS:&nbsp;1&nbsp;CopyPart-<br />#15982679&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;394&nbsp;ft:&nbsp;2339&nbsp;corp:&nbsp;907/149Kb&nbsp;lim:&nbsp;4096&nbsp;exec/s:&nbsp;36657&nbsp;rss:&nbsp;520Mb&nbsp;L:&nbsp;59/3997&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#15987521&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;394&nbsp;ft:&nbsp;2339&nbsp;corp:&nbsp;907/149Kb&nbsp;lim:&nbsp;4096&nbsp;exec/s:&nbsp;36668&nbsp;rss:&nbsp;520Mb&nbsp;L:&nbsp;39/3997&nbsp;MS:&nbsp;2&nbsp;ChangeBinInt-EraseBytes-<br />#16003877&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;394&nbsp;ft:&nbsp;2339&nbsp;corp:&nbsp;907/149Kb&nbsp;lim:&nbsp;4096&nbsp;exec/s:&nbsp;36706&nbsp;rss:&nbsp;520Mb&nbsp;L:&nbsp;12/3997&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#16009046&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;394&nbsp;ft:&nbsp;2339&nbsp;corp:&nbsp;907/149Kb&nbsp;lim:&nbsp;4096&nbsp;exec/s:&nbsp;36717&nbsp;rss:&nbsp;520Mb&nbsp;L:&nbsp;463/3997&nbsp;MS:&nbsp;4&nbsp;EraseBytes-ChangeByte-ChangeASCIIInt-CopyPart-<br />#16011977&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;394&nbsp;ft:&nbsp;2339&nbsp;corp:&nbsp;907/149Kb&nbsp;lim:&nbsp;4096&nbsp;exec/s:&nbsp;36724&nbsp;rss:&nbsp;520Mb&nbsp;L:&nbsp;212/3997&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#16012410&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;394&nbsp;ft:&nbsp;2339&nbsp;corp:&nbsp;907/149Kb&nbsp;lim:&nbsp;4096&nbsp;exec/s:&nbsp;36725&nbsp;rss:&nbsp;520Mb&nbsp;L:&nbsp;165/3997&nbsp;MS:&nbsp;3&nbsp;ChangeBinInt-ChangeBinInt-EraseBytes-<br />#16015058&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;394&nbsp;ft:&nbsp;2339&nbsp;corp:&nbsp;907/149Kb&nbsp;lim:&nbsp;4096&nbsp;exec/s:&nbsp;36647&nbsp;rss:&nbsp;520Mb&nbsp;L:&nbsp;626/3997&nbsp;MS:&nbsp;3&nbsp;ShuffleBytes-ChangeBit-EraseBytes-<br />#16020179&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;394&nbsp;ft:&nbsp;2339&nbsp;corp:&nbsp;907/149Kb&nbsp;lim:&nbsp;4096&nbsp;exec/s:&nbsp;36659&nbsp;rss:&nbsp;520Mb&nbsp;L:&nbsp;441/3997&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#16027290&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;394&nbsp;ft:&nbsp;2339&nbsp;corp:&nbsp;907/148Kb&nbsp;lim:&nbsp;4096&nbsp;exec/s:&nbsp;36675&nbsp;rss:&nbsp;520Mb&nbsp;L:&nbsp;376/3997&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br /></div></div><br /><h3>and with proper seeds:</h3><br /><br /><div class="codebox"><div class="codebox">$&nbsp;./build/make-clang++-debug-standard-c++11/fuzz_xpath&nbsp;./CORPUS_XPATH_WITH_SEED/&nbsp;./tests/data_fuzz_xpath/<br />#6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;INITED&nbsp;cov:&nbsp;251&nbsp;ft:&nbsp;445&nbsp;corp:&nbsp;5/189b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;28Mb<br />#7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;254&nbsp;ft:&nbsp;453&nbsp;corp:&nbsp;6/240b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;29Mb&nbsp;L:&nbsp;51/63&nbsp;MS:&nbsp;1&nbsp;CopyPart-<br />#11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;254&nbsp;ft:&nbsp;454&nbsp;corp:&nbsp;7/303b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;29Mb&nbsp;L:&nbsp;63/63&nbsp;MS:&nbsp;4&nbsp;ChangeBit-ChangeASCIIInt-ChangeBit-ChangeByte-<br />#12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;254&nbsp;ft:&nbsp;470&nbsp;corp:&nbsp;8/354b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;29Mb&nbsp;L:&nbsp;51/63&nbsp;MS:&nbsp;1&nbsp;ChangeBinInt-<br />#15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;256&nbsp;ft:&nbsp;496&nbsp;corp:&nbsp;9/403b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;29Mb&nbsp;L:&nbsp;49/63&nbsp;MS:&nbsp;3&nbsp;CopyPart-ChangeASCIIInt-EraseBytes-<br />#17&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;258&nbsp;ft:&nbsp;503&nbsp;corp:&nbsp;10/466b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;29Mb&nbsp;L:&nbsp;63/63&nbsp;MS:&nbsp;2&nbsp;ChangeBit-CrossOver-<br />#38&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;260&nbsp;ft:&nbsp;517&nbsp;corp:&nbsp;11/517b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;29Mb&nbsp;L:&nbsp;51/63&nbsp;MS:&nbsp;1&nbsp;ChangeBit-<br />#39&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;261&nbsp;ft:&nbsp;530&nbsp;corp:&nbsp;12/568b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;29Mb&nbsp;L:&nbsp;51/63&nbsp;MS:&nbsp;1&nbsp;CopyPart-<br />#41&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;261&nbsp;ft:&nbsp;530&nbsp;corp:&nbsp;12/546b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;29Mb&nbsp;L:&nbsp;27/63&nbsp;MS:&nbsp;2&nbsp;ChangeBinInt-CrossOver-<br />#42&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;261&nbsp;ft:&nbsp;531&nbsp;corp:&nbsp;13/550b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;29Mb&nbsp;L:&nbsp;4/63&nbsp;MS:&nbsp;1&nbsp;CrossOver-<br />#45&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;261&nbsp;ft:&nbsp;548&nbsp;corp:&nbsp;14/601b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;29Mb&nbsp;L:&nbsp;51/63&nbsp;MS:&nbsp;3&nbsp;ChangeASCIIInt-ChangeBit-CopyPart-<br />#51&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;261&nbsp;ft:&nbsp;548&nbsp;corp:&nbsp;14/586b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;29Mb&nbsp;L:&nbsp;48/63&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#57&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;261&nbsp;ft:&nbsp;556&nbsp;corp:&nbsp;15/637b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;29Mb&nbsp;L:&nbsp;51/63&nbsp;MS:&nbsp;1&nbsp;ChangeBinInt-<br />#58&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;261&nbsp;ft:&nbsp;557&nbsp;corp:&nbsp;16/688b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;29Mb&nbsp;L:&nbsp;51/63&nbsp;MS:&nbsp;1&nbsp;ShuffleBytes-<br />#60&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;263&nbsp;ft:&nbsp;577&nbsp;corp:&nbsp;17/739b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;29Mb&nbsp;L:&nbsp;51/63&nbsp;MS:&nbsp;2&nbsp;ChangeBit-ShuffleBytes-<br />#61&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;263&nbsp;ft:&nbsp;577&nbsp;corp:&nbsp;17/736b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;29Mb&nbsp;L:&nbsp;24/63&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#63&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;263&nbsp;ft:&nbsp;577&nbsp;corp:&nbsp;17/689b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;29Mb&nbsp;L:&nbsp;4/63&nbsp;MS:&nbsp;2&nbsp;ShuffleBytes-CrossOver-<br /><br />....<br />....<br />#17514433&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;419&nbsp;ft:&nbsp;2522&nbsp;corp:&nbsp;930/175Kb&nbsp;lim:&nbsp;4096&nbsp;exec/s:&nbsp;33877&nbsp;rss:&nbsp;517Mb&nbsp;L:&nbsp;40/3887&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#17518959&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;419&nbsp;ft:&nbsp;2522&nbsp;corp:&nbsp;930/175Kb&nbsp;lim:&nbsp;4096&nbsp;exec/s:&nbsp;33885&nbsp;rss:&nbsp;517Mb&nbsp;L:&nbsp;71/3887&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#17525935&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;419&nbsp;ft:&nbsp;2522&nbsp;corp:&nbsp;930/175Kb&nbsp;lim:&nbsp;4096&nbsp;exec/s:&nbsp;33899&nbsp;rss:&nbsp;517Mb&nbsp;L:&nbsp;50/3887&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#17526181&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;419&nbsp;ft:&nbsp;2522&nbsp;corp:&nbsp;930/175Kb&nbsp;lim:&nbsp;4096&nbsp;exec/s:&nbsp;33899&nbsp;rss:&nbsp;517Mb&nbsp;L:&nbsp;33/3887&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#17531012&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;419&nbsp;ft:&nbsp;2522&nbsp;corp:&nbsp;930/174Kb&nbsp;lim:&nbsp;4096&nbsp;exec/s:&nbsp;33909&nbsp;rss:&nbsp;517Mb&nbsp;L:&nbsp;428/3887&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#17539037&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;419&nbsp;ft:&nbsp;2522&nbsp;corp:&nbsp;930/174Kb&nbsp;lim:&nbsp;4096&nbsp;exec/s:&nbsp;33859&nbsp;rss:&nbsp;517Mb&nbsp;L:&nbsp;246/3887&nbsp;MS:&nbsp;5&nbsp;CopyPart-ChangeByte-ChangeBinInt-EraseBytes-EraseBytes-<br />#17542348&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;419&nbsp;ft:&nbsp;2522&nbsp;corp:&nbsp;930/174Kb&nbsp;lim:&nbsp;4096&nbsp;exec/s:&nbsp;33865&nbsp;rss:&nbsp;517Mb&nbsp;L:&nbsp;36/3887&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#17544339&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;419&nbsp;ft:&nbsp;2522&nbsp;corp:&nbsp;930/174Kb&nbsp;lim:&nbsp;4096&nbsp;exec/s:&nbsp;33869&nbsp;rss:&nbsp;517Mb&nbsp;L:&nbsp;25/3887&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#17545530&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;419&nbsp;ft:&nbsp;2522&nbsp;corp:&nbsp;930/174Kb&nbsp;lim:&nbsp;4096&nbsp;exec/s:&nbsp;33871&nbsp;rss:&nbsp;517Mb&nbsp;L:&nbsp;1060/3887&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#17559652&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;419&nbsp;ft:&nbsp;2522&nbsp;corp:&nbsp;930/174Kb&nbsp;lim:&nbsp;4096&nbsp;exec/s:&nbsp;33898&nbsp;rss:&nbsp;517Mb&nbsp;L:&nbsp;81/3887&nbsp;MS:&nbsp;2&nbsp;ShuffleBytes-EraseBytes-<br />#17561824&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;419&nbsp;ft:&nbsp;2522&nbsp;corp:&nbsp;930/174Kb&nbsp;lim:&nbsp;4096&nbsp;exec/s:&nbsp;33903&nbsp;rss:&nbsp;517Mb&nbsp;L:&nbsp;188/3887&nbsp;MS:&nbsp;2&nbsp;InsertByte-EraseBytes-<br />#17575419&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;419&nbsp;ft:&nbsp;2522&nbsp;corp:&nbsp;930/174Kb&nbsp;lim:&nbsp;4096&nbsp;exec/s:&nbsp;33929&nbsp;rss:&nbsp;517Mb&nbsp;L:&nbsp;1344/3887&nbsp;MS:&nbsp;5&nbsp;CopyPart-CopyPart-ChangeByte-ChangeBit-EraseBytes-<br />#17588515&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;419&nbsp;ft:&nbsp;2522&nbsp;corp:&nbsp;930/174Kb&nbsp;lim:&nbsp;4096&nbsp;exec/s:&nbsp;33889&nbsp;rss:&nbsp;517Mb&nbsp;L:&nbsp;345/3887&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#17592336&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;419&nbsp;ft:&nbsp;2522&nbsp;corp:&nbsp;930/174Kb&nbsp;lim:&nbsp;4096&nbsp;exec/s:&nbsp;33896&nbsp;rss:&nbsp;517Mb&nbsp;L:&nbsp;159/3887&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#17593442&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;419&nbsp;ft:&nbsp;2522&nbsp;corp:&nbsp;930/174Kb&nbsp;lim:&nbsp;4096&nbsp;exec/s:&nbsp;33898&nbsp;rss:&nbsp;517Mb&nbsp;L:&nbsp;72/3887&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#17597614&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;419&nbsp;ft:&nbsp;2522&nbsp;corp:&nbsp;930/174Kb&nbsp;lim:&nbsp;4096&nbsp;exec/s:&nbsp;33906&nbsp;rss:&nbsp;517Mb&nbsp;L:&nbsp;695/3887&nbsp;MS:&nbsp;2&nbsp;ChangeASCIIInt-EraseBytes-<br />#17602550&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;419&nbsp;ft:&nbsp;2522&nbsp;corp:&nbsp;930/174Kb&nbsp;lim:&nbsp;4096&nbsp;exec/s:&nbsp;33916&nbsp;rss:&nbsp;517Mb&nbsp;L:&nbsp;351/3887&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#17611001&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;419&nbsp;ft:&nbsp;2522&nbsp;corp:&nbsp;930/174Kb&nbsp;lim:&nbsp;4096&nbsp;exec/s:&nbsp;33932&nbsp;rss:&nbsp;517Mb&nbsp;L:&nbsp;585/3887&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#17620672&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;419&nbsp;ft:&nbsp;2522&nbsp;corp:&nbsp;930/174Kb&nbsp;lim:&nbsp;4096&nbsp;exec/s:&nbsp;33885&nbsp;rss:&nbsp;517Mb&nbsp;L:&nbsp;40/3887&nbsp;MS:&nbsp;1&nbsp;EraseBytes-&nbsp;&nbsp;&nbsp;</div></div><br /><br /><br /><br /><br /><br /></div><div class='page'><h1 class='title level-3'>3_Visualising_coverage</h1><br/></div><div class='page'><h1 class='title level-4'>1_Demonstration of visualising coverage _ ADA Logics</h1><br/>此处代码覆盖率的计算基于基本代码块的执行<br /><br />创建源码文件并用clang结合指定flag进行编译，从而在fuzzing时保存cov信息<br /><a href=""><img src="images\944-1.png" alt="images\944-1.png" /></a><br /><br />运行fuzzer，使用ctrl+c结束fuzzing过程，同目录下生成default.profraw文件，但该文件长度为0，说明文件生成异常<br /><a href=""><img src="images\944-2.png" alt="images\944-2.png" /></a><br /><br />删除default.profraw文件，然后重新运行fuzz，此时使用-max_total_time指定fuzzer的运行时常<br /><a href=""><img src="images\944-3.png" alt="images\944-3.png" /></a><br /><br />此次生成的default.profraw文件长度不为0<br /><a href=""><img src="images\944-4.png" alt="images\944-4.png" /></a><br /><br />运行llvm-profdata merge将生成的cov文件转为可读形式，<br /><span style="color:#ff0000;">当同一项目存在多个fuzzer时，生成的多个cov文件可以通过该方法合并为同一个cov文件，从而查看fuzz的覆盖情况</span><br /><a href=""><img src="images\944-5.png" alt="images\944-5.png" /></a><br /><br />使用llvm-cov程序将覆盖率情况转化为html文件格式<br />注意命令中最后一个参数为被fuzz的二进制程序的路径<br />倒数第二个参数为html的生成路径<br /><a href=""><img src="images\944-6.png" alt="images\944-6.png" /></a><br /><br />在html生成目录中启动python的html服务<br />该命令会在docker镜像上打开指定端口<br /><a href=""><img src="images\944-7.png" alt="images\944-7.png" /></a><br /><br />访问输出的url<br /><a href=""><img src="images\944-8.png" alt="images\944-8.png" /></a><br /><br />点击源码文件链接，找到源码中每行代码的执行次数<br /><a href=""><img src="images\944-9.png" alt="images\944-9.png" /></a><br /><br /><br /><br /></div><div class='page'><h1 class='title level-4'>2_Visualising_coverage</h1><br/><h1>Visualising coverage</h1><br /><br />LLVM的一个有趣功能是，我们可以使用检测工具编译应用程序，从而可以查看在程序执行期间执行了哪些代码。 这是一个独立于LibFuzzer的功能，但是，它可以与LibFuzzer结合使用，这使其成为一个强大的功能，因为它使我们能够观察到目标代码库的哪些部分由我们的模糊器执行。 例如，这有助于确定我们在分析中遗漏的代码以及其他内容。 在本节中，我们将介绍这种类型的覆盖率工具的工作方式。<br /><br />描述概念：<br />llvm-cov <br />llvm-profmergedata<br />覆盖的检测标志。<br />如何在两者之间使用语料库<br />给出一个带有真实程序的脚本示例，在该程序中我们先运行模糊器一会儿，然后提取覆盖率。<br /><br /><h2>Fuzzer example</h2><br />我们将使用以下示例来显示coverage可视化如何工作<br />fuzz_binary.cc<br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;stdlib.h&gt;<br />#include&nbsp;&lt;stdint.h&gt;<br /><br />int&nbsp;magic_check(char&nbsp;*buf)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(buf[0]&nbsp;!=&nbsp;&#39;F&#39;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(buf[1]&nbsp;!=&nbsp;&#39;U&#39;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(buf[2]&nbsp;!=&nbsp;&#39;Z&#39;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(buf[3]&nbsp;!=&nbsp;&#39;Z&#39;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br />}<br /><br />int<br />consistency_check(char&nbsp;*buf,&nbsp;int&nbsp;size)<br />{<br />&nbsp;&nbsp;&nbsp;if&nbsp;(size&nbsp;&lt;&nbsp;30)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;<br /><br />&nbsp;&nbsp;&nbsp;int&nbsp;consistency_val&nbsp;=&nbsp;0;<br />&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;size;&nbsp;i++)<br />&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;consistency_val&nbsp;+=&nbsp;(int)buf[i];<br />&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;if&nbsp;(consistency_val&nbsp;!=&nbsp;0x1443)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;<br />&nbsp;&nbsp;&nbsp;return&nbsp;0;<br />}<br /><br />int&nbsp;final_check(char&nbsp;*buffer)<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;buffer&nbsp;+=&nbsp;4;<br />&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;buffer_val&nbsp;=&nbsp;*(int*)buffer;<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(buffer_val&nbsp;!=&nbsp;0xaabbccdd)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br />}<br />int<br />attack_me(char&nbsp;*buffer,&nbsp;int&nbsp;size)<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(size&nbsp;&lt;&nbsp;4)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(magic_check(buffer)&nbsp;!=&nbsp;0)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(consistency_check(buffer,&nbsp;size)&nbsp;!=&nbsp;0)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(final_check(buffer)&nbsp;!=&nbsp;0)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br />}<br /><br /><br />int&nbsp;LLVMFuzzerTestOneInput(const&nbsp;uint8_t&nbsp;*data,&nbsp;size_t&nbsp;size)<br /><span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;attack_me((char*)data,&nbsp;size);<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />上面的模糊器以我们通常的Attack_me函数为目标。  Attack_me函数本身调用三个不同的函数，每个函数的目的都是对输入进行验证检查。 对于每个函数，如果输入验证成功，则给定函数将返回0。<br /><br />第一个输入验证检查magic_check仅检查缓冲区的前四个字符是否对应于“ FUZZ”。 如果输入缓冲区的所有字符加起来等于0x1443，则第二个输入验证函数Consistency_check进行验证；如果输入缓冲区的前四个字节与整数0xaabbccdd相对应，则第二个验证函数final_check进行检查。 这些检查中的每一项检查都越来越困难，我们希望使用覆盖率可视化来确定我们的模糊器能够执行代码的哪些部分。<br /><br /><h2>Extracting the coverage report</h2><br /><br /><h2>Step 1. Building with coverage instrumentation</h2><br /><br />该过程的第一步是在启用覆盖率信息的情况下编译我们的目标代码和模糊器。 在我们的情况下，模糊器和目标代码在同一文件中，因此我们唯一要做的就是使用coverage工具编译该文件。 为此，除了-fsanitize = fuzzer标志外，我们还需要给clang标志-fprofile-instr-generate -fcoverage-mapping。 我们可以使用以下简单脚本来自动执行此操作：<br /><div class="codebox"><div class="codebox">if&nbsp;[&nbsp;$#&nbsp;-eq&nbsp;0&nbsp;]<br />then<br />&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;Please&nbsp;give&nbsp;a&nbsp;filename&quot;<br />&nbsp;&nbsp;&nbsp;&nbsp;exit&nbsp;1<br />fi<br /><br />FUZZ_FLAGS=&quot;-fsanitize=fuzzer&nbsp;-fprofile-instr-generate&nbsp;-fcoverage-mapping&nbsp;&quot;<br />clang&nbsp;$FUZZ_FLAGS&nbsp;$1</div></div><br /><br /><h2>Step 2. Running with coverage</h2><br />用覆盖率工具编译目标后，下一步是运行模糊器并收集覆盖率信息。 为此，我们需要添加标志-dump_coverage = 1，这将导致原始coverage报告转储到文件系统。 我们可以通过LLVM_PROFILE_FILE环境变量指定覆盖率报告的名称，并且覆盖率报告的默认名称就是default.profraw。 此外，我们必须确保模糊器正常退出，否则将不会写入覆盖率报告，我们可以使用标志-max_total_time = X来执行此操作，其中X是我们希望模糊器运行的秒数。 总之，我们可以使用以下命令提取原始覆盖率报告：<br /><br />-timeout<br />	超时（以秒为单位），默认值为1200。如果输入的时间长于此超时时间，则该过程将视为失败情况。<br />	<br /><span style="color:#17191c;">-close_fd_mask</span>	<br />	指示输出流在启动时关闭。 请注意，这将从目标代码中删除诊断输出（例如，断言失败时的消息）。<br />	0（默认）：不关闭stdout或stderr <br />	1：关闭stdout <br />	2：关闭stderr <br />	3：关闭stdout和stderr。<br />	<br /><h3>$ LLVM_PROFILE_FILE=cov.profraw ./fuzz_binary -dump_coverage=1 -max_total_time=2 -timeout=100 -close_fd_mask=3 ./corpus</h3><br /><br /><h3>This command will execute the fuzzer and you will start to see output as follows:</h3><br /><div class="codebox"><div class="codebox">INFO:&nbsp;Seed:&nbsp;402119064&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />INFO:&nbsp;Loaded&nbsp;1&nbsp;modules&nbsp;&nbsp;&nbsp;(21&nbsp;inline&nbsp;8-bit&nbsp;counters):&nbsp;21&nbsp;[0x4751e9,&nbsp;0x4751fe),<br />INFO:&nbsp;Loaded&nbsp;1&nbsp;PC&nbsp;tables&nbsp;(21&nbsp;PCs):&nbsp;21&nbsp;[0x462700,0x462850),<br />INFO:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;files&nbsp;found&nbsp;in&nbsp;seed1<br />INFO:&nbsp;-max_len&nbsp;is&nbsp;not&nbsp;provided;&nbsp;libFuzzer&nbsp;will&nbsp;not&nbsp;generate&nbsp;inputs&nbsp;larger&nbsp;than&nbsp;4096&nbsp;bytes<br />INFO:&nbsp;A&nbsp;corpus&nbsp;is&nbsp;not&nbsp;provided,&nbsp;starting&nbsp;from&nbsp;an&nbsp;empty&nbsp;corpus<br />#2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;INITED&nbsp;cov:&nbsp;3&nbsp;ft:&nbsp;4&nbsp;corp:&nbsp;1/1b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;23Mb<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW_FUNC[1/1]:&nbsp;0x4522b0&nbsp;in&nbsp;magic_check&nbsp;(/work/a.out+0x4522b0)<br />#36&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;6&nbsp;ft:&nbsp;7&nbsp;corp:&nbsp;2/5b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;26Mb&nbsp;L:&nbsp;4/4&nbsp;MS:&nbsp;4&nbsp;InsertByte-ChangeByte-ChangeByte-CopyPart-<br />#3617&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;7&nbsp;ft:&nbsp;8&nbsp;corp:&nbsp;3/9b&nbsp;lim:&nbsp;38&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;26Mb&nbsp;L:&nbsp;4/4&nbsp;MS:&nbsp;1&nbsp;CMP-&nbsp;DE:&nbsp;&quot;F\x00\x00\x00&quot;-<br />#28335&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;8&nbsp;ft:&nbsp;9&nbsp;corp:&nbsp;4/13b&nbsp;lim:&nbsp;277&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;26Mb&nbsp;L:&nbsp;4/4&nbsp;MS:&nbsp;3&nbsp;PersAutoDict-ShuffleBytes-ChangeByte-&nbsp;DE:&nbsp;&quot;F\x00\x00\x00&quot;-<br />#43601&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;9&nbsp;ft:&nbsp;10&nbsp;corp:&nbsp;5/17b&nbsp;lim:&nbsp;421&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;26Mb&nbsp;L:&nbsp;4/4&nbsp;MS:&nbsp;1&nbsp;ChangeByte-<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW_FUNC[1/1]:&nbsp;0x452450&nbsp;in&nbsp;consistency_check&nbsp;(/work/a.out+0x452450)<br />#44807&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;13&nbsp;ft:&nbsp;14&nbsp;corp:&nbsp;6/21b&nbsp;lim:&nbsp;429&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;26Mb&nbsp;L:&nbsp;4/4&nbsp;MS:&nbsp;1&nbsp;CopyPart-<br />#45199&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;15&nbsp;ft:&nbsp;16&nbsp;corp:&nbsp;7/450b&nbsp;lim:&nbsp;429&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;26Mb&nbsp;L:&nbsp;429/429&nbsp;MS:&nbsp;2&nbsp;CopyPart-CrossOver-<br />#45235&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;15&nbsp;ft:&nbsp;16&nbsp;corp:&nbsp;7/438b&nbsp;lim:&nbsp;429&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;26Mb&nbsp;L:&nbsp;417/417&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#45277&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;15&nbsp;ft:&nbsp;17&nbsp;corp:&nbsp;8/811b&nbsp;lim:&nbsp;429&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;26Mb&nbsp;L:&nbsp;373/417&nbsp;MS:&nbsp;2&nbsp;InsertRepeatedBytes-EraseBytes-<br />#45280&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;15&nbsp;ft:&nbsp;18&nbsp;corp:&nbsp;9/1068b&nbsp;lim:&nbsp;429&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;26Mb&nbsp;L:&nbsp;257/417&nbsp;MS:&nbsp;3&nbsp;ShuffleBytes-InsertByte-EraseBytes-<br />#45356&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;15&nbsp;ft:&nbsp;19&nbsp;corp:&nbsp;10/1329b&nbsp;lim:&nbsp;429&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;26Mb&nbsp;L:&nbsp;261/417&nbsp;MS:&nbsp;1&nbsp;CrossOver-<br />#45367&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;15&nbsp;ft:&nbsp;19&nbsp;corp:&nbsp;10/1314b&nbsp;lim:&nbsp;429&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;26Mb&nbsp;L:&nbsp;358/417&nbsp;MS:&nbsp;1&nbsp;CrossOver-<br />#45375&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;15&nbsp;ft:&nbsp;20&nbsp;corp:&nbsp;11/1583b&nbsp;lim:&nbsp;429&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;26Mb&nbsp;L:&nbsp;269/417&nbsp;MS:&nbsp;3&nbsp;ChangeByte-InsertByte-CopyPart-<br />#45418&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;15&nbsp;ft:&nbsp;20&nbsp;corp:&nbsp;11/1560b&nbsp;lim:&nbsp;429&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;26Mb&nbsp;L:&nbsp;335/417&nbsp;MS:&nbsp;3&nbsp;CopyPart-ChangeByte-EraseBytes-<br />#45484&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;15&nbsp;ft:&nbsp;21&nbsp;corp:&nbsp;12/1819b&nbsp;lim:&nbsp;429&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;26Mb&nbsp;L:&nbsp;259/417&nbsp;MS:&nbsp;1&nbsp;CMP-&nbsp;DE:&nbsp;&quot;\x012&quot;-<br />#45519&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;15&nbsp;ft:&nbsp;22&nbsp;corp:&nbsp;13/2093b&nbsp;lim:&nbsp;429&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;26Mb&nbsp;L:&nbsp;274/417&nbsp;MS:&nbsp;5&nbsp;CrossOver-ChangeBit-EraseBytes-CopyPart-CMP-&nbsp;DE:&nbsp;&quot;\x01\x00\x00\x00\x00\x00\x00\x00&quot;-<br />#45556&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;15&nbsp;ft:&nbsp;22&nbsp;corp:&nbsp;13/1888b&nbsp;lim:&nbsp;429&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;26Mb&nbsp;L:&nbsp;212/335&nbsp;MS:&nbsp;2&nbsp;ShuffleBytes-EraseBytes-</div></div><br /><br />这会将覆盖率报告写入cov.profraw文件。<br /><br /><h2>Step3.对原始coverage数据进行后处理</h2><br /><br />第三步是将我们从上一步获得的Raw Coverage报告转换为更具可读性的报告。 为此，我们需要使用带有merge命令的llvm-profdata工具。 以下命令将原始Coverage报告转换为可用于可视化coverage的报告：<br /><br /><h3>$llvm-profdata merge -sparse cov.profraw -o merged_cov.profdata</h3><br /><br />该命令的输出是文件merged_cov.profdata，如-o标志所示。<br /><br /><br /><h2>Step 4. Converting coverage reports to html</h2><br /><br />第四步是将上一步的报告转换为一组html文件，可用于可视化覆盖范围，为此，我们需要使用带有标志-instr-profile = merged_cov.profdata的llvm-cov工具 以及-format = html表示我们需要html输出。 以下命令负责此事项：<br /><br /><h3>llvm-cov show -instr-profile=merged_cov.profdata -format=html -output-dir ./coverage_report ./fuzz_binary</h3><br /><br />此命令将创建一个名为coverage_report的目录，其中包含我们所有的html文件。<br /><br /><h2>Step 5. Displaying the coverage report</h2><br />下一步很简单，就是在coverage_report目录中启动一个次要的Web服务器，这将使我们能够可视化我们的Fuzzer运行的覆盖范围。 为此，只需在coverage_report目录中执行命令python3 -m http.server 5001即可，这将在端口5001上启动模糊报告。<br /><br /><h2>浏览覆盖率报告</h2><br />在这一部分中，我们将展示如何浏览模糊报告。<br /><a href=""><img src="images\945-1.png" alt="images\945-1.png" /></a><br /><br />Coverage overview<br /><br /><a href=""><img src="images\945-2.png" alt="images\945-2.png" /></a><br /><br />Coverage code listing.<br /><br />在报告中，我们可以看到每行代码的，无论是否执行，甚至执行了多少次。 在上面的示例中，我们只能看到模糊器无法执行的唯一代码行是第39、40、52和53行，甚至可以看到，第37行的条件检查阻碍了模糊器的执行。 进一步探索代码。<br /><br />代码覆盖率报告中的一个有趣观察是，明确观察到在源码中，给定一行达到了多少测试用例。 通过查看LLVMFUzzerTestOneInput函数执行的次数，可以看到大约执行了140万个测试用例。 查看Attack_me函数的执行情况，我们观察到有137万个测试用例通过了检查if（size &lt;4），801K个测试用例通过了magic_check检查，只有6.91K个测试用例通过了consistency_check检查，但是， 没有一个测试用例通过了final_check。<br /></div><div class='page'><h1 class='title level-4'>3_Demonstration of Xpdf coverage visualisation _ ADA Logics</h1><br/><div class="codebox"><div class="codebox">$&nbsp;export&nbsp;CFLAGS=&quot;-fsanitize=fuzzer-no-link&nbsp;-fprofile-instr-generate&nbsp;-fcoverage-mapping&nbsp;&quot;<br />$&nbsp;export&nbsp;CXXFLAGS=&quot;-fsanitize=fuzzer-no-link&nbsp;-fprofile-instr-generate&nbsp;-fcoverage-mapping&nbsp;&quot;<br />$&nbsp;cmake&nbsp;../&nbsp;-DCMAKE_C_FLAGS=&quot;$CFLAGS&quot;&nbsp;-DCMAKE_CXX_FLAGS=&quot;$CXXFLAGS&quot;<br />$&nbsp;make<br />$&nbsp;clang++&nbsp;fuzz_pdf.cc&nbsp;-fsanitize=fuzzer&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;-fprofile-instr-generate&nbsp;-fcoverage-mapping&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;./xpdf/libtestXpdfStatic.a&nbsp;./fofi/libfofi.a&nbsp;./goo/libgoo.a&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;-I../&nbsp;-I../goo&nbsp;-I../fofi&nbsp;-I../xpdf&nbsp;-I.&nbsp;-g</div></div><br /><br />与4_Coverage_visualisation_of_xpdf所述不同的是，运行fuzzer时仅使用了-max_total_time作为flag<br /><a href=""><img src="images\947-1.png" alt="images\947-1.png" /></a><br /><br />执行完毕后生成cov相关文件<br /><a href=""><img src="images\947-2.png" alt="images\947-2.png" /></a><br /><br />从结果中可以fuzz整体的代码覆盖率仅为2.42%，一般当代码覆盖率达到75%时才算完整覆盖了该项目<br /><a href=""><img src="images\947-3.png" alt="images\947-3.png" /></a><br /><br /><br /><h1>ASAN+种子文件+代码覆盖率统计联合使用</h1><br />创建文件夹，在该文件夹内编译开启了ASAN的xpdf静态库文件<br /><a href=""><img src="images\947-4.png" alt="images\947-4.png" /></a><br /><br />make指令编译xpdf静态库<br /><a href=""><img src="images\947-5.png" alt="images\947-5.png" /></a><br /><br />编译fuzzer，注意需要使用-fsanitizer=fuzzer,address<br /><a href=""><img src="images\947-6.png" alt="images\947-6.png" /></a><br /><br /><a href=""><img src="images\947-7.png" alt="images\947-7.png" /></a><br /><br />创建目录保存语料库，并开始运行fuzzer<br /><a href=""><img src="images\947-8.png" alt="images\947-8.png" /></a><br /><br /><br />当fuzz运行一段时间后（一般为1h或cov数据不再增长），语料库中已经保存了大量能够触发新路径的测试用例，此时使用代码覆盖率统计，可以看出本次fuzzing行动的执行情况<br /><br />一段时间后生成了84个测试用例，(有ASAN的情况下)，<br />之所以时84个是因为wc -l统计时也会将. ..两个目录统计进去<br /><br /><a href=""><img src="images\947-9.png" alt="images\947-9.png" /></a><br /><br />当获得ASAN fuzzer产生的86个测试用例之后，使用增加了代码覆盖率统计功能的fuzzer运行以上测试用例，计算出此类测试用例带来的代码覆盖率<br /><br />使用以下命令将带有代码覆盖率统计功能的fuzzer所运行的测试用例限制在指定目录，该目录中为带ASAN功能的fuzzer生成的测试用例<br /><br />下图中，带有代码覆盖率统计功能的fuzzer运行了所有84个测试用例<br /><br /><span style="color:#17191c;">-runs</span><br />	单个测试运行的次数，-1（默认）为无限期运行。<br /><a href=""><img src="images\947-10.png" alt="images\947-10.png" /></a><br /><br />将新生成的cov数据进行可视化转换，得到如下结果<br />如下结果中代码行数覆盖从原来的2.42%提升到了2.47%<br /><a href=""><img src="images\947-11.png" alt="images\947-11.png" /></a><br /><br />查看具体的源码，发现每行被执行的代码均执行了84次，即该fuzzer仅仅执行了命令行中提供的84个测试用例<br /><a href=""><img src="images\947-12.png" alt="images\947-12.png" /></a><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /></div><div class='page'><h1 class='title level-4'>4_Coverage_visualisation_of_xpdf</h1><br/><h1>Coverage visualisation of xpdf</h1><br /><br /><h3>In this section we will go through coverage visualisation of the Xpdf project.</h3><br /><br /><h2>Compiling with coverage support</h2><br /><div class="codebox"><div class="codebox">$&nbsp;export&nbsp;CFLAGS=&quot;-fsanitize=fuzzer-no-link&nbsp;-fprofile-instr-generate&nbsp;-fcoverage-mapping&nbsp;&quot;<br />$&nbsp;export&nbsp;CXXFLAGS=&quot;-fsanitize=fuzzer-no-link&nbsp;-fprofile-instr-generate&nbsp;-fcoverage-mapping&nbsp;&quot;<br />$&nbsp;cmake&nbsp;../&nbsp;-DCMAKE_C_FLAGS=&quot;$CFLAGS&quot;&nbsp;-DCMAKE_CXX_FLAGS=&quot;$CXXFLAGS&quot;<br />$&nbsp;make<br />$&nbsp;clang++&nbsp;fuzz_pdf.cc&nbsp;-fsanitize=fuzzer&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;-fprofile-instr-generate&nbsp;-fcoverage-mapping&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;./xpdf/libtestXpdfStatic.a&nbsp;./fofi/libfofi.a&nbsp;./goo/libgoo.a&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;-I../&nbsp;-I../goo&nbsp;-I../fofi&nbsp;-I../xpdf&nbsp;-I.&nbsp;-g</div></div><br /><br /><h3>We then create a directory for our seeds and run the fuzzer for 20 seconds:</h3><br /><div class="codebox"><div class="codebox">$&nbsp;mkdir&nbsp;CORPUS<br />$&nbsp;LLVM_PROFILE_FILE=cov.profraw&nbsp;./a.out&nbsp;\<br />&nbsp;&nbsp;&nbsp;-dump_coverage=1&nbsp;-max_total_time=20&nbsp;-timeout=100&nbsp;-close_fd_mask=3&nbsp;./CORPUS</div></div><br /><br /><h3>And we can then run the instructions that convert the </h3><code>cov.profraw</code><h3> file into static HTML pages we can view in the browser:</h3><br /><div class="codebox"><div class="codebox">$&nbsp;llvm-profdata&nbsp;merge&nbsp;-sparse&nbsp;cov.profraw&nbsp;-o&nbsp;merged_cov.profdata<br />$&nbsp;llvm-cov&nbsp;show&nbsp;-instr-profile=merged_cov.profdata&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-format=html&nbsp;-output-dir&nbsp;./coverage_report&nbsp;./a.out</div></div><br /><br /><h3>Now we can launch the simple HTTP web server:</h3><br /><div class="codebox"><div class="codebox">$&nbsp;cd&nbsp;coverage_report<br />$&nbsp;python3&nbsp;-m&nbsp;http.server&nbsp;5002&nbsp;</div></div><br /><br /><h3>And we can observe the coverage achieved:</h3><br /><a href=""><img src="images\948-1.png" alt="images\948-1.png" /></a><br /><br /><br /><br /><br /><br /><br /><br /><br /></div><div class='page'><h1 class='title level-4'>5_Demonstration of PugiXML coverage visualisation _ ADA Logics</h1><br/><h1>针对fuzz_parse进行覆盖率测试</h1><br /><div class="codebox"><div class="codebox">$&nbsp;git&nbsp;clone&nbsp;https://github.com/zeux/pugixml<br />$&nbsp;cd&nbsp;pugixml<br />$&nbsp;clang++&nbsp;-g&nbsp;-Wall&nbsp;-Wextra&nbsp;-Werror&nbsp;-pedantic&nbsp;-Wundef&nbsp;-Wshadow&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;-Wcast-align&nbsp;-Wcast-qual&nbsp;-Wold-style-cast&nbsp;-Wdouble-promotion&nbsp;-std=c++11&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;-fsanitize=fuzzer&nbsp;-fprofile-instr-generate&nbsp;-fcoverage-mapping&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;tests/fuzz_parse.cpp&nbsp;src/pugixml.cpp&nbsp;-o&nbsp;fuzz_parse<br /></div></div><br /><br /><a href=""><img src="images\949-1.png" alt="images\949-1.png" /></a><br /><br /><a href=""><img src="images\949-2.png" alt="images\949-2.png" /></a><br /><br /><div class="codebox"><div class="codebox">$&nbsp;llvm-profdata&nbsp;merge&nbsp;-sparse&nbsp;cov_parse.profraw&nbsp;-o&nbsp;cov_parse.profdata<br />$&nbsp;llvm-cov&nbsp;show&nbsp;-instr-profile=cov_parse.profdata&nbsp;-format=html&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;-output-dir&nbsp;./coverage_report&nbsp;fuzz_parse<br />$&nbsp;cd&nbsp;coverage-report<br />$&nbsp;python3&nbsp;-m&nbsp;http.server&nbsp;5002</div></div><br /><br /><br /><h1>针对fuzz_xpath进行覆盖率测试</h1><br /><div class="codebox"><div class="codebox">$&nbsp;clang++&nbsp;-g&nbsp;-Wall&nbsp;-Wextra&nbsp;-Werror&nbsp;-pedantic&nbsp;-Wundef&nbsp;-Wshadow&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;-Wcast-align&nbsp;-Wcast-qual&nbsp;-Wold-style-cast&nbsp;-Wdouble-promotion&nbsp;-std=c++11&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;-fsanitize=fuzzer&nbsp;-fprofile-instr-generate&nbsp;-fcoverage-mapping&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;tests/fuzz_xpath.cpp&nbsp;src/pugixml.cpp&nbsp;-o&nbsp;fuzz_xpath</div></div><br /><br /><a href=""><img src="images\949-3.png" alt="images\949-3.png" /></a><br /><br /><a href=""><img src="images\949-4.png" alt="images\949-4.png" /></a><br /><br /><div class="codebox"><div class="codebox">$&nbsp;llvm-profdata&nbsp;merge&nbsp;-sparse&nbsp;cov_xpath.profraw&nbsp;-o&nbsp;cov_xpath.profdata<br />$&nbsp;llvm-cov&nbsp;show&nbsp;-instr-profile=cov_xpath.profdata&nbsp;-format=html&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;-output-dir&nbsp;./coverage_report2&nbsp;fuzz_xpath<br />$&nbsp;cd&nbsp;coverage_report2<br />python3&nbsp;-m&nbsp;http.server&nbsp;5002<br /></div></div><br /><br /><h1>组合两次fuzz的代码覆盖率结果</h1><br />注意再将多个fuzz的覆盖率结果组合为一个的情况下，在将cov结果转为html文件夹时，需要使用-object 指定多个fuzzer程序的路径<br /><div class="codebox"><div class="codebox">$&nbsp;llvm-profdata&nbsp;merge&nbsp;-sparse&nbsp;cov_parse.profraw&nbsp;cov_xpath.profraw&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-o&nbsp;total_merged_coverage.profdata<br />$&nbsp;llvm-cov&nbsp;show&nbsp;-instr-profile=total_merged_coverage.profdata&nbsp;-format=html&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;-output-dir&nbsp;./coverage_report3&nbsp;-object&nbsp;fuzz_xpath&nbsp;-object&nbsp;fuzz_parse</div></div><br /><br /> <br /></div><div class='page'><h1 class='title level-4'>6_Coverage_visualisation_of_PugiXML</h1><br/><h1>Coverage visualisation of PugiXML</h1><br /><br />在本节中，我们将介绍PugiXML的覆盖可视化。 在前面的部分中，我们已经介绍了如何使用模糊器编译该库，因此在此不再赘述。 但是，我们将依靠早期模糊产生的语料库作为生成覆盖率报告的种子。<br /><br /><h2>获取PugiXML源代码：</h2><br /><div class="codebox"><div class="codebox">$&nbsp;git&nbsp;clone&nbsp;https:<span style="color:#0088ff;font-weight:400">//github.com/zeux/pugixml</span><br />$&nbsp;cd&nbsp;pugixml</div></div><br /><br /><h2>fuzz_parse的覆盖范围</h2><br /><br />对于每个模糊器，我们都需要使用覆盖率支持对其进行编译，然后再使用LLVM的覆盖率工具来提取HTML页面。 我们可以对fuzz_parse模糊器执行此操作：<br /><div class="codebox"><div class="codebox">$&nbsp;clang++&nbsp;-g&nbsp;-Wall&nbsp;-Wextra&nbsp;-Werror&nbsp;-pedantic&nbsp;-Wundef&nbsp;-Wshadow&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;-Wcast-align&nbsp;-Wcast-qual&nbsp;-Wold-style-cast&nbsp;-Wdouble-promotion&nbsp;-std=c++<span style="color:#ff0044;font-weight:400">11</span>&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;-fsanitize=fuzzer&nbsp;-fprofile-instr-generate&nbsp;-fcoverage-mapping&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;tests/fuzz_parse.cpp&nbsp;src/pugixml.cpp&nbsp;-o&nbsp;fuzz_parse</div></div><br /><br />现在我们可以运行覆盖率编译的模糊器：<br /><div class="codebox"><div class="codebox">$&nbsp;LLVM_PROFILE_FILE=cov_parse.profraw&nbsp;./fuzz_parse&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;-dump_coverage=<span style="color:#ff0044;font-weight:400">1</span>&nbsp;-max_total_time=<span style="color:#ff0044;font-weight:400">2</span>&nbsp;-timeout=<span style="color:#ff0044;font-weight:400">100</span>&nbsp;-close_fd_mask=<span style="color:#ff0044;font-weight:400">3</span>&nbsp;\<br /><br />$&nbsp;llvm-profdata&nbsp;merge&nbsp;-sparse&nbsp;cov_parse.profraw&nbsp;-o&nbsp;cov_parse.profdata<br />$&nbsp;llvm-cov&nbsp;show&nbsp;-instr-profile=cov_parse.profdata&nbsp;-format=html&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;-output-dir&nbsp;./coverage_report&nbsp;fuzz_parse</div></div><br /><br />并访问coverage目录以显示coverage报告的HTML内容：<br /><div class="codebox"><div class="codebox">$&nbsp;cd&nbsp;coverage-report<br />$&nbsp;python3&nbsp;-m&nbsp;http.server&nbsp;<span style="color:#ff0044;font-weight:400">5002</span></div></div><br /><br /><a href=""><img src="images\950-1.png" alt="images\950-1.png" /></a><br /><br />此时，我们将能够通过浏览器在端口5002上本地观察该视图，即：localhost：5002<br /><br /><h2>fuzz_xpath的覆盖范围</h2><br /><br />对于fuzz_xpath模糊测试器，第一步是对其进行编译：<br /><div class="codebox"><div class="codebox">$&nbsp;clang++&nbsp;-g&nbsp;-Wall&nbsp;-Wextra&nbsp;-Werror&nbsp;-pedantic&nbsp;-Wundef&nbsp;-Wshadow&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;-Wcast-align&nbsp;-Wcast-qual&nbsp;-Wold-style-cast&nbsp;-Wdouble-promotion&nbsp;-std=c++<span style="color:#ff0044;font-weight:400">11</span>&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;-fsanitize=fuzzer&nbsp;-fprofile-instr-generate&nbsp;-fcoverage-mapping&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;tests/fuzz_xpath.cpp&nbsp;src/pugixml.cpp&nbsp;-o&nbsp;fuzz_xpath</div></div><br /><br />现在，我们可以运行coverage编译的模糊器并提取用于显示coverage的HTML代码：<br /><div class="codebox"><div class="codebox">$&nbsp;LLVM_PROFILE_FILE=cov_xpath.profraw&nbsp;./fuzz_xpath&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;-dump_coverage=<span style="color:#ff0044;font-weight:400">1</span>&nbsp;-max_total_time=<span style="color:#ff0044;font-weight:400">2</span>&nbsp;-timeout=<span style="color:#ff0044;font-weight:400">100</span>&nbsp;-close_fd_mask=<span style="color:#ff0044;font-weight:400">3</span><br />$&nbsp;llvm-profdata&nbsp;merge&nbsp;-sparse&nbsp;cov_xpath.profraw&nbsp;-o&nbsp;cov_xpath.profdata<br />$&nbsp;llvm-cov&nbsp;show&nbsp;-instr-profile=cov_xpath.profdata&nbsp;-format=html&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;-output-dir&nbsp;./coverage_report2&nbsp;fuzz_xpath<br /></div></div><br /><br />此时，我们可以导航到Coverge目录并启动我们的简单HTML服务器：<br /><div class="codebox"><div class="codebox">$&nbsp;cd&nbsp;coverage_report2<br />python3&nbsp;-m&nbsp;http.server&nbsp;<span style="color:#ff0044;font-weight:400">5002</span><br /></div></div><br /><br />这将为我们提供类似于localhost：5002的浏览器中的以下内容：<br /><a href=""><img src="images\950-2.png" alt="images\950-2.png" /></a><br /><br /><h2>合并覆盖率报告</h2><br />我们可以将两个模糊器的覆盖率报告转换为一个，以便获得所有模糊器的总覆盖率。<br />注意再将多个fuzz的覆盖率结果组合为一个的情况下，在将cov结果转为html文件夹时，需要使用-object 指定多个fuzzer程序的路径<br /><div class="codebox"><div class="codebox">$&nbsp;llvm-profdata&nbsp;merge&nbsp;-sparse&nbsp;cov_parse.profraw&nbsp;cov_xpath.profraw&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-o&nbsp;total_merged_coverage.profdata<br />$&nbsp;llvm-cov&nbsp;show&nbsp;-instr-profile=total_merged_coverage.profdata&nbsp;-format=html&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;-output-dir&nbsp;./coverage_report3&nbsp;-object&nbsp;fuzz_xpath&nbsp;-object&nbsp;fuzz_parse</div></div><br /><br />现在，我们可以启动合并的总覆盖率报告，如下所示：<br /><div class="codebox"><div class="codebox">$&nbsp;cd&nbsp;coverage_report3<br />python3&nbsp;-m&nbsp;http.server&nbsp;<span style="color:#ff0044;font-weight:400">5002</span></div></div><br /><br />现在，我们可以观察到localhost：5002的总覆盖率，并且应该看到如下内容：<br /><a href=""><img src="images\950-3.png" alt="images\950-3.png" /></a><br /><br /><br /><br /><br /><br /><br /><br /></div><div class='page'><h1 class='title level-3'>4_Assignment</h1><br/></div><div class='page'><h1 class='title level-4'>1_Efficient_fuzzing_assignment</h1><br/><h1>高效的模糊分配</h1><br /><br /><h1>问题1：收集早期项目的覆盖率报告</h1><br /><br />具体来说，对于每个项目：<br /><br />• Tiny Regex: <a href="https://github.com/kokke/tiny-regex-c">https://github.com/kokke/tiny-regex-c</a><br />• utf8: <a href="https://github.com/sheredom/utf8.h">https://github.com/sheredom/utf8.h</a><br />• json-parser: <a href="https://github.com/udp/json-parser">https://github.com/udp/json-parser</a><br />• Libcaca: <a href="https://github.com/cacalabs/libcaca">https://github.com/cacalabs/libcaca</a><br /><br />以及我们在上一个作业中开发的模糊器，请您执行以下操作：<br />1、将基于覆盖率的工具集成到构建脚本中，以便您可以构建模糊测试器和目标库以进行覆盖率分析。<br />2、运行模糊器至少一分钟以收集语料库。<br />3、使用上一步中的语料库运行基于覆盖率的模糊器<br />4、生成Coverage HTML报告<br /><br />要求您提交脚本和代码以及生成的覆盖率报告。<br /><br /><h2>问题2：XPDF</h2><br /><br />在这个问题上，要求您继续进行我们讨论的Xpdf项目。 要求您执行以下任务：<br /><br />1、编译涵盖的XPDF项目<br />2、确定使用种子和不使用种子时覆盖范围的差异。提出一个针对3的附加模糊器。与现有状态相比，Xpdf可以增加覆盖范围。<br />3、收集两个模糊器的总覆盖率并记录您的改进。<br /><br />要求您记录您的步骤。<br /><br /><h1>问题3：PugiXML</h1><br />这个问题的目的是继续进行PugiXML项目的工作，以实现更高的覆盖率。 为此，我们将首先提取现有的覆盖范围，然后对模糊设置进行改进，尤其是在要求您回答以下问题时：<br /><br />1、确定使用种子与不使用种子之间的总覆盖率差异。<br />2、在模糊器中实施更改，使您可以增加模糊器的覆盖率。 在这个问题中，一切都很重要，包括更改模糊器的源代码，提供种子和添加字典。<br /><br />要求您记录现有设置的覆盖范围，并记录您的改进。</div><div class='page'><h1 class='title level-2'>4_Structure-aware_fuzzing</h1><br/></div><div class='page'><h1 class='title level-3'>1_Introducing_structure-aware_fuzzing</h1><br/></div><div class='page'><h1 class='title level-4'>1_Introduction_to_structure-aware_fuzzing</h1><br/><h1>结构感知fuzz介绍</h1><br /><br />在本节中，我们将介绍结构感知的模糊测试的概念，一般而言，该概念涉及目标代码期望结构化数据的模糊测试。因此，结构感知的模糊器实现了将核心libfuzzer引擎提供的数据转换为结构化格式的逻辑，然后想法是结构化格式是每次模糊迭代中都在改变的格式。在大多数情况下，实现结构化的模糊测试的目的是使那些对模糊测试效率非常低的代码模糊化。<br /><br />结构化模糊在某种意义上是一个广义的概念，因此应将其理解为一个通用概念，而不是特定的代码构造或特定的狭窄技术。在本节中，我们将讨论LibFuzzer提供的对结构化模糊的支持，并讨论结构化模糊的示例用例。<br /><br />在许多方面，结构感知的模糊测试是模糊测试功能的第二步。到目前为止，根据我们目前掌握的知识，可以写出能够发现很多bug的fuzzer。但是，复杂的系统通常会期望将复杂的数据作为输入，甚至没有特定的输入格式，这是结构感知的模糊处理所取代的，这是我们迄今为止介绍的模糊处理技术所无法比拟的。尽管如此，在这里应该注意的是，从某种意义上讲，结构感知的模糊实际上只是一个附加的编程步骤，它在来自模糊器的随机数据和目标系统之间建立了桥梁。这样也为更多的模糊器设置打开了可能，这可能发现更多bug。<br /><br />结构感知的模糊测试最常见的应用之一是创建模糊器，这些模糊器可以用于测试非解析器程序。例如，创建针对编译器的模糊器。编译器接受一个简单字符串形式的程序，并且很自然地创建一个模糊器，该模糊器只获取随机数据并将其解析给编译器。但是，这样的模糊器将花费大部分时间来创建编译器无法理解的异常输入，并最终有效地探索了编译器解析例程的所有不同代码。因此，编译器的核心逻辑，即在初始解析后对输入进行操作的所有代码，执行的次数明显少于实际的解析例程。但是，<br /><br />使用结构感知的模糊测试，可以创建仅对解析器产生与有效代码字符串相对应的输入的模糊器，从而有效地使解析器的约束在每个输入中均得到满足，因此模糊器将 在每次模糊迭代中有效地达到目标的逻辑<br /><br />。通过这种方式，编译器的核心逻辑将是变得模糊的代码，因此我们将在这里找到错误。</div><div class='page'><h1 class='title level-3'>2_Custom_libfuzzer_mutators</h1><br/></div><div class='page'><h1 class='title level-4'>1_Demonstration of custom mutators _ ADA Logics</h1><br/>libfuzzer的源码，其中也包含了sanitizer的源码实现<br /><a href=""><img src="images\960-1.png" alt="images\960-1.png" /></a><br /><br />其中libfuzzer突变策略实现在如下函数中<br /><a href=""><img src="images\960-2.png" alt="images\960-2.png" /></a><br /><br />源码中默认的突变函数均位于DefaultMutators对象中<br /><a href=""><img src="images\960-3.png" alt="images\960-3.png" /></a><br /><br />搜索函数名，可以找到突变函数的具体实现，所有默认突变函数的拥有相同的参数以及返回值<br />Data指向要变异的种子数据<br />size描述上述数据大小<br />MaxSize表示该要变异的种子数据允许的最大大小<br />函数返回变异后的种子数据的大小<br /><a href=""><img src="images\960-4.png" alt="images\960-4.png" /></a><br /><br />源码中如果LLVMFuzzerCustomMutator函数存在，则会给Mutators对象增加一个元素，该元素即为自定义的突变函数，否则会将默认突变函数对象DefaultMutators赋值给Mutarors对象<br /><a href=""><img src="images\960-5.png" alt="images\960-5.png" /></a><br /><br />以上代码中MutationDispatcher::Mutate_Custom实际上就是调用了LLVMFuzzerCustomMutator函数，但注意两函数前三个参数均相同，但LLVMFuzzerCustomMutator函数还存在第四个参数，是一个随机种子<br /><a href=""><img src="images\960-6.png" alt="images\960-6.png" /></a><br /><br />创建fuzz源码文件<br /><a href=""><img src="images\960-7.png" alt="images\960-7.png" /></a><br /><br />编译并运行libfuzzer<br /><a href=""><img src="images\960-8.png" alt="images\960-8.png" /></a><br /><br />创建新的fuzzer，让种子数据有ab和ba两种可能<br /><a href=""><img src="images\960-9.png" alt="images\960-9.png" /></a><br /><br />编译并运行<br /><a href=""><img src="images\960-10.png" alt="images\960-10.png" /></a><br /><br />fuzzer的输出并不仅仅是ab ba，还有aa和bb<br /><a href=""><img src="images\960-11.png" alt="images\960-11.png" /></a><br /><br />为了探究出现AA BB种子的原因，在执行突变逻辑之前，将libfuzzer传入LLVMFuzzerCunstomMutator函数的Data打印出来<br /><a href=""><img src="images\960-12.png" alt="images\960-12.png" /></a><br /><br />编译并执行<br /><a href=""><img src="images\960-13.png" alt="images\960-13.png" /></a><br /><br />将执行结果重定向到txt文件中<br /><a href=""><img src="images\960-14.png" alt="images\960-14.png" /></a><br /><br />根据输出文件，该fuzzer首先会执行两次LLVMFuzzerTestOneInput函数，两次的种子数据的长度分别为0，1，根据后面的分析可知，长度为1的种子文件对应数据为0xa<br />之后才会执行LLVMFuzzerCustomMutator函数，且LLVMFuzzerCustomMutator函数第一次执行时，种子文件长度为1，数据为0xa，该种子文件会被加入到libfuzzer种子池中，且在之后的fuzzer过程中会被再次选出作为种子进行变异<br /><a href=""><img src="images\960-15.png" alt="images\960-15.png" /></a><br /><br />为了进一步理解种子a和输出BB的关系（上图红框），对fuzzer进行进一步修改<br />即尝试输出种子文件的三字节长度的内容，而不是仅仅输出种子文件长度<br /><a href=""><img src="images\960-16.png" alt="images\960-16.png" /></a><br /><br />编译并运行，得到以下结果<br />根据结果，之所以可以输出BB类型的种子文件，是因为libfuzzer将种子池中的0xa挑选出来作为种子时，种子内存空间中仍存在上一次种子数据的残留（即0x42 0x41 0x0），0xa将会占用0x42的内存位置，但是LLVMFuzzerCustomMutator函数在突变种子时并未判断种子文件长度（即size参数）而是直接将种子文件长度视为3字节，所以导致了出现BB类型的种子文件<br /><a href=""><img src="images\960-17.png" alt="images\960-17.png" /></a><br /><br />如果一开始给以上fuzzer提供种子文件，那么输出结果会不会有所不同？<br /><br />创建语料库文件夹以及种子文件夹，并创建种子文件，给fuzzer提供种子文件，并执行fuzzer<br /><a href=""><img src="images\960-18.png" alt="images\960-18.png" /></a><br /><br />种子文件中写写入若干C<br /><a href=""><img src="images\960-19.png" alt="images\960-19.png" /></a><br /><br />输出如下，<br />第一轮迭代过程中，种子文件大小仍为0，第二轮迭代过程中，种子文件大小仍为8<br />种子文件数据在第二轮迭代过程中被作为Data传给了LLVMFuzzerTestOneInput中<br /><a href=""><img src="images\960-20.png" alt="images\960-20.png" /></a><br /><br /><br /><br /><br /></div><div class='page'><h1 class='title level-4'>2_Custom_LibFuzzer_mutators</h1><br/><h1>自定义LibFuzzer变异器</h1><br /><br />在本节中，我们将讨论LibFuzzer中对自定义转换器的支持。 回想一下，我们在本课程的早期讨论了LibFuzzer的变异，共有十个默认变异器功能。<br /><br /><h3>LibFuzzer default mutation functions</h3><br /><br />我们可以在这里找到LibFuzzer的默认变异例程。<br /><a href="https://github.com/llvm/llvm-project/blob/master/compiler-rt/lib/fuzzer/FuzzerMutate.cpp">https://github.com/llvm/llvm-project/blob/master/compiler-rt/lib/fuzzer/FuzzerMutate.cpp</a><br /><br />• <strong>EraseBytes</strong>: 从种子中删除一组字节。 将最大去除一半的种子。<br />• <strong>InsertByte</strong>:在种子的随机位置插入一个随机字节。<br />• <strong>InsertRepeatedBytes</strong>: 重复插入同一字节多次。 请注意，此处将优先级赋予0x00和0xff，并且这些字节之一将是一半时间选择的字节。<br />• <strong>ChangeByte</strong>: 在种子中的随机位置选择一个字节，并将其替换为随机字节。<br />• <strong>ChangeBit</strong>: 在种子中的任意位置选择一个字节，然后用1bit数据XoRs在该字节中的单个bit。<br />• <strong>ShuffleBytes</strong>: 通过std :: shuffle对种子中的随机字节序列进行重新排序。  ChangeASCIIInt：扫描种子，以查找与整数表示形式对应的ASCII字符的首次出现。 然后将这些ASCII字符转换为实际整数，并通过简单的算术运算（例如： 增加/减少，除以2或乘以2或将其替换为随机数。 然后继续将整数转换为ASCII字符并覆盖最初找到的ASCII字符。<br />• <strong>ChangeBinInt</strong>: 将种子中的随机位置解释为1,2,4或8个字节的整数，然后基于简单的按位算术对该字节进行突变。<br />• <strong>CopyPart</strong>: 将字节从种子的一部分复制到种子的另一部分。<br />• <strong>CrossOver</strong>: 与CopyPart密切相关，但是诱变策略不是从自己的种子中复制数据，而是将数据从随机整数复制到种子上。<br /><br />如果您想在源代码中看到突变策略的实现，则将它们全部放在此文件中：<a href="https://github.com/llvm/llvm-project/blob/master/compiler-rt/lib/fuzzer/FuzzerMutate.cpp">https://github.com/llvm/llvm-project/blob/master/compiler-rt/lib/fuzzer/FuzzerMutate.cpp</a><h3>.</h3> 每个执行突变的功能的名称都是以Mutate_为前缀的突变名称。 因此，用于EraseBytes突变的函数的名称由Mutate_EraseBytes给出。<br /><br />这些突变功能背后的关键目标是以某种方式修改数据。 但是，从一般的角度来看，模糊器实际上并没有严格的方法来突变其数据，因此，LibFuzzer提供了编写自定义突变函数的机会。为了编写自定义突变函数，我们只需在模糊器中定义函数LLVMFuzzerCustomMutator。 如果我们在代码中定义了LLVMFuzzerCustomMutator函数，那么它将是LibFuzzer明确调用的唯一变异函数，这意味着除非我们从模糊器中显式调用它们，否则不会调用其他任何突变函数。 我们可以通过调用LLVMFuzzerMutate函数来应用默认突变。<br /><br />LLVMFuzzerCustomMutator的完整功能签名为<br /><h3>extern &quot;C&quot; size_t LLVMFuzzerCustomMutator(uint8_t *Data, size_t Size, size_t MaxSize, unsigned int Seed)</h3><br /><br />该函数中，将种子文件数据指针作为参数，在函数内部对种子数据进行突变，最后返回突变后种子数据的大小<br /><br />函数参数<br />• <strong>Data</strong> 是指向现有种子数据的指针，这是应该被突变的缓冲区。 具体来说，这也是将用于下一个种子的数据。<br />• <strong>Size</strong> 是现有种子的大小。<br />• <strong>MaxSize</strong> 是Data指向的缓冲区可以容纳的最大大小。 因此，该突变不得创建大于MaxSize的数据。<br />• <strong>Seed</strong>是一个随机的unsigned int整数，由libfuzzer核心引擎生成，可以由mutator函数使用以影响突变。<br /><br />使用LLVMFuzzerCustomMutator时，我们要做的基本步骤是修改Data缓冲区并返回修改后的种子的大小。 修改后的种子最大长度为MaxSize。 为了可视化始终产生相同种子的简单自定义模糊器的实现，请考虑以下示例模糊器：<br /><br /><a href="http://fuzz.cc/">fuzz.cc</a><br /><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdint.h&gt;<br />#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;stdlib.h&gt;<br /><br />#include&nbsp;&lt;iostream&gt;<br /><br />extern&nbsp;&quot;C&quot;&nbsp;int&nbsp;LLVMFuzzerTestOneInput(const&nbsp;uint8_t&nbsp;*Data,&nbsp;size_t&nbsp;Size)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;&quot;seed&nbsp;size&nbsp;&quot;&nbsp;&lt;&lt;&nbsp;Size&nbsp;&lt;&lt;&nbsp;&quot;&nbsp;content:&nbsp;&quot;&nbsp;&lt;&lt;&nbsp;std::endl;<br />&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;Data&nbsp;&lt;&lt;&nbsp;std::endl;<br />&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;&quot;===========+&quot;&nbsp;&lt;&lt;&nbsp;std::endl;<br />&nbsp;&nbsp;return&nbsp;0;<br />}<br /><br />extern&nbsp;&quot;C&quot;&nbsp;size_t&nbsp;LLVMFuzzerCustomMutator(uint8_t&nbsp;*Data,&nbsp;size_t&nbsp;Size,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;MaxSize,&nbsp;unsigned&nbsp;int&nbsp;Seed)&nbsp;<span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;Data[0]&nbsp;=&nbsp;&#39;A&#39;;<br />&nbsp;&nbsp;&nbsp;&nbsp;Data[1]&nbsp;=&nbsp;&#39;B&#39;;<br />&nbsp;&nbsp;&nbsp;&nbsp;Data[2]&nbsp;=&nbsp;&#39;\0&#39;;<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;3;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />上面的模糊器仅将每个种子设置为3个字节，并且等于包含空终止符的字符串“ AB”。 自然，此模糊器本身没有用，但是它显示了LLVMFuzzerTestOneInput和LLVMFuzzerMutate协同工作的结构。 执行以上操作的结果如下：<br /><div class="codebox"><div class="codebox">$&nbsp;clang++&nbsp;-fsanitize=fuzzer&nbsp;fuzz.cc&nbsp;-o&nbsp;fuzz<br />$&nbsp;./fuzz<br />seed&nbsp;size&nbsp;0&nbsp;content:<br /><br />===========+<br />seed&nbsp;size&nbsp;1&nbsp;content:<br /><br /><br />===========+<br />seed&nbsp;size&nbsp;3&nbsp;content:<br />AB<br />===========+<br />seed&nbsp;size&nbsp;3&nbsp;content:<br />AB<br />===========+<br />seed&nbsp;size&nbsp;3&nbsp;content:<br />AB<br />===========+<br />seed&nbsp;size&nbsp;3&nbsp;content:<br />AB<br />===========+<br />seed&nbsp;size&nbsp;3&nbsp;content:<br />AB<br />===========+<br />seed&nbsp;size&nbsp;3&nbsp;content:<br />AB<br />===========+<br /></div></div><br /><br />上面的自定义变异策略实际上并不是很有趣，因为它总是产生与三个字节完全相同的种子：\ x41 \ x42 \ x00。自然而然的下一步是生产可以以某种方式改变种子文件的模糊器。以我们的示例为例，我们将实现一个种子大小为3的模糊器，相较于始终生成种子“ AB”，而是使种子不断在“ AB”，“ BA”，“ AB”，“  BA”等变化，这种样本突变策略的目标是可视化突变周围基础结构的工作原理。 考虑下面的C ++代码可以做到这一点：<br /><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdint.h&gt;<br />#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;stdlib.h&gt;<br />#include&nbsp;&lt;iostream&gt;<br /><br />extern&nbsp;&quot;C&quot;&nbsp;int&nbsp;LLVMFuzzerTestOneInput(const&nbsp;uint8_t&nbsp;*Data,&nbsp;size_t&nbsp;Size)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;&quot;seed&nbsp;size&nbsp;&quot;&nbsp;&lt;&lt;&nbsp;Size&nbsp;&lt;&lt;&nbsp;&quot;&nbsp;content:&nbsp;&quot;&nbsp;&lt;&lt;&nbsp;std::endl;<br />&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;Data&nbsp;&lt;&lt;&nbsp;std::endl;<br />&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;&quot;===========+&quot;&nbsp;&lt;&lt;&nbsp;std::endl;<br />&nbsp;&nbsp;return&nbsp;0;<br />}<br /><br />extern&nbsp;&quot;C&quot;&nbsp;size_t&nbsp;LLVMFuzzerCustomMutator(uint8_t&nbsp;*Data,&nbsp;size_t&nbsp;Size,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;MaxSize,&nbsp;unsigned&nbsp;int&nbsp;Seed)&nbsp;<span style="color:#000000;font-weight:400">{</span><br /><br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(Data[0]&nbsp;!=&nbsp;&#39;A&#39;&nbsp;&amp;&amp;&nbsp;Data[0]&nbsp;!=&nbsp;&#39;B&#39;)&nbsp;Data[0]&nbsp;=&nbsp;&#39;A&#39;;<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(Data[1]&nbsp;!=&nbsp;&#39;A&#39;&nbsp;&amp;&amp;&nbsp;Data[1]&nbsp;!=&nbsp;&#39;B&#39;)&nbsp;Data[1]&nbsp;=&nbsp;&#39;B&#39;;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;2;&nbsp;i&nbsp;++)<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(Data[i]&nbsp;==&nbsp;&#39;A&#39;)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Data[i]&nbsp;=&nbsp;&#39;B&#39;;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;(Data[i]&nbsp;==&nbsp;&#39;B&#39;)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Data[i]&nbsp;=&nbsp;&#39;A&#39;;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;Data[2]&nbsp;=&nbsp;&#39;\0&#39;;<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;3;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />上面的代码包括两个部分。 首先，它检查第一个字符是否不是&#39;A&#39;或&#39;B&#39;，如果是这种情况，则将种子中的第一个字符设置为&#39;A&#39;。 同样，它对种子的第二个字符进行相同的检查，如果条件成立，将字符设置为“ B”。 它的第二部分是循环，它将循环通过种子的前两个字符。 如果字符是“ A”，则该字符将是“ B”，如果字符是“ B”，则将其设置为“ A”。<br /><br />按照上述模糊器的逻辑，我们始终只能创建两个可能的种子：“ AB”和“ BA”（不包括空终止符）。 因此，让我们编译一下并运行模糊器：<br /><div class="codebox"><div class="codebox">$&nbsp;clang++&nbsp;-fsanitize=fuzzer&nbsp;fuzz.cc<br />$&nbsp;./a.out<br />seed&nbsp;size&nbsp;0&nbsp;content:<br /><br />===========+<br />seed&nbsp;size&nbsp;1&nbsp;content:<br /><br /><br />===========+<br />seed&nbsp;size&nbsp;3&nbsp;content:<br />BA<br />===========+<br />seed&nbsp;size&nbsp;3&nbsp;content:<br />AB<br />===========+<br />seed&nbsp;size&nbsp;3&nbsp;content:<br />BA<br />===========+<br />seed&nbsp;size&nbsp;3&nbsp;content:<br />AB<br />===========+<br />seed&nbsp;size&nbsp;3&nbsp;content:<br />BA<br />===========+<br />seed&nbsp;size&nbsp;3&nbsp;content:<br />BB<br />===========+<br />seed&nbsp;size&nbsp;3&nbsp;content:<br />AA<br />===========+<br />seed&nbsp;size&nbsp;3&nbsp;content:<br />BB<br />===========+<br />seed&nbsp;size&nbsp;3&nbsp;content:<br />AA<br />===========+<br />seed&nbsp;size&nbsp;3&nbsp;content:<br />BB<br />===========+<br />seed&nbsp;size&nbsp;3&nbsp;content:<br />BA<br />===========+</div></div><br /><br />如我们所见，模糊器实际上并不会产生的唯一种子。要理解该模糊器为何不会产生所需模式“ AB”，“ BA”，“ AB”，“ BA”，...，的确切行为， 我们可以扩展自定义模糊器，以显示正被传递到我们的变异例程的种子，如下所示：<br /><br /><a href="http://fuzz.cc/">fuzz.cc</a><br /><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdint.h&gt;<br />#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;stdlib.h&gt;<br />#include&nbsp;&lt;iostream&gt;<br /><br />extern&nbsp;&quot;C&quot;&nbsp;int&nbsp;LLVMFuzzerTestOneInput(const&nbsp;uint8_t&nbsp;*Data,&nbsp;size_t&nbsp;Size)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;&quot;seed&nbsp;size&nbsp;&quot;&nbsp;&lt;&lt;&nbsp;Size&nbsp;&lt;&lt;&nbsp;&quot;&nbsp;content:&nbsp;&quot;&nbsp;&lt;&lt;&nbsp;std::endl;<br />&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;Data&nbsp;&lt;&lt;&nbsp;std::endl;<br />&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;&quot;===========+&quot;&nbsp;&lt;&lt;&nbsp;std::endl;<br />&nbsp;&nbsp;return&nbsp;0;<br />}<br /><br />extern&nbsp;&quot;C&quot;&nbsp;size_t&nbsp;LLVMFuzzerCustomMutator(uint8_t&nbsp;*Data,&nbsp;size_t&nbsp;Size,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;MaxSize,&nbsp;unsigned&nbsp;int&nbsp;Seed)&nbsp;<span style="color:#000000;font-weight:400">{</span><br /><br />&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;&quot;Pre&nbsp;size&nbsp;seed&nbsp;&quot;&nbsp;&lt;&lt;&nbsp;Size&nbsp;&lt;&lt;&nbsp;std::endl;<br />&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;&quot;Pre&nbsp;seed&nbsp;{&nbsp;&quot;;<br />&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;Size;&nbsp;i++)<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;std::hex&nbsp;&lt;&lt;&nbsp;(int)Data[i]&nbsp;&lt;&lt;&nbsp;&quot;&nbsp;&quot;;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;&quot;&nbsp;}&quot;&nbsp;&lt;&lt;&nbsp;std::endl;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(Data[0]&nbsp;!=&nbsp;&#39;A&#39;&nbsp;&amp;&amp;&nbsp;Data[0]&nbsp;!=&nbsp;&#39;B&#39;)&nbsp;Data[0]&nbsp;=&nbsp;&#39;A&#39;;<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(Data[1]&nbsp;!=&nbsp;&#39;A&#39;&nbsp;&amp;&amp;&nbsp;Data[1]&nbsp;!=&nbsp;&#39;B&#39;)&nbsp;Data[1]&nbsp;=&nbsp;&#39;B&#39;;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;2;&nbsp;i&nbsp;++)<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(Data[i]&nbsp;==&nbsp;&#39;A&#39;)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Data[i]&nbsp;=&nbsp;&#39;B&#39;;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;(Data[i]&nbsp;==&nbsp;&#39;B&#39;)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Data[i]&nbsp;=&nbsp;&#39;A&#39;;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;Data[2]&nbsp;=&nbsp;&#39;\0&#39;;<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;3;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />我们在模糊器中插入的唯一代码是在LLVMFuzzerCustomMutator的开头，我们在其中插入了几行，这些行将打印将要突变的种子的大小以及给定种子的字节。 这样，我们可以编译此模糊器，运行它，然后观察输出：<br /><br /><div class="codebox"><div class="codebox">$&nbsp;&nbsp;clang++&nbsp;-fsanitize=fuzzer&nbsp;fuzz.cc<br />seed&nbsp;size&nbsp;0&nbsp;content:<br /><br />===========+<br />seed&nbsp;size&nbsp;1&nbsp;content:<br /><br /><br />===========+<br />Pre&nbsp;size&nbsp;seed&nbsp;1<br />Pre&nbsp;seed&nbsp;{&nbsp;a&nbsp;&nbsp;}<br />seed&nbsp;size&nbsp;3&nbsp;content:<br />BA<br />===========+<br />Pre&nbsp;size&nbsp;seed&nbsp;3<br />Pre&nbsp;seed&nbsp;{&nbsp;42&nbsp;41&nbsp;0&nbsp;&nbsp;}<br />seed&nbsp;size&nbsp;3&nbsp;content:<br />AB<br />===========+<br />Pre&nbsp;size&nbsp;seed&nbsp;3<br />Pre&nbsp;seed&nbsp;{&nbsp;41&nbsp;42&nbsp;0&nbsp;&nbsp;}<br />seed&nbsp;size&nbsp;3&nbsp;content:<br />BA<br />===========+<br />Pre&nbsp;size&nbsp;seed&nbsp;3<br />Pre&nbsp;seed&nbsp;{&nbsp;42&nbsp;41&nbsp;0&nbsp;&nbsp;}<br />seed&nbsp;size&nbsp;3&nbsp;content:<br />AB<br />===========+<br />Pre&nbsp;size&nbsp;seed&nbsp;3<br />Pre&nbsp;seed&nbsp;{&nbsp;41&nbsp;42&nbsp;0&nbsp;&nbsp;}<br />seed&nbsp;size&nbsp;3&nbsp;content:<br />BA<br />===========+<br />Pre&nbsp;size&nbsp;seed&nbsp;1<br />Pre&nbsp;seed&nbsp;{&nbsp;a&nbsp;&nbsp;}<br />seed&nbsp;size&nbsp;3&nbsp;content:<br />BB<br />===========+<br />Pre&nbsp;size&nbsp;seed&nbsp;3<br />Pre&nbsp;seed&nbsp;{&nbsp;42&nbsp;42&nbsp;0&nbsp;&nbsp;}<br />seed&nbsp;size&nbsp;3&nbsp;content:<br />AA<br />===========+<br />Pre&nbsp;size&nbsp;seed&nbsp;3<br />Pre&nbsp;seed&nbsp;{&nbsp;41&nbsp;41&nbsp;0&nbsp;&nbsp;}<br />seed&nbsp;size&nbsp;3&nbsp;content:<br />BB<br />===========+<br />Pre&nbsp;size&nbsp;seed&nbsp;3<br />Pre&nbsp;seed&nbsp;{&nbsp;42&nbsp;42&nbsp;0&nbsp;&nbsp;}<br />seed&nbsp;size&nbsp;3&nbsp;content:<br />AA<br />===========+<br />Pre&nbsp;size&nbsp;seed&nbsp;3<br />Pre&nbsp;seed&nbsp;{&nbsp;41&nbsp;41&nbsp;0&nbsp;&nbsp;}<br />seed&nbsp;size&nbsp;3&nbsp;content:<br />BB<br />===========+<br />Pre&nbsp;size&nbsp;seed&nbsp;1<br />Pre&nbsp;seed&nbsp;{&nbsp;a&nbsp;&nbsp;}<br />seed&nbsp;size&nbsp;3&nbsp;content:<br />BA<br />===========+</div></div><br /><br />至此，行为变得清晰。 传递给我们的LLVMFuzzerTestOneInput函数的第一个种子是零字节（大小为0）的种子，传递给LLVMFuzzerTestOneInput的第二个种子是值为0x0a的1字节的种子，并且只有在第三次迭代中LibFuzzer触发了我们的自定义 变异函数，即我们的字符串“ Pre size seed 1”的打印位置。我们可以在这里观察到种子的值为0x0a，大小仅为1，这意味着在我们的种子库中存在种子&#39;\ x0a&#39;。<br /><br />我们可以使用上一段中的观察来合理化观察到诸如“ BB”和“ AA”之类的种子的原因。特别是，在我们看到的“ BB”的第一个实例中，我们可以看到选择的种子是&#39;\ x0a&#39;种子。但是，就在我们的“ BB”种子的第一个实例之前，我们产生了一个种子“ BA”，这意味着在将1个字节“ \ x0a”的种子复制到种子之前，我们种子的数据缓冲区包含“ BA” 缓冲。这样，在第一种情况“ BB”中，在应用突变之前，种子的前两个字节为“ \ x0a \ x41”（尤其是第一个字节为“ \ x0a”，第二个字节为“ A”）  。 在我们的变异逻辑预先设置了种子的情况下，种子将变成“ BB”，这正是发生的情况。<br /><br />现在我们更好地理解了为什么种子的生成比我们真正预期的要远得多。这样做的原因很简单，就是LibFuzzer先会从空种子开始两次随机模糊迭代，从而生成随机种子，最后才应用我们的自定义突变函数，这些种子中的第二个会被放入我们的种子库中（即本例中的0xa），这意味着它将在模糊测试期间的某个时候被拾取，然后就产生新种子而言，它实际上变成了滚雪球效应，例如，我们还可以看到我们创建了类似“ AA”的种子，这是上述行为的结果。<br /><br />为了阐明以上几点，我们可以在自定义变异器中插入其他日志记录，该日志记录器将打印种子的所有前三个字节，而不只是打印低于种子大小的字节，如下所示：<br /><br />fuzz.cc<br /><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdint.h&gt;<br />#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;stdlib.h&gt;<br />#include&nbsp;&lt;iostream&gt;<br /><br />extern&nbsp;&quot;C&quot;&nbsp;int&nbsp;LLVMFuzzerTestOneInput(const&nbsp;uint8_t&nbsp;*Data,&nbsp;size_t&nbsp;Size)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;&quot;seed&nbsp;size&nbsp;&quot;&nbsp;&lt;&lt;&nbsp;Size&nbsp;&lt;&lt;&nbsp;&quot;&nbsp;content:&nbsp;&quot;&nbsp;&lt;&lt;&nbsp;std::endl;<br />&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;Data&nbsp;&lt;&lt;&nbsp;std::endl;<br />&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;&quot;===========+&quot;&nbsp;&lt;&lt;&nbsp;std::endl;<br />&nbsp;&nbsp;return&nbsp;0;<br />}<br /><br />extern&nbsp;&quot;C&quot;&nbsp;size_t&nbsp;LLVMFuzzerCustomMutator(uint8_t&nbsp;*Data,&nbsp;size_t&nbsp;Size,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;MaxSize,&nbsp;unsigned&nbsp;int&nbsp;Seed)&nbsp;<span style="color:#000000;font-weight:400">{</span><br /><br />&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;&quot;Pre&nbsp;size&nbsp;seed&nbsp;&quot;&nbsp;&lt;&lt;&nbsp;Size&nbsp;&lt;&lt;&nbsp;std::endl;<br />&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;&quot;Pre&nbsp;seed&nbsp;{&nbsp;&quot;;<br />&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;3;&nbsp;i++)<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;std::hex&nbsp;&lt;&lt;&nbsp;(int)Data[i]&nbsp;&lt;&lt;&nbsp;&quot;&nbsp;&quot;;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;&quot;&nbsp;}&quot;&nbsp;&lt;&lt;&nbsp;std::endl;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(Data[0]&nbsp;!=&nbsp;&#39;A&#39;&nbsp;&amp;&amp;&nbsp;Data[0]&nbsp;!=&nbsp;&#39;B&#39;)&nbsp;Data[0]&nbsp;=&nbsp;&#39;A&#39;;<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(Data[1]&nbsp;!=&nbsp;&#39;A&#39;&nbsp;&amp;&amp;&nbsp;Data[1]&nbsp;!=&nbsp;&#39;B&#39;)&nbsp;Data[1]&nbsp;=&nbsp;&#39;B&#39;;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;2;&nbsp;i&nbsp;++)<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(Data[i]&nbsp;==&nbsp;&#39;A&#39;)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Data[i]&nbsp;=&nbsp;&#39;B&#39;;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;(Data[i]&nbsp;==&nbsp;&#39;B&#39;)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Data[i]&nbsp;=&nbsp;&#39;A&#39;;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;Data[2]&nbsp;=&nbsp;&#39;\0&#39;;<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;3;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />编译并运行此代码后，我们将得到以下输出：<br /><div class="codebox"><div class="codebox">seed&nbsp;size&nbsp;0&nbsp;content:<br /><br />===========+<br />seed&nbsp;size&nbsp;1&nbsp;content:<br /><br /><br />===========+<br />Pre&nbsp;size&nbsp;seed&nbsp;1<br />Pre&nbsp;seed&nbsp;{&nbsp;a&nbsp;0&nbsp;0&nbsp;&nbsp;}<br />seed&nbsp;size&nbsp;3&nbsp;content:<br />BA<br />===========+<br />Pre&nbsp;size&nbsp;seed&nbsp;3<br />Pre&nbsp;seed&nbsp;{&nbsp;42&nbsp;41&nbsp;0&nbsp;&nbsp;}<br />seed&nbsp;size&nbsp;3&nbsp;content:<br />AB<br />===========+<br />Pre&nbsp;size&nbsp;seed&nbsp;3<br />Pre&nbsp;seed&nbsp;{&nbsp;41&nbsp;42&nbsp;0&nbsp;&nbsp;}<br />seed&nbsp;size&nbsp;3&nbsp;content:<br />BA<br />===========+<br />Pre&nbsp;size&nbsp;seed&nbsp;3<br />Pre&nbsp;seed&nbsp;{&nbsp;42&nbsp;41&nbsp;0&nbsp;&nbsp;}<br />seed&nbsp;size&nbsp;3&nbsp;content:<br />AB<br />===========+<br />Pre&nbsp;size&nbsp;seed&nbsp;3<br />Pre&nbsp;seed&nbsp;{&nbsp;41&nbsp;42&nbsp;0&nbsp;&nbsp;}<br />seed&nbsp;size&nbsp;3&nbsp;content:<br />BA<br />===========+<br />Pre&nbsp;size&nbsp;seed&nbsp;1<br />Pre&nbsp;seed&nbsp;{&nbsp;a&nbsp;41&nbsp;0&nbsp;&nbsp;}<br />seed&nbsp;size&nbsp;3&nbsp;content:<br />BB<br />===========+<br />Pre&nbsp;size&nbsp;seed&nbsp;3<br />Pre&nbsp;seed&nbsp;{&nbsp;42&nbsp;42&nbsp;0&nbsp;&nbsp;}<br />seed&nbsp;size&nbsp;3&nbsp;content:<br />AA<br />===========+<br />Pre&nbsp;size&nbsp;seed&nbsp;3<br />Pre&nbsp;seed&nbsp;{&nbsp;41&nbsp;41&nbsp;0&nbsp;&nbsp;}<br />seed&nbsp;size&nbsp;3&nbsp;content:<br />BB<br />===========+<br />Pre&nbsp;size&nbsp;seed&nbsp;3<br />Pre&nbsp;seed&nbsp;{&nbsp;42&nbsp;42&nbsp;0&nbsp;&nbsp;}<br />seed&nbsp;size&nbsp;3&nbsp;content:<br />AA<br />===========+<br />Pre&nbsp;size&nbsp;seed&nbsp;3<br />Pre&nbsp;seed&nbsp;{&nbsp;41&nbsp;41&nbsp;0&nbsp;&nbsp;}<br />seed&nbsp;size&nbsp;3&nbsp;content:<br />BB<br />===========+<br />Pre&nbsp;size&nbsp;seed&nbsp;1<br />Pre&nbsp;seed&nbsp;{&nbsp;a&nbsp;42&nbsp;0&nbsp;&nbsp;}<br />seed&nbsp;size&nbsp;3&nbsp;content:<br />BA<br />===========+</div></div><br /><br />输出确认了我们的分析，因为我们可以在第一个实例中看到种子为“ BB”的情况，解析到我们的自定义突变例程的种子的大小为1，第一个字节为&#39;\ x0a&#39;，但是第二个字节 缓冲区的确确实是&#39;\ x41&#39;（&#39;A&#39;），这就是为什么我们的自定义突变函数创建“ BB”种子的原因，因为我们的突变函数在执行其突变时不进行大小检查。<br /><br />最后，为了绕过LibFuzzer提供的空的第一个种子，我们可以提供一个初始种子，例如种子“ CCC”：<br /><div class="codebox"><div class="codebox">$&nbsp;mkdir&nbsp;CORPUS<br />$&nbsp;mkdir&nbsp;SEEDS<br />$&nbsp;echo&nbsp;&quot;CCC&quot;&nbsp;&gt;&gt;&nbsp;&nbsp;SEEDS/seed1<br />$&nbsp;./fuzz&nbsp;CORPUS&nbsp;SEEDS<br />seed&nbsp;size&nbsp;0&nbsp;content:&nbsp;<br />&nbsp;sP4^?<br />===========+<br />seed&nbsp;size&nbsp;4&nbsp;content:&nbsp;<br />CCC<br />^?<br />===========+<br />Pre&nbsp;size&nbsp;seed&nbsp;4<br />Pre&nbsp;seed&nbsp;{&nbsp;43&nbsp;43&nbsp;43&nbsp;&nbsp;}<br />seed&nbsp;size&nbsp;3&nbsp;content:&nbsp;<br />BA<br />===========+<br />Pre&nbsp;size&nbsp;seed&nbsp;3<br />Pre&nbsp;seed&nbsp;{&nbsp;42&nbsp;41&nbsp;0&nbsp;&nbsp;}<br />seed&nbsp;size&nbsp;3&nbsp;content:&nbsp;<br />AB<br />===========+<br />Pre&nbsp;size&nbsp;seed&nbsp;3<br />Pre&nbsp;seed&nbsp;{&nbsp;41&nbsp;42&nbsp;0&nbsp;&nbsp;}<br />seed&nbsp;size&nbsp;3&nbsp;content:&nbsp;<br />BA<br />===========+<br />Pre&nbsp;size&nbsp;seed&nbsp;3<br />Pre&nbsp;seed&nbsp;{&nbsp;42&nbsp;41&nbsp;0&nbsp;&nbsp;}<br />seed&nbsp;size&nbsp;3&nbsp;content:&nbsp;<br />AB<br />===========+<br />Pre&nbsp;size&nbsp;seed&nbsp;3<br />Pre&nbsp;seed&nbsp;{&nbsp;41&nbsp;42&nbsp;0&nbsp;&nbsp;}<br />seed&nbsp;size&nbsp;3&nbsp;content:&nbsp;<br />BA<br />===========+<br />Pre&nbsp;size&nbsp;seed&nbsp;3<br />Pre&nbsp;seed&nbsp;{&nbsp;42&nbsp;41&nbsp;0&nbsp;&nbsp;}<br />seed&nbsp;size&nbsp;3&nbsp;content:&nbsp;<br />AB<br />===========+<br />Pre&nbsp;size&nbsp;seed&nbsp;3<br />Pre&nbsp;seed&nbsp;{&nbsp;42&nbsp;41&nbsp;0&nbsp;&nbsp;}<br />seed&nbsp;size&nbsp;3&nbsp;content:&nbsp;<br />AB<br />===========+<br />Pre&nbsp;size&nbsp;seed&nbsp;3<br />Pre&nbsp;seed&nbsp;{&nbsp;41&nbsp;42&nbsp;0&nbsp;&nbsp;}<br />seed&nbsp;size&nbsp;3&nbsp;content:&nbsp;<br />BA<br />===========+<br />Pre&nbsp;size&nbsp;seed&nbsp;3<br />Pre&nbsp;seed&nbsp;{&nbsp;42&nbsp;41&nbsp;0&nbsp;&nbsp;}<br />seed&nbsp;size&nbsp;3&nbsp;content:&nbsp;<br />AB<br />===========+<br /></div></div><br /><br />现在我们可以观察到，我们总是在空种子的情况下执行模糊器的初始运行，并且只有在第二次迭代中才提供初始种子。 但是，我们可以观察到该空种子没有放入我们的种子库中，因此我们永远都无法获得带有“ BB”或“ AA”的种子，因为我们所有的种子大小均为3或4（除了 进行初始空运行）。<br /><br /><h1>部署自定义变异器函数的原因</h1><br /><br />上一节详细介绍了如何编写自定义突变例程，还深入研究了如何将这些例程放置在LibFuzzer的内部工作流程中。 这使我们对LibFuzzer的工作方式有了更好的了解，但是，我们还没有介绍部署自定义突变策略的动机，因此我们将在此进行讨论。<br /><br />通常，自定义突变例程很少见，并不是我们经常做的事情。 但是，至少有两个普遍的原因为什么可以部署给定的自定义模糊测试例程。首先，如果您希望编写自己的突变函数而不是LibFuzzer中实现的那些，或者减少使用的突变函数的数量，则可以自己实现突变函数。其次，如果您要对要变异的数据进行预处理。出于第二个原因，我们认为自定义突变是结构感知的模糊测试的一部分，自然，您可以将自定义变异用作常规测试工作的一部分，而不必出于满足更高抽象结构的种子的目的。<br /><br />在第一个示例的情况下，开发自己的突变函数的原因确实非常普遍。 如果您打算编写自己的变异函数，则最有可能与以下原因有关：<br /><br />1、您希望传递给目标的数据的每个字节都具有特定的结构，例如 所有ASCII字符。<br />2、您有一个新的突变函数的假设，该函数将优于LibFuzzer的突变函数。<br />3、您想要对各种变异函数进行基准分析，以便了解每个变异函数所实现的覆盖范围。<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /></div><div class='page'><h1 class='title level-4'>3_Custom_mutation_strategy1</h1><br/><h1>自定义突变策略1</h1><br /><br />以下实现是模糊器入口点LLVMFuzzerTestOneInput和自定义突变函数LLVMFuzzerCustomMutator的实现。  LLVMFuzzerCustomMutator函数的目标是将每个“ C”符号切换为“ D”符号。 请完成自定义转换器的实现。<br /><br /><a href="http://fuzzer.cc/">fuzzer.cc</a><br /><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdint.h&gt;<br />#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;stdlib.h&gt;<br /><br />#include&nbsp;&lt;iostream&gt;<br /><br />extern&nbsp;&quot;C&quot;&nbsp;int&nbsp;LLVMFuzzerTestOneInput(const&nbsp;uint8_t&nbsp;*Data,&nbsp;size_t&nbsp;Size)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;&quot;seed&nbsp;size&nbsp;&quot;&nbsp;&lt;&lt;&nbsp;Size&nbsp;&lt;&lt;&nbsp;&quot;&nbsp;content:&nbsp;&quot;&nbsp;&lt;&lt;&nbsp;std::endl;<br />&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;Data&nbsp;&lt;&lt;&nbsp;std::endl;<br />&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;&quot;===========+&quot;&nbsp;&lt;&lt;&nbsp;std::endl;<br />&nbsp;&nbsp;return&nbsp;0;<br />}<br /><br />extern&nbsp;&quot;C&quot;&nbsp;size_t&nbsp;LLVMFuzzerCustomMutator(uint8_t&nbsp;*Data,&nbsp;size_t&nbsp;Size,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;MaxSize,&nbsp;unsigned&nbsp;int&nbsp;Seed)&nbsp;<span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;Size;&nbsp;i&nbsp;++)<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(Data[i]&nbsp;==&nbsp;&#39;C&#39;)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Insert&nbsp;code&nbsp;below&nbsp;here<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Insert&nbsp;code&nbsp;above&nbsp;here.&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Size;<br /><span style="color:#000000;font-weight:400">}</span></div></div></div><div class='page'><h1 class='title level-4'>4_Custom_mutation_strategy_2</h1><br/><h1>自定义突变策略2</h1><br /><br />以下实现是模糊器入口点LLVMFuzzerTestOneInput和自定义突变函数LLVMFuzzerCustomMutator的实现。  LLVMFuzzerCustomMutator函数的目标是在种子中选择一个随机索引，并对该字节及其前一个字节执行XoR操作。 请完成自定义转换器的实现。<br /><br /><a href="http://fuzzer.cc/">fuzzer.cc</a><br /><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdint.h&gt;<br />#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;stdlib.h&gt;<br /><br />#include&nbsp;&lt;iostream&gt;<br /><br />extern&nbsp;&quot;C&quot;&nbsp;int&nbsp;LLVMFuzzerTestOneInput(const&nbsp;uint8_t&nbsp;*Data,&nbsp;size_t&nbsp;Size)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;&quot;seed&nbsp;size&nbsp;&quot;&nbsp;&lt;&lt;&nbsp;Size&nbsp;&lt;&lt;&nbsp;&quot;&nbsp;content:&nbsp;&quot;&nbsp;&lt;&lt;&nbsp;std::endl;<br />&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;Data&nbsp;&lt;&lt;&nbsp;std::endl;<br />&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;&quot;===========+&quot;&nbsp;&lt;&lt;&nbsp;std::endl;<br />&nbsp;&nbsp;return&nbsp;0;<br />}<br /><br />extern&nbsp;&quot;C&quot;&nbsp;size_t&nbsp;LLVMFuzzerCustomMutator(uint8_t&nbsp;*Data,&nbsp;size_t&nbsp;Size,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;MaxSize,&nbsp;unsigned&nbsp;int&nbsp;Seed)&nbsp;<span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(Size&nbsp;&lt;&nbsp;3&nbsp;&amp;&amp;&nbsp;MaxSize&nbsp;&gt;&nbsp;5)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Data[0]&nbsp;=&nbsp;Seed&nbsp;%&nbsp;MaxSize;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Data[1]&nbsp;=&nbsp;Seed&nbsp;%&nbsp;(int)(MaxSize/2);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Data[2]&nbsp;=&nbsp;Seed&nbsp;%&nbsp;(int)(MaxSize/3);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;3;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;idx&nbsp;=&nbsp;Seed&nbsp;%&nbsp;(Size-1);<br />&nbsp;&nbsp;&nbsp;&nbsp;idx++;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Insert&nbsp;code&nbsp;below&nbsp;here<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Insert&nbsp;code&nbsp;above&nbsp;here.<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Size;<br /><span style="color:#000000;font-weight:400">}</span></div></div></div><div class='page'><h1 class='title level-4'>5_Custom_mutation_strategy_3</h1><br/><h1>自定义突变策略3</h1><br /><br />以下实现是模糊器入口点LLVMFuzzerTestOneInput和自定义突变函数LLVMFuzzerCustomMutator的实现。  LLVMFuzzerCustomMutator函数的目标是根据LibFuzzer提供的以整数为模的随机整数在缓冲区中选择一个索引，然后在该索引上翻转一位。 请填写以下XXX和YYY位置，以完成更改程序例程。<br /><br /><a href="http://fuzzer.cc/">fuzzer.cc</a><br /><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdint.h&gt;<br />#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;stdlib.h&gt;<br /><br />#include&nbsp;&lt;iostream&gt;<br /><br />extern&nbsp;&quot;C&quot;&nbsp;int&nbsp;LLVMFuzzerTestOneInput(const&nbsp;uint8_t&nbsp;*Data,&nbsp;size_t&nbsp;Size)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;&quot;seed&nbsp;size&nbsp;&quot;&nbsp;&lt;&lt;&nbsp;Size&nbsp;&lt;&lt;&nbsp;&quot;&nbsp;content:&nbsp;&quot;&nbsp;&lt;&lt;&nbsp;std::endl;<br />&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;Data&nbsp;&lt;&lt;&nbsp;std::endl;<br />&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;&quot;===========+&quot;&nbsp;&lt;&lt;&nbsp;std::endl;<br />&nbsp;&nbsp;return&nbsp;0;<br />}<br /><br />extern&nbsp;&quot;C&quot;&nbsp;size_t&nbsp;LLVMFuzzerCustomMutator(uint8_t&nbsp;*Data,&nbsp;size_t&nbsp;Size,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;MaxSize,&nbsp;unsigned&nbsp;int&nbsp;Seed)&nbsp;<span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(Size&nbsp;&lt;&nbsp;3&nbsp;&amp;&amp;&nbsp;MaxSize&nbsp;&gt;&nbsp;5)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Data[0]&nbsp;=&nbsp;Seed&nbsp;%&nbsp;MaxSize;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Data[1]&nbsp;=&nbsp;Seed&nbsp;%&nbsp;(int)(MaxSize/2);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Data[2]&nbsp;=&nbsp;Seed&nbsp;%&nbsp;(int)(MaxSize/3);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;3;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;idx&nbsp;=&nbsp;Seed&nbsp;%&nbsp;419;<br />&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;bitLocation&nbsp;=&nbsp;Rand(8);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Insert&nbsp;code&nbsp;below&nbsp;here<br />&nbsp;&nbsp;&nbsp;&nbsp;Data[XXX]&nbsp;^=&nbsp;YYY<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Insert&nbsp;code&nbsp;above&nbsp;here.<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Size;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /></div><div class='page'><h1 class='title level-3'>3_Stateful_applications_fuzzing</h1><br/></div><div class='page'><h1 class='title level-4'>1_Demonstration of stateful fuzzing _ ADA Logics</h1><br/>此处fuzz哈希表的项目与之前不同的是，之前fuzz的项目中，我们可以针对数据自由进行读写操作（通过引用内存地址等）但是哈希表中，必须使用项目自己实现的api操作数据，为了在此类项目中触发crash，需要以特定顺序使用特定参数调用若干api，这与之前fuzz解析器项目获得crash不相同。<br /><br />该方法被使用到对chrme中实现的协议进行fuzz等复杂项目中，可以在关键软件中找到关键漏洞<br /><br />就本项目的哈希表项目的源码来说，没有一个api适合于直接构造fuzzer，所以需要调用多个api，即fuzz的对象是彼此具有联系的多个api <br /><br />创建项目源码文件和fuzz文件，同时编译fuzz<br /><a href=""><img src="images\965-1.png" alt="images\965-1.png" /></a><br /><br />得到报错<br /><a href=""><img src="images\965-2.png" alt="images\965-2.png" /></a><br /><br />查看crash文件，可以发现，其中并未给出很多有用信息能够用于分析导致问题的根源<br /><a href=""><img src="images\965-3.png" alt="images\965-3.png" /></a><br /><br />重新运行fuzz，触发相同的异常，但是导致异常的crash文件与前一个并不相同，这说明并不是特定输入导致的问题，而是代码逻辑自身导致的问题<br /><a href=""><img src="images\965-4.png" alt="images\965-4.png" /></a><br /><br />结构感知类fuzzing的分析相对困难，原因就在于导致crash的数据与crash发生的原因联系并不紧密，此时分析思路有两种<br />1、更多的手动调试<br />2、源码中插入更多log信息，从而在运行是输出参考信息<br /><br />经过分析是如下两条命令导致的，将两命令前后替换即可<br /><h3>hashIndex %= SIZE; <br />++hashIndex;</h3><br /><br /><br /><br /><br /></div><div class='page'><h1 class='title level-4'>2_Fuzzing_stateful_applications</h1><br/><h1>fuzzing有状态的应用程序</h1><br /><br />在本节中，我们将讨论如何攻击有状态的API。 有状态API的示例包括数据结构和长期服务。从结构感知fuzzer的角度来看，它们的共同点是，我们可以继续在目标代码上调用各种例程，这将在执行代码时改变代码的状态。我们接下来要探索的错误和漏洞是存在于不同代码执行状态中的错误和漏洞，为了使目标代码能够探索这些状态，我们将以伪随机方式简单地在目标代码上调用这些API。  <br /><br /><h2>攻击常见的有状态应用程序：哈希表</h2><br /><br />传统的数据结构实现是有状态代码的一个很好的例子，我们可以对其进行模糊处理，包括列表，集合和哈希表。这些数据结构通常包含简单的API，这些API公开了可以在其上执行的操作，但是这些API通常不会在传统意义被进行fuzzing。但是，这并不会使它们变得不能被fuzzing，我们只需要适应一种更具结构感知的方法即可。<br /><br />考虑下面的哈希映射实现示例：<br /><br /><h3>hashmap.h</h3><br /><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;string.h&gt;<br />#include&nbsp;&lt;stdlib.h&gt;<br />#include&nbsp;&lt;stdbool.h&gt;<br />#include&nbsp;&lt;stdint.h&gt;<br /><br />/*&nbsp;Simple&nbsp;hashmap&nbsp;implementation&nbsp;to&nbsp;illustrate&nbsp;the&nbsp;concept<br />&nbsp;&nbsp;&nbsp;of&nbsp;structure-aware&nbsp;fuzzing&nbsp;targeted&nbsp;stateful&nbsp;applications&nbsp;*/<br /><br />#define&nbsp;SIZE&nbsp;20<br />struct&nbsp;DataItem&nbsp;{<br />&nbsp;&nbsp;&nbsp;int&nbsp;data;<br />&nbsp;&nbsp;&nbsp;int&nbsp;key;<br />};<br /><br />struct&nbsp;DataItem&nbsp;**hashArray&nbsp;=&nbsp;NULL;<br />struct&nbsp;DataItem*&nbsp;dummyItem;<br />struct&nbsp;DataItem*&nbsp;item;<br /><br />int&nbsp;init()&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;hashArray&nbsp;=&nbsp;malloc(sizeof(struct&nbsp;DataItem&nbsp;*)&nbsp;*&nbsp;SIZE);<br />&nbsp;&nbsp;&nbsp;&nbsp;memset(hashArray,&nbsp;&#39;\0&#39;,&nbsp;sizeof(struct&nbsp;DataItem&nbsp;*)&nbsp;*&nbsp;SIZE);<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(hashArray&nbsp;!=&nbsp;NULL)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br />}<br /><br />void&nbsp;clear()&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Clean&nbsp;each&nbsp;of&nbsp;the&nbsp;elements<br />&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;SIZE;&nbsp;i++)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(hashArray[i]);<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Free&nbsp;the&nbsp;array&nbsp;itself<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(hashArray&nbsp;!=&nbsp;NULL)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(hashArray);<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />}<br /><br />int&nbsp;hashCode(int&nbsp;key)&nbsp;{<br />&nbsp;&nbsp;&nbsp;return&nbsp;key&nbsp;%&nbsp;SIZE;<br />}<br /><br />struct&nbsp;DataItem&nbsp;*search(int&nbsp;key)&nbsp;{<br />&nbsp;&nbsp;&nbsp;//get&nbsp;the&nbsp;hash<br />&nbsp;&nbsp;&nbsp;int&nbsp;hashIndex&nbsp;=&nbsp;hashCode(key);<br /><br />&nbsp;&nbsp;&nbsp;//move&nbsp;in&nbsp;array&nbsp;until&nbsp;an&nbsp;empty<br />&nbsp;&nbsp;&nbsp;while(hashArray[hashIndex]&nbsp;!=&nbsp;NULL)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(hashArray[hashIndex]-&gt;key&nbsp;==&nbsp;key)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;hashArray[hashIndex];<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hashIndex&nbsp;%=&nbsp;SIZE;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++hashIndex;<br />&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;return&nbsp;NULL;<br />}<br /><br />void&nbsp;insert(int&nbsp;key,int&nbsp;data)&nbsp;{<br />&nbsp;&nbsp;&nbsp;struct&nbsp;DataItem&nbsp;*item&nbsp;=&nbsp;(struct&nbsp;DataItem*)&nbsp;malloc(sizeof(struct&nbsp;DataItem));<br />&nbsp;&nbsp;&nbsp;item-&gt;data&nbsp;=&nbsp;data;<br />&nbsp;&nbsp;&nbsp;item-&gt;key&nbsp;=&nbsp;key;<br /><br />&nbsp;&nbsp;&nbsp;//get&nbsp;the&nbsp;hash<br />&nbsp;&nbsp;&nbsp;int&nbsp;hashIndex&nbsp;=&nbsp;hashCode(key);<br /><br />&nbsp;&nbsp;&nbsp;//move&nbsp;in&nbsp;array&nbsp;until&nbsp;an&nbsp;empty&nbsp;or&nbsp;deleted&nbsp;cell<br />&nbsp;&nbsp;&nbsp;int&nbsp;rounds&nbsp;=&nbsp;0;<br />&nbsp;&nbsp;&nbsp;while(hashArray[hashIndex]&nbsp;!=&nbsp;NULL&nbsp;&amp;&amp;&nbsp;hashArray[hashIndex]-&gt;key&nbsp;!=&nbsp;-1)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//go&nbsp;to&nbsp;next&nbsp;cell<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++hashIndex;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(hashIndex&nbsp;==&nbsp;SIZE-2)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rounds++;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(rounds&nbsp;&gt;&nbsp;2)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(item);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//wrap&nbsp;around&nbsp;the&nbsp;table<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hashIndex&nbsp;%=&nbsp;SIZE;<br />&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;hashArray[hashIndex]&nbsp;=&nbsp;item;<br />}<br /><br />struct&nbsp;DataItem*&nbsp;delete(struct&nbsp;DataItem*&nbsp;item)&nbsp;<span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;int&nbsp;key&nbsp;=&nbsp;item-&gt;key;<br /><br />&nbsp;&nbsp;&nbsp;//get&nbsp;the&nbsp;hash<br />&nbsp;&nbsp;&nbsp;int&nbsp;hashIndex&nbsp;=&nbsp;hashCode(key);<br /><br />&nbsp;&nbsp;&nbsp;//move&nbsp;in&nbsp;array&nbsp;until&nbsp;an&nbsp;empty<br />&nbsp;&nbsp;&nbsp;int&nbsp;rounds&nbsp;=&nbsp;0;<br />&nbsp;&nbsp;&nbsp;while(hashArray[hashIndex]&nbsp;!=&nbsp;NULL)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(hashArray[hashIndex]-&gt;key&nbsp;==&nbsp;key)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;DataItem*&nbsp;temp&nbsp;=&nbsp;hashArray[hashIndex];<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//assign&nbsp;a&nbsp;dummy&nbsp;item&nbsp;at&nbsp;deleted&nbsp;position<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hashArray[hashIndex]&nbsp;=&nbsp;dummyItem;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;temp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(hashIndex&nbsp;==&nbsp;SIZE-1)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rounds++;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(rounds&nbsp;&gt;&nbsp;2)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++hashIndex;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hashIndex&nbsp;%=&nbsp;SIZE;<br />&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;return&nbsp;NULL;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />总共有三个API函数：<br />• <code>search</code><br />• <code>insert</code><br />• <code>delete</code><br /><br />这些函数本身都不容易模糊，并且每个函数中都没有大量的输入处理。但是，数据结构在某种意义上说是有状态的，因为它在程序中使用时通常会生存更长的时间，哈希表的状态会根据搜索，插入和删除的调用方式而改变数据结构。这样，对于哈希表的实现实例，实例的状态将基于调用它的API进行更改，并且哈希图的给定状态可能会引入错误或漏洞。<br /><br />哈希图的状态取决于哈希图上API调用的顺序以及提供给每个API调用的参数。因此，从模糊测试的角度来看，我们希望对哈希表的不同状态进行模糊测试，并且要做到这一点的方法是创建一个模糊器，该模糊器使用基于模糊器提供的伪随机数据调用哈希表搜索，插入和删除的功能。具体来说，我们要创建一个模糊器函数，该函数对给定的哈希图执行一系列调用，这些调用的序列必须取决于提供给模糊器函数的伪随机数据。<br /><br />下面的模糊器实现提供了一个示例：<br /><br /><h3>fuzz_hashmap.c</h3><br /><br /><div class="codebox"><div class="codebox">#include&nbsp;&quot;hashmap.h&quot;<br /><br />int&nbsp;LLVMFuzzerTestOneInput(const&nbsp;uint8_t&nbsp;*data,&nbsp;size_t&nbsp;size)<span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Initialise&nbsp;the&nbsp;hashmap<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(init()&nbsp;!=&nbsp;1)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Now&nbsp;call&nbsp;the&nbsp;APIs&nbsp;of&nbsp;the&nbsp;hashmap&nbsp;in&nbsp;a&nbsp;diverse&nbsp;sequence.<br />&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;size;&nbsp;i++)<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;((data[i]&nbsp;%&nbsp;3)&nbsp;==&nbsp;0)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;search(data[i]);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;((data[i]&nbsp;%&nbsp;3)&nbsp;==&nbsp;1)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;insert(data[i],&nbsp;data[i]);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;DataItem&nbsp;di;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;di.key&nbsp;=&nbsp;data[i];<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;DataItem*&nbsp;tmp&nbsp;=&nbsp;delete(&amp;di);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(tmp&nbsp;!=&nbsp;NULL)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(tmp);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Cleanup&nbsp;the&nbsp;hashmap<br />&nbsp;&nbsp;&nbsp;&nbsp;clear();<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />以上fuzzer的关键在于，哈希表对象的状态正确与否取决于两个方面<br />1、哈希表对象api的调用顺序<br />2、哈希表对象api调用时使用的参数<br />以上fuzzer通过使用libfuzzer提供的随机数据，将以上两个方面的因素均进行了随机化，从而进行fuzz<br /><br />模糊器的关键思想是使用伪随机数据中的每个字节作为API调用的触发器。这是通过依次浏览从第一个字节到最后一个字节的数据，然后根据给定的字节确定要调用的API的方式与哈希图的API调用次数，（本例中通过对3进行取模运算来实现）在这种情况下，如果随机字节%3运算分别为0,1和2，则模糊器将调用search，insert和delete。<br /><br />模糊器通过调用init（）哈希函数在每次模糊迭代的开始时初始化一个新的哈希图，然后在每次模糊迭代的末尾通过调用clear（）清理哈希图实例。<br /><br />为了测试该模糊器，我们可以将hashmap.h和fuzz_hashmap.c放在同一文件夹中，然后按以下方式编译该模糊器：<br /><br /><h3>clang -g -fsanitize=address,fuzzer fuzz_hashmap.c -o fuzz_hashmap</h3><br /><br />运行模糊器会为我们提供类似于以下内容的输出<br /><br />现在，对于结构感知的模糊测试，通常比针对专注于攻击解析器例程的模糊测试更难进行根本原因分析。这是因为在解析器例程中，触发给定崩溃的种子通常本身具有含义。 例如，如果我们对json解析器进行模糊处理，则种子本身很可能具有json数据的形状或与之非常相似。但是，在结构感知的模糊测试中，对种子没有如此清晰的解释。<br /><br />通常，以两种方式处理对结构感知的模糊进行根本原因分析的复杂性：要么在检查堆栈跟踪时进行更多的人工工作，要么在模糊器/目标代码中插入大量日志，以使其更易于理解目标的特定行为会迫使其发生错误。<h3> </h3>自然地，两者的结合通常是最有效的方法，并且还有许多其他方法可以进行根本原因分析，例如通过调试器。<br /><br />在上述情况下，我们的哈希表的实现足够小，可以自己进行根本原因分析。 我们知道该错误发生在与该行相对应的第49行。<br /><br />发生堆溢出读取的行<br /><h3> </h3><h3>while</h3><h3>(hashArray[hashIndex] != </h3><h3>NULL</h3><h3>) {</h3><br /> <br />如果我们进一步深入该函数，则会发现以下两行：<br />在数组边界上方排列增加索引<br /><h3>hashIndex %= SIZE;     <br />++hashIndex;</h3><br /><br />上面的两行代码将用于访问hashArray的索引加1。 但是，由于hashIndex％= SIZE，会出现问题，该行用于确保索引永远不会超出数组的范围，但自++hashIndex; 行之后，数组索引可以比数组的边界高一，当调用while（hashArray [hashIndex]！= NULL）时，我们突然受到一次读取访问的限制。<br /><br />例如代码中SIZE=20，当hashIndex为19时，执行hashIndex %= SIZE;  则hashIndex仍为19，<br />之后++hashIndex导致hashIndex值为20，从而导致溢出<br /><br />我们可以通过切换行来解决此错误，使它们变为：<br /><br /><h3>++hashIndex;     <br />hashIndex %= SIZE;</h3><br /><br />然后再次运行模糊器，我们得到输出：<br /><br /><div class="codebox"><div class="codebox">./fuzz_hashmap<br />INFO:&nbsp;Seed:&nbsp;2305105602<br />INFO:&nbsp;Loaded&nbsp;1&nbsp;modules&nbsp;&nbsp;&nbsp;(37&nbsp;inline&nbsp;8-bit&nbsp;counters):&nbsp;37&nbsp;[0x567ef0,&nbsp;0x567f15),<br />INFO:&nbsp;Loaded&nbsp;1&nbsp;PC&nbsp;tables&nbsp;(37&nbsp;PCs):&nbsp;37&nbsp;[0x543a00,0x543c50),<br />INFO:&nbsp;-max_len&nbsp;is&nbsp;not&nbsp;provided;&nbsp;libFuzzer&nbsp;will&nbsp;not&nbsp;generate&nbsp;inputs&nbsp;larger&nbsp;than&nbsp;4096&nbsp;bytes<br />INFO:&nbsp;A&nbsp;corpus&nbsp;is&nbsp;not&nbsp;provided,&nbsp;starting&nbsp;from&nbsp;an&nbsp;empty&nbsp;corpus<br />#2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;INITED&nbsp;cov:&nbsp;14&nbsp;ft:&nbsp;15&nbsp;corp:&nbsp;1/1b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;27Mb<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW_FUNC[1/1]:&nbsp;0x526260&nbsp;in&nbsp;search&nbsp;/work/./hashmap.h:44<br />#5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;17&nbsp;ft:&nbsp;20&nbsp;corp:&nbsp;2/3b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;28Mb&nbsp;L:&nbsp;2/2&nbsp;MS:&nbsp;3&nbsp;CopyPart-ChangeBinInt-InsertByte-<br />#7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;17&nbsp;ft:&nbsp;23&nbsp;corp:&nbsp;3/5b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;28Mb&nbsp;L:&nbsp;2/2&nbsp;MS:&nbsp;2&nbsp;ShuffleBytes-ChangeByte-<br />#8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;17&nbsp;ft:&nbsp;28&nbsp;corp:&nbsp;4/9b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;28Mb&nbsp;L:&nbsp;4/4&nbsp;MS:&nbsp;1&nbsp;CrossOver-<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW_FUNC[1/1]:&nbsp;0x526850&nbsp;in&nbsp;delete&nbsp;/work/./hashmap.h:86<br />#13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;20&nbsp;ft:&nbsp;33&nbsp;corp:&nbsp;5/12b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;28Mb&nbsp;L:&nbsp;3/4&nbsp;MS:&nbsp;5&nbsp;ChangeBinInt-CopyPart-EraseBytes-InsertByte-InsertByte-<br />#14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;20&nbsp;ft:&nbsp;36&nbsp;corp:&nbsp;6/16b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;28Mb&nbsp;L:&nbsp;4/4&nbsp;MS:&nbsp;1&nbsp;CrossOver-<br />#17&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;21&nbsp;ft:&nbsp;37&nbsp;corp:&nbsp;7/20b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;28Mb&nbsp;L:&nbsp;4/4&nbsp;MS:&nbsp;3&nbsp;ChangeByte-ChangeBinInt-ChangeByte-<br />#26&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;21&nbsp;ft:&nbsp;40&nbsp;corp:&nbsp;8/22b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;28Mb&nbsp;L:&nbsp;2/4&nbsp;MS:&nbsp;4&nbsp;CopyPart-CrossOver-ChangeByte-ChangeBit-<br />#43&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;24&nbsp;ft:&nbsp;48&nbsp;corp:&nbsp;9/25b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;28Mb&nbsp;L:&nbsp;3/4&nbsp;MS:&nbsp;2&nbsp;InsertByte-ChangeBit-<br />#80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;24&nbsp;ft:&nbsp;56&nbsp;corp:&nbsp;10/28b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;28Mb&nbsp;L:&nbsp;3/4&nbsp;MS:&nbsp;2&nbsp;ChangeByte-ChangeByte-<br />#87&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;24&nbsp;ft:&nbsp;61&nbsp;corp:&nbsp;11/32b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;28Mb&nbsp;L:&nbsp;4/4&nbsp;MS:&nbsp;2&nbsp;ShuffleBytes-InsertByte-<br />#91&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;26&nbsp;ft:&nbsp;63&nbsp;corp:&nbsp;12/36b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;28Mb&nbsp;L:&nbsp;4/4&nbsp;MS:&nbsp;4&nbsp;ChangeByte-InsertByte-ChangeBit-ChangeBit-<br />#94&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;26&nbsp;ft:&nbsp;66&nbsp;corp:&nbsp;13/40b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;28Mb&nbsp;L:&nbsp;4/4&nbsp;MS:&nbsp;3&nbsp;EraseBytes-CrossOver-CopyPart-<br />#98&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;26&nbsp;ft:&nbsp;67&nbsp;corp:&nbsp;14/44b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;28Mb&nbsp;L:&nbsp;4/4&nbsp;MS:&nbsp;4&nbsp;CopyPart-ChangeBit-CrossOver-CopyPart-<br />#105&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;26&nbsp;ft:&nbsp;70&nbsp;corp:&nbsp;15/48b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;28Mb&nbsp;L:&nbsp;4/4&nbsp;MS:&nbsp;2&nbsp;ShuffleBytes-ChangeBinInt-<br />#106&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;26&nbsp;ft:&nbsp;73&nbsp;corp:&nbsp;16/52b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;28Mb&nbsp;L:&nbsp;4/4&nbsp;MS:&nbsp;1&nbsp;CopyPart-<br />#122&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;26&nbsp;ft:&nbsp;73&nbsp;corp:&nbsp;16/51b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;28Mb&nbsp;L:&nbsp;3/4&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#126&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;26&nbsp;ft:&nbsp;76&nbsp;corp:&nbsp;17/54b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;28Mb&nbsp;L:&nbsp;3/4&nbsp;MS:&nbsp;4&nbsp;CrossOver-EraseBytes-ChangeBit-ChangeByte-<br />#267&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;26&nbsp;ft:&nbsp;76&nbsp;corp:&nbsp;17/52b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;28Mb&nbsp;L:&nbsp;2/4&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#374&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;26&nbsp;ft:&nbsp;76&nbsp;corp:&nbsp;17/50b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;28Mb&nbsp;L:&nbsp;2/4&nbsp;MS:&nbsp;2&nbsp;ChangeBinInt-EraseBytes-<br />#412&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;26&nbsp;ft:&nbsp;78&nbsp;corp:&nbsp;18/54b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;28Mb&nbsp;L:&nbsp;4/4&nbsp;MS:&nbsp;3&nbsp;InsertByte-ChangeBit-ChangeByte-<br />#474&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;26&nbsp;ft:&nbsp;79&nbsp;corp:&nbsp;19/58b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;28Mb&nbsp;L:&nbsp;4/4&nbsp;MS:&nbsp;2&nbsp;ShuffleBytes-CopyPart-<br />#647&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;27&nbsp;ft:&nbsp;80&nbsp;corp:&nbsp;20/62b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;28Mb&nbsp;L:&nbsp;4/4&nbsp;MS:&nbsp;3&nbsp;ChangeByte-ChangeByte-CopyPart-<br />#716&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;27&nbsp;ft:&nbsp;82&nbsp;corp:&nbsp;21/66b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;28Mb&nbsp;L:&nbsp;4/4&nbsp;MS:&nbsp;4&nbsp;ShuffleBytes-ShuffleBytes-CrossOver-CopyPart-<br />#817&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;27&nbsp;ft:&nbsp;83&nbsp;corp:&nbsp;22/70b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;28Mb&nbsp;L:&nbsp;4/4&nbsp;MS:&nbsp;1&nbsp;CopyPart-<br />#829&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;27&nbsp;ft:&nbsp;84&nbsp;corp:&nbsp;23/74b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;28Mb&nbsp;L:&nbsp;4/4&nbsp;MS:&nbsp;2&nbsp;CopyPart-CopyPart-<br />#1115&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;27&nbsp;ft:&nbsp;85&nbsp;corp:&nbsp;24/79b&nbsp;lim:&nbsp;6&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;28Mb&nbsp;L:&nbsp;5/5&nbsp;MS:&nbsp;1&nbsp;CopyPart-<br />#1325&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;27&nbsp;ft:&nbsp;87&nbsp;corp:&nbsp;25/87b&nbsp;lim:&nbsp;8&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;29Mb&nbsp;L:&nbsp;8/8&nbsp;MS:&nbsp;5&nbsp;CrossOver-InsertByte-CopyPart-CrossOver-CrossOver-<br />#1369&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;27&nbsp;ft:&nbsp;90&nbsp;corp:&nbsp;26/94b&nbsp;lim:&nbsp;8&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;29Mb&nbsp;L:&nbsp;7/8&nbsp;MS:&nbsp;4&nbsp;InsertByte-ChangeBinInt-InsertByte-CopyPart-<br />#1401&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;27&nbsp;ft:&nbsp;91&nbsp;corp:&nbsp;27/102b&nbsp;lim:&nbsp;8&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;29Mb&nbsp;L:&nbsp;8/8&nbsp;MS:&nbsp;2&nbsp;CopyPart-CopyPart-<br />#1402&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;27&nbsp;ft:&nbsp;94&nbsp;corp:&nbsp;28/110b&nbsp;lim:&nbsp;8&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;29Mb&nbsp;L:&nbsp;8/8&nbsp;MS:&nbsp;1&nbsp;CopyPart-<br />#1428&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;27&nbsp;ft:&nbsp;94&nbsp;corp:&nbsp;28/109b&nbsp;lim:&nbsp;8&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;29Mb&nbsp;L:&nbsp;3/8&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#1495&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;27&nbsp;ft:&nbsp;96&nbsp;corp:&nbsp;29/114b&nbsp;lim:&nbsp;8&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;29Mb&nbsp;L:&nbsp;5/8&nbsp;MS:&nbsp;2&nbsp;InsertByte-CopyPart-<br />#1601&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;27&nbsp;ft:&nbsp;96&nbsp;corp:&nbsp;29/113b&nbsp;lim:&nbsp;8&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;29Mb&nbsp;L:&nbsp;4/8&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#1671&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;27&nbsp;ft:&nbsp;101&nbsp;corp:&nbsp;30/121b&nbsp;lim:&nbsp;8&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;29Mb&nbsp;L:&nbsp;8/8&nbsp;MS:&nbsp;5&nbsp;EraseBytes-ShuffleBytes-ChangeBit-ChangeASCIIInt-CrossOver-<br />#1777&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;27&nbsp;ft:&nbsp;102&nbsp;corp:&nbsp;31/127b&nbsp;lim:&nbsp;8&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;29Mb&nbsp;L:&nbsp;6/8&nbsp;MS:&nbsp;1&nbsp;CopyPart-<br />#1812&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;27&nbsp;ft:&nbsp;104&nbsp;corp:&nbsp;32/135b&nbsp;lim:&nbsp;8&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;29Mb&nbsp;L:&nbsp;8/8&nbsp;MS:&nbsp;5&nbsp;ChangeBinInt-CopyPart-EraseBytes-ShuffleBytes-CrossOver-<br />#2075&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;27&nbsp;ft:&nbsp;104&nbsp;corp:&nbsp;32/134b&nbsp;lim:&nbsp;8&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;29Mb&nbsp;L:&nbsp;3/8&nbsp;MS:&nbsp;3&nbsp;ShuffleBytes-ChangeBit-EraseBytes-<br />#2131&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;27&nbsp;ft:&nbsp;104&nbsp;corp:&nbsp;32/133b&nbsp;lim:&nbsp;8&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;29Mb&nbsp;L:&nbsp;5/8&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#2440&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;27&nbsp;ft:&nbsp;107&nbsp;corp:&nbsp;33/144b&nbsp;lim:&nbsp;11&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;29Mb&nbsp;L:&nbsp;11/11&nbsp;MS:&nbsp;4&nbsp;CrossOver-ChangeBit-CopyPart-CMP-&nbsp;DE:&nbsp;&quot;\xff\xff\xff\xff\xff\xff\xff\xff&quot;-<br />#2642&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;27&nbsp;ft:&nbsp;109&nbsp;corp:&nbsp;34/155b&nbsp;lim:&nbsp;11&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;29Mb&nbsp;L:&nbsp;11/11&nbsp;MS:&nbsp;2&nbsp;CopyPart-InsertRepeatedBytes-<br />#2830&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;27&nbsp;ft:&nbsp;110&nbsp;corp:&nbsp;35/165b&nbsp;lim:&nbsp;11&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;29Mb&nbsp;L:&nbsp;10/11&nbsp;MS:&nbsp;3&nbsp;CrossOver-ChangeBit-CopyPart-<br />#2841&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;27&nbsp;ft:&nbsp;110&nbsp;corp:&nbsp;35/164b&nbsp;lim:&nbsp;11&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;29Mb&nbsp;L:&nbsp;10/11&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#2847&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;27&nbsp;ft:&nbsp;113&nbsp;corp:&nbsp;36/175b&nbsp;lim:&nbsp;11&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;29Mb&nbsp;L:&nbsp;11/11&nbsp;MS:&nbsp;1&nbsp;CopyPart-<br />#2948&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;27&nbsp;ft:&nbsp;113&nbsp;corp:&nbsp;36/174b&nbsp;lim:&nbsp;11&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;30Mb&nbsp;L:&nbsp;7/11&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#3097&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;28&nbsp;ft:&nbsp;114&nbsp;corp:&nbsp;37/185b&nbsp;lim:&nbsp;11&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;30Mb&nbsp;L:&nbsp;11/11&nbsp;MS:&nbsp;4&nbsp;CopyPart-PersAutoDict-ChangeBit-CrossOver-&nbsp;DE:&nbsp;&quot;\xff\xff\xff\xff\xff\xff\xff\xff&quot;-<br />#3621&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;28&nbsp;ft:&nbsp;117&nbsp;corp:&nbsp;38/198b&nbsp;lim:&nbsp;14&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;30Mb&nbsp;L:&nbsp;13/13&nbsp;MS:&nbsp;4&nbsp;ShuffleBytes-EraseBytes-CopyPart-ChangeASCIIInt-<br />#3768&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;28&nbsp;ft:&nbsp;117&nbsp;corp:&nbsp;38/197b&nbsp;lim:&nbsp;14&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;30Mb&nbsp;L:&nbsp;6/13&nbsp;MS:&nbsp;2&nbsp;InsertByte-EraseBytes-<br />#3774&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;28&nbsp;ft:&nbsp;118&nbsp;corp:&nbsp;39/207b&nbsp;lim:&nbsp;14&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;30Mb&nbsp;L:&nbsp;10/13&nbsp;MS:&nbsp;1&nbsp;CopyPart-<br />#3842&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;28&nbsp;ft:&nbsp;120&nbsp;corp:&nbsp;40/220b&nbsp;lim:&nbsp;14&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;30Mb&nbsp;L:&nbsp;13/13&nbsp;MS:&nbsp;3&nbsp;ShuffleBytes-ChangeBinInt-CopyPart-<br />#3868&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;28&nbsp;ft:&nbsp;120&nbsp;corp:&nbsp;40/218b&nbsp;lim:&nbsp;14&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;30Mb&nbsp;L:&nbsp;9/13&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#3957&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;28&nbsp;ft:&nbsp;120&nbsp;corp:&nbsp;40/217b&nbsp;lim:&nbsp;14&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;30Mb&nbsp;L:&nbsp;9/13&nbsp;MS:&nbsp;4&nbsp;ChangeBit-PersAutoDict-InsertRepeatedBytes-CrossOver-&nbsp;DE:&nbsp;&quot;\xff\xff\xff\xff\xff\xff\xff\xff&quot;-<br />#4073&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;28&nbsp;ft:&nbsp;120&nbsp;corp:&nbsp;40/216b&nbsp;lim:&nbsp;14&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;30Mb&nbsp;L:&nbsp;10/13&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#4399&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;28&nbsp;ft:&nbsp;122&nbsp;corp:&nbsp;41/233b&nbsp;lim:&nbsp;17&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;30Mb&nbsp;L:&nbsp;17/17&nbsp;MS:&nbsp;1&nbsp;CrossOver-<br />#4475&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;28&nbsp;ft:&nbsp;122&nbsp;corp:&nbsp;41/232b&nbsp;lim:&nbsp;17&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;30Mb&nbsp;L:&nbsp;3/17&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#4502&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;28&nbsp;ft:&nbsp;125&nbsp;corp:&nbsp;42/249b&nbsp;lim:&nbsp;17&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;30Mb&nbsp;L:&nbsp;17/17&nbsp;MS:&nbsp;2&nbsp;InsertRepeatedBytes-PersAutoDict-&nbsp;DE:&nbsp;&quot;\xff\xff\xff\xff\xff\xff\xff\xff&quot;-<br />#4547&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;28&nbsp;ft:&nbsp;126&nbsp;corp:&nbsp;43/266b&nbsp;lim:&nbsp;17&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;30Mb&nbsp;L:&nbsp;17/17&nbsp;MS:&nbsp;5&nbsp;InsertRepeatedBytes-ShuffleBytes-CrossOver-ChangeASCIIInt-ChangeASCIIInt-<br />#4818&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;28&nbsp;ft:&nbsp;131&nbsp;corp:&nbsp;44/282b&nbsp;lim:&nbsp;17&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;30Mb&nbsp;L:&nbsp;16/17&nbsp;MS:&nbsp;1&nbsp;CopyPart-<br />#5163&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;28&nbsp;ft:&nbsp;131&nbsp;corp:&nbsp;44/281b&nbsp;lim:&nbsp;17&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;31Mb&nbsp;L:&nbsp;16/17&nbsp;MS:&nbsp;5&nbsp;ShuffleBytes-EraseBytes-ChangeByte-CopyPart-InsertRepeatedBytes-<br />#5189&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;28&nbsp;ft:&nbsp;134&nbsp;corp:&nbsp;45/298b&nbsp;lim:&nbsp;17&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;31Mb&nbsp;L:&nbsp;17/17&nbsp;MS:&nbsp;1&nbsp;CopyPart-<br />#5327&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;28&nbsp;ft:&nbsp;135&nbsp;corp:&nbsp;46/315b&nbsp;lim:&nbsp;17&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;31Mb&nbsp;L:&nbsp;17/17&nbsp;MS:&nbsp;3&nbsp;ShuffleBytes-InsertByte-InsertRepeatedBytes-<br />#5358&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;28&nbsp;ft:&nbsp;135&nbsp;corp:&nbsp;46/314b&nbsp;lim:&nbsp;17&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;31Mb&nbsp;L:&nbsp;9/17&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#5400&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;28&nbsp;ft:&nbsp;135&nbsp;corp:&nbsp;46/312b&nbsp;lim:&nbsp;17&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;31Mb&nbsp;L:&nbsp;11/17&nbsp;MS:&nbsp;2&nbsp;CopyPart-EraseBytes-<br />#5482&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;28&nbsp;ft:&nbsp;135&nbsp;corp:&nbsp;46/311b&nbsp;lim:&nbsp;17&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;31Mb&nbsp;L:&nbsp;5/17&nbsp;MS:&nbsp;2&nbsp;ShuffleBytes-EraseBytes-<br />#5641&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;28&nbsp;ft:&nbsp;135&nbsp;corp:&nbsp;46/310b&nbsp;lim:&nbsp;17&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;31Mb&nbsp;L:&nbsp;9/17&nbsp;MS:&nbsp;4&nbsp;CopyPart-InsertByte-ChangeBinInt-EraseBytes-<br />#6292&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;28&nbsp;ft:&nbsp;138&nbsp;corp:&nbsp;47/330b&nbsp;lim:&nbsp;21&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;31Mb&nbsp;L:&nbsp;20/20&nbsp;MS:&nbsp;1&nbsp;InsertRepeatedBytes-<br />#6314&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;30&nbsp;ft:&nbsp;141&nbsp;corp:&nbsp;48/351b&nbsp;lim:&nbsp;21&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;31Mb&nbsp;L:&nbsp;21/21&nbsp;MS:&nbsp;2&nbsp;EraseBytes-InsertRepeatedBytes-<br />#6465&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;30&nbsp;ft:&nbsp;142&nbsp;corp:&nbsp;49/372b&nbsp;lim:&nbsp;21&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;31Mb&nbsp;L:&nbsp;21/21&nbsp;MS:&nbsp;1&nbsp;CopyPart-<br />#6531&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;30&nbsp;ft:&nbsp;143&nbsp;corp:&nbsp;50/393b&nbsp;lim:&nbsp;21&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;32Mb&nbsp;L:&nbsp;21/21&nbsp;MS:&nbsp;1&nbsp;CrossOver-<br />#7029&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;30&nbsp;ft:&nbsp;143&nbsp;corp:&nbsp;50/391b&nbsp;lim:&nbsp;25&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;32Mb&nbsp;L:&nbsp;18/21&nbsp;MS:&nbsp;3&nbsp;CopyPart-InsertByte-EraseBytes-<br />#7046&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;31&nbsp;ft:&nbsp;144&nbsp;corp:&nbsp;51/416b&nbsp;lim:&nbsp;25&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;32Mb&nbsp;L:&nbsp;25/25&nbsp;MS:&nbsp;2&nbsp;ChangeASCIIInt-CrossOver-<br />#7077&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;31&nbsp;ft:&nbsp;148&nbsp;corp:&nbsp;52/440b&nbsp;lim:&nbsp;25&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;32Mb&nbsp;L:&nbsp;24/25&nbsp;MS:&nbsp;1&nbsp;InsertRepeatedBytes-<br />#7124&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;31&nbsp;ft:&nbsp;151&nbsp;corp:&nbsp;53/465b&nbsp;lim:&nbsp;25&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;32Mb&nbsp;L:&nbsp;25/25&nbsp;MS:&nbsp;2&nbsp;ChangeBit-CrossOver-<br />^C==29==&nbsp;libFuzzer:&nbsp;run&nbsp;interrupted;&nbsp;exiting<br /></div></div><br /><br /><br /><br /></div><div class='page'><h1 class='title level-3'>4_Libprotobuf-mutator</h1><br/></div><div class='page'><h1 class='title level-4'>1_Demonstration of Libprotobuf-mutator _ ADA Logics</h1><br/>protobuf:使用流程：定义.proto文件定义数据结构-》将.proto文件转为.cc文件，后者中以c++类形式实现了.proto数据结构-》将.cc文件编译为.o文件-》链接过程中链接.o文件，使用其中数据结构<br /><br />libprotobuf-mutator：<a href="https://github.com/google/libprotobuf-mutator">https://github.com/google/libprotobuf-mutator</a><br /><br />通过 libprotobuf-mutator可以实现定义指定数据结构，并且将该数据结构转为c++对象，并使用随机数据创建该对象实例，从而实现fuzzz<br /><br /><h1>docker中安装libprotobuf-mutator</h1><br /><a href=""><img src="images\968-1.png" alt="images\968-1.png" /></a><br /><br /><a href=""><img src="images\968-2.png" alt="images\968-2.png" /></a><br /><br /><a href=""><img src="images\968-3.png" alt="images\968-3.png" /></a><br /><br /><a href=""><img src="images\968-4.png" alt="images\968-4.png" /></a><br /><br /><a href=""><img src="images\968-5.png" alt="images\968-5.png" /></a><br /><br /><a href=""><img src="images\968-6.png" alt="images\968-6.png" /></a><br /><br /><a href=""><img src="images\968-7.png" alt="images\968-7.png" /></a><br /><br /><a href=""><img src="images\968-8.png" alt="images\968-8.png" /></a><br /><br />生成libproto的中间文件<br /><a href=""><img src="images\968-9.png" alt="images\968-9.png" /></a><br /><br />生成fuzzer的中间文件<br /><a href=""><img src="images\968-10.png" alt="images\968-10.png" /></a><br /><br />将fuzzer的中间文件以及libproto的中间文件链接起来<br /><a href=""><img src="images\968-11.png" alt="images\968-11.png" /></a><br /><br />运行fuzzer<br /><a href=""><img src="images\968-12.png" alt="images\968-12.png" /></a><br /><br /><h1>简单示例使用protobuf</h1><br /><a href=""><img src="images\968-13.png" alt="images\968-13.png" /></a><br /><br />创建自己的proto文件，并编译为cc文件<br /><a href=""><img src="images\968-14.png" alt="images\968-14.png" /></a><br /><a href=""><img src="images\968-15.png" alt="images\968-15.png" /></a><br /><br />编译proto文件，生成.o文件<br /><a href=""><img src="images\968-16.png" alt="images\968-16.png" /></a><br /><br />创建fuzzer的源码文件，注意此时fuzzer的入口点为<br />DEFINE_PROTO_FUZZER宏<br /><a href=""><img src="images\968-17.png" alt="images\968-17.png" /></a><br /><br />更简单的fuzzer版本<br /><a href=""><img src="images\968-18.png" alt="images\968-18.png" /></a><br /><br />编译并链接fuzzer<br /><a href=""><img src="images\968-19.png" alt="images\968-19.png" /></a><br /><br />运行fuzzer<br />根据调用栈发现<br />DEFINE_PROTO_FUZZER宏 实际函数名称为 TestOneProtoInput，该函数实际被LLVMFuzzerTestOneInput函数调用<br />除此还可以在输出中看到导致crash的数据对象<br /><a href=""><img src="images\968-20.png" alt="images\968-20.png" /></a><br /><br />可以修改fuzzer，从而使fuzzer更容易命中abort<br /><a href=""><img src="images\968-21.png" alt="images\968-21.png" /></a><br /><br />重新运行fuzzer，得到导致crash的数据对象<br /><a href=""><img src="images\968-22.png" alt="images\968-22.png" /></a><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /></div><div class='page'><h1 class='title level-4'>2_Libprotobuf-mutator</h1><br/><h1>Libprotobuf-mutator</h1><br /><br />在本节中，我们将讨论如何对Protobuf中定义的类型进行模糊处理（通过libprotobuf-mutator的方式。）<br />libprotobuf-mutator：<a href="https://github.com/google/libprotobuf-mutator">https://github.com/google/libprotobuf-mutator</a><br />从高级的角度来看，libprotobuf-mutator解决的问题是将来自模糊器的随机数据自动转换为结构化的CPP类对象。更具体地说，CPP类结构由libprotobuf规范定义。具体来说，给定一个protobuf规范，我们可以使用libprotobuf-mutator连续使用模糊器提供的数据创建给定类型的对象。这样，我们的模糊器的函数签名现在将接受指向特定protobuf类型对象的指针，而不是通常的uint8_t * data，size_t size 参数。这样，libprotobuf-mutator就位于我们作为模糊器编写器编写的代码与核心Libfuzzer引擎之间。<br /><br /><h2>构建libprotobuf-mutator并从libprotobuf-mutator运行示例</h2><br /><br />我们要做的第一步是构建libprotobuf-mutator并从项目本身运行示例。 我们不会详细看代码，而是简要浏览一下代码，然后转到我们自己的示例。<br /><br />在我们的Docker映像中执行以下步骤。 首先更新软件包<br /><br /><div class="codebox"><div class="codebox">#&nbsp;Update&nbsp;the&nbsp;settings<br />apt-get&nbsp;update<br />apt-get&nbsp;install&nbsp;protobuf-compiler&nbsp;libprotobuf-dev&nbsp;binutils&nbsp;cmake&nbsp;\<br />&nbsp;&nbsp;ninja-build&nbsp;liblzma-dev&nbsp;libz-dev&nbsp;pkg-config&nbsp;autoconf&nbsp;libtool&nbsp;-y</div></div><br /><br />现在创建一个工作目录，我们将在其中放置libprotobuf-mutator的源代码：<br /><div class="codebox"><div class="codebox">cd&nbsp;/work&nbsp;&amp;&amp;&nbsp;mkdir&nbsp;libprotobuf-mutator&nbsp;&amp;&amp;&nbsp;cd&nbsp;libprotobuf-mutator<br /><br />#&nbsp;Clone&nbsp;lib-protobufmutator<br />git&nbsp;clone&nbsp;https://github.com/google/libprotobuf-mutator<br />cd&nbsp;libprotobuf-mutator<br /></div></div><br /><br />现在，我们有了libprotobuf-mutator的源代码，因此下一步就是构建源代码：<br /><div class="codebox"><div class="codebox">#&nbsp;Build&nbsp;the&nbsp;libprotobuf&nbsp;stuff<br />mkdir&nbsp;build<br />cd&nbsp;build<br />cmake&nbsp;..&nbsp;-GNinja&nbsp;-DCMAKE_C_COMPILER=clang&nbsp;-DCMAKE_CXX_COMPILER=clang++&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;-DCMAKE_BUILD_TYPE=Debug&nbsp;-DLIB_PROTO_MUTATOR_DOWNLOAD_PROTOBUF=ON<br />ninja<br /></div></div><br /><br />现在导航到示例文件夹：<br /><div class="codebox"><div class="codebox">#&nbsp;Now&nbsp;build&nbsp;the&nbsp;the&nbsp;libfuzzer&nbsp;example<br />cd&nbsp;../examples/libfuzzer/</div></div><br /><br />下一步是将.proto文件编译到CPP代码中：<br />该步骤即根据.proto文件（libfuzzer_example.proto）生成对应c++文件（libfuzzer_example.pb.cc）<br /><div class="codebox"><div class="codebox">#&nbsp;Create&nbsp;the&nbsp;protobuf&nbsp;source&nbsp;code<br />mkdir&nbsp;cpp_build<br />/work/libprotobuf-mutator/libprotobuf-mutator/build/external.protobuf/bin/protoc&nbsp;\<br />&nbsp;&nbsp;--cpp_out&nbsp;.&nbsp;libfuzzer_example.proto</div></div><br /><br />现在，编译CPP创建的protobuf代码：<br /><div class="codebox"><div class="codebox">#&nbsp;Compile&nbsp;the&nbsp;protobuf&nbsp;source&nbsp;code<br />clang++&nbsp;-o&nbsp;libfuzzer_example.pb.cc.o&nbsp;-g&nbsp;-c&nbsp;libfuzzer_example.pb.cc&nbsp;&nbsp;\<br />&nbsp;&nbsp;-I../../build/external.protobuf/include</div></div><br /><br />最后，我们可以继续编译和链接模糊器：<br /><div class="codebox"><div class="codebox">#&nbsp;Compile&nbsp;the&nbsp;fuzzer<br />clang++&nbsp;-fno-exceptions&nbsp;-Werror&nbsp;-Wall&nbsp;-Wstring-conversion&nbsp;-g&nbsp;\<br />&nbsp;&nbsp;-fsanitize=fuzzer-no-link&nbsp;-std=gnu++11&nbsp;-MD&nbsp;-c&nbsp;libfuzzer_example.cc&nbsp;\<br />&nbsp;&nbsp;-o&nbsp;libfuzzer_example.o&nbsp;-I.&nbsp;-I../../&nbsp;-I../../build/external.protobuf/include<br /><br />#&nbsp;Link&nbsp;the&nbsp;fuzzer<br />clang++&nbsp;-fsanitize=fuzzer&nbsp;libfuzzer_example.o&nbsp;libfuzzer_example.pb.cc.o&nbsp;&nbsp;\<br />&nbsp;&nbsp;../../build/src/libfuzzer/libprotobuf-mutator-libfuzzer.a&nbsp;\<br />&nbsp;&nbsp;../../build/src/libprotobuf-mutator.a&nbsp;\<br />&nbsp;&nbsp;../../build/external.protobuf/lib/libprotobufd.a</div></div><br /><br />此时，我们将在/work/libprotobuf-mutator/libprotobuf-mutator/examples/libfuzzer/a.out路径中安装一个模糊器。 执行此模糊器将为我们提供类似于以下内容的输出：<br /><div class="codebox"><div class="codebox">$&nbsp;./a.out<br />INFO:&nbsp;Seed:&nbsp;3245650726<br />INFO:&nbsp;Loaded&nbsp;1&nbsp;modules&nbsp;&nbsp;&nbsp;(171&nbsp;inline&nbsp;8-bit&nbsp;counters):&nbsp;171&nbsp;[0x6f8a08,&nbsp;0x6f8ab3),<br />INFO:&nbsp;Loaded&nbsp;1&nbsp;PC&nbsp;tables&nbsp;(171&nbsp;PCs):&nbsp;171&nbsp;[0x647018,0x647ac8),<br />INFO:&nbsp;-max_len&nbsp;is&nbsp;not&nbsp;provided;&nbsp;libFuzzer&nbsp;will&nbsp;not&nbsp;generate&nbsp;inputs&nbsp;larger&nbsp;than&nbsp;4096&nbsp;bytes<br />INFO:&nbsp;A&nbsp;corpus&nbsp;is&nbsp;not&nbsp;provided,&nbsp;starting&nbsp;from&nbsp;an&nbsp;empty&nbsp;corpus<br />#2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;INITED&nbsp;cov:&nbsp;45&nbsp;ft:&nbsp;46&nbsp;corp:&nbsp;1/1b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;25Mb<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW_FUNC[1/1]:&nbsp;0x459a40&nbsp;in&nbsp;google::protobuf::internal::InternalMetadata::ContainerBase*&nbsp;google::protobuf::internal::InternalMetadata::PtrValue()&nbsp;const&nbsp;/work/libprotobuf-mutator/libprotobuf-mutator/examples/libfuzzer/../../build/external.protobuf/include/google/protobuf/metadata_lite.h:151<br />#3448&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;47&nbsp;ft:&nbsp;57&nbsp;corp:&nbsp;2/38b&nbsp;lim:&nbsp;38&nbsp;exec/s:&nbsp;3448&nbsp;rss:&nbsp;28Mb&nbsp;L:&nbsp;37/37&nbsp;MS:&nbsp;3&nbsp;InsertByte-ChangeBinInt-Custom-<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW_FUNC[1/2]:&nbsp;0x459f00&nbsp;in&nbsp;google::protobuf::internal::ArenaStringPtr::CreateInstance(google::protobuf::Arena*,&nbsp;std::__cxx11::basic_string,&nbsp;std::allocator&nbsp;&gt;&nbsp;const*)&nbsp;/work/libprotobuf-mutator/libprotobuf-mutator/examples/libfuzzer/../../build/external.protobuf/include/google/protobuf/arenastring.h:289<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW_FUNC[2/2]:&nbsp;0x45a290&nbsp;in&nbsp;std::__cxx11::basic_string,&nbsp;std::allocator&nbsp;&gt;&nbsp;const&amp;&nbsp;std::forward,&nbsp;std::allocator&nbsp;&gt;&nbsp;const&amp;&gt;(std::remove_reference,&nbsp;std::allocator&nbsp;&gt;&nbsp;const&amp;&gt;::type&amp;)&nbsp;/usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/move.h:75<br />#5472&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;52&nbsp;ft:&nbsp;63&nbsp;corp:&nbsp;3/95b&nbsp;lim:&nbsp;58&nbsp;exec/s:&nbsp;5472&nbsp;rss:&nbsp;29Mb&nbsp;L:&nbsp;57/57&nbsp;MS:&nbsp;6&nbsp;InsertRepeatedBytes-ShuffleBytes-Custom-Custom-Custom-CustomCrossOver-<br />#6136&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;52&nbsp;ft:&nbsp;63&nbsp;corp:&nbsp;3/94b&nbsp;lim:&nbsp;63&nbsp;exec/s:&nbsp;6136&nbsp;rss:&nbsp;29Mb&nbsp;L:&nbsp;56/56&nbsp;MS:&nbsp;5&nbsp;Custom-Custom-Custom-InsertByte-Custom-<br />#11497&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;52&nbsp;ft:&nbsp;64&nbsp;corp:&nbsp;4/205b&nbsp;lim:&nbsp;116&nbsp;exec/s:&nbsp;11497&nbsp;rss:&nbsp;29Mb&nbsp;L:&nbsp;111/111&nbsp;MS:&nbsp;1&nbsp;CustomCrossOver-<br />#11507&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;52&nbsp;ft:&nbsp;64&nbsp;corp:&nbsp;4/131b&nbsp;lim:&nbsp;116&nbsp;exec/s:&nbsp;11507&nbsp;rss:&nbsp;29Mb&nbsp;L:&nbsp;37/56&nbsp;MS:&nbsp;5&nbsp;Custom-Custom-Custom-Custom-Custom-<br />#32768&nbsp;&nbsp;pulse&nbsp;&nbsp;cov:&nbsp;52&nbsp;ft:&nbsp;64&nbsp;corp:&nbsp;4/131b&nbsp;lim:&nbsp;325&nbsp;exec/s:&nbsp;16384&nbsp;rss:&nbsp;29Mb<br />#65536&nbsp;&nbsp;pulse&nbsp;&nbsp;cov:&nbsp;52&nbsp;ft:&nbsp;64&nbsp;corp:&nbsp;4/131b&nbsp;lim:&nbsp;652&nbsp;exec/s:&nbsp;21845&nbsp;rss:&nbsp;29Mb<br />#131072&nbsp;pulse&nbsp;&nbsp;cov:&nbsp;52&nbsp;ft:&nbsp;64&nbsp;corp:&nbsp;4/131b&nbsp;lim:&nbsp;1300&nbsp;exec/s:&nbsp;26214&nbsp;rss:&nbsp;29Mb<br />#262144&nbsp;pulse&nbsp;&nbsp;cov:&nbsp;52&nbsp;ft:&nbsp;64&nbsp;corp:&nbsp;4/131b&nbsp;lim:&nbsp;2600&nbsp;exec/s:&nbsp;29127&nbsp;rss:&nbsp;29Mb<br />#524288&nbsp;pulse&nbsp;&nbsp;cov:&nbsp;52&nbsp;ft:&nbsp;64&nbsp;corp:&nbsp;4/131b&nbsp;lim:&nbsp;4096&nbsp;exec/s:&nbsp;30840&nbsp;rss:&nbsp;29Mb<br /></div></div><br /><br /><h2>一个简单的协议缓冲区示例</h2><br /><br />本节假定您已如上所述设置libprotobuf-mutator。 具体来说，它在上述代码放置的位置使用libprotobuf-mutator组件的路径。 第一步是创建我们的工作目录：<br /><div class="codebox"><div class="codebox">cd&nbsp;/work/libprotobuf-mutator<br />mkdir&nbsp;own_example</div></div><br /><br />接下来，我们在protobuf中创建一个简单的消息类型，名为Person，并将其放入文件myprof.prot中<br />myprof.proto<br /><div class="codebox"><div class="codebox">syntax&nbsp;=&nbsp;&quot;proto2&quot;;<br /><br />package&nbsp;tutorial;<br /><br />message&nbsp;Person&nbsp;<span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;required&nbsp;string&nbsp;name&nbsp;=&nbsp;1;<br />&nbsp;&nbsp;required&nbsp;int32&nbsp;id&nbsp;=&nbsp;2;<br />&nbsp;&nbsp;optional&nbsp;string&nbsp;email&nbsp;=&nbsp;3;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />接下来，我们将把这个protobuf规范编译成其相应的CPP代码，然后将CPP代码编译为目标代码：<br /><div class="codebox"><div class="codebox">/work/libprotobuf-mutator/libprotobuf-mutator/build/external.protobuf/bin/protoc&nbsp;\<br />&nbsp;&nbsp;--cpp_out&nbsp;.&nbsp;myprof.proto<br /><br />#&nbsp;Compile&nbsp;the&nbsp;protobuf&nbsp;source&nbsp;code<br />clang++&nbsp;-o&nbsp;myprof.pb.cc.o&nbsp;-g&nbsp;-c&nbsp;myprof.pb.cc&nbsp;&nbsp;\<br />&nbsp;&nbsp;-fsanitize=fuzzer-no-link&nbsp;\<br />&nbsp;&nbsp;-I../libprotobuf-mutator/build/external.protobuf/include</div></div><br /><br />在这一阶段，我们准备创建我们的模糊器。 因此，我们继续在simple_example.cpp文件中编写以下模糊器：<br /><h3>simple_example.cpp</h3><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;iostream&gt;<br />#include&nbsp;&quot;myprof.pb.h&quot;<br />#include&nbsp;&quot;port/protobuf.h&quot;<br />#include&nbsp;&quot;src/libfuzzer/libfuzzer_macro.h&quot;<br /><br />DEFINE_PROTO_FUZZER(const&nbsp;tutorial::Person&amp;&nbsp;psn)&nbsp;<span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;if&nbsp;(psn.id()&nbsp;==&nbsp;123)<br />&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(psn.name()&nbsp;==&nbsp;&quot;Ada&quot;)<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;abort();<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;}<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />现在，我们编译此模糊器并将其链接到我们的protobuf目标代码：<br /><div class="codebox"><div class="codebox">#&nbsp;Compile&nbsp;the&nbsp;fuzzer<br />clang++&nbsp;-fno-exceptions&nbsp;-Werror&nbsp;-Wall&nbsp;-Wstring-conversion&nbsp;-g&nbsp;\<br />&nbsp;&nbsp;-fsanitize=fuzzer-no-link&nbsp;-std=gnu++11&nbsp;-MD&nbsp;-g&nbsp;-c&nbsp;simple_example.cpp&nbsp;\<br />&nbsp;&nbsp;-o&nbsp;simple_example.o&nbsp;-I.&nbsp;-I../libprotobuf-mutator/&nbsp;\<br />&nbsp;&nbsp;-I../libprotobuf-mutator/build/external.protobuf/include<br /><br />#&nbsp;Link&nbsp;the&nbsp;fuzzer<br />clang++&nbsp;-fsanitize=fuzzer&nbsp;simple_example.o&nbsp;myprof.pb.cc.o&nbsp;&nbsp;\<br />&nbsp;&nbsp;../libprotobuf-mutator/build/src/libfuzzer/libprotobuf-mutator-libfuzzer.a&nbsp;\<br />&nbsp;&nbsp;../libprotobuf-mutator/build/src/libprotobuf-mutator.a&nbsp;\<br />&nbsp;&nbsp;../libprotobuf-mutator/build/external.protobuf/lib/libprotobufd.a</div></div><br /><br />在这一阶段，我们的模糊器位于a.out中，我们可以运行示例模糊器：<br /><br /><br /><br /></div><div class='page'><h1 class='title level-3'>5_Grammar-aware_fuzzing</h1><br/></div><div class='page'><h1 class='title level-4'>1_Grammar-aware fuzzing with LibFuzzer _ ADA Logics</h1><br/>该技术可以使高度结构化的数据随机化，即可以创建符合某种语法规定的随机数据<br /><br /><h1>定义语法</h1><br />有关该种表示语法的方式：<a href="https://en.wikipedia.org/wiki/Backus-Naur_form">https://en.wikipedia.org/wiki/Backus-Naur_form</a><br />在计算机科学中，Backus–Naur形式或Backus范式（BNF）是上下文无关文法的元语法符号，通常用于描述计算所用语言的语法，例如计算机编程语言，文档格式， 指令集和通信协议。 它们可用于需要精确描述语言的地方：例如，官方语言规范，手册和编程语言理论教科书。<br /><a href=""><img src="images\970-1.png" alt="images\970-1.png" /></a><br /><br /><h1>根据语法定义编写protobuf文件</h1><br /><a href=""><img src="images\970-2.png" alt="images\970-2.png" /></a> <a href=""><img src="images\970-3.png" alt="images\970-3.png" /></a><br /><br />编写fuzzer，将protobuf结构体的内容转换为字符串，从而为进一步利用打下基础<br /><a href=""><img src="images\970-4.png" alt="images\970-4.png" /></a><br />为了将protobuf对象转为字符串，fuzzer中实现了两个运算符重载，针对两个protobuf对象的&lt;&lt;运算符进行重载<br />故在入口函数的代码1处时，os&lt;&lt;psn会调用psn对象的符号重载函数，将对象中的内容转为字符串输出到os<br />之后在代码2处通过os.str()将os中的数据转为字符串赋值给字符串变量，完成从protobuf对象到字符串的转换<br /><a href=""><img src="images\970-5.png" alt="images\970-5.png" /></a><br /><br />将.protobuf文件转为.cc文件、.h文件<br /><a href=""><img src="images\970-6.png" alt="images\970-6.png" /></a><br /><br />得到protobuf的.o文件<br /><a href=""><img src="images\970-7.png" alt="images\970-7.png" /></a><br /><br />将fuzzer编译为.o文件<br /><a href=""><img src="images\970-8.png" alt="images\970-8.png" /></a><br /><br />链接各种中间文件，生成最终fuzzer<br /><a href=""><img src="images\970-9.png" alt="images\970-9.png" /></a><br /><br /><span style="color:#ff0000;">查看fuzzer的输出，生成了大量符合算术运算规则的字符串，此时若被fuzz的目标是一个计算器，而此类字符串为其输入，则此时可以通过当前fuzz进行计算器程序的fuzzing</span><br /><a href=""><img src="images\970-10.png" alt="images\970-10.png" /></a><br /><br /><h1>在当前基础上为语法感知fuzzer增加语法</h1>（增加变量定义与变量赋值）<br />清理当前工作目录，创建新的.portobuf文件<br /><a href=""><img src="images\970-11.png" alt="images\970-11.png" /></a>  <a href=""><img src="images\970-12.png" alt="images\970-12.png" /></a><br /><br />将.portobuf转为.cc文件，最后转为.o文件，（命令与前述相同）<br /><br />创建新的fuzzer<br /><a href=""><img src="images\970-13.png" alt="images\970-13.png" /></a><br /><br />使用与之前完全相同的命令编译链接fuzzer<br /><br />运行fuzzer<br /><a href=""><img src="images\970-14.png" alt="images\970-14.png" /></a><br /><br /><span style="color:#ff0000;">根据以上结果，如果进一步扩充当前的语法，则我们可以创建一门编程语言的语法，之后产生符合编程语言规范的随机数据，将该数据转为字符串后，可以涌起fuzzing对应语言的编译器。<br /></span><br /><h1>在以上的基础上增加条件判断语法</h1><br /><br />清理文件夹<br /><a href=""><img src="images\970-15.png" alt="images\970-15.png" /></a><br /><br />创建.portobuf文件<br /><a href=""><img src="images\970-16.png" alt="images\970-16.png" /></a><br /><a href=""><img src="images\970-17.png" alt="images\970-17.png" /></a><br /><br />创建对应fuzzer文件<br /><a href=""><img src="images\970-18.png" alt="images\970-18.png" /></a><br /><br />按照之前的命令分别处理.protobuf文件和fuzzer文件<br /><br />运行fuzzer<br /><a href=""><img src="images\970-19.png" alt="images\970-19.png" /></a><br /><a href=""><img src="images\970-20.png" alt="images\970-20.png" /></a><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /></div><div class='page'><h1 class='title level-4'>2_Grammar-aware_fuzzing_with_libprotobuf-mutator</h1><br/><h1>使用libprotobuf-mutator进行语法感知的模糊测试</h1><br /><br />在本节中，我们将概述如何通过Libfuzzer执行基于语法的模糊测试。 这是一种非常强大的技术，因为可以通过语法描述许多数据格式，并且能够执行语法感知的模糊测试为模糊许多不同类型的目标打开了大门。特别是，它使您能够对应用程序的核心逻辑进行模糊处理，因为模糊器创建的数据将能够满足解析器施加的约束。<br /><br />为了通过Libfuzzer进行语法感知的模糊处理，我们将使用Protobuf作为中间表示，然后让Libprotobuf-mutator为我们执行变异。我们将语法本身指定为Protobuf消息，然后在模糊器中实现将Protobuf代码的CPP类转换为字符串的逻辑。然后，此字符串将作为字节的原始缓冲区传递到目标代码中。 这样，我们的模糊器会将Protobuf类转换为字符串，并且因为Protobuf类表示给定的语法，所以我们创建的字符串将是满足该语法的字符串。<br /><br />根据以上描述，我们可以将语法感知的Libfuzzer模糊器的组件缩小为：<br />1、Protobuf定义的语法<br />2、将protobuf类转换为字符串所需的代码。<br /><br />举一个例子，我们将编写一个使用Protobuf中的简单编程语言定义的模糊器，然后编写用于将C ++ Protobuf类转换为表示实际代码的字符串的转换逻辑。然后，在实际的用例中，我们将能够将给定的字符串代码传递到某个API库中，该API库需要使用给定语言的字符串，例如该语言的编译器。为了针对各种编译器和解释器，我们将采用类似的方法，但要使用我们要使用的给定目标语言的语法。<br /><br />我们将包含在语法中的特定语言构造为：<br />1、简单的算术运算；<br />2、变量声明和变量赋值；<br />3、一个简单的条件语句。<br /><br />我们将分步解决问题，并按照上述三种语言结构，分三步实施语法。<br /><br /><h2>步骤1：算术运算</h2><br />我们将从定义一个可以表达算术运算的简单语法开始。 以下语法中的BinaryOp将能够做到这一点：<br /><br />简单的算术运算语法<br /><br /><div class="codebox"><div class="codebox">Const&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::=&nbsp;INTEGER<br />Op&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::=&nbsp;&quot;+&quot;&nbsp;|&nbsp;&quot;-&quot;&nbsp;|&nbsp;&quot;*&quot;&nbsp;|&nbsp;&quot;/&quot;<br />RValue&nbsp;&nbsp;&nbsp;&nbsp;::=&nbsp;&lt;Const&gt;&nbsp;|&nbsp;&lt;BinaryOp&gt;<br />BinaryOp&nbsp;&nbsp;::=&nbsp;&lt;RVALUE&gt;&nbsp;&lt;Op&gt;&nbsp;&lt;RVALUE&gt;<br /></div></div><br /><br />如果您不熟悉该符号，我们会在此处提供详细说明（<a href="https://en.wikipedia.org/wiki/Backus-Naur_form">https://en.wikipedia.org/wiki/Backus-Naur_form</a>）。<br />但是，为了简短说明，我们有四个规则：Const，Op，RValue和BinaryOp。  Const是整数，Op是算术运算符，在我们的例子中是{“ +”，“-”，“ *”，“ /”}中的一个，RValue是Const或BinaryOp，而BinaryOp由三个组件组成：一个RValue，一个Op和另一个RValue。请注意，Const是整数的字符串表示形式，这意味着我们的语法中只有两个原子字符串，即Const和Op。<br /><br />现在的想法是在Protobuf消息中对此语法进行编码，我们可以执行以下操作：<br /><br /><h3>lang_grammar.proto</h3><br /><br /><div class="codebox"><div class="codebox">syntax&nbsp;=&nbsp;&quot;proto2&quot;;<br /><br />package&nbsp;LG;<br /><br />message&nbsp;Const&nbsp;{<br />&nbsp;&nbsp;required&nbsp;int32&nbsp;val&nbsp;=&nbsp;1;<br />}<br /><br />message&nbsp;BinaryOp&nbsp;{<br />&nbsp;&nbsp;enum&nbsp;Op&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;PLUS&nbsp;=&nbsp;0;<br />&nbsp;&nbsp;&nbsp;&nbsp;MINUS&nbsp;=&nbsp;1;<br />&nbsp;&nbsp;&nbsp;&nbsp;MUL&nbsp;=&nbsp;2;<br />&nbsp;&nbsp;&nbsp;&nbsp;DIV&nbsp;=&nbsp;3;<br />&nbsp;&nbsp;};<br />&nbsp;&nbsp;required&nbsp;Op&nbsp;op&nbsp;=&nbsp;1;<br />&nbsp;&nbsp;required&nbsp;Rvalue&nbsp;left&nbsp;=&nbsp;2;<br />&nbsp;&nbsp;required&nbsp;Rvalue&nbsp;right&nbsp;=&nbsp;3;<br />}<br /><br />message&nbsp;Rvalue&nbsp;<span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;oneof&nbsp;rvalue_oneof&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;Const&nbsp;cons&nbsp;=&nbsp;1;<br />&nbsp;&nbsp;&nbsp;&nbsp;BinaryOp&nbsp;binop&nbsp;=&nbsp;2;<br />&nbsp;&nbsp;}<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />本质上，上述语法包含足以表达算术运算的规则：（1）加法；  （2）减法；  （3）乘法和（4）除法。 在此阶段，我们可以像以前使用Protobuf一样编译此语法，然后使用Libprotobuf-mutator来突变Protobuf产生的给定类。实际上，这正是我们要做的，但是，为了执行完全语法感知的模糊测试，我们需要在模糊测试器中实现将Protobuf对象转换为字符串的逻辑。 考虑以下准确执行此操作的模糊器：<br /><br /><h3>grammar_fuzz.cpp</h3><br /><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;iostream&gt;<br />#include&nbsp;&lt;ostream&gt;<br />#include&nbsp;&lt;sstream&gt;<br /><br />#include&nbsp;&lt;stdlib.h&gt;<br />#include&nbsp;&quot;lang_grammar.pb.h&quot;<br />#include&nbsp;&quot;port/protobuf.h&quot;<br />#include&nbsp;&quot;src/libfuzzer/libfuzzer_macro.h&quot;<br /><br />std::ostream&nbsp;&amp;operator&lt;&lt;(std::ostream&nbsp;&amp;os,&nbsp;const&nbsp;LG::BinaryOp&amp;&nbsp;psn);<br />std::ostream&nbsp;&amp;operator&lt;&lt;(std::ostream&nbsp;&amp;os,&nbsp;const&nbsp;LG::Rvalue&amp;&nbsp;rval);<br /><br />int&nbsp;static&nbsp;depth&nbsp;=&nbsp;0;<br /><br />//&nbsp;BinaryOp&nbsp;converter<br />std::ostream&nbsp;&amp;operator&lt;&lt;(std::ostream&nbsp;&amp;os,&nbsp;const&nbsp;LG::BinaryOp&amp;&nbsp;psn)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Increase&nbsp;depth&nbsp;to&nbsp;ensure&nbsp;we&nbsp;dont&nbsp;reach&nbsp;a&nbsp;stack-overflow.<br />&nbsp;&nbsp;&nbsp;&nbsp;depth&nbsp;+=&nbsp;1;<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(depth&nbsp;&gt;=&nbsp;10)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;os;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;os&nbsp;&lt;&lt;&nbsp;psn.left();<br />&nbsp;&nbsp;&nbsp;&nbsp;switch(psn.op())<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;LG::BinaryOp::PLUS:&nbsp;&nbsp;&nbsp;os&nbsp;&lt;&lt;&nbsp;&quot;+&quot;;&nbsp;break;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;LG::BinaryOp::MINUS:&nbsp;&nbsp;os&nbsp;&lt;&lt;&nbsp;&quot;-&quot;;&nbsp;break;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;LG::BinaryOp::MUL:&nbsp;&nbsp;&nbsp;&nbsp;os&nbsp;&lt;&lt;&nbsp;&quot;*&quot;;&nbsp;break;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;LG::BinaryOp::DIV:&nbsp;&nbsp;&nbsp;&nbsp;os&nbsp;&lt;&lt;&nbsp;&quot;/&quot;;&nbsp;break;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;abort();<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;os&nbsp;&lt;&lt;&nbsp;psn.right();<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;os;<br />}<br /><br />//&nbsp;Rvalue&nbsp;converter<br />std::ostream&nbsp;&amp;operator&lt;&lt;(std::ostream&nbsp;&amp;os,&nbsp;const&nbsp;LG::Rvalue&amp;&nbsp;rval)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(rval.has_cons())&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;os&nbsp;&lt;&lt;&nbsp;rval.cons().val();<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;(depth&nbsp;&gt;&nbsp;10)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;os&nbsp;&lt;&lt;&nbsp;&quot;123&quot;;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;os&nbsp;&lt;&lt;&nbsp;rval.binop();<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;os;<br />}<br /><br />DEFINE_PROTO_FUZZER(const&nbsp;LG::BinaryOp&amp;&nbsp;psn)&nbsp;<span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;depth&nbsp;=&nbsp;0;<br />&nbsp;&nbsp;&nbsp;&nbsp;std::ostringstream&nbsp;os;<br />&nbsp;&nbsp;&nbsp;&nbsp;os&nbsp;&lt;&lt;&nbsp;psn;<br />&nbsp;&nbsp;&nbsp;&nbsp;std::string&nbsp;lang_string&nbsp;=&nbsp;os.str();<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Print&nbsp;the&nbsp;string&nbsp;for&nbsp;convenience<br />&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;&quot;----------------------------&quot;&nbsp;&lt;&lt;&nbsp;std::endl;<br />&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;lang_string&nbsp;&lt;&lt;&nbsp;std::endl;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />模糊测试代码背后的想法是为每种protobuf消息类型覆盖&lt;&lt;操作符。 然后，我们将依靠&lt;&lt;操作符将protobuf对象转换为字符串，然后将使用该字符串作为目标代码的输入。 从这个意义上说，在模糊入口点DEFINE_PROTO_FUZZER中的行os &lt;&lt; psn; 是启动将protobuf类型（LG :: BinaryOp）转换为字符串的关键逻辑。<br /><br />模糊器的源代码包含两个主要功能：<br /><h3>std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const LG::Rvalue&amp; rval)</h3><br /><h3>std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const LG::BinaryOp&amp; psn)</h3><br /><br />这些负责将Rvalue和BinaryOp类的实例分别转换为字符串。 从本质上讲，它们非常直观，并且背后的逻辑很简单。但是，警告之一是使用depth变量。depth变量是一个全局静态变量，它在DEFINE_PROTO_FUZZER函数的开头初始化为0，并作为std :: ostream＆operator &lt;&lt;（std :: ostream＆os，const LG :: BinaryOp＆psn函数中的第一件事递增，此depth变量用于控制Protobuf实例的递归深度，本质上不会引起不必要的堆栈溢出。 模糊器本身并不针对任何特定代码，并且实际上，模糊器唯一要做的就是将传递给DEFINE_PROTO_FUZZER的protobuf BinaryOp实例转换为字符串。这样做的原因是保持示例简单，并可视化我们可以使用语法感知fuzzer创建的数据。 现在，运行模糊器将为我们提供一组打印语句，这些语句均反映了一组不同的算术运算：<br /><br />在我们的Docker映像内部执行以下操作：<br />build_grammar.sh<br /><div class="codebox"><div class="codebox">/work/libprotobuf-mutator/libprotobuf-mutator/build/external.protobuf/bin/protoc&nbsp;\<br />&nbsp;&nbsp;--cpp_out&nbsp;.&nbsp;lang_grammar.proto<br /><br />#&nbsp;Compile&nbsp;the&nbsp;protobuf&nbsp;source&nbsp;code<br />clang++&nbsp;-o&nbsp;lang_grammar.pb.cc.o&nbsp;-g&nbsp;-c&nbsp;lang_grammar.pb.cc&nbsp;&nbsp;\<br />&nbsp;&nbsp;-I../build/external.protobuf/include<br /><br /><br />clang++&nbsp;-fno-exceptions&nbsp;-Werror&nbsp;-Wall&nbsp;-Wstring-conversion&nbsp;-g&nbsp;\<br />&nbsp;&nbsp;-fsanitize=fuzzer-no-link&nbsp;-std=gnu++11&nbsp;-MD&nbsp;-c&nbsp;grammar_fuzz.cpp&nbsp;\<br />&nbsp;&nbsp;-o&nbsp;grammar_fuzz.o&nbsp;-I.&nbsp;-I../&nbsp;-I../build/external.protobuf/include<br /><br />#&nbsp;Link&nbsp;the&nbsp;fuzzer<br />clang++&nbsp;-fsanitize=fuzzer&nbsp;grammar_fuzz.o&nbsp;lang_grammar.pb.cc.o&nbsp;&nbsp;\<br />&nbsp;&nbsp;../build/src/libfuzzer/libprotobuf-mutator-libfuzzer.a&nbsp;\<br />&nbsp;&nbsp;../build/src/libprotobuf-mutator.a&nbsp;\<br />&nbsp;&nbsp;../build/external.protobuf/lib/libprotobufd.a</div></div><br /><br />最后，我们可以执行模糊器，开始看到有趣的输出。 在开始执行此模糊器之后，可能会看到几秒钟的输出“ 123 + 123 + 123 + 123 + 123 + 123 + 123 + 123 + 123 + 123 + 123 + 123”，但是之后您应该会看到 其他类型的算术语句即将出现：<br /><div class="codebox"><div class="codebox">$&nbsp;./a.out<br />----------------------------<br />123+123+123+123+123+123+123+123+123+123+123<br />----------------------------<br />123+123+123+123+123+123+123+123+123+123+123<br />----------------------------<br />123+123+123+123+123+123+123+123+123+123+123<br />----------------------------<br />123+123+123+123+123+123+123+123+123+123+123<br />....<br />....<br />....<br />----------------------------<br />123+123+123+123+123/123/0/123-0/123/0<br />----------------------------<br />0/123+123+123+123+123+123+123-0/123/0<br />----------------------------<br />0/0/0*0*0/0*0*0/123+123*538968064<br />----------------------------<br />0/0/0*0*123+123+123+123+123+123+123<br />----------------------------<br />7274496/123+123+123+123+123+123+123+123+123+123</div></div><br /><br />如我们所见，输出创建了许多不同类型的算术表达式。<br /><br /><h2>步骤2：分配作业</h2><br /><br />前面的示例仅说明了可以用常规编程语言编写的内容的一小部分。 语法自然可以表达更多，我们将在这里继续扩展语法，使其包含赋值运算的概念。<br /><br />考虑如下语法：<br />该语法包括变量引用和赋值表达式的概念。 为了支持赋值操作，我们在语法中包括了三个新规则：Stmt，AssignmentStmt和VarRef。 这个想法是，我们现在将能够fuzz许多不同的变量分配，其中每个变量分配都基于算术表达式。<br /><br />以下protobuf消息实现了此语法：<br /><h3>lang_grammar.proto</h3><br /><div class="codebox"><div class="codebox">syntax&nbsp;=&nbsp;&quot;proto2&quot;;<br /><br />package&nbsp;LG;<br /><br />message&nbsp;VarRef&nbsp;{<br />&nbsp;&nbsp;required&nbsp;int32&nbsp;varnum&nbsp;=&nbsp;1;<br />}<br /><br />message&nbsp;Const&nbsp;{<br />&nbsp;&nbsp;required&nbsp;int32&nbsp;val&nbsp;=&nbsp;1;<br />}<br /><br />message&nbsp;BinaryOp&nbsp;{<br />&nbsp;&nbsp;enum&nbsp;Op&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;PLUS&nbsp;=&nbsp;0;<br />&nbsp;&nbsp;&nbsp;&nbsp;MINUS&nbsp;=&nbsp;1;<br />&nbsp;&nbsp;&nbsp;&nbsp;MUL&nbsp;=&nbsp;2;<br />&nbsp;&nbsp;&nbsp;&nbsp;DIV&nbsp;=&nbsp;3;<br />&nbsp;&nbsp;};<br />&nbsp;&nbsp;required&nbsp;Op&nbsp;op&nbsp;=&nbsp;1;<br />&nbsp;&nbsp;required&nbsp;Rvalue&nbsp;left&nbsp;=&nbsp;2;<br />&nbsp;&nbsp;required&nbsp;Rvalue&nbsp;right&nbsp;=&nbsp;3;<br />}<br /><br />message&nbsp;Rvalue&nbsp;{<br />&nbsp;&nbsp;oneof&nbsp;rvalue_oneof&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;Const&nbsp;cons&nbsp;=&nbsp;1;<br />&nbsp;&nbsp;&nbsp;&nbsp;BinaryOp&nbsp;binop&nbsp;=&nbsp;2;<br />&nbsp;&nbsp;}<br />}<br /><br />message&nbsp;AssignmentStmt&nbsp;{<br />&nbsp;&nbsp;required&nbsp;VarRef&nbsp;lvalue&nbsp;=&nbsp;1;<br />&nbsp;&nbsp;required&nbsp;Rvalue&nbsp;rvalue&nbsp;=&nbsp;2;<br />}<br /><br />message&nbsp;Stmt&nbsp;<span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;repeated&nbsp;AssignmentStmt&nbsp;assignment_stmts&nbsp;=&nbsp;1;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />我们包括的唯一片段是Stmt，AssignmentStmt和VarRef的消息类型。 这些与上述语法的新规则相对应。 相应的模糊器实现如下：<br /><h3>grammar_fuzz.cpp</h3><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;iostream&gt;<br />#include&nbsp;&lt;ostream&gt;<br />#include&nbsp;&lt;sstream&gt;<br />#include&nbsp;&lt;stdlib.h&gt;<br />#include&nbsp;&quot;lang_grammar.pb.h&quot;<br />#include&nbsp;&quot;port/protobuf.h&quot;<br />#include&nbsp;&quot;src/libfuzzer/libfuzzer_macro.h&quot;<br /><br />std::ostream&nbsp;&amp;operator&lt;&lt;(std::ostream&nbsp;&amp;os,&nbsp;const&nbsp;LG::BinaryOp&amp;&nbsp;psn);<br />std::ostream&nbsp;&amp;operator&lt;&lt;(std::ostream&nbsp;&amp;os,&nbsp;const&nbsp;LG::Rvalue&amp;&nbsp;rval);<br /><br />#define&nbsp;MAX_VAR&nbsp;3<br />int&nbsp;static&nbsp;depth&nbsp;=&nbsp;0;<br /><br />//&nbsp;BinaryOp&nbsp;converter<br />std::ostream&nbsp;&amp;operator&lt;&lt;(std::ostream&nbsp;&amp;os,&nbsp;const&nbsp;LG::BinaryOp&amp;&nbsp;psn)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Increase&nbsp;depth&nbsp;to&nbsp;ensure&nbsp;we&nbsp;dont&nbsp;reach&nbsp;a&nbsp;stack-overflow.<br />&nbsp;&nbsp;&nbsp;&nbsp;depth&nbsp;+=&nbsp;1;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;os&nbsp;&lt;&lt;&nbsp;psn.left();<br />&nbsp;&nbsp;&nbsp;&nbsp;switch(psn.op())<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;LG::BinaryOp::PLUS:&nbsp;&nbsp;&nbsp;os&nbsp;&lt;&lt;&nbsp;&quot;+&quot;;&nbsp;break;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;LG::BinaryOp::MINUS:&nbsp;&nbsp;os&nbsp;&lt;&lt;&nbsp;&quot;-&quot;;&nbsp;break;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;LG::BinaryOp::MUL:&nbsp;&nbsp;&nbsp;&nbsp;os&nbsp;&lt;&lt;&nbsp;&quot;*&quot;;&nbsp;break;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;LG::BinaryOp::DIV:&nbsp;&nbsp;&nbsp;&nbsp;os&nbsp;&lt;&lt;&nbsp;&quot;/&quot;;&nbsp;break;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;abort();<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;os&nbsp;&lt;&lt;&nbsp;psn.right();<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;os;<br />}<br /><br />//&nbsp;Rvalue&nbsp;converter<br />std::ostream&nbsp;&amp;operator&lt;&lt;(std::ostream&nbsp;&amp;os,&nbsp;const&nbsp;LG::Rvalue&amp;&nbsp;rval)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(rval.has_cons())&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;os&nbsp;&lt;&lt;&nbsp;rval.cons().val();<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;(depth&nbsp;&lt;&nbsp;10)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;os&nbsp;&lt;&lt;&nbsp;rval.binop();<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;os&nbsp;&lt;&lt;&nbsp;&quot;123&quot;;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;os;<br />}<br /><br />std::ostream&nbsp;&amp;operator&lt;&lt;(std::ostream&nbsp;&amp;os,&nbsp;const&nbsp;LG::VarRef&nbsp;var_ref)&nbsp;{<br />&nbsp;&nbsp;&nbsp;return&nbsp;os&nbsp;&lt;&lt;&nbsp;&quot;var&quot;&nbsp;&lt;&lt;&nbsp;abs((var_ref.varnum()&nbsp;%&nbsp;MAX_VAR));<br />}<br /><br />std::ostream&nbsp;&amp;operator&lt;&lt;(std::ostream&nbsp;&amp;os,&nbsp;const&nbsp;LG::AssignmentStmt&nbsp;assign_stmt)&nbsp;{<br />&nbsp;&nbsp;&nbsp;os&nbsp;&lt;&lt;&nbsp;assign_stmt.lvalue()&nbsp;&lt;&lt;&nbsp;&quot;&nbsp;=&nbsp;&quot;&nbsp;&lt;&lt;&nbsp;assign_stmt.rvalue();<br />&nbsp;&nbsp;&nbsp;return&nbsp;os;<br />}<br /><br />std::ostream&nbsp;&amp;operator&lt;&lt;(std::ostream&nbsp;&amp;os,&nbsp;const&nbsp;LG::Stmt&nbsp;stmt)&nbsp;{<br />&nbsp;&nbsp;&nbsp;for&nbsp;(const&nbsp;LG::AssignmentStmt&nbsp;&amp;assign_stmt&nbsp;:&nbsp;stmt.assignment_stmts())<br />&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;os&nbsp;&lt;&lt;&nbsp;assign_stmt&nbsp;&lt;&lt;&nbsp;&quot;;\n&quot;;<br />&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;return&nbsp;os;<br />}<br /><br />DEFINE_PROTO_FUZZER(const&nbsp;LG::Stmt&amp;&nbsp;inp)&nbsp;<span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;depth&nbsp;=&nbsp;0;<br />&nbsp;&nbsp;&nbsp;&nbsp;std::ostringstream&nbsp;os;<br />&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&nbsp;&lt;&nbsp;MAX_VAR;&nbsp;i++)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;os&nbsp;&lt;&lt;&nbsp;&quot;var&quot;&nbsp;&lt;&lt;&nbsp;i&nbsp;&lt;&lt;&nbsp;&quot;;\n&quot;;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;os&nbsp;&lt;&lt;&nbsp;inp;<br />&nbsp;&nbsp;&nbsp;&nbsp;std::string&nbsp;lang_string&nbsp;=&nbsp;os.str();<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Print&nbsp;the&nbsp;string&nbsp;for&nbsp;convenience<br />&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;&quot;----------------------------&quot;&nbsp;&lt;&lt;&nbsp;std::endl;<br />&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;lang_string&nbsp;&lt;&lt;&nbsp;std::endl;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />编译protobuf文件和模糊器，然后运行我们得到的可执行文件，将得到以下输出：<br /><div class="codebox"><div class="codebox">$&nbsp;./a.out<br />----------------------------<br />var0;<br />var1;<br />var2;<br /><br />----------------------------<br />var0;<br />var1;<br />var2;<br />----------------------------<br />....<br />....<br />....<br />----------------------------<br />var0;<br />var1;<br />var2;<br />var0&nbsp;=&nbsp;123+123+123+123+123+123+123+123+123+123+123;<br /><br />----------------------------<br />var0;<br />var1;<br />var2;<br />var0&nbsp;=&nbsp;123+123+123+123+123+123+123+123+123+123+123;<br />var0&nbsp;=&nbsp;123;<br />var0&nbsp;=&nbsp;123;<br />var0&nbsp;=&nbsp;0;<br /><br />----------------------------<br />var0;<br />var1;<br />var2;<br />var0&nbsp;=&nbsp;123+123+123+123+123+123+123+123+123+123+123;<br />var0&nbsp;=&nbsp;123;<br />var1&nbsp;=&nbsp;123;<br />var0&nbsp;=&nbsp;0;<br /></div></div><br /><br /><h2>步骤3：if陈述</h2><br /><br />在我们的语法意识模糊测试示例的最后一步，我们将在语法中添加if条件的概念。 请考虑以下语法。<br /><h3>The grammar:</h3><br /><div class="codebox"><div class="codebox">Const&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:=&nbsp;&lt;INTEGER&gt;<br />Op&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:=&nbsp;&quot;+&quot;&nbsp;|&nbsp;&quot;-&quot;&nbsp;|&nbsp;&quot;*&quot;&nbsp;|&nbsp;&quot;/&quot;<br />RValue&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:=&nbsp;&lt;Const&gt;&nbsp;|&nbsp;&lt;BinaryOp&gt;<br />BinaryOp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:=&nbsp;&lt;RVALUE&gt;&nbsp;&lt;Op&gt;&nbsp;&lt;RVALUE&gt;<br />VarRef&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:=&nbsp;&quot;var&quot;-&lt;INTEGER&gt;<br />AssignmentStmt&nbsp;:=&nbsp;&lt;VarRef&gt;&nbsp;&quot;=&quot;&nbsp;&lt;Rvalue&gt;<br />Cond&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:=&nbsp;&lt;Rvalue&gt;<br />IfCond&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:=&nbsp;&quot;if&nbsp;(&quot;&lt;Cond&gt;&quot;){&quot;&nbsp;&lt;StmtSeq&gt;&quot;}&quot;<br />Stmt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:=&nbsp;&lt;AssignmentStmt&gt;&nbsp;|&nbsp;&lt;IfCond&gt;<br />StmtSeq&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:=&nbsp;&lt;Stmt&gt;&quot;;&quot;&nbsp;&lt;StmtSeq&gt;&nbsp;|&nbsp;<span style="color:#000000;font-weight:400">&lt;</span>Stmt<span style="color:#000000;font-weight:400">&gt;</span></div></div><br /><br />语法的核心补充是IfCond规则，该规则使我们能够表达if条件。 考虑以下定义此语法的protbuf实现：<br /><h3>lang_grammar.proto</h3><br /><a href=""><img src="images\971-1.png" alt="images\971-1.png" /></a><br /><a href=""><img src="images\971-2.png" alt="images\971-2.png" /></a><br /><br /><br /><br /><br />我们包含的上述关键消息类型是IfCond消息类型。  fuzzer的以下实现能够将StmtSeq的实例转换为可用于模糊测试的字符串：<br /><h3>grammar_fuzz.cpp</h3><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;iostream&gt;<br />#include&nbsp;&lt;ostream&gt;<br />#include&nbsp;&lt;sstream&gt;<br />#include&nbsp;&lt;stdlib.h&gt;<br />#include&nbsp;&quot;lang_grammar.pb.h&quot;<br />#include&nbsp;&quot;port/protobuf.h&quot;<br />#include&nbsp;&quot;src/libfuzzer/libfuzzer_macro.h&quot;<br /><br />std::ostream&nbsp;&amp;operator&lt;&lt;(std::ostream&nbsp;&amp;os,&nbsp;const&nbsp;LG::BinaryOp&amp;&nbsp;psn);<br />std::ostream&nbsp;&amp;operator&lt;&lt;(std::ostream&nbsp;&amp;os,&nbsp;const&nbsp;LG::Rvalue&amp;&nbsp;rval);<br />std::ostream&nbsp;&amp;operator&lt;&lt;(std::ostream&nbsp;&amp;os,&nbsp;const&nbsp;LG::VarRef&nbsp;var_ref);<br />std::ostream&nbsp;&amp;operator&lt;&lt;(std::ostream&nbsp;&amp;os,&nbsp;const&nbsp;LG::AssignmentStmt&nbsp;assign_stmt);<br />std::ostream&nbsp;&amp;operator&lt;&lt;(std::ostream&nbsp;&amp;os,&nbsp;const&nbsp;LG::Cond&nbsp;cond);<br />std::ostream&nbsp;&amp;operator&lt;&lt;(std::ostream&nbsp;&amp;os,&nbsp;const&nbsp;LG::IfCond&nbsp;if_cond);<br />std::ostream&nbsp;&amp;operator&lt;&lt;(std::ostream&nbsp;&amp;os,&nbsp;const&nbsp;LG::Stmt&nbsp;stmt);<br />std::ostream&nbsp;&amp;operator&lt;&lt;(std::ostream&nbsp;&amp;os,&nbsp;const&nbsp;LG::StmtSeq&nbsp;stmt_seq);<br /><br />#define&nbsp;MAX_VAR&nbsp;3<br />int&nbsp;static&nbsp;depth&nbsp;=&nbsp;0;<br /><br />//&nbsp;BinaryOp&nbsp;converter<br />std::ostream&nbsp;&amp;operator&lt;&lt;(std::ostream&nbsp;&amp;os,&nbsp;const&nbsp;LG::BinaryOp&amp;&nbsp;psn)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Increase&nbsp;depth&nbsp;to&nbsp;ensure&nbsp;we&nbsp;dont&nbsp;reach&nbsp;a&nbsp;stack-overflow.<br />&nbsp;&nbsp;&nbsp;&nbsp;depth&nbsp;+=&nbsp;1;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;os&nbsp;&lt;&lt;&nbsp;psn.left();<br />&nbsp;&nbsp;&nbsp;&nbsp;switch(psn.op())<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;LG::BinaryOp::PLUS:&nbsp;&nbsp;&nbsp;os&nbsp;&lt;&lt;&nbsp;&quot;+&quot;;&nbsp;break;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;LG::BinaryOp::MINUS:&nbsp;&nbsp;os&nbsp;&lt;&lt;&nbsp;&quot;-&quot;;&nbsp;break;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;LG::BinaryOp::MUL:&nbsp;&nbsp;&nbsp;&nbsp;os&nbsp;&lt;&lt;&nbsp;&quot;*&quot;;&nbsp;break;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;LG::BinaryOp::DIV:&nbsp;&nbsp;&nbsp;&nbsp;os&nbsp;&lt;&lt;&nbsp;&quot;/&quot;;&nbsp;break;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;abort();<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;os&nbsp;&lt;&lt;&nbsp;psn.right();<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;os;<br />}<br /><br />//&nbsp;Rvalue&nbsp;converter<br />std::ostream&nbsp;&amp;operator&lt;&lt;(std::ostream&nbsp;&amp;os,&nbsp;const&nbsp;LG::Rvalue&amp;&nbsp;rval)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(rval.has_cons())&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;os&nbsp;&lt;&lt;&nbsp;rval.cons().val();<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;(depth&nbsp;&lt;&nbsp;10)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;os&nbsp;&lt;&lt;&nbsp;rval.binop();<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;os&nbsp;&lt;&lt;&nbsp;&quot;123&quot;;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;os;<br />}<br /><br />std::ostream&nbsp;&amp;operator&lt;&lt;(std::ostream&nbsp;&amp;os,&nbsp;const&nbsp;LG::VarRef&nbsp;var_ref)&nbsp;{<br />&nbsp;&nbsp;&nbsp;return&nbsp;os&nbsp;&lt;&lt;&nbsp;&quot;var&quot;&nbsp;&lt;&lt;&nbsp;abs((var_ref.varnum()&nbsp;%&nbsp;MAX_VAR));<br />}<br /><br />std::ostream&nbsp;&amp;operator&lt;&lt;(std::ostream&nbsp;&amp;os,&nbsp;const&nbsp;LG::AssignmentStmt&nbsp;assign_stmt)&nbsp;{<br />&nbsp;&nbsp;&nbsp;os&nbsp;&lt;&lt;&nbsp;assign_stmt.lvalue()&nbsp;&lt;&lt;&nbsp;&quot;&nbsp;=&nbsp;&quot;&nbsp;&lt;&lt;&nbsp;assign_stmt.rvalue();<br />&nbsp;&nbsp;&nbsp;return&nbsp;os;<br />}<br /><br />std::ostream&nbsp;&amp;operator&lt;&lt;(std::ostream&nbsp;&amp;os,&nbsp;const&nbsp;LG::Cond&nbsp;cond)&nbsp;{<br />&nbsp;&nbsp;&nbsp;return&nbsp;os&nbsp;&lt;&lt;&nbsp;cond.rval();<br />}<br /><br />std::ostream&nbsp;&amp;operator&lt;&lt;(std::ostream&nbsp;&amp;os,&nbsp;const&nbsp;LG::IfCond&nbsp;if_cond)&nbsp;{<br />&nbsp;&nbsp;&nbsp;os&nbsp;&lt;&lt;&nbsp;&quot;if&nbsp;(&quot;&nbsp;&lt;&lt;&nbsp;if_cond.cond()&nbsp;&lt;&lt;&nbsp;&quot;)&quot;&nbsp;&lt;&lt;&nbsp;&quot;\n&quot;;<br />&nbsp;&nbsp;&nbsp;os&nbsp;&lt;&lt;&nbsp;&quot;{\n&quot;;<br />&nbsp;&nbsp;&nbsp;os&nbsp;&lt;&lt;&nbsp;if_cond.body();<br />&nbsp;&nbsp;&nbsp;os&nbsp;&lt;&lt;&nbsp;&quot;}&quot;;<br />&nbsp;&nbsp;&nbsp;return&nbsp;os;<br />}<br /><br />std::ostream&nbsp;&amp;operator&lt;&lt;(std::ostream&nbsp;&amp;os,&nbsp;const&nbsp;LG::Stmt&nbsp;stmt)&nbsp;{<br />&nbsp;&nbsp;&nbsp;if&nbsp;(stmt.stmt_var_case()&nbsp;==&nbsp;LG::Stmt::StmtVarCase::kAssignmt)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;os&nbsp;&lt;&lt;&nbsp;stmt.assignmt()&nbsp;&lt;&lt;&nbsp;&quot;;\n&quot;;<br />&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;(stmt.stmt_var_case()&nbsp;==&nbsp;LG::Stmt::StmtVarCase::kIfCond)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;os&nbsp;&lt;&lt;&nbsp;stmt.if_cond()&nbsp;&lt;&lt;&nbsp;&quot;\n&quot;;<br />&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;return&nbsp;os;<br />}<br /><br />std::ostream&nbsp;&amp;operator&lt;&lt;(std::ostream&nbsp;&amp;os,&nbsp;const&nbsp;LG::StmtSeq&nbsp;stmt_seq)&nbsp;{<br />&nbsp;&nbsp;&nbsp;for&nbsp;(const&nbsp;LG::Stmt&nbsp;&amp;stmt&nbsp;:&nbsp;stmt_seq.stmts())&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;os&nbsp;&lt;&lt;&nbsp;stmt;<br />&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;return&nbsp;os;<br />}<br /><br />DEFINE_PROTO_FUZZER(const&nbsp;LG::StmtSeq&amp;&nbsp;inp)&nbsp;<span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;depth&nbsp;=&nbsp;0;<br />&nbsp;&nbsp;&nbsp;&nbsp;std::ostringstream&nbsp;os;<br />&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&nbsp;&lt;&nbsp;MAX_VAR;&nbsp;i++)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;os&nbsp;&lt;&lt;&nbsp;&quot;var&quot;&nbsp;&lt;&lt;&nbsp;i&nbsp;&lt;&lt;&nbsp;&quot;;\n&quot;;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;os&nbsp;&lt;&lt;&nbsp;inp;<br />&nbsp;&nbsp;&nbsp;&nbsp;std::string&nbsp;lang_string&nbsp;=&nbsp;os.str();<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Print&nbsp;the&nbsp;string&nbsp;for&nbsp;convenience<br />&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;&quot;----------------------------&quot;&nbsp;&lt;&lt;&nbsp;std::endl;<br />&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;lang_string&nbsp;&lt;&lt;&nbsp;std::endl;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><br />编译protobuf文件和模糊器，然后运行我们得到的可执行文件，将得到以下输出：<br /><div class="codebox"><div class="codebox">$&nbsp;./a.out<br />----------------------------<br />var0;<br />var1;<br />var2;<br /><br />----------------------------<br />var0;<br />var1;<br />var2;<br />----------------------------<br />....<br />....<br />....<br />----------------------------<br />var0;<br />var1;<br />var2;<br />if&nbsp;(0)<br />{<br />if&nbsp;(123+123+123+123+123+123+123+123+123+123+123)<br />{<br />}<br />}<br /><br />----------------------------<br />var0;<br />var1;<br />var2;<br />if&nbsp;(0)<br />{<br />var0&nbsp;=&nbsp;123+123+123+123+123+123+123+123+123+123+123;<br />if&nbsp;(123)<br />{<br />}<br />}<br /><br />----------------------------<br />var0;<br />var1;<br />var2;<br />var0&nbsp;=&nbsp;123+123+123+123+123+123+123+123+123+123+123;</div></div><br /><br /><h1>总结</h1><br />我们在本讲义中介绍的技术非常出色，并显示了模糊测试的三个重要方面。<br /><br />首先，它显示了如何使用LibFuzzer进行语法感知的模糊测试的技术方面，这是本演练的明确而实用的目标。<br /><br />其次，它显示了有关libprotobuf-mutator的一些有趣的技术方面。 特别是，我们现在可以看到libprotobuf-mutator只是在LibFuzzer之上的复杂抽象构建，可用于许多不同的任务。这是令人难以置信的深刻见解，因为它为在LibFuzzer之上创建其他类型的常规添加打开了大门，这为进一步的有趣类型的Fuzzer打开了大门。到目前为止，在此过程中，我们一直在关注编写最多两百行代码的专用模糊器，而libprotobuf-mutator向我们展示了我们实际上可以在LibFuzzer之上构建任意复杂的模糊器。<br /><br />第三，在第二个方面之后，我们还开始看到LibFuzzer的强大功能，即在LibFuzzer之上构建复杂的模糊器意味着我们免费获得LibFuzzer开发的所有内容，尤其是覆盖率指导的模糊测试。请记住，LibFuzzer将使用coverage-instrumentation执行目标代码。 因此，我们在本讲座中开发的语法感知模糊技术将与实际目标集成后，将有效地成为“基于语法感知覆盖的进化模糊器”，这是我们本质上将这些技术真正强大地结合在一起 从Libfuzzer和Lib-protbuf变异器免费获得。通过这种方式，我们可以看到LibFuzzer使我们能够将覆盖率指导的模糊集成到其他类型的模糊测试技术中，这非常简单（相对于我们自己开发）。</div><div class='page'><h1 class='title level-4'>3_Completing_a_grammar_interface</h1><br/><h1>完成语法界面</h1><br /><br />请考虑以下示例语法片段：<br />语法<br /><div class="codebox"><div class="codebox">bottomRight&nbsp;::=&nbsp;....<br />bottomLeft&nbsp;::=&nbsp;.....<br />simpleTwo&nbsp;::=&nbsp;....<br />TopRule&nbsp;::=&nbsp;.....</div></div><br /><br />我们已经创建了该语法的protobuf定义，下面是该语法的摘要：<br /><h3>lang_grammar.proto</h3><br /><div class="codebox"><div class="codebox">syntax&nbsp;=&nbsp;&quot;proto2&quot;;<br />package&nbsp;EX;<br /><br />message&nbsp;bottomRight&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;....<br />}<br />message&nbsp;bottomLeft&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;....<br />}<br />message&nbsp;simpleTwo&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;....<br />}<br />message&nbsp;TopRule&nbsp;<span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;....<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />现在，实现模糊器的策略是覆盖protobuf文件中每种消息类型的&lt;&lt;操作符。 我们已经完成了其中一些操作，但只剩下一个，要求您完成最后一个函数签名：<br /><a href="http://fuzzer.cc/">fuzzer.cc</a><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;iostream&gt;<br />#include&nbsp;&lt;ostream&gt;<br />#include&nbsp;&lt;sstream&gt;<br />#include&nbsp;&lt;stdlib.h&gt;<br />#include&nbsp;&quot;lang_grammar.pb.h&quot;<br />#include&nbsp;&quot;port/protobuf.h&quot;<br />#include&nbsp;&quot;src/libfuzzer/libfuzzer_macro.h&quot;<br /><br />std::ostream&nbsp;&amp;operator&lt;&lt;(std::ostream&nbsp;&amp;os,&nbsp;const&nbsp;EX::bottomRight&amp;&nbsp;br);<br />std::ostream&nbsp;&amp;operator&lt;&lt;(std::ostream&nbsp;&amp;os,&nbsp;const&nbsp;EX::bottomLeft&amp;&nbsp;bl);<br />//&nbsp;Insert&nbsp;code&nbsp;below&nbsp;here<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />//&nbsp;Insert&nbsp;code&nbsp;above&nbsp;here.<br /><br />/*&nbsp;Implementation&nbsp;of&nbsp;TopRule&nbsp;which&nbsp;is&nbsp;the&nbsp;fuzzer&nbsp;entry&nbsp;point&nbsp;*/<br />DEFINE_PROTO_FUZZER(const&nbsp;EX::TopRule&amp;&nbsp;tr)&nbsp;<span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;std::ostringstream&nbsp;os;<br />&nbsp;&nbsp;&nbsp;&nbsp;os&nbsp;&lt;&lt;&nbsp;tr;<br />&nbsp;&nbsp;&nbsp;&nbsp;std::string&nbsp;lang_string&nbsp;=&nbsp;os.str();<br />&nbsp;&nbsp;&nbsp;&nbsp;target_code(lang_string);<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /></div><div class='page'><h1 class='title level-4'>4_Completing_a_grammar-aware_fuzz_snippet</h1><br/><h1>完成语法感知的模糊代码段</h1><br /><br />考虑以下protobuf消息的片段<br /><h3>lang_grammar.proto</h3><br /><div class="codebox"><div class="codebox">syntax&nbsp;=&nbsp;&quot;proto2&quot;;<br />package&nbsp;EX2;<br /><br />message&nbsp;RuleTwo&nbsp;<span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;required&nbsp;Simp&nbsp;sim&nbsp;=&nbsp;1;<br />&nbsp;&nbsp;required&nbsp;Rvalue&nbsp;the_left&nbsp;=&nbsp;2;<br />&nbsp;&nbsp;required&nbsp;Rvalue&nbsp;the_right&nbsp;=&nbsp;3;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />以下是我们的模糊器代码的片段，该片段将RuleTwo转换为字符串。 转换器的实现只是获取RuleTwo消息类型中每个字段的字符串。 请完成剩余的代码：<br /><a href="http://fuzzer.cc/">fuzzer.cc</a><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;iostream&gt;<br />#include&nbsp;&lt;ostream&gt;<br />#include&nbsp;&lt;sstream&gt;<br />#include&nbsp;&lt;stdlib.h&gt;<br />#include&nbsp;&quot;lang_grammar.pb.h&quot;<br />#include&nbsp;&quot;port/protobuf.h&quot;<br />#include&nbsp;&quot;src/libfuzzer/libfuzzer_macro.h&quot;<br /><br />std::ostream&nbsp;&amp;operator&lt;&lt;(std::ostream&nbsp;&amp;os,&nbsp;const&nbsp;EX2::RuleTwo&amp;&nbsp;rt)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;os&nbsp;&lt;&lt;&nbsp;rt.the_left();<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Insert&nbsp;code&nbsp;below&nbsp;here<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Insert&nbsp;code&nbsp;above&nbsp;here.<br />&nbsp;&nbsp;&nbsp;&nbsp;os&nbsp;&lt;&lt;&nbsp;rt.the_right();<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;os;<br />}<br /></div></div></div><div class='page'><h1 class='title level-3'>6_Assignment</h1><br/></div><div class='page'><h1 class='title level-4'>1_Structure-aware_fuzzing_assignment</h1><br/><h1>结构感知的fuzz作业</h1><br /><br /><h2>问题1：自定义变异器的实现</h2><br />在此问题中，要求您实现自定义更改程序例程。 具体来说，系统会要求您实现LLVMFuzzerCustomMutator版本，如本课程所示。 之后，您应该对LibFuzzer中的默认mutator函数与mutator函数之间的差异进行实证研究。 具体来说，您必须执行以下步骤：<br /><br />1、实现LLVMFuzzerCustomMutator的版本。 对于变异器的复杂性/行为没有要求。<br />2、将您的自定义变异器功能集成到您先前在课程中开发的一个模糊器中。<br />3、执行两次模糊测试：一次运行自定义mutator函数，另一次运行默认mutator函数。 将它们运行相同的时间（使用-max_total_time标志控制执行时间）并记录差异。<br /><br />您需要提交<br />自定义增变器的源代码<br />将其集成到现有的模糊器中<br />差异的数量测量，例如 实现的覆盖率差异与相似。<br /><br /><h2>问题2：哈希表的状态模糊测试</h2><br />在此问题中，要求您执行哈希表实现的状态模糊测试。 您将进行fuzzing的哈希表应用必须是以下项目之一：<br />• <a href="https://github.com/petewarden/c_hashmap">https://github.com/petewarden/c_hashmap</a><br />• <a href="https://github.com/tidwall/hashmap.c">https://github.com/tidwall/hashmap.c</a><br /><br />对于模糊测试活动，要求您记录以下步骤：<br />模糊测试脚本<br />编译模糊测试的脚本<br />实现的覆盖率以及发现的错误<br /><br /><h2>问题3：扩展我们的语言模糊器</h2><br />在这个问题中，要求您使用更多其他语言构造来扩展我们的语法感知语言模糊器。 目的是创建一个模糊器，以生成各种源代码示例集，而不是攻击特定目标。 在这种意义上，我们将使用语法感知的模糊器作为创建有趣的模糊器的场所，并在模糊器写作的基础方面练习我们的技能。<br /><br />在本练习中，将要求您扩展上一节中具有以下功能的语法意识模糊器：<br />if-else构造。 具体来说，以前的语法仅包含用于if条件的“ if”主体，并且具体地说，它对于if-else构造不产生任何内容。 请扩展语法，使其包含if-else构造的“ else”部分。<br /><br />调用原始函数的可能性。 具体来说，我们希望模糊器能够以给定的语言（例如C语言中的strlen，strcpy，strcat等）调用常见的API函数。 特定功能可以集成到语法本身中。<br /><br />任意函数类型声明。 语法模糊器必须能够创建任意函数。 这些功能的表达方式没有要求，例如 您可以决定是否包括参数传递，返回值等，但是，这些函数必须能够包含从语法的其余部分生成的代码。<br /><br />此练习可能非常耗时。 甚至正确设置的第一步也可能需要时间。 但是，学习这些功能可提供强大的模糊能力，并记住在整个过程中都使用您的讲师支持。</div><div class='page'><h1 class='title level-2'>5_In-depth_case_studies</h1><br/></div><div class='page'><h1 class='title level-3'>1_Introduction</h1><br/>	</div><div class='page'><h1 class='title level-4'>1_ Introduction</h1><br/><h1>介绍</h1><br /><br />在本节中，我们将分析大型实际应用中的模糊器设置的几种情况。 我们将从以模糊器为中心的角度研究fuzzer设置，这意味着我们将主要从模糊器的角度来研究项目，而不是覆盖模糊器目标的每个代码库。自然地，对于每个模糊器设置，其目标代码在创建模糊器之前就已经存在，并且在构造新的模糊器时，第一步始终是分析目标代码库并编写针对给定代码库的模糊器。这样，我们将略微跳过模糊器开发过程中的第一步，但是，本节的目的是研究现有模糊器的设置，以便我们可以提高针对类似应用程序的模糊器编写技能。<br /><br />我们将在本节中研究的应用程序是<br />• <a href="https://fluentbit.io/">Fluent Bit</a><br />• <a href="https://www.php.net/">PHP</a><br />• <a href="https://www.chromium.org/">Chromium</a><br /><br />在我们研究的每个项目中，我们将采用以下方法：<br /><br />通过以下方法分析现有的模糊器设置：<br />研究源代码；<br /> 建立模糊器； <br /> 运行模糊器。<br /><br />通过以下方式为项目构造一个新的模糊器：<br />分析项目中未被模糊器覆盖的部分； <br />提出涵盖未发现代码的模糊器源代码； <br />构建并运行模糊器。</div><div class='page'><h1 class='title level-3'>2_Fluent_Bit_fuzzing</h1><br/></div><div class='page'><h1 class='title level-4'>1_Fluent_Bit_introduction</h1><br/><h1>Fluent Bit introduction</h1><br /><br />在本节中，我们将研究和扩展Fluent Bit的模糊测试基础设施。  Fluent Bit是一个开源日志处理器和转发器，可用于执行以下任务，例如从各种来源收集日志/数据，将它们统一并发送到多个位置。这是一个云原生项目，与Docker以及Kubernetes环境完全兼容。<br /><br />Fluent Bit是用C编写的，这使其成为模糊测试的自然目标。 它运行在Linux上，这使其成为LibFuzzer的便捷目标，此外它还具有多种解析功能，例如 解析Json，LTSV和Logfmt数据。<br /></div><div class='page'><h1 class='title level-4'>2_Fluent Bit Introduction _ ADA Logics</h1><br/><a href=""><img src="images\982-1.png" alt="images\982-1.png" /></a><br /><br /><a href=""><img src="images\982-2.png" alt="images\982-2.png" /></a><br /><br /><h2>在源码中查看是否存在潜在攻击目标</h2><br /><br />查看src目录中的内容，根据文件名判断是否存在感兴趣的目标<br />src目录中发现parser字样的.c文件，此类文件常对应解析器程序，以字符串作为输出并处理字符串，适合进行fuzzing<br /><span style="color:#ff0000;">常见关键字<br />parser：解析器<br />pack:以相同形式对数据进行包装，从而时程序运行在不同架构计算机上<br />utils：工具类，常存在针对字符串的处理函数<br />url：网址字符串处理相关<br /><br />一般情况下，最终目标为fuzzing项目中所有代码，可以从parser相关程序开始fuzzing<br /></span><a href=""><img src="images\982-3.png" alt="images\982-3.png" /></a><br /><br />查看flb_parser.c文件，该文件中以char*作为参数的函数适合被fuzzing，即以函数参数类型为原则选择被fuzz ing的函数<br /><a href=""><img src="images\982-4.png" alt="images\982-4.png" /></a><br /><br />flb_parser_create函数中该部分代码表示可以创建针对json logfmt等数据格式的解析器<br /><a href=""><img src="images\982-5.png" alt="images\982-5.png" /></a><br /><br />该函数以配置文件作为输入加载paeser，同样可以通过libfuzzer进行fuzzing处理<br /><a href=""><img src="images\982-6.png" alt="images\982-6.png" /></a><br /><br />也是一个可以fuzzing的函数<br /><a href=""><img src="images\982-7.png" alt="images\982-7.png" /></a><br /><br /><h2>查看项目中提供的示例文件，弄清paeser相关函数如何被调用</h2><br /><br />即尝试将项目中的单元测试转换为fuzzer<br /><br />单元测试文件所在目录<br /><a href=""><img src="images\982-8.png" alt="images\982-8.png" /></a><br /><br />该目录中parser.c可能为该项目parser部分的单元测试，查看该文件<br /><a href=""><img src="images\982-9.png" alt="images\982-9.png" /></a><br /><br />该文件中搜索之前定位到的可以被fuzzing的api，发现此类api被调用，可以学习该类函数被调用的方法<br /><a href=""><img src="images\982-10.png" alt="images\982-10.png" /></a><br /><br />实际上该项目提供了现成的fuzzer<br /><a href=""><img src="images\982-11.png" alt="images\982-11.png" /></a><br /><br /><h2>尝试编译现有fuzzer</h2><br /><br />下载项目源码<br /><div class="codebox"><div class="codebox">apt-get&nbsp;install&nbsp;-y&nbsp;make&nbsp;cmake&nbsp;git<br />cd&nbsp;/work<br />git&nbsp;clone&nbsp;https://github.com/fluent/fluent-bit/<br />cd&nbsp;fluent-bit<br /></div></div><br /><br />执行如下脚本即可编译整个项目，包括项目中自带fuzzer<br /><br />注意脚本中cmake指令中存在“-DFLB_TESTS_INTERNAL_FUZZ=ON ”等flag，疑似为是否编译项目中自带fuzzer的开关<br /><br /><h3>build_fb.sh</h3><br /><div class="codebox"><div class="codebox">#&nbsp;set&nbsp;the&nbsp;correct&nbsp;environment&nbsp;variables<br />export&nbsp;CC=clang<br />export&nbsp;CXX=clang++<br />export&nbsp;CFLAGS=-fsanitize=fuzzer-no-link,address<br />export&nbsp;CXXFLAGS=-fsanitize=fuzzer-no-link,address<br />export&nbsp;LIB_FUZZING_ENGINE=-fsanitize=fuzzer<br /><br />#&nbsp;Move&nbsp;into&nbsp;the&nbsp;Fluent&nbsp;Bit&nbsp;directory<br />cd&nbsp;/work/fluent-bit<br /><br />#&nbsp;Prepare&nbsp;a&nbsp;build&nbsp;folder<br />rm&nbsp;-rf&nbsp;./build<br />mkdir&nbsp;build&nbsp;&amp;&amp;&nbsp;cd&nbsp;build<br /><br />#&nbsp;Fluent&nbsp;Bit&nbsp;contains&nbsp;a&nbsp;lot&nbsp;of&nbsp;plugins&nbsp;and&nbsp;we&nbsp;do&nbsp;not&nbsp;care&nbsp;about<br />#&nbsp;building&nbsp;either&nbsp;of&nbsp;these&nbsp;as&nbsp;we&nbsp;will&nbsp;fuzz&nbsp;the&nbsp;core.&nbsp;As&nbsp;such,<br />#&nbsp;disable&nbsp;all&nbsp;of&nbsp;the&nbsp;plugins.<br />INPUT_PLUGINS=&quot;-DFLB_IN_COLLECTD=OFF&nbsp;-DFLB_IN_CPU=OFF<br />-DFLB_IN_DISK=OFF&nbsp;-DFLB_IN_DOCKER=OFF&nbsp;-DFLB_IN_EXEC=OFF<br />-DFLB_IN_FORWARD=OFF&nbsp;-DFLB_IN_HEAD=OFF&nbsp;-DFLB_IN_HEALTH=OFF<br />-DFLB_IN_KMSG=OFF&nbsp;-DFLB_IN_MEM=OFF&nbsp;-DFLB_IN_MQTT=OFF<br />-DFLB_IN_NETIF=OFF&nbsp;-DFLB_IN_PROC=OFF&nbsp;-DFLB_IN_RANDOM=OFF<br />-DFLB_IN_SERIAL=OFF&nbsp;-DFLB_IN_STDIN=OFF&nbsp;-DFLB_IN_SYSLOG=OFF<br />-DFLB_IN_SYSTEMD=OFF&nbsp;-DFLB_IN_TAIL=OFF&nbsp;-DFLB_IN_TCP=OFF<br />-DFLB_IN_THERMAL=OFF&nbsp;-DFLB_IN_WINLOG=OFF&quot;<br /><br />OUTPUT_PLUGINS=&quot;-DFLB_RECORD_ACCESSOR=Off&nbsp;-DFLB_STREAM_PROCESSOR=Off<br />-DFLB_LUAJIT=OFF&nbsp;-DFLB_FILTER_GREP=OFF&nbsp;-DFLB_FILTER_REWRITE_TAG=OFF<br />-DFLB_OUT_AZURE=OFF&nbsp;-DFLB_OUT_BIGQUERY=OFF&nbsp;-DFLB_OUT_COUNTER=OFF<br />-DFLB_OUT_DATADOG=OFF&nbsp;-DFLB_OUT_ES=OFF&nbsp;-DFLB_OUT_FILE=OFF<br />-DFLB_OUT_FLOWCOUNTER=OFF&nbsp;-DFLB_OUT_FORWARD=OFF&nbsp;-DFLB_OUT_GELF=OFF<br />-DFLB_OUT_HTTP=OFF&nbsp;-DFLB_OUT_INFLUXDB=OFF&nbsp;-DFLB_OUT_KAFKA=OFF<br />-DFLB_OUT_KAFKA_REST=OFF&nbsp;-DFLB_OUT_NATS=OFF&nbsp;-DFLB_OUT_NULL=OFF<br />-DFLB_OUT_PGSQL=OFF&nbsp;-DFLB_OUT_PLOT=OFF&nbsp;-DFLB_OUT_SLACK=OFF<br />-DFLB_OUT_SPLUNK=OFF&nbsp;-DFLB_OUT_STACKDRIVER=OFF&nbsp;-DFLB_OUT_STDOUT=OFF<br />-DFLB_OUT_TCP=OFF&nbsp;-DFLB_OUT_SYSLOG=OFF&nbsp;-DFLB_OUT_NRLOGS=OFF<br />-DFLB_OUT_LOKI=OFF&quot;<br /><br />FILTER_PLUGINS=&quot;-DFLB_FILTER_RECORD_MODIFIER=OFF&nbsp;-DFLB_FILTER_MODIFY=OFF<br />-DFLB_FILTER_THROTTLE=OFF&nbsp;-DFLB_FILTER_KUBERNETES=OFF&nbsp;-DFLB_FILTER_NEST=OFF<br />-DFLB_FILTER_PARSER=OFF&nbsp;-DFLB_FILTER_AWS=OFF&nbsp;-DFLB_FILTER_ALTER_SIZE=OFF&quot;<br /><br />#&nbsp;Now&nbsp;call&nbsp;CMAKE&nbsp;with&nbsp;proper&nbsp;flags&nbsp;and&nbsp;then&nbsp;Make&nbsp;afterwards.<br />cmake&nbsp;-DMBEDTLS_FATAL_WARNINGS=OFF&nbsp;-DFLB_TESTS_INTERNAL=ON&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-DFLB_TESTS_INTERNAL_FUZZ=ON&nbsp;-DFLB_TESTS_OSSFUZZ=ON&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;${INPUT_PLUGINS}&nbsp;${FILTER_PLUGINS}&nbsp;${OUTPUT_PLUGINS}&nbsp;..<br />make</div></div><br /><br />编译过程中可以看到fuzzer相关可执行文件被创建<br /><a href=""><img src="images\982-12.png" alt="images\982-12.png" /></a><br /><br />编译完成后相关可执行文件放在fluent-bit/build/bin目录下<br />该目录下存在生成的fuzzer，但我们感兴趣的fuzzer是带有_OSSFUZZ的若干个<br />其中flb-it-fuzz-parser_json_fuzzer_OSSFUZZ对应了fuzzer源码中的parser_json_fuzzzer.c文件<br /><a href=""><img src="images\982-13.png" alt="images\982-13.png" /></a> <br /><br />关于OSSFUZZ<br /><a href="https://google.github.io/oss-fuzz/">https://google.github.io/oss-fuzz/</a><br /><a href="https://github.com/google/oss-fuzz">https://github.com/google/oss-fuzz</a><br /><br />执行此类fuzzer<br /><br /><br /><br /><br /><br /></div><div class='page'><h1 class='title level-4'>3_Fluent Bit fuzzer architecture _ ADA Logics</h1><br/>与之前使用的命令相同，下载项目源码并使用脚本编译（同时会编译项目中的fuzzer）<br />编译成功<br /><a href=""><img src="images\983-1.png" alt="images\983-1.png" /></a><br /><br />研究编译项目的脚本<br />脚本中起到重要作用的是cmake指令，其使用了三个特定的flags，如下图红框<br /><a href=""><img src="images\983-2.png" alt="images\983-2.png" /></a><br /><br />查看项目根目录中的CMakeLists.txt文件，可以看到falg的对应定义<br /><a href=""><img src="images\983-3.png" alt="images\983-3.png" /></a><br /><br />该文件中此处说明了如果FLB_TESTS_INTERNAL被定义，则会将tests/internal目录加入到相关路径中<br /><a href=""><img src="images\983-4.png" alt="images\983-4.png" /></a><br /><br />tests/internal目录中也有CMakeLists.txt文件，查看该文件内容<br /><a href=""><img src="images\983-5.png" alt="images\983-5.png" /></a><br /><br />该文件中搜索FLB_TESTS_INTERNAL_FUZZ，找到如下内容，即将tests/internal/fuzzer目录加入路径<br /><a href=""><img src="images\983-6.png" alt="images\983-6.png" /></a><br /><br />tests/internal/fuzzer目录中也存在CMakeLists.txt文件<br /><a href=""><img src="images\983-7.png" alt="images\983-7.png" /></a><br /><br />该文件前部分指示了用于生成fuzzer的.c文件，似乎可以通过在此处增加.c文件的文件名，从而生成新的fuzzer<br /><a href=""><img src="images\983-8.png" alt="images\983-8.png" /></a><br /><br />该文件中搜索FLB_TESTS_OSSFUZZ，找到如下内容，由于该flag的存在，最终才会生成_OSSFUZZ结尾的fuzzer，如果仅仅将该flag设置为off，则最后仅生成不带_OSSFUZZ的fuzzer<br /><a href=""><img src="images\983-9.png" alt="images\983-9.png" /></a>    <a href=""><img src="images\983-10.png" alt="images\983-10.png" /></a><br /><br /><h1>分析具体fuzzer</h1><br /><br /><h2>parser_xx_fizzer.c</h2><br /><br /><a href=""><img src="images\983-11.png" alt="images\983-11.png" /></a><br /><br /><h2>parser_fuzzer.c</h2><br /><br />parser_fuzzer.c中实现了项目中所有parser相关的代码的fuzzing，整体流程和parser_json_fuzzer.c等fuzzer差不多，但是parser_fuzzer.c上实现了关键函数flb_parser_create所有参数的随机化（如下图）<br /><a href=""><img src="images\983-12.png" alt="images\983-12.png" /></a><br /><br />与之相比parser_json_fuzzer.c等.c文件中flb_parser_create函数的参数大量使用NULL（如下图）<br /><a href=""><img src="images\983-13.png" alt="images\983-13.png" /></a><br /><br /><h2>flb_fuzz_header.h</h2><br /><br />flb_fuzz_header.h头文件中get_null_terminated函数用于产生null结尾的字符串<br />宏定义GRT_MOD_EQ函数用于根据随机数据返回0或1的结果<br />例如GRT_MOD_EQ(4,0)(data[0]%4)==0<br />该宏含义为随机数据的起始四字节数据与4做模运算，如果余数为0，则该宏返回1，否则返回0<br /><a href=""><img src="images\983-14.png" alt="images\983-14.png" /></a><br /><br />类似的可以使用以下四宏从而产生四个0或1的随机序列<br />GRT_MOD_EQ(4,0)<br />GRT_MOD_EQ(4,1)<br />GRT_MOD_EQ(4,2)<br />GRT_MOD_EQ(4,3)<br /><h3>parser_fuzzer.c</h3>中就使用了该技巧用于决定生成何种类型的parser<br /><a href=""><img src="images\983-15.png" alt="images\983-15.png" /></a><br /><br /><h2>strp_fuzzer.c</h2><br /><a href=""><img src="images\983-16.png" alt="images\983-16.png" /></a><br />其中flb_strptime函数来自flb_strptime.c源码文件，该文件中可以找到flb_strptime函数的定义<br /><a href=""><img src="images\983-17.png" alt="images\983-17.png" /></a><br /><br /><h2>utils_fuzzer.c</h2><br /><br />该fuzzer中调用了很多utils函数，此类函数来自flb_utils.c源码文件，单个utils函数所对应的代码量并不多，所以在该fuzzer中将多个utils连续进行调用，从而fuzzing<br />虽然此类函数较为简单，但仍有必要进行fuzzing，因为之后调用的函数可能受此类函数执行结果的影响<br /><a href=""><img src="images\983-18.png" alt="images\983-18.png" /></a><br /><br />utils_fuzzer.c中也调用了url、hash、gzip等相关函数，两函数分别来自flb_uri.c、flb_hash.c、flb_gzip.c<br /><a href=""><img src="images\983-19.png" alt="images\983-19.png" /></a><a href=""><img src="images\983-20.png" alt="images\983-20.png" /></a><br /><br />utils_fuzzer.c中来自libfuzzer的随机数据被用在很多位置<br /><a href=""><img src="images\983-21.png" alt="images\983-21.png" /></a><br /><br />根据随机数据生成的null结尾的字符串也被用于诸多位置，（注意多个函数使用相同的随机字符串进行fuzzing）<br /><a href=""><img src="images\983-22.png" alt="images\983-22.png" /></a><br /><br />运行utils_fuzzer.c生成的fuzzer，得到如下输出（因为编译选项中没有加-g，故没有输出crash在源码中的位置）<br /><a href=""><img src="images\983-23.png" alt="images\983-23.png" /></a><br /><br />找到出现crash的函数，分析crash原因可能是当len变量为0时，程序将访问time[-1]，从而导致crash<br /><a href=""><img src="images\983-24.png" alt="images\983-24.png" /></a><br /><br /><h2>运行strp的fuzzer</h2><br /><a href=""><img src="images\983-25.png" alt="images\983-25.png" /></a><br /><a href=""><img src="images\983-26.png" alt="images\983-26.png" /></a><br /><br /><h2>运行ltsv的fuzzer</h2><br /><a href=""><img src="images\983-27.png" alt="images\983-27.png" /></a><br />未发现crash<br /><a href=""><img src="images\983-28.png" alt="images\983-28.png" /></a><br /><br /><h2>运行json的fuzzer</h2><br /><a href=""><img src="images\983-29.png" alt="images\983-29.png" /></a><br />未发现crash<br /><br /><h2>运行logfmt的fuzzer</h2><br /><a href=""><img src="images\983-30.png" alt="images\983-30.png" /></a><br />未发现crash<br /><a href=""><img src="images\983-31.png" alt="images\983-31.png" /></a><br /><br /><h2>运行parser的fuzzer</h2><br /><a href=""><img src="images\983-32.png" alt="images\983-32.png" /></a><br />出现crash<br /><a href=""><img src="images\983-33.png" alt="images\983-33.png" /></a><br /><br />经过分析该crash可能是fuzzer实现存在缺陷导致，不是对应函数的问题<br /><a href=""><img src="images\983-34.png" alt="images\983-34.png" /></a><br /><br /><br /><br /><h2>fuzz思路</h2><span style="color:#ff0000;"><br /><br />尽可能将libfuzzer提供的随机数据使用在更多的库函数中，包括库函数不同的参数，包括根据随机数据决定函数不同的执行顺序等<br /><br />fuzzer过程中可以使用很多算法，从而方便地将随机数据转化为函数执行的随机性（例如取模运算可以根据libfuzzer提供的随机数据生成一定范围内的随机整数，以生成的随机整数作为函数执行的条件，从而将函数执行次序随机化）<br /><br />fuzzer中针对目标函数，在满足函数调用条件的前提下，尽可能将更多参数随机化，可以提高fuzzing效果<br /><br />fuzzer中从使用随机数据的函数开始，之后的函数在执行过程中均可能受到该随机数据的影响，从而暴露bug（前提是之后执行的函数会受到之前函数的执行结果的影响，例如将之前函数的返回值作为参数）<br /><br />在源码中，函数会经常与特定函数组合在一起使用，在fuzz过程中，可以将此类函数一起进行fuzz，从而在函数序列中传导随机数据，从而暴露bug<br /><br />util_fuzzer.c中针对多个源码文件中的不同函数进行了fuzzing，具体表现为将libfuzzer提供的随机数据尽可能多的传递给不同函数，多个函数可以来源于同一个源码文件，例如多个相互独立的utils函数（在同一fuzzer文件中依次调用进行fuzzing），多个函数也可以来源于不同源码文件，但是该多个函数常常在一起被使用（为了实现某种功能），所以实现了让随机数据在函数序列中传导</span></div><div class='page'><h1 class='title level-4'>4_Fluent Bit new fuzzer _ ADA Logics</h1><br/><h1>为项目创建新的fuzzer</h1><br /><br />当前已经拥有项目源码以及编译脚本<br /><a href=""><img src="images\984-1.png" alt="images\984-1.png" /></a><br /><br />查看src目录，可以发现flb_record_accessor.c源码文件<br /><a href=""><img src="images\984-2.png" alt="images\984-2.png" /></a><br /><br />搜索parser关键字，发现该文件中有很多，所以容易被fuzzing<br /><a href=""><img src="images\984-3.png" alt="images\984-3.png" /></a><br /><br />经过分析flb_ra_create中函数容易进行fuzzing且该函数存在关于缓冲区的复杂逻辑，故作为目标函数<br /><a href=""><img src="images\984-4.png" alt="images\984-4.png" /></a><br /><br />需要弄清flb_ra_create函数如何被调用，在fluent-bit/test/internal目录下存在使用该函数的单元测试<br /><a href=""><img src="images\984-5.png" alt="images\984-5.png" /></a><br /><br />该文件中这一段代码可以用于构造fuzzer<br /><a href=""><img src="images\984-6.png" alt="images\984-6.png" /></a><br /><br />最终的fuzzer代码<br /><a href=""><img src="images\984-7.png" alt="images\984-7.png" /></a><br /><br />将新fuzzer放入指定文件夹中<br /><a href=""><img src="images\984-8.png" alt="images\984-8.png" /></a><br /><br />将新fuzzer的文件名加入到CMakeLists.txt中<br /><a href=""><img src="images\984-9.png" alt="images\984-9.png" /></a><br /><br />重新运行脚本编译整个项目<br /><a href=""><img src="images\984-10.png" alt="images\984-10.png" /></a><br /><br />出现报错信息，未找到flb_ra_create函数的引用<br /><a href=""><img src="images\984-11.png" alt="images\984-11.png" /></a><br /><br />错误原因在于原版编译脚本中将-DFLB_RECORD_ACCESSOR设置为Off，从而导致flb_ra_create函数对应的源码文件未被编译，将该flag修改为On即可，修改完成后重新编译<br /><a href=""><img src="images\984-12.png" alt="images\984-12.png" /></a><br /><br />编译成功<br /><a href=""><img src="images\984-13.png" alt="images\984-13.png" /></a><br /><br />运行生成的fuzzer<br /><a href=""><img src="images\984-14.png" alt="images\984-14.png" /></a><br /><br />检测到内存泄露<br /><a href=""><img src="images\984-15.png" alt="images\984-15.png" /></a><br /><br />通过指定 -detect_leak=0从而在fuzz过程中忽略内存泄露<br /><a href=""><img src="images\984-16.png" alt="images\984-16.png" /></a><br /><br />重新执行fuzz后，由于实际输出的内容过多，不方便查看，故将输出重定位到txt文档中<br /><a href=""><img src="images\984-17.png" alt="images\984-17.png" /></a><br /><br />在生成的txt文件中过滤存在cov的内容<br /><a href=""><img src="images\984-18.png" alt="images\984-18.png" /></a><br /><br />之后查看该fuzzer覆盖了哪些部分的代码，并进一步扩充当前fuzzer，以图覆盖更多的代码<br /><br />扩充当前fuzzer时，可以根据创建fuzzer时参考的单元测试，将其中更多的代码逻辑引入到fuzzer中<br />例如当前目标函数为flb_ra_create，而单元测试中大量函数将flb_ra_create的返回值作为参数，故此类函数也可以被fuzzing测试<br /><a href=""><img src="images\984-19.png" alt="images\984-19.png" /></a></div><div class='page'><h1 class='title level-4'>5_Studying_existing_Fluent_Bit_fuzzing_infrastructure</h1><br/><h1>研究现有的Fluent Bit模糊化基础架构</h1><br /><br /><h2>Fluent Bit存储库概述</h2><br />以下是Fluent Bit源代码树顶部文件夹中的文件夹的概述：<br /><div class="codebox"><div class="codebox">bin<br />build<br />ci<br />cmake<br />conf<br />cpack<br />debian<br />documentation<br />examples<br />gen_static_conf<br />include<br />init<br />lib<br />plugins<br />scripts<br />snap<br />src<br />tests<br />tools</div></div><br /><br />对我们来说，最重要的两个文件夹是src和tests。  src文件夹包含Fluent Bit核心部分的源文件，而tests文件夹包含现有模糊器基础结构的逻辑。<br /><br />src文件夹的片段如下所示：<br /><div class="codebox"><div class="codebox">...<br />flb_log.c<br />flb_luajit.c<br />flb_meta.c<br />flb_metrics.c<br />flb_metrics_exporter.c<br />flb_mp.c<br />flb_network.c<br />flb_oauth2.c<br />flb_output.c<br />flb_pack.c<br />flb_pack_gelf.c<br />flb_parser.c<br />flb_parser_decoder.c<br />flb_parser_json.c<br />flb_parser_logfmt.c<br />flb_parser_ltsv.c<br />flb_parser_regex.c<br />flb_pipe.c<br />flb_plugin.c<br />flb_plugin_proxy.c<br />...</div></div><br /><br />Fluent Bit的源代码在C中，现在我们已经可以看到有名为flb_parser * .c的文件，这始终是开始模糊测试的好地方。 自然地，考虑到所有Fluent Bit内核都是用C编写的事实，理想情况下，我们希望攻击整个代码库，而不是将自己局限于解析器。<br /><br />在对构成Fluent Bit核心的文件进行了简短了解之后，我们将评估Fluent Bit的现有模糊器设置。  Fluent Bit的模糊器设置位于<strong>tests/internal/fuzzers</strong>中。 在此文件夹中，我们看到以下文件：<br /><br />从一般的角度来看，我们可以在此处看到三个不同的文件：<br />• A <code>CMakeLists.txt</code> file<br />• A <code>flb_fuzz_header.h</code> file<br />• A list of <code>*.c</code> files<br /><br />CMakeLists.txt包含构建模糊器所必需的逻辑。  flb_fuzz_header.h文件包含Fluent Bit的各种模糊器使用的常规功能，并且每个* .c文件都对应一个模糊器。<br /><br /><h2>构建和运行现有的模糊器</h2><br /><br />编译Fluent Bit的模糊器的第一步是在我们的Docker映像中创建一个有效目录，并克隆主要的Fluent Bit存储库：<br /><div class="codebox"><div class="codebox">apt-get&nbsp;install&nbsp;-y&nbsp;make&nbsp;cmake&nbsp;git<br />cd&nbsp;/work<br />git&nbsp;clone&nbsp;https://github.com/fluent/fluent-bit/<br />cd&nbsp;fluent-bit<br /></div></div><br /><br />现在，下一步是使用fuzzer支持编译Fluent Bit项目，我们可以使用以下脚本进行操作：<br /><h3>build_fb.sh</h3><br /><div class="codebox"><div class="codebox">#&nbsp;set&nbsp;the&nbsp;correct&nbsp;environment&nbsp;variables<br />export&nbsp;CC=clang<br />export&nbsp;CXX=clang++<br />export&nbsp;CFLAGS=-fsanitize=fuzzer-no-link,address<br />export&nbsp;CXXFLAGS=-fsanitize=fuzzer-no-link,address<br />export&nbsp;LIB_FUZZING_ENGINE=-fsanitize=fuzzer<br /><br />#&nbsp;Move&nbsp;into&nbsp;the&nbsp;Fluent&nbsp;Bit&nbsp;directory<br />cd&nbsp;/work/fluent-bit<br /><br />#&nbsp;Prepare&nbsp;a&nbsp;build&nbsp;folder<br />rm&nbsp;-rf&nbsp;./build<br />mkdir&nbsp;build&nbsp;&amp;&amp;&nbsp;cd&nbsp;build<br /><br />#&nbsp;Fluent&nbsp;Bit&nbsp;contains&nbsp;a&nbsp;lot&nbsp;of&nbsp;plugins&nbsp;and&nbsp;we&nbsp;do&nbsp;not&nbsp;care&nbsp;about<br />#&nbsp;building&nbsp;either&nbsp;of&nbsp;these&nbsp;as&nbsp;we&nbsp;will&nbsp;fuzz&nbsp;the&nbsp;core.&nbsp;As&nbsp;such,<br />#&nbsp;disable&nbsp;all&nbsp;of&nbsp;the&nbsp;plugins.<br />INPUT_PLUGINS=&quot;-DFLB_IN_COLLECTD=OFF&nbsp;-DFLB_IN_CPU=OFF<br />-DFLB_IN_DISK=OFF&nbsp;-DFLB_IN_DOCKER=OFF&nbsp;-DFLB_IN_EXEC=OFF<br />-DFLB_IN_FORWARD=OFF&nbsp;-DFLB_IN_HEAD=OFF&nbsp;-DFLB_IN_HEALTH=OFF<br />-DFLB_IN_KMSG=OFF&nbsp;-DFLB_IN_MEM=OFF&nbsp;-DFLB_IN_MQTT=OFF<br />-DFLB_IN_NETIF=OFF&nbsp;-DFLB_IN_PROC=OFF&nbsp;-DFLB_IN_RANDOM=OFF<br />-DFLB_IN_SERIAL=OFF&nbsp;-DFLB_IN_STDIN=OFF&nbsp;-DFLB_IN_SYSLOG=OFF<br />-DFLB_IN_SYSTEMD=OFF&nbsp;-DFLB_IN_TAIL=OFF&nbsp;-DFLB_IN_TCP=OFF<br />-DFLB_IN_THERMAL=OFF&nbsp;-DFLB_IN_WINLOG=OFF&quot;<br /><br />OUTPUT_PLUGINS=&quot;-DFLB_RECORD_ACCESSOR=Off&nbsp;-DFLB_STREAM_PROCESSOR=Off<br />-DFLB_LUAJIT=OFF&nbsp;-DFLB_FILTER_GREP=OFF&nbsp;-DFLB_FILTER_REWRITE_TAG=OFF<br />-DFLB_OUT_AZURE=OFF&nbsp;-DFLB_OUT_BIGQUERY=OFF&nbsp;-DFLB_OUT_COUNTER=OFF<br />-DFLB_OUT_DATADOG=OFF&nbsp;-DFLB_OUT_ES=OFF&nbsp;-DFLB_OUT_FILE=OFF<br />-DFLB_OUT_FLOWCOUNTER=OFF&nbsp;-DFLB_OUT_FORWARD=OFF&nbsp;-DFLB_OUT_GELF=OFF<br />-DFLB_OUT_HTTP=OFF&nbsp;-DFLB_OUT_INFLUXDB=OFF&nbsp;-DFLB_OUT_KAFKA=OFF<br />-DFLB_OUT_KAFKA_REST=OFF&nbsp;-DFLB_OUT_NATS=OFF&nbsp;-DFLB_OUT_NULL=OFF<br />-DFLB_OUT_PGSQL=OFF&nbsp;-DFLB_OUT_PLOT=OFF&nbsp;-DFLB_OUT_SLACK=OFF<br />-DFLB_OUT_SPLUNK=OFF&nbsp;-DFLB_OUT_STACKDRIVER=OFF&nbsp;-DFLB_OUT_STDOUT=OFF<br />-DFLB_OUT_TCP=OFF&nbsp;-DFLB_OUT_SYSLOG=OFF&nbsp;-DFLB_OUT_NRLOGS=OFF<br />-DFLB_OUT_LOKI=OFF&quot;<br /><br />FILTER_PLUGINS=&quot;-DFLB_FILTER_RECORD_MODIFIER=OFF&nbsp;-DFLB_FILTER_MODIFY=OFF<br />-DFLB_FILTER_THROTTLE=OFF&nbsp;-DFLB_FILTER_KUBERNETES=OFF&nbsp;-DFLB_FILTER_NEST=OFF<br />-DFLB_FILTER_PARSER=OFF&nbsp;-DFLB_FILTER_AWS=OFF&nbsp;-DFLB_FILTER_ALTER_SIZE=OFF&quot;<br /><br />#&nbsp;Now&nbsp;call&nbsp;CMAKE&nbsp;with&nbsp;proper&nbsp;flags&nbsp;and&nbsp;then&nbsp;Make&nbsp;afterwards.<br />cmake&nbsp;-DMBEDTLS_FATAL_WARNINGS=OFF&nbsp;-DFLB_TESTS_INTERNAL=ON&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-DFLB_TESTS_INTERNAL_FUZZ=ON&nbsp;-DFLB_TESTS_OSSFUZZ=ON&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;${INPUT_PLUGINS}&nbsp;${FILTER_PLUGINS}&nbsp;${OUTPUT_PLUGINS}&nbsp;..<br />make</div></div><br /><br />注意脚本中cmake指令中存在“-DFLB_TESTS_INTERNAL_FUZZ=ON ”等flag，疑似为是否编译项目中自带fuzzer的开关<br /><br /><h2>现有Fluent Bit模糊器概述</h2><br /><br />在这一点上，更详细地研究现有的模糊器是有意义的。 tests/internal/fuzzer存储库中的模糊器如下：<br /><div class="codebox"><div class="codebox">flb_json_fuzzer.c<br />http_fuzzer.c<br />msgpack_parse_fuzzer.c<br />msgpack_to_gelf_fuzzer.c<br />pack_json_state_fuzzer.c<br />parse_json_fuzzer.c<br />parse_logfmt_fuzzer.c<br />parse_ltsv_fuzzer.c<br />parser_fuzzer.c<br />strp_fuzzer.c<br />utils_fuzzer.c</div></div><br /><br />模糊器的一个引人注目的方面是，有四个名为parse * .c的模糊器和另一个名为msgpack_parse_fuzzer.c的模糊器。 这些模糊器很可能以src目录中的flb_parse _ *。c文件为目标。在此之后，还有其他各种模糊器似乎彼此之间没有规律，因此我们将逐个研究它们。 但是，在查看各个模糊器之前，有必要研究中央头文件flb_fuzz_header.h。<br /><br />我们可以采用多种不同的方法来研究现有的模糊器。 但是，关键目标之一是确定将来自模糊器的随机数据输入到目标应用程序中。 因此，重要的一步实质上是查看const uint8_t * data指针在模糊器中的使用位置。然后，另一个要素是查看目标库使用的特定功能，特别是关注必要的设置和清理例程。 这些也是我们研究Fluent Bit模糊器时要考虑的方面。<br /><h3>flb_fuzz_header.h</h3><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdint.h&gt;<br />#include&nbsp;&lt;string.h&gt;<br /><br />#define&nbsp;GET_MOD_EQ(max,&nbsp;idx)&nbsp;(data[0]&nbsp;%&nbsp;max)&nbsp;==&nbsp;idx<br />#define&nbsp;MOVE_INPUT(offset)&nbsp;data&nbsp;+=&nbsp;offset;&nbsp;size&nbsp;-=&nbsp;offset;<br /><br />char&nbsp;*get_null_terminated(size_t&nbsp;size,&nbsp;const&nbsp;uint8_t&nbsp;**data,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;*total_data_size)<br /><span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;char&nbsp;*tmp&nbsp;=&nbsp;flb_malloc(size+1);<br />&nbsp;&nbsp;memcpy(tmp,&nbsp;*data,&nbsp;size);<br />&nbsp;&nbsp;tmp[size]&nbsp;=&nbsp;&#39;\0&#39;;<br /><br />&nbsp;&nbsp;/*&nbsp;Modify&nbsp;the&nbsp;fuzz&nbsp;variables&nbsp;*/<br />&nbsp;&nbsp;*total_data_size&nbsp;-=&nbsp;size;<br />&nbsp;&nbsp;*data&nbsp;+=&nbsp;size;<br /><br />&nbsp;&nbsp;return&nbsp;tmp;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />parse_json_fuzzer.c模糊器以Fluent Bit的json解析例程为目标。 如果您正在分析部署了JSON的例程，则JSON解析例程始终是进行fuzzing的有趣目标。 模糊器的源代码如下：<br /><h3>parse_json_fuzzer.c</h3><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdint.h&gt;<br />#include&nbsp;&lt;string.h&gt;<br />#include&nbsp;&lt;stdlib.h&gt;<br />#include&nbsp;&lt;fluent-bit/flb_time.h&gt;<br />#include&nbsp;&lt;fluent-bit/flb_parser.h&gt;<br /><br />int&nbsp;LLVMFuzzerTestOneInput(const&nbsp;uint8_t&nbsp;*data,&nbsp;size_t&nbsp;size)<span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*out_buf&nbsp;=&nbsp;NULL;<br />&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;out_size&nbsp;=&nbsp;0;<br />&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;flb_time&nbsp;out_time;<br />&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;flb_config&nbsp;*fuzz_config;<br />&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;flb_parser&nbsp;*fuzz_parser;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;json&nbsp;parser&nbsp;*/<br />&nbsp;&nbsp;&nbsp;&nbsp;fuzz_config&nbsp;=&nbsp;flb_config_init();<br />&nbsp;&nbsp;&nbsp;&nbsp;fuzz_parser&nbsp;=&nbsp;flb_parser_create(&quot;fuzzer&quot;,&nbsp;&quot;json&quot;,&nbsp;NULL,&nbsp;NULL,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NULL,&nbsp;NULL,&nbsp;MK_FALSE,&nbsp;NULL,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0,&nbsp;NULL,&nbsp;fuzz_config);<br />&nbsp;&nbsp;&nbsp;&nbsp;flb_parser_do(fuzz_parser,&nbsp;(char*)data,&nbsp;size,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;out_buf,&nbsp;&amp;out_size,&nbsp;&amp;out_time);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(out_buf&nbsp;!=&nbsp;NULL)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(out_buf);<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;flb_parser_destroy(fuzz_parser);<br />&nbsp;&nbsp;&nbsp;&nbsp;flb_config_exit(fuzz_config);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />我们可以看到，模糊器总共由五个Fluent Bit特定例程组成：<br />• <code>flb_config_init</code><br />• <code>flb_parser_create</code><br />• <code>flb_parser_do</code><br />• <code>flb_parser_destroy</code><br />• <code>flb_config_exit</code><br /><br />其中四个功能与fuzzing设置有关：flb_config_init，flb_parser_create用于设置，而flb_parser_destory和flb_config_exit用于清理。仅执行flb_paser_do函数时受到随机数据影响，没有其他Fluent Bit函数显式或隐式传递随机数据。 因此，此模糊器实际上正在分析flb_parser_do的代码。<br /><br />parse_logfmt_fuzzer.c的结构与parse_json_fuzzer.c的结构非常相似，实际上只有一点点不同。 这是parse_logfmt_fuzzer.c的源代码：<br /><h3>parse_logfmt_fuzzer.c</h3><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdint.h&gt;<br />#include&nbsp;&lt;string.h&gt;<br />#include&nbsp;&lt;stdlib.h&gt;<br />#include&nbsp;&lt;fluent-bit/flb_time.h&gt;<br />#include&nbsp;&lt;fluent-bit/flb_parser.h&gt;<br /><br />int&nbsp;LLVMFuzzerTestOneInput(const&nbsp;uint8_t&nbsp;*data,&nbsp;size_t&nbsp;size)<span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*out_buf&nbsp;=&nbsp;NULL;<br />&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;out_size&nbsp;=&nbsp;0;<br />&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;flb_time&nbsp;out_time;<br />&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;flb_config&nbsp;*fuzz_config;<br />&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;flb_parser&nbsp;*fuzz_parser;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;logfmt&nbsp;parser&nbsp;*/<br />&nbsp;&nbsp;&nbsp;&nbsp;fuzz_config&nbsp;=&nbsp;flb_config_init();<br />&nbsp;&nbsp;&nbsp;&nbsp;fuzz_parser&nbsp;=&nbsp;flb_parser_create(&quot;fuzzer&quot;,&nbsp;&quot;logfmt&quot;,&nbsp;NULL,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NULL,&nbsp;NULL,&nbsp;NULL,&nbsp;MK_FALSE,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NULL,&nbsp;0,&nbsp;NULL,&nbsp;fuzz_config);<br />&nbsp;&nbsp;&nbsp;&nbsp;flb_parser_do(fuzz_parser,&nbsp;(char*)data,&nbsp;size,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;out_buf,&nbsp;&amp;out_size,&nbsp;&amp;out_time);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(out_buf&nbsp;!=&nbsp;NULL)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(out_buf);<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;flb_parser_destroy(fuzz_parser);<br />&nbsp;&nbsp;&nbsp;&nbsp;flb_config_exit(fuzz_config);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />唯一的区别在于对flb_parser_create的调用，其中parse_json_fuzzer.c中的第二个参数是字符串“ json”，而parse_logfmt_fuzzer.c中的flb_parser_create的第二个参数是字符串“ logfmt”。这样，就可以清楚地看到每个模糊器如何以不同的解析例程为目标，即通过将flb_parser_create函数的第二个参数设置为它们要针对的数据格式的名称。<br /><br />前两个模糊器分别针对Fluent Bit的单独解析例程。 但是，从这个意义上讲，parser_fuzzer.c更为笼统，其目的是针对Fluent位的所有各种数据格式解析例程。<br /><h3>parser_fuzzer.c</h3><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdint.h&gt;<br />#include&nbsp;&lt;string.h&gt;<br />#include&nbsp;&lt;stdlib.h&gt;<br />#include&nbsp;&lt;fluent-bit/flb_time.h&gt;<br />#include&nbsp;&lt;fluent-bit/flb_parser.h&gt;<br />#include&nbsp;&lt;fluent-bit/flb_parser_decoder.h&gt;<br /><br />#include&nbsp;&quot;flb_fuzz_header.h&quot;<br /><br />#define&nbsp;TYPES_LEN&nbsp;5<br /><br />int&nbsp;LLVMFuzzerTestOneInput(const&nbsp;uint8_t&nbsp;*data,&nbsp;size_t&nbsp;size)<br /><span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*format&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;NULL;<br />&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*time_fmt&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;NULL;<br />&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*time_key&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;NULL;<br />&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*time_offset&nbsp;=&nbsp;NULL;<br />&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*pregex&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;NULL;<br />&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;flb_parser_types&nbsp;*types&nbsp;=&nbsp;NULL;<br />&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;flb_config&nbsp;*fuzz_config&nbsp;=&nbsp;NULL;<br />&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;flb_parser&nbsp;*fuzz_parser&nbsp;=&nbsp;NULL;<br />&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;time_keep&nbsp;=&nbsp;0;<br />&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;types_len&nbsp;=&nbsp;0;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(size&nbsp;&lt;&nbsp;100)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;json&nbsp;parser&nbsp;*/<br />&nbsp;&nbsp;&nbsp;&nbsp;fuzz_config&nbsp;=&nbsp;flb_config_init();<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;format&nbsp;+&nbsp;pregex&nbsp;*/<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(GET_MOD_EQ(4,0))&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;format&nbsp;=&nbsp;&quot;json&quot;;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;(GET_MOD_EQ(4,1))&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;format&nbsp;=&nbsp;&quot;regex&quot;;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pregex&nbsp;=&nbsp;malloc(30);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pregex[29]&nbsp;=&nbsp;&#39;\0&#39;;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(pregex,&nbsp;data,&nbsp;29);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data&nbsp;+=&nbsp;29;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size&nbsp;-=&nbsp;29;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;(GET_MOD_EQ(4,2))&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;format&nbsp;=&nbsp;&quot;ltsv&quot;;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;format&nbsp;=&nbsp;&quot;logfmt&quot;;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;MOVE_INPUT(1);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;time_fmt&nbsp;*/<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(GET_MOD_EQ(2,1))&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;time_fmt&nbsp;=&nbsp;get_null_terminated(15,&nbsp;&amp;data,&nbsp;&amp;size);<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;MOVE_INPUT(1);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;time_key&nbsp;*/<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(GET_MOD_EQ(2,1))&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;time_key&nbsp;=&nbsp;get_null_terminated(15,&nbsp;&amp;data,&nbsp;&amp;size);<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;MOVE_INPUT(1);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;time_offset&nbsp;*/<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(GET_MOD_EQ(2,1))&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;time_offset&nbsp;=&nbsp;get_null_terminated(15,&nbsp;&amp;data,&nbsp;&amp;size);<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;MOVE_INPUT(1);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;time_keep&nbsp;*/<br />&nbsp;&nbsp;&nbsp;&nbsp;time_keep&nbsp;=&nbsp;(GET_MOD_EQ(2,1))&nbsp;?&nbsp;MK_TRUE&nbsp;:&nbsp;MK_FALSE;<br />&nbsp;&nbsp;&nbsp;&nbsp;MOVE_INPUT(1);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;types_str&nbsp;*/<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(GET_MOD_EQ(2,1))&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;types&nbsp;=&nbsp;&nbsp;flb_malloc(sizeof(struct&nbsp;flb_parser_types)&nbsp;*&nbsp;TYPES_LEN);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*parser_type_keys[5]&nbsp;=&nbsp;{&quot;AAA&quot;,&nbsp;&quot;BBB&quot;,&nbsp;&quot;CCC&quot;,&nbsp;&quot;DDD&quot;,&nbsp;&quot;EEE&quot;&nbsp;};<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;parser_types[5]&nbsp;=&nbsp;{FLB_PARSER_TYPE_INT,&nbsp;FLB_PARSER_TYPE_FLOAT,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FLB_PARSER_TYPE_BOOL,&nbsp;FLB_PARSER_TYPE_STRING,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FLB_PARSER_TYPE_HEX};<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;TYPES_LEN;&nbsp;i++)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;types[i].key&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;strdup(parser_type_keys[i]);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;types[i].key_len&nbsp;=&nbsp;strlen(parser_type_keys[i]);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;types[i].type&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;parser_types[i];<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;types_len&nbsp;=&nbsp;TYPES_LEN;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;MOVE_INPUT(1);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;decoders&nbsp;*/<br />&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;mk_list&nbsp;*list&nbsp;=&nbsp;NULL;<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(GET_MOD_EQ(2,1))&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MOVE_INPUT(1);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list&nbsp;=&nbsp;flb_malloc(sizeof(struct&nbsp;mk_list));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mk_list_init(list);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;flb_parser_dec&nbsp;*dec&nbsp;=&nbsp;malloc(sizeof(struct&nbsp;flb_parser_dec));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dec-&gt;key&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;flb_sds_create_len(&quot;AAA&quot;,&nbsp;3);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dec-&gt;buffer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;flb_sds_create_size(FLB_PARSER_DEC_BUF_SIZE);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dec-&gt;add_extra_keys&nbsp;=&nbsp;FLB_TRUE;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mk_list_init(&amp;dec-&gt;rules);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mk_list_add(&amp;dec-&gt;_head,&nbsp;list);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;flb_parser_dec_rule&nbsp;*dec_rule&nbsp;=&nbsp;malloc(sizeof(struct&nbsp;flb_parser_dec_rule));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dec_rule-&gt;type&nbsp;=&nbsp;(int)(data[0]&nbsp;%&nbsp;0x02);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MOVE_INPUT(1);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dec_rule-&gt;backend&nbsp;=&nbsp;(int)(data[0]&nbsp;%&nbsp;0x04);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MOVE_INPUT(1);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dec_rule-&gt;action&nbsp;=&nbsp;(int)data[0]&nbsp;%&nbsp;0x03;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mk_list_add(&amp;dec_rule-&gt;_head,&nbsp;&amp;dec-&gt;rules);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(GET_MOD_EQ(2,1))&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;flb_parser_dec_rule&nbsp;*dec_rule2&nbsp;=&nbsp;malloc(sizeof(struct&nbsp;flb_parser_dec_rule));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dec_rule2-&gt;type&nbsp;=&nbsp;(int)(data[0]&nbsp;%&nbsp;0x02);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MOVE_INPUT(1);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dec_rule2-&gt;backend&nbsp;=&nbsp;(int)(data[0]&nbsp;%&nbsp;0x04);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MOVE_INPUT(1);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dec_rule-&gt;action&nbsp;=&nbsp;(int)data[0]&nbsp;%&nbsp;0x03;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mk_list_add(&amp;dec_rule2-&gt;_head,&nbsp;&amp;dec-&gt;rules);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;MOVE_INPUT(1);<br />&nbsp;&nbsp;&nbsp;&nbsp;fuzz_parser&nbsp;=&nbsp;flb_parser_create(&quot;fuzzer&quot;,&nbsp;format,&nbsp;pregex,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;time_fmt,&nbsp;time_key,&nbsp;time_offset,&nbsp;time_keep,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;types,&nbsp;types_len,&nbsp;list,&nbsp;fuzz_config);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Second&nbsp;step&nbsp;is&nbsp;to&nbsp;use&nbsp;the&nbsp;random&nbsp;parser&nbsp;to&nbsp;parse&nbsp;random&nbsp;input&nbsp;*/<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(fuzz_parser&nbsp;!=&nbsp;NULL)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*out_buf&nbsp;=&nbsp;NULL;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;out_size&nbsp;=&nbsp;0;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;flb_time&nbsp;out_time;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flb_parser_do(fuzz_parser,&nbsp;(char*)data,&nbsp;size,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;out_buf,&nbsp;&amp;out_size,&nbsp;&amp;out_time);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(out_buf&nbsp;!=&nbsp;NULL)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(out_buf);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flb_parser_destroy(fuzz_parser);<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Parser&nbsp;creation&nbsp;failed&nbsp;but&nbsp;we&nbsp;still&nbsp;need&nbsp;to&nbsp;clean<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;up&nbsp;types&nbsp;and&nbsp;decoders&nbsp;*/<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(types&nbsp;!=&nbsp;NULL)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i=0;&nbsp;i&lt;&nbsp;TYPES_LEN;&nbsp;i++){<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flb_free(types[i].key);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flb_free(types);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(list&nbsp;!=&nbsp;NULL)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flb_parser_decoder_list_destroy(list);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Cleanup&nbsp;everything&nbsp;but&nbsp;the&nbsp;parser&nbsp;*/<br />&nbsp;&nbsp;&nbsp;&nbsp;flb_config_exit(fuzz_config);<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(time_fmt&nbsp;!=&nbsp;NULL)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flb_free(time_fmt);<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(time_key&nbsp;!=&nbsp;NULL)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flb_free(time_key);<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(time_offset&nbsp;!=&nbsp;NULL)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flb_free(time_offset);<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(pregex&nbsp;!=&nbsp;NULL)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flb_free(pregex);<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />parser_fuzzer.c比其他前面提到的解析器模糊器复杂得多。 特别地，parser_fuzzer.c的目标是使用随机数据来影响（1）解析器生成和（2）数据解析中的每个决策。从这个意义上讲，parser_fuzzer.c在探索Fluent Bit项目中可用的所有代码方面做出了巨大的努力。<br /><br /><h3>http_fuzzer.c</h3><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdlib.h&gt;<br />#include&nbsp;&lt;fluent-bit/flb_time.h&gt;<br />#include&nbsp;&lt;fluent-bit/flb_parser.h&gt;<br />#include&nbsp;&lt;fluent-bit/flb_info.h&gt;<br />#include&nbsp;&lt;fluent-bit/flb_mem.h&gt;<br />#include&nbsp;&lt;fluent-bit/flb_error.h&gt;<br />#include&nbsp;&lt;fluent-bit/flb_socket.h&gt;<br />#include&nbsp;&lt;fluent-bit/flb_http_client.h&gt;<br /><br />#include&nbsp;&quot;flb_fuzz_header.h&quot;<br /><br />int&nbsp;LLVMFuzzerTestOneInput(const&nbsp;uint8_t&nbsp;*data,&nbsp;size_t&nbsp;size)<br /><span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;flb_upstream&nbsp;*u;<br />&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;flb_upstream_conn&nbsp;*u_conn&nbsp;=&nbsp;NULL;<br />&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;flb_http_client&nbsp;*c;<br />&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;flb_config&nbsp;*config;<br />&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*uri&nbsp;=&nbsp;NULL;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(size&nbsp;&lt;&nbsp;120)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;config&nbsp;=&nbsp;flb_config_init();<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(config&nbsp;==&nbsp;NULL)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;u&nbsp;=&nbsp;flb_upstream_create(config,&nbsp;&quot;127.0.0.1&quot;,&nbsp;8001,&nbsp;0,&nbsp;NULL);<br />&nbsp;&nbsp;&nbsp;&nbsp;u_conn&nbsp;=&nbsp;flb_malloc(sizeof(struct&nbsp;flb_upstream_conn));<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(u_conn&nbsp;==&nbsp;NULL)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br />&nbsp;&nbsp;&nbsp;&nbsp;u_conn-&gt;u&nbsp;=&nbsp;u;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*proxy&nbsp;=&nbsp;NULL;<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(GET_MOD_EQ(2,1))&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proxy&nbsp;=&nbsp;get_null_terminated(50,&nbsp;&amp;data,&nbsp;&amp;size);<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;uri&nbsp;=&nbsp;get_null_terminated(20,&nbsp;&amp;data,&nbsp;&amp;size);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;method&nbsp;=&nbsp;(int)data[0];<br />&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;flb_http_client(u_conn,&nbsp;method,&nbsp;uri,&nbsp;NULL,&nbsp;0,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;127.0.0.1&quot;,&nbsp;8001,&nbsp;proxy,&nbsp;0);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(c&nbsp;!=&nbsp;NULL)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*null_terminated&nbsp;=&nbsp;get_null_terminated(size-20,&nbsp;&amp;data,&nbsp;&amp;size);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Perform&nbsp;a&nbsp;set&nbsp;of&nbsp;operations&nbsp;on&nbsp;the&nbsp;http_client&nbsp;*/<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flb_http_basic_auth(c,&nbsp;null_terminated,&nbsp;null_terminated);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flb_http_set_content_encoding_gzip(c);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flb_http_set_keepalive(c);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flb_http_strip_port_from_host(c);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flb_http_allow_duplicated_headers(c,&nbsp;0);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flb_http_buffer_size(c,&nbsp;(*(size_t&nbsp;*)data)&nbsp;&amp;&nbsp;0xfff);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MOVE_INPUT(4)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flb_http_add_header(c,&nbsp;&quot;User-Agent&quot;,&nbsp;10,&nbsp;&quot;Fluent-Bit&quot;,&nbsp;10);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flb_http_add_header(c,&nbsp;(char*)data,&nbsp;size,&nbsp;&quot;Fluent-Bit&quot;,&nbsp;10);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flb_http_buffer_size(c,&nbsp;(int)data[0]);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MOVE_INPUT(1)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flb_http_buffer_available(c);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;out_size&nbsp;=&nbsp;0;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flb_http_buffer_increase(c,&nbsp;(*(size_t&nbsp;*)data)&nbsp;&amp;&nbsp;0xfff,&nbsp;&amp;out_size);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MOVE_INPUT(4)<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;b_sent;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flb_http_do(c,&nbsp;&amp;b_sent);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flb_http_client_destroy(c);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flb_free(null_terminated);<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;flb_free(u_conn);<br />&nbsp;&nbsp;&nbsp;&nbsp;flb_upstream_destroy(u);<br />&nbsp;&nbsp;&nbsp;&nbsp;flb_config_exit(config);<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(uri&nbsp;!=&nbsp;NULL)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flb_free(uri);<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(proxy&nbsp;!=&nbsp;NULL)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flb_free(proxy);<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><h3>utils_fuzzer.c</h3><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdint.h&gt;<br />#include&nbsp;&lt;string.h&gt;<br />#include&nbsp;&lt;stdlib.h&gt;<br />#include&nbsp;&lt;msgpack.h&gt;<br />#include&nbsp;&lt;fluent-bit/flb_mem.h&gt;<br />#include&nbsp;&lt;fluent-bit/flb_utils.h&gt;<br />#include&nbsp;&lt;fluent-bit/flb_gzip.h&gt;<br />#include&nbsp;&lt;fluent-bit/flb_hash.h&gt;<br />#include&nbsp;&lt;fluent-bit/flb_uri.h&gt;<br /><br />int&nbsp;LLVMFuzzerTestOneInput(const&nbsp;uint8_t&nbsp;*data,&nbsp;size_t&nbsp;size)<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;We&nbsp;need&nbsp;a&nbsp;bit&nbsp;of&nbsp;data&nbsp;in&nbsp;this&nbsp;fuzzer&nbsp;*/<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(size&nbsp;&lt;&nbsp;600)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Prepare&nbsp;a&nbsp;general&nbsp;null-terminated&nbsp;string&nbsp;*/<br />&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*null_terminated&nbsp;=&nbsp;(char*)malloc(size+1);<br />&nbsp;&nbsp;&nbsp;&nbsp;null_terminated[size]&nbsp;=&nbsp;&#39;\0&#39;;<br />&nbsp;&nbsp;&nbsp;&nbsp;memcpy(null_terminated,&nbsp;data,&nbsp;size);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Fuzzing&nbsp;of&nbsp;flb_utils.c&nbsp;*/<br />&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;sec;<br />&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;nsec;<br />&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;new_size;<br />&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*prot&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;NULL;<br />&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*host&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;NULL;<br />&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*port&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;NULL;<br />&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*uri&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;NULL;<br />&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*new_dst&nbsp;=&nbsp;NULL;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;new_dst&nbsp;=&nbsp;(char*)malloc(size&nbsp;*&nbsp;2);<br />&nbsp;&nbsp;&nbsp;&nbsp;flb_utils_write_str_buf(null_terminated,&nbsp;size,&nbsp;&amp;new_dst,&nbsp;&amp;new_size);<br />&nbsp;&nbsp;&nbsp;&nbsp;flb_free(new_dst);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;mk_list&nbsp;*list&nbsp;=&nbsp;flb_utils_split(null_terminated,&nbsp;&#39;A&#39;,&nbsp;3);<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(list&nbsp;!=&nbsp;NULL)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flb_utils_split_free(list);<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;flb_utils_url_split(null_terminated,&nbsp;&amp;prot,&nbsp;&amp;host,&nbsp;&amp;port,&nbsp;&amp;uri);<br />&nbsp;&nbsp;&nbsp;&nbsp;flb_utils_size_to_bytes(null_terminated);<br />&nbsp;&nbsp;&nbsp;&nbsp;flb_utils_time_split(null_terminated,&nbsp;&amp;sec,&nbsp;&amp;nsec);<br />&nbsp;&nbsp;&nbsp;&nbsp;flb_utils_time_to_seconds(null_terminated);<br />&nbsp;&nbsp;&nbsp;&nbsp;flb_utils_bool(null_terminated);<br />&nbsp;&nbsp;&nbsp;&nbsp;flb_utils_hex2int(null_terminated,&nbsp;size);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Fuzzong&nbsp;of&nbsp;flb_uri.c&nbsp;*/<br />&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;flb_uri&nbsp;*uri2&nbsp;=&nbsp;NULL;<br />&nbsp;&nbsp;&nbsp;&nbsp;uri2&nbsp;=&nbsp;flb_uri_create(null_terminated);<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(uri2&nbsp;!=&nbsp;NULL)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flb_uri_get(uri2,&nbsp;(int)data[0]);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flb_uri_dump(uri2);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flb_uri_destroy(uri2);<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;flb_uri_encode((char*)data,&nbsp;size);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Fuzzing&nbsp;of&nbsp;flb_hash.c&nbsp;*/<br />&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;flb_hash&nbsp;*ht&nbsp;=&nbsp;NULL;<br />&nbsp;&nbsp;&nbsp;&nbsp;ht&nbsp;=&nbsp;flb_hash_create((int)(data[2]&nbsp;%&nbsp;0x04),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(size_t)data[0],<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(int)data[1]);<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(ht&nbsp;!=&nbsp;NULL)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flb_hash_add(ht,&nbsp;null_terminated,&nbsp;size,&nbsp;null_terminated,&nbsp;size);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*out_buf&nbsp;=&nbsp;NULL;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;out_size;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flb_hash_get(ht,&nbsp;null_terminated,&nbsp;size,&nbsp;(const&nbsp;char&nbsp;**)&amp;out_buf,&nbsp;&amp;out_size);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;now&nbsp;let&#39;s&nbsp;create&nbsp;some&nbsp;more&nbsp;instances&nbsp;*/<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*instances1[128]&nbsp;=&nbsp;{&nbsp;NULL&nbsp;};<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*instances2[128]&nbsp;=&nbsp;{&nbsp;NULL&nbsp;};<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;128;&nbsp;i++)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*in1&nbsp;=&nbsp;malloc(3);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*in2&nbsp;=&nbsp;malloc(3);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(in1,&nbsp;data+(i*4),&nbsp;2);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(in2,&nbsp;data+(i*4)+2,&nbsp;2);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in1[2]&nbsp;=&nbsp;&#39;\0&#39;;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in2[2]&nbsp;=&nbsp;&#39;\0&#39;;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flb_hash_add(ht,&nbsp;in1,&nbsp;2,&nbsp;in2,&nbsp;2);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instances1[i]&nbsp;=&nbsp;in1;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instances2[i]&nbsp;=&nbsp;in2;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;20;&nbsp;i++)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*hash_out_buf;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;hash_out_size;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flb_hash_get_by_id(ht,&nbsp;(int)data[i],&nbsp;(char*)&amp;data[i+1],<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(const&nbsp;char&nbsp;**)&amp;hash_out_buf,&nbsp;&amp;hash_out_size);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flb_hash_destroy(ht);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=0;&nbsp;i&lt;128;&nbsp;i++)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flb_free(instances1[i]);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flb_free(instances2[i]);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Fuzzing&nbsp;of&nbsp;flb_gzip.c&nbsp;*/<br />&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*str&nbsp;=&nbsp;NULL;<br />&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;len;<br />&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*out_data&nbsp;=&nbsp;NULL;<br />&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;out_len;<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(flb_gzip_compress((char*)data,&nbsp;size,&nbsp;&amp;str,&nbsp;&amp;len)&nbsp;!=&nbsp;-1)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flb_gzip_uncompress(str,&nbsp;len,&nbsp;&amp;out_data,&nbsp;&amp;out_len);<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(str&nbsp;!=&nbsp;NULL)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(str);<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(out_data&nbsp;!=&nbsp;NULL)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(out_data);<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*out_data2&nbsp;=&nbsp;NULL;<br />&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;out2_len;<br />&nbsp;&nbsp;&nbsp;&nbsp;flb_gzip_uncompress((char*)data,&nbsp;size,&nbsp;&amp;out_data2,&nbsp;&amp;out2_len);<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(out_data2&nbsp;!=&nbsp;NULL)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flb_free(out_data2);<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;General&nbsp;cleanup&nbsp;*/<br />&nbsp;&nbsp;&nbsp;&nbsp;flb_free(null_terminated);<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br />}<br /></div></div><br /><br /><h3>strp_fuzzer.c</h3><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdint.h&gt;<br />#include&nbsp;&lt;string.h&gt;<br />#include&nbsp;&lt;stdlib.h&gt;<br />#include&nbsp;&lt;fluent-bit/flb_time.h&gt;<br />#include&nbsp;&lt;fluent-bit/flb_parser.h&gt;<br />#include&nbsp;&lt;msgpack.h&gt;<br />#include&nbsp;&lt;fluent-bit/flb_info.h&gt;<br />#include&nbsp;&lt;fluent-bit/flb_mem.h&gt;<br />#include&nbsp;&lt;fluent-bit/flb_pack.h&gt;<br />#include&nbsp;&lt;fluent-bit/flb_utils.h&gt;<br />#include&nbsp;&lt;fluent-bit/flb_version.h&gt;<br />#include&nbsp;&lt;fluent-bit/flb_strptime.h&gt;<br />#include&nbsp;&quot;flb_fuzz_header.h&quot;<br /><br />int&nbsp;LLVMFuzzerTestOneInput(const&nbsp;uint8_t&nbsp;*data,&nbsp;size_t&nbsp;size)<br /><span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(size&nbsp;&lt;&nbsp;40)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*fmt&nbsp;=&nbsp;get_null_terminated(size&nbsp;-&nbsp;30,&nbsp;&amp;data,&nbsp;&amp;size);<br />&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*buf&nbsp;=&nbsp;get_null_terminated(size,&nbsp;&amp;data,&nbsp;&amp;size);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;tm&nbsp;tt;<br />&nbsp;&nbsp;&nbsp;&nbsp;flb_strptime(buf,&nbsp;fmt,&nbsp;&amp;tt);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;flb_free(buf);<br />&nbsp;&nbsp;&nbsp;&nbsp;flb_free(fmt);<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /></div><div class='page'><h1 class='title level-4'>6_Coming_up_with_a_new_fluent_Bit_fuzzer</h1><br/><h1>提出一个新的fluent Bit Fuzzer</h1><br /><br />现在，我们的下一步是为Fluent Bit设计一个新的模糊器。 为此，我们将使用以下模糊器并将其放置在locatoin tests / internals / fuzzers / ra_parse_fuzzer.c中：<br /><br /><h3>ra_parse_fuzzer.c</h3><br /><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;fluent-bit/flb_info.h&gt;<br />#include&nbsp;&lt;fluent-bit/flb_mem.h&gt;<br />#include&nbsp;&lt;fluent-bit/flb_error.h&gt;<br />#include&nbsp;&lt;fluent-bit/flb_sds.h&gt;<br />#include&nbsp;&lt;fluent-bit/flb_pack.h&gt;<br />#include&nbsp;&lt;fluent-bit/flb_record_accessor.h&gt;<br />#include&nbsp;&lt;fluent-bit/record_accessor/flb_ra_parser.h&gt;<br />#include&nbsp;&lt;msgpack.h&gt;<br />#include&nbsp;&quot;flb_fuzz_header.h&quot;<br /><br />int&nbsp;LLVMFuzzerTestOneInput(const&nbsp;uint8_t&nbsp;*data,&nbsp;size_t&nbsp;size)<br /><span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(size&nbsp;&lt;&nbsp;100)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;flb_record_accessor&nbsp;*ra&nbsp;=&nbsp;NULL;<br />&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*null_terminated&nbsp;=&nbsp;get_null_terminated(size,&nbsp;&amp;data,&nbsp;&amp;size);<br />&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*ra_str&nbsp;=&nbsp;flb_sds_create(null_terminated);<br />&nbsp;&nbsp;&nbsp;&nbsp;ra&nbsp;=&nbsp;flb_ra_create(ra_str,&nbsp;FLB_FALSE);<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!ra)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flb_free(null_terminated);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;flb_ra_destroy(ra);<br />&nbsp;&nbsp;&nbsp;&nbsp;flb_sds_destroy(ra_str);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;General&nbsp;cleanup&nbsp;*/<br />&nbsp;&nbsp;&nbsp;&nbsp;flb_free(null_terminated);<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />下一步是将模糊器集成到放置在tests / internals / fuzzers / CMakeLists.txt的CMakeLists.txt文件中，尤其是将模糊器的文件名包含在文件顶部：<br /><div class="codebox"><div class="codebox">set(UNIT_TESTS_FILES<br />&nbsp;&nbsp;ra_parse_fuzzer.c<br />....</div></div><br /><br />现在，我们可以通过重新编译Fluent Bit来简单地运行我们的模糊器，但是，为此，我们首先需要在Docker映像内安装其他库：<br /><h3>apt-get install flex bison</h3><br /><br />并且还要从我们的build_fb.sh脚本中删除-DFLB_RECORD_ACCESSOR = Off文本。 完成此操作后，我们现在可以再次编译Fluent Bit并运行我们的新模糊器，它将放置在build / bin目录中。<br /><br /><br /><br /></div><div class='page'><h1 class='title level-3'>3_PHP_fuzzing</h1><br/></div><div class='page'><h1 class='title level-4'>1_PHP_introduction</h1><br/><h1>PHP介绍  </h1><br />在本节中，我们将研究PHP的模糊测试。  PHP是最著名的语言之一，并且已在许多基于Web的项目中大量部署。 这使得它成为一个非常相关的项目，因为其中有许多系统依赖于PHP的安全性。在本节中，我们将研究现有的PHP模糊器设置，并使用新颖的模糊器扩展该设置。 本部分的主要目标是突出显示围绕PHP模糊测试的体系结构，并展示该项目的一些有趣特征。特别是，我们不会像这样大量地研究PHP的源代码，而是尝试将范围限制在PHP的模糊测试特定方面。</div><div class='page'><h1 class='title level-4'>2_PHP Fuzzing introduction _ ADA Logics</h1><br/>php源码<br /><a href=""><img src="images\990-1.png" alt="images\990-1.png" /></a><br /><br />两个关键目录，后者中存在fuzzer目录<br /><a href=""><img src="images\990-2.png" alt="images\990-2.png" /></a> <a href=""><img src="images\990-3.png" alt="images\990-3.png" /></a><br /><br />fuzzer目录中的内容<br /><a href=""><img src="images\990-4.png" alt="images\990-4.png" /></a><br /><br />Zend目录保存整个PHP虚拟机的实现<br /><a href=""><img src="images\990-5.png" alt="images\990-5.png" /></a><br /><br /><h2>分析fuzzer-mbstring.c文件</h2><br /><span style="color:#ff0000;">LLVMFuzzerInitialize函数被libfuzzer核心调用，仅在首次运行该fuzzer时执行一次，并且在LLVMFuzzerTestOneInput函数之前执行</span><br /><a href=""><img src="images\990-6.png" alt="images\990-6.png" /></a><br /><br />搜索mb_ereg函数，该函数用于正则表达式匹配<br /><a href=""><img src="images\990-7.png" alt="images\990-7.png" /></a><br /><br />查看fuzzer_request_startup函数的实现，该函数实现在fuzzer_sapi.c文件中，该文件仅为其他fuzzer提供api，本身并不进行fuzzing<br /><a href=""><img src="images\990-8.png" alt="images\990-8.png" /></a><br /><br />fuzzer_request_startup函数调用了php_request_startup函数，php_request_startup函数实现在项目的mian文件夹中<br /><a href=""><img src="images\990-9.png" alt="images\990-9.png" /></a><br /><br />查看fuzzer_init_php函数，该函数实现在fuzzer_sapi.c中<br />该函数的关键调用在于sapi_startup函数<br /><a href=""><img src="images\990-10.png" alt="images\990-10.png" /></a><br /><br />查看fuzzer_request_shutdown函数，该函数实现在fuzzer_sapi.c中<br />该函数关键调用是php_request_shutdown()<br /><a href=""><img src="images\990-11.png" alt="images\990-11.png" /></a><br /><br />同理查看fuzzer_setup_dummy_frame<br /><a href=""><img src="images\990-12.png" alt="images\990-12.png" /></a><br /><br />同理查看fuzzer_call_php_func<br />其中ZVAL_STRING函数用于char*类型的参数字符串转为php类型字符串，以此作为函数参数<br /><a href=""><img src="images\990-13.png" alt="images\990-13.png" /></a><br /><br /><h2>分析fuzzer_parser.c文件</h2><br />关键函数：fuzzer_do_request_from_buffer<br /><a href=""><img src="images\990-14.png" alt="images\990-14.png" /></a><br /><br />查看fuzzer_do_request_from_buffer实现（实现在fuzzer_sapi.c文件中）<br /><a href=""><img src="images\990-15.png" alt="images\990-15.png" /></a><br /><br /><br /><h2>分析fuzzer_execute.c文件</h2><br /><br />原理上看该fuzzer可以fuzzing php核心的任意代码，（通过构建任意的php语言结构），该fuzzer是该项目中最通用的fuzzer<br /><br />该文件中共LLVMFuzzerInitialize函数中除了初始化php的函数，还会给三个静态变量设置函数指针，该三个函数也实现在当前文件中<br /><br />该fuzzer核心函数为fuzzer_do_request_from_buffer，且调用该函数时第四个参数为1，说明该函数最终会将输入的随机数据编译为file，且使用该file调用zend_execute函数，即执行php引擎解析php文件的过程<br /><a href=""><img src="images\990-16.png" alt="images\990-16.png" /></a><br /><br />三个函数中fuzzer_execute_ex会作为回调函数<br /><a href=""><img src="images\990-17.png" alt="images\990-17.png" /></a><br /><br />另外两个函数疑似在程序编译过程中进行劫持，即将程序原本要编译的函数替换为自己实现的函数，目的可能是减少需要编译的代码量，提高fuzzer的编译、执行效率<br /><br />该fuzzer可以结合语法感知fuzzer的技巧进一步提升fuzzer效率<br /><br /><br /><br /><br /><br /><br /><br /><br /></div><div class='page'><h1 class='title level-4'>3_PHP Fuzzing adding a new fuzzer _ ADA Logics</h1><br/><h1>构建fuzzer</h1><br /><br />fuzzer目录中有两个文件与构建fuzzer相关<br /><a href=""><img src="images\991-1.png" alt="images\991-1.png" /></a><br /><br />Makefile.frag文件中包含fuzzer相关条目，若要新增fuzzer，疑似需要在该文件中增加对应条目<br /><a href=""><img src="images\991-2.png" alt="images\991-2.png" /></a><br /><br />config.m4的底部也存在疑似对应具体fuzzer的条目<br /><a href=""><img src="images\991-3.png" alt="images\991-3.png" /></a><br /><br />config.m4中相关flag说明了若要将fuzzer编译到项目中，需要使用--enable-fuzzer的flag<br /><a href=""><img src="images\991-4.png" alt="images\991-4.png" /></a><br /><br />使用脚本编译php项目以及fuzzer （具体脚本见下一篇内容）<br /><a href=""><img src="images\991-5.png" alt="images\991-5.png" /></a><br /><br />编译完成后，进入fuzzer目录<br /><a href=""><img src="images\991-6.png" alt="images\991-6.png" /></a><br /><br />找到如下fuzzer可执行文件，可以依次执行此类fuzzer<br /><a href=""><img src="images\991-7.png" alt="images\991-7.png" /></a><br /><br />在执行php_fuzz_execute函数过程中，由于会将随机数据编译成php文件让php引擎执行，所以可以使用已有php程序文件作为种子执行fuzzer<br /><br /><h1>新创建fuzzer</h1><br />以fuzzer_mbstring.c为模板，调用其他的php函数进行fuzzing<br /><br />在fuzzzer目录下创建新的fuzzer的源码（具体源码见5)<br /><a href=""><img src="images\991-8.png" alt="images\991-8.png" /></a><br /><br />新fuzzer中的目标函数为preg_match，该函数用于判断指定字符串是否符合给定正则表达式的模式<br /><a href=""><img src="images\991-9.png" alt="images\991-9.png" /></a><br /><br />将新版fuzzer的信息增加到Makefile.frag以及config.m4中（详见5）<br /><a href=""><img src="images\991-10.png" alt="images\991-10.png" /></a><br /><br /><a href=""><img src="images\991-11.png" alt="images\991-11.png" /></a><br /><br />创建fuzz_build.sh脚本，该脚本与之前编译php项目和fuzzer的区别没有重新下载php源码项目，而是在重新编译当前的php项目，从而生成新的fuzzer(详细脚本见5)<br /><br />创建编译脚本重新编译php项目<br /><a href=""><img src="images\991-12.png" alt="images\991-12.png" /></a><br /><br />想要进一步进行php的fuzzer，需要进一步理解php源码，从而查看还有那些fuzzing切入点<br /><br /><br /><br /><br /><br /><br /><br /></div><div class='page'><h1 class='title level-4'>4_Studying_existing_PHP_fuzzing_infrastructure</h1><br/><h1>研究现有的PHP模糊化基础架构</h1><br />在本节中，我们将研究PHP的LibFuzzer设置。<br /><br /><h1>PHP源代码树概述</h1><br />php-srcsource树中的顶级文件夹如下：<br /><div class="codebox"><div class="codebox">php-src<br />&nbsp;&nbsp;&nbsp;|---&gt;&nbsp;appveyor<br />&nbsp;&nbsp;&nbsp;|---&gt;&nbsp;azure<br />&nbsp;&nbsp;&nbsp;|---&gt;&nbsp;build<br />&nbsp;&nbsp;&nbsp;|---&gt;&nbsp;docs<br />&nbsp;&nbsp;&nbsp;|---&gt;&nbsp;ext<br />&nbsp;&nbsp;&nbsp;|---&gt;&nbsp;main<br />&nbsp;&nbsp;&nbsp;|---&gt;&nbsp;pear<br />&nbsp;&nbsp;&nbsp;|---&gt;&nbsp;sapi<br />&nbsp;&nbsp;&nbsp;|---&gt;&nbsp;scripts<br />&nbsp;&nbsp;&nbsp;|---&gt;&nbsp;tests<br />&nbsp;&nbsp;&nbsp;|---&gt;&nbsp;travis<br />&nbsp;&nbsp;&nbsp;|---&gt;&nbsp;TSRM<br />&nbsp;&nbsp;&nbsp;|---&gt;&nbsp;win32<br />&nbsp;&nbsp;&nbsp;|---&gt;&nbsp;Zend</div></div><br /><br />Zend目录包含Z-engine的代码，Z-engine是PHP语言的核心执行引擎。  ext文件夹包含PHP上的所有扩展，这是一长串的PHP语言所使用的第三方库，例如通过Oniguruma库支持正则表达式。main文件夹包含与PHP可执行文件相关的逻辑，因此，它是整个项目的粘合剂。sapi文件夹包含PHP附带的各种开发人员工具，并且所有模糊测试逻辑都位于该文件夹中。 模糊测试的目标是位于Zend和ext目录中的代码。<br /><br /><h2>通用设置</h2><br />PHP的模糊器设置位于源树中的sapi / fuzzer /<br /><br /><h2>PHP模糊测试器</h2><br />像往常一样，要研究模糊测试器，我们将遵循以下方法：<br />1、查找随机数据的使用位置<br />2、标识初始化和清理代码<br /><br />PHP SAPI设置使我们能够：<br />1、轻松调用php函数<br />2、使用Zend helper方法创建PHP变量<br />3、轻松初始化和关闭PHP<br /><br /><h3>mbstring模糊测试</h3><br />mbstring模糊测试程序针对ext文件夹中的扩展，用于模糊PHP的正则表达式库。 特别是，针对的相应PHP函数是mb_ereg和mb_eregi。 模糊器的源代码如下：<br /><h3>fuzzer-mbstring.c</h3><br /><div class="codebox"><div class="codebox">/*<br />&nbsp;&nbsp;&nbsp;+----------------------------------------------------------------------+<br />&nbsp;&nbsp;&nbsp;|&nbsp;Copyright&nbsp;(c)&nbsp;The&nbsp;PHP&nbsp;Group&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br />&nbsp;&nbsp;&nbsp;+----------------------------------------------------------------------+<br />&nbsp;&nbsp;&nbsp;|&nbsp;This&nbsp;source&nbsp;file&nbsp;is&nbsp;subject&nbsp;to&nbsp;version&nbsp;3.01&nbsp;of&nbsp;the&nbsp;PHP&nbsp;license,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br />&nbsp;&nbsp;&nbsp;|&nbsp;that&nbsp;is&nbsp;bundled&nbsp;with&nbsp;this&nbsp;package&nbsp;in&nbsp;the&nbsp;file&nbsp;LICENSE,&nbsp;and&nbsp;is&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br />&nbsp;&nbsp;&nbsp;|&nbsp;available&nbsp;through&nbsp;the&nbsp;world-wide-web&nbsp;at&nbsp;the&nbsp;following&nbsp;url:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br />&nbsp;&nbsp;&nbsp;|&nbsp;http://www.php.net/license/3_01.txt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br />&nbsp;&nbsp;&nbsp;|&nbsp;If&nbsp;you&nbsp;did&nbsp;not&nbsp;receive&nbsp;a&nbsp;copy&nbsp;of&nbsp;the&nbsp;PHP&nbsp;license&nbsp;and&nbsp;are&nbsp;unable&nbsp;to&nbsp;&nbsp;&nbsp;|<br />&nbsp;&nbsp;&nbsp;|&nbsp;obtain&nbsp;it&nbsp;through&nbsp;the&nbsp;world-wide-web,&nbsp;please&nbsp;send&nbsp;a&nbsp;note&nbsp;to&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br />&nbsp;&nbsp;&nbsp;|&nbsp;license@php.net&nbsp;so&nbsp;we&nbsp;can&nbsp;mail&nbsp;you&nbsp;a&nbsp;copy&nbsp;immediately.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br />&nbsp;&nbsp;&nbsp;+----------------------------------------------------------------------+<br />&nbsp;&nbsp;&nbsp;|&nbsp;Authors:&nbsp;Stanislav&nbsp;Malyshev&nbsp;&lt;stas@php.net&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br />&nbsp;&nbsp;&nbsp;+----------------------------------------------------------------------+<br />&nbsp;*/<br /><br /><br />#include&nbsp;&quot;fuzzer.h&quot;<br /><br />#include&nbsp;&quot;Zend/zend.h&quot;<br />#include&nbsp;&quot;main/php_config.h&quot;	<br />#include&nbsp;&quot;main/php_main.h&quot;<br />#include&nbsp;&quot;oniguruma.h&quot;<br /><br />#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;stdint.h&gt;<br />#include&nbsp;&lt;stdlib.h&gt;<br /><br />#include&nbsp;&quot;fuzzer-sapi.h&quot;<br /><br />int&nbsp;LLVMFuzzerTestOneInput(const&nbsp;uint8_t&nbsp;*Data,&nbsp;size_t&nbsp;Size)&nbsp;{<br />#ifdef&nbsp;HAVE_MBREGEX<br />	char&nbsp;*args[2];<br />	char&nbsp;*data&nbsp;=&nbsp;malloc(Size+1);<br />	memcpy(data,&nbsp;Data,&nbsp;Size);<br />	data[Size]&nbsp;=&nbsp;&#39;\0&#39;;<br /><br />	if&nbsp;(fuzzer_request_startup()&nbsp;==&nbsp;FAILURE)&nbsp;{<br />		return&nbsp;0;<br />	}<br /><br />	args[0]&nbsp;=&nbsp;data;<br />	args[1]&nbsp;=&nbsp;&quot;test123&quot;;<br />	fuzzer_call_php_func(&quot;mb_ereg&quot;,&nbsp;2,&nbsp;args);<br /><br />	args[0]&nbsp;=&nbsp;data;<br />	args[1]&nbsp;=&nbsp;&quot;test123&quot;;<br />	fuzzer_call_php_func(&quot;mb_eregi&quot;,&nbsp;2,&nbsp;args);<br /><br />	args[0]&nbsp;=&nbsp;data;<br />	args[1]&nbsp;=&nbsp;data;<br />	fuzzer_call_php_func(&quot;mb_ereg&quot;,&nbsp;2,&nbsp;args);<br /><br />	args[0]&nbsp;=&nbsp;data;<br />	args[1]&nbsp;=&nbsp;data;<br />	fuzzer_call_php_func(&quot;mb_eregi&quot;,&nbsp;2,&nbsp;args);<br /><br />	php_request_shutdown(NULL);<br /><br />	free(data);<br />#else<br />	fprintf(stderr,&nbsp;&quot;\n\nERROR:\nPHP&nbsp;built&nbsp;without&nbsp;mbstring,&nbsp;recompile&nbsp;with&nbsp;--enable-mbstring&nbsp;to&nbsp;use&nbsp;this&nbsp;fuzzer\n&quot;);<br />	exit(1);<br />#endif<br />	return&nbsp;0;<br />}<br /><br />int&nbsp;LLVMFuzzerInitialize(int&nbsp;*argc,&nbsp;char&nbsp;***argv)&nbsp;<span style="color:#000000;font-weight:400">{</span><br />	fuzzer_init_php();<br /><br />	/*&nbsp;The&nbsp;default&nbsp;parse&nbsp;depth&nbsp;limit&nbsp;allows&nbsp;stack&nbsp;overflows&nbsp;under&nbsp;asan.&nbsp;*/<br />	onig_set_parse_depth_limit(512);<br /><br />	/*&nbsp;fuzzer_shutdown_php();&nbsp;*/<br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />LLVMFuzzerTestOneInput的第一部分只是将来自模糊器的数据包装到通过malloc分配的内存中的以空字符结尾的字符串中。 然后，要启动PHP，模糊器将调用fuzzer_request_startup，并在此之后进行对php特定功能的四个调用，即对mb_ereg和mb_eregi的各两次调用。这两个调用都使用随机模糊数据作为目标函数的输入。 最后，将调用php_request_shutdown函数，该函数将清理PHP执行状态。<br /><br />模糊器非常简单，其核心复杂性在于函数fuzzer_request_startup，fuzzer_call_php_func和php_request_shutdown，因此让我们研究它们。<br /><br />fuzzer_request_startup的来源如下：<br /><div class="codebox"><div class="codebox">int&nbsp;fuzzer_request_startup()<br /><span style="color:#000000;font-weight:400">{</span><br />	if&nbsp;(php_request_startup()&nbsp;==&nbsp;FAILURE)&nbsp;{<br />		php_module_shutdown();<br />		return&nbsp;FAILURE;<br />	}<br /><br />#ifdef&nbsp;ZEND_SIGNALS<br />	/*&nbsp;Some&nbsp;signal&nbsp;handlers&nbsp;will&nbsp;be&nbsp;overridden,<br />	&nbsp;*&nbsp;don&#39;t&nbsp;complain&nbsp;about&nbsp;them&nbsp;during&nbsp;shutdown.&nbsp;*/<br />	SIGG(check)&nbsp;=&nbsp;0;<br />#endif<br /><br />	return&nbsp;SUCCESS;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />此代码仅调用php_request_startup函数，我们假设该函数启动了PHP引擎。 我们不需要任何更多细节来继续进行模糊测试，因此我们只需要了解fuzzer_request_startup即可，了解它调用了php_request_startup函数。<br /><br />fuzzer_shutdown_php的源代码如下：<br /><div class="codebox"><div class="codebox">int&nbsp;fuzzer_shutdown_php()<br /><span style="color:#000000;font-weight:400">{</span><br />	php_module_shutdown();<br />	sapi_shutdown();<br /><br />	free(fuzzer_module.ini_entries);<br />	return&nbsp;SUCCESS;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />此代码仅调用php_module_shutdown和sapi_shutdown，它们都是内部PHP函数。 因此，我们将不做任何更详细的介绍，因为这对于我们理解PHP模糊测试程序的代码是不需要的。<br /><br /><h2>解析器模糊测试</h2><br />php解析器模糊器依赖于集成的PHP编译器，并且模糊器的源代码如下：<br /><h3>fuzzer-parser.c</h3><br /><div class="codebox"><div class="codebox">/*<br />&nbsp;&nbsp;&nbsp;+----------------------------------------------------------------------+<br />&nbsp;&nbsp;&nbsp;|&nbsp;Copyright&nbsp;(c)&nbsp;The&nbsp;PHP&nbsp;Group&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br />&nbsp;&nbsp;&nbsp;+----------------------------------------------------------------------+<br />&nbsp;&nbsp;&nbsp;|&nbsp;This&nbsp;source&nbsp;file&nbsp;is&nbsp;subject&nbsp;to&nbsp;version&nbsp;3.01&nbsp;of&nbsp;the&nbsp;PHP&nbsp;license,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br />&nbsp;&nbsp;&nbsp;|&nbsp;that&nbsp;is&nbsp;bundled&nbsp;with&nbsp;this&nbsp;package&nbsp;in&nbsp;the&nbsp;file&nbsp;LICENSE,&nbsp;and&nbsp;is&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br />&nbsp;&nbsp;&nbsp;|&nbsp;available&nbsp;through&nbsp;the&nbsp;world-wide-web&nbsp;at&nbsp;the&nbsp;following&nbsp;url:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br />&nbsp;&nbsp;&nbsp;|&nbsp;http://www.php.net/license/3_01.txt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br />&nbsp;&nbsp;&nbsp;|&nbsp;If&nbsp;you&nbsp;did&nbsp;not&nbsp;receive&nbsp;a&nbsp;copy&nbsp;of&nbsp;the&nbsp;PHP&nbsp;license&nbsp;and&nbsp;are&nbsp;unable&nbsp;to&nbsp;&nbsp;&nbsp;|<br />&nbsp;&nbsp;&nbsp;|&nbsp;obtain&nbsp;it&nbsp;through&nbsp;the&nbsp;world-wide-web,&nbsp;please&nbsp;send&nbsp;a&nbsp;note&nbsp;to&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br />&nbsp;&nbsp;&nbsp;|&nbsp;license@php.net&nbsp;so&nbsp;we&nbsp;can&nbsp;mail&nbsp;you&nbsp;a&nbsp;copy&nbsp;immediately.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br />&nbsp;&nbsp;&nbsp;+----------------------------------------------------------------------+<br />&nbsp;&nbsp;&nbsp;|&nbsp;Authors:&nbsp;Johannes&nbsp;Schlüter&nbsp;&lt;johanes@php.net&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br />&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stanislav&nbsp;Malyshev&nbsp;&lt;stas@php.net&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br />&nbsp;&nbsp;&nbsp;+----------------------------------------------------------------------+<br />&nbsp;*/<br /><br />#include&nbsp;&lt;main/php.h&gt;<br />#include&nbsp;&lt;main/php_main.h&gt;<br />#include&nbsp;&lt;main/SAPI.h&gt;<br />#include&nbsp;&lt;ext/standard/info.h&gt;<br />#include&nbsp;&lt;ext/standard/php_var.h&gt;<br />#include&nbsp;&lt;main/php_variables.h&gt;<br /><br />#include&nbsp;&quot;fuzzer.h&quot;<br />#include&nbsp;&quot;fuzzer-sapi.h&quot;<br /><br />int&nbsp;LLVMFuzzerTestOneInput(const&nbsp;uint8_t&nbsp;*Data,&nbsp;size_t&nbsp;Size)&nbsp;{<br />	char&nbsp;*s;<br />	if&nbsp;(Size&nbsp;&gt;&nbsp;32&nbsp;*&nbsp;1024)&nbsp;{<br />		/*&nbsp;Large&nbsp;inputs&nbsp;have&nbsp;a&nbsp;large&nbsp;impact&nbsp;on&nbsp;fuzzer&nbsp;performance,<br />		&nbsp;*&nbsp;but&nbsp;are&nbsp;unlikely&nbsp;to&nbsp;be&nbsp;necessary&nbsp;to&nbsp;reach&nbsp;new&nbsp;codepaths.&nbsp;*/<br />		return&nbsp;0;<br />	}<br /><br />	s&nbsp;=&nbsp;malloc(Size+1);<br />	memcpy(s,&nbsp;Data,&nbsp;Size);<br />	s[Size]&nbsp;=&nbsp;&#39;\0&#39;;<br /><br />	fuzzer_do_request_from_buffer(&quot;fuzzer.php&quot;,&nbsp;s,&nbsp;Size);<br /><br />	/*&nbsp;Do&nbsp;not&nbsp;free&nbsp;s:&nbsp;fuzzer_do_request_from_buffer()&nbsp;takes&nbsp;ownership&nbsp;of&nbsp;the&nbsp;allocation.&nbsp;*/<br />	return&nbsp;0;<br />}<br /><br />int&nbsp;LLVMFuzzerInitialize(int&nbsp;*argc,&nbsp;char&nbsp;***argv)&nbsp;<span style="color:#000000;font-weight:400">{</span><br />	/*&nbsp;Compilation&nbsp;will&nbsp;often&nbsp;trigger&nbsp;fatal&nbsp;errors.<br />	&nbsp;*&nbsp;Use&nbsp;tracked&nbsp;allocation&nbsp;mode&nbsp;to&nbsp;avoid&nbsp;leaks&nbsp;in&nbsp;that&nbsp;case.&nbsp;*/<br />	putenv(&quot;USE_TRACKED_ALLOC=1&quot;);<br /><br />	fuzzer_init_php();<br /><br />	/*&nbsp;fuzzer_shutdown_php();&nbsp;*/<br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />sapi / fuzzer / fuzzer-sapi.c中的fuzzer_do_request_from_buffer的代码如下：<br /><h3>fuzzer-sapi.c</h3><br /><div class="codebox"><div class="codebox">int&nbsp;fuzzer_do_request_from_buffer(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*filename,&nbsp;const&nbsp;char&nbsp;*data,&nbsp;size_t&nbsp;data_len,&nbsp;zend_bool&nbsp;execute)<br /><span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;retval&nbsp;=&nbsp;FAILURE;&nbsp;/*&nbsp;failure&nbsp;by&nbsp;default&nbsp;*/<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;SG(options)&nbsp;|=&nbsp;SAPI_OPTION_NO_CHDIR;<br />&nbsp;&nbsp;&nbsp;&nbsp;SG(request_info).argc=0;<br />&nbsp;&nbsp;&nbsp;&nbsp;SG(request_info).argv=NULL;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(fuzzer_request_startup()&nbsp;==&nbsp;FAILURE)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;FAILURE;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Commented&nbsp;out&nbsp;to&nbsp;avoid&nbsp;leaking&nbsp;the&nbsp;header&nbsp;callback.<br />&nbsp;&nbsp;&nbsp;&nbsp;//SG(headers_sent)&nbsp;=&nbsp;1;<br />&nbsp;&nbsp;&nbsp;&nbsp;//SG(request_info).no_headers&nbsp;=&nbsp;1;<br />&nbsp;&nbsp;&nbsp;&nbsp;php_register_variable(&quot;PHP_SELF&quot;,&nbsp;filename,&nbsp;NULL);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;zend_first_try&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zend_file_handle&nbsp;file_handle;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zend_stream_init_filename(&amp;file_handle,&nbsp;filename);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file_handle.buf&nbsp;=&nbsp;estrndup(data,&nbsp;data_len);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file_handle.len&nbsp;=&nbsp;data_len;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zend_op_array&nbsp;*op_array&nbsp;=&nbsp;zend_compile_file(&amp;file_handle,&nbsp;ZEND_REQUIRE);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(op_array)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(execute)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zend_execute(op_array,&nbsp;NULL);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;destroy_op_array(op_array);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;efree(op_array);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;zend_end_try();<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;CG(compiled_filename)&nbsp;=&nbsp;NULL;&nbsp;/*&nbsp;???&nbsp;*/<br />&nbsp;&nbsp;&nbsp;&nbsp;fuzzer_request_shutdown();<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(retval&nbsp;==&nbsp;SUCCESS)&nbsp;?&nbsp;SUCCESS&nbsp;:&nbsp;FAILURE;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />fuzzer_do_request_from_buffer函数的关键元素是对zend_compile_file函数和zend_execute函数的调用。 在调用zend_compile_file之前，fuzzer_do_request_from_buffer首先使用php_register_variable（“ PHP_SELF”，filename，NULL）;注册一个PHP变量。 这是PHP编译器所需的内部变量，因此只是初始化的一部分。此后将使用函数zend_stream_init_filename创建具有随机数据内容的zend文件流，然后使用zend_compile_file编译流，最后通过zend_execute执行PHP代码。但是，只有在fuzzer_do_request_from_buffer的参数即execute被设置的情况下才调用zend_execute。<br /><br /><h2>Exif模糊器</h2><br />Exif模糊器的源代码如下：<br /><h3>fuzzer-exif.c</h3><br /><div class="codebox"><div class="codebox">/*<br />&nbsp;&nbsp;&nbsp;+----------------------------------------------------------------------+<br />&nbsp;&nbsp;&nbsp;|&nbsp;Copyright&nbsp;(c)&nbsp;The&nbsp;PHP&nbsp;Group&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br />&nbsp;&nbsp;&nbsp;+----------------------------------------------------------------------+<br />&nbsp;&nbsp;&nbsp;|&nbsp;This&nbsp;source&nbsp;file&nbsp;is&nbsp;subject&nbsp;to&nbsp;version&nbsp;3.01&nbsp;of&nbsp;the&nbsp;PHP&nbsp;license,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br />&nbsp;&nbsp;&nbsp;|&nbsp;that&nbsp;is&nbsp;bundled&nbsp;with&nbsp;this&nbsp;package&nbsp;in&nbsp;the&nbsp;file&nbsp;LICENSE,&nbsp;and&nbsp;is&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br />&nbsp;&nbsp;&nbsp;|&nbsp;available&nbsp;through&nbsp;the&nbsp;world-wide-web&nbsp;at&nbsp;the&nbsp;following&nbsp;url:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br />&nbsp;&nbsp;&nbsp;|&nbsp;http://www.php.net/license/3_01.txt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br />&nbsp;&nbsp;&nbsp;|&nbsp;If&nbsp;you&nbsp;did&nbsp;not&nbsp;receive&nbsp;a&nbsp;copy&nbsp;of&nbsp;the&nbsp;PHP&nbsp;license&nbsp;and&nbsp;are&nbsp;unable&nbsp;to&nbsp;&nbsp;&nbsp;|<br />&nbsp;&nbsp;&nbsp;|&nbsp;obtain&nbsp;it&nbsp;through&nbsp;the&nbsp;world-wide-web,&nbsp;please&nbsp;send&nbsp;a&nbsp;note&nbsp;to&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br />&nbsp;&nbsp;&nbsp;|&nbsp;license@php.net&nbsp;so&nbsp;we&nbsp;can&nbsp;mail&nbsp;you&nbsp;a&nbsp;copy&nbsp;immediately.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br />&nbsp;&nbsp;&nbsp;+----------------------------------------------------------------------+<br />&nbsp;&nbsp;&nbsp;|&nbsp;Authors:&nbsp;Stanislav&nbsp;Malyshev&nbsp;&lt;stas@php.net&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br />&nbsp;&nbsp;&nbsp;+----------------------------------------------------------------------+<br />&nbsp;*/<br /><br />#include&nbsp;&quot;fuzzer.h&quot;<br /><br />#include&nbsp;&quot;Zend/zend.h&quot;<br />#include&nbsp;&quot;main/php_config.h&quot;<br />#include&nbsp;&quot;main/php_main.h&quot;<br />#include&nbsp;&quot;ext/standard/php_var.h&quot;<br /><br />#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;stdint.h&gt;<br />#include&nbsp;&lt;stdlib.h&gt;<br />#include&nbsp;&lt;sys/types.h&gt;<br />#include&nbsp;&lt;sys/stat.h&gt;<br />#include&nbsp;&lt;fcntl.h&gt;<br /><br />#include&nbsp;&quot;fuzzer-sapi.h&quot;<br /><br />int&nbsp;LLVMFuzzerTestOneInput(const&nbsp;uint8_t&nbsp;*Data,&nbsp;size_t&nbsp;Size)&nbsp;{<br />#if&nbsp;HAVE_EXIF<br />	php_stream&nbsp;*stream;<br />	zval&nbsp;stream_zv;<br /><br />	if&nbsp;(Size&nbsp;&gt;&nbsp;256&nbsp;*&nbsp;1024)&nbsp;{<br />		/*&nbsp;Large&nbsp;inputs&nbsp;have&nbsp;a&nbsp;large&nbsp;impact&nbsp;on&nbsp;fuzzer&nbsp;performance,<br />		&nbsp;*&nbsp;but&nbsp;are&nbsp;unlikely&nbsp;to&nbsp;be&nbsp;necessary&nbsp;to&nbsp;reach&nbsp;new&nbsp;codepaths.&nbsp;*/<br />		return&nbsp;0;<br />	}<br /><br />	if&nbsp;(fuzzer_request_startup()&nbsp;==&nbsp;FAILURE)&nbsp;{<br />		return&nbsp;0;<br />	}<br /><br />	stream&nbsp;=&nbsp;php_stream_memory_create(TEMP_STREAM_DEFAULT);<br />	php_stream_write(stream,&nbsp;(const&nbsp;char&nbsp;*)&nbsp;Data,&nbsp;Size);<br />	php_stream_to_zval(stream,&nbsp;&amp;stream_zv);<br /><br />	fuzzer_call_php_func_zval(&quot;exif_read_data&quot;,&nbsp;1,&nbsp;&amp;stream_zv);<br /><br />	zval_ptr_dtor(&amp;stream_zv);<br /><br />	/*&nbsp;cleanup&nbsp;*/<br />	php_request_shutdown(NULL);<br /><br />	return&nbsp;0;<br />#else<br />	fprintf(stderr,&nbsp;&quot;\n\nERROR:\nPHP&nbsp;built&nbsp;without&nbsp;EXIF,&nbsp;recompile&nbsp;with&nbsp;--enable-exif&nbsp;to&nbsp;use&nbsp;this&nbsp;fuzzer\n&quot;);<br />	exit(1);<br />#endif<br />}<br /><br />int&nbsp;LLVMFuzzerInitialize(int&nbsp;*argc,&nbsp;char&nbsp;***argv)&nbsp;<span style="color:#000000;font-weight:400">{</span><br />	fuzzer_init_php();<br /><br />	/*&nbsp;fuzzer_shutdown_php();&nbsp;*/<br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><h2>构建PHP模糊器</h2><br />在我们的Docker映像中，执行以下操作：<br /><h3>build_php_fuzzer.sh</h3><br /><div class="codebox"><div class="codebox">#&nbsp;Set&nbsp;several&nbsp;variables&nbsp;used&nbsp;by&nbsp;the&nbsp;PHP&nbsp;fuzzer&nbsp;build&nbsp;structure&nbsp;<br />export&nbsp;CC=clang<br />export&nbsp;CXX=clang++<br />export&nbsp;CFLAGS=&quot;-fsanitize=fuzzer-no-link,address&quot;<br />export&nbsp;CXXFLAGS=&quot;-fsanitize=fuzzer-no-link,address&nbsp;-stdlib=libc++&quot;<br />export&nbsp;LIB_FUZZING_ENGINE=&quot;-fsanitize=fuzzer&quot;<br /><br />#&nbsp;Set&nbsp;up&nbsp;some&nbsp;symbolic&nbsp;links&nbsp;since&nbsp;we&nbsp;need&nbsp;to&nbsp;<br />#&nbsp;link&nbsp;libc++.so<br />ln&nbsp;-s&nbsp;/lib/x86_64-linux-gnu/libstdc++.so.6&nbsp;/lib/x86_64-linux-gnu/libc++.so<br /><br />#&nbsp;Install&nbsp;packages&nbsp;that&nbsp;PHP&nbsp;depends&nbsp;on<br />apt-get&nbsp;install&nbsp;-y&nbsp;autoconf&nbsp;automake&nbsp;libtool&nbsp;bison&nbsp;re2c&nbsp;pkg-config<br /><br />#&nbsp;Now&nbsp;begin&nbsp;the&nbsp;process&nbsp;of&nbsp;install&nbsp;PHP&nbsp;source&nbsp;code<br />git&nbsp;clone&nbsp;https://github.com/php/php-src.git&nbsp;/work/php-src<br />git&nbsp;clone&nbsp;https://github.com/kkos/oniguruma.git&nbsp;/work/php-src/oniguruma<br /><br />#&nbsp;First&nbsp;install&nbsp;oniguruma<br />cd&nbsp;/work/php-src/oniguruma<br />autoreconf&nbsp;-vfi<br />./configure<br />make&nbsp;-j$(nproc)<br />cd&nbsp;/work/php-src/<br /><br />export&nbsp;ONIG_CFLAGS=&quot;-I$PWD/oniguruma/src&quot;<br />export&nbsp;ONIG_LIBS=&quot;-L$PWD/oniguruma/src/.libs&nbsp;-l:libonig.a&quot;<br /><br />#&nbsp;Now&nbsp;compile&nbsp;the&nbsp;core&nbsp;PHP&nbsp;source&nbsp;code&nbsp;<br />./buildconf<br />./configure&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;--disable-all&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;--enable-debug-assertions&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;--enable-option-checking=fatal&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;--enable-fuzzer&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;--enable-exif&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;--enable-mbstring&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;--without-pcre-jit&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;--disable-phpdbg&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;--disable-cgi&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;--with-pic<br />make</div></div><br /><br /><strong><span style="color:#8ae234;">export</span></strong> CXXFLAGS=<span style="color:#edd400;">&quot;-fsanitize=fuzzer-no-link,address -stdlib=libc++&quot;</span><br />-stdlib=libc++表示链接时使用LLVM标准C ++库<br /><br /><strong><span style="color:#8ae234;">export</span></strong> LIB_FUZZING_ENGINE=<span style="color:#edd400;">&quot;-fsanitize=fuzzer&quot;</span><br />该环境变量常在OSS-fuzz项目中用于指定使用libfuzzer对项目进行fuzzing<br /><a href="https://github.com/google/oss-fuzz/issues/2317">https://github.com/google/oss-fuzz/issues/2317</a><br /><br /><br /><br />在这一阶段，我们将在sapi / fuzzers目录中看到我们的模糊器，并且可以像平常一样简单地执行它们。</div><div class='page'><h1 class='title level-4'>5_Coming_up_with_a_new_PHP_fuzzer</h1><br/><h1>提出一个新的PHP模糊器</h1><br /><br /><h2>在设置中添加另一个模糊器</h2><br />PHP源存储库中与fuzzer相关的所有工作都在sapi / fuzzer目录中。 在这里，我们找到了模糊器的所有源代码文件以及与构建源代码有关的所有文件。 因此，在将另一个模糊器添加到PHP的源代码时，我们将在此文件夹中进行所有工作。<br /><br />向PHP添加新的模糊测试器时，我们关心三个文件：<br />• <code>sapi/fuzzer/Makefile.frag</code><br />• <code>sapi/fuzzer/config.m4</code><br />• <code>sapi/fuzzer/OUR_FUZZER_SOURCE_CODE.c</code><br /><br />为了包括我们的模糊器，我们需要修改上述文件的前两个，列表中的最后一个文件将是我们放置源代码的文件。 因此，对于我们来说，第一步是要设计出新颖的模糊器<br /><br /><h2>创建模糊器</h2><br />从对现有PHP模糊器的研究中，我们分离出了几个重要的函数，可以用来构成模糊器：<br />• <code>fuzzer_init_php</code> : is used by other fuzzers as part of the <code>LLVMFuzzerInitialize</code> function.<br />• <code>fuzzer_request_startup</code> : is used by the other fuzzers to launch the PHP zend engine, and effectivelly start all of the engine set up necessary to launch PHP.<br />• <code>fuzzer_call_php_func</code> : is used by the other fuzzers to call into a PHP function.<br />• <code>php_request_shutdown</code> : is used by the other fuzzers to cleanly shut down PHP at the end of a fuzzing iteration.<br /><br />遵循上述功能，似乎我们具有创建PHP模糊器所需的组件。 特别是，我们知道（1）启动和关闭PHP以及（2）调用PHP函数需要什么。 因此，对我们来说，下一步实际上是确定我们要攻击的函数。 在此示例中，我们将尝试寻找一种方便的函数，即与解析随机数据相比，它不需要做更多的工作。从本质上讲，我们希望自己集成一个新型的模糊测试器，以快速应对端到端的模糊测试器。然后，在建立端到端模糊器之后的实际情况中，下一个场景是将其用作构建更多模糊器的基准。<br /><br />我们将要攻击的函数是preg_match函数，有关此函数的说明，请参见此处。 该函数是一个正则表达式匹配器，因此从本质上讲，该函数期望一个字符串以及一个正则表达式，然后它将确定该字符串是否与正则表达式匹配。 功能签名如下：<br /><div class="codebox"><div class="codebox">preg_match&nbsp;(&nbsp;string&nbsp;$pattern&nbsp;,&nbsp;string&nbsp;$subject&nbsp;[,&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;array&nbsp;&amp;$matches&nbsp;[,&nbsp;int&nbsp;$flags&nbsp;=&nbsp;0&nbsp;[,&nbsp;int&nbsp;$offset&nbsp;=&nbsp;0&nbsp;]]]&nbsp;)&nbsp;:&nbsp;int</div></div><br /><br />该函数本身接受两个必需参数，然后接受几个可选参数。 我们将仅提供两个必需的参数。 特别是，该函数需要两个字符串作为输入，因此我们可以为此使用随机数据。 以下是PHP本身中preg_match函数的一个简单示例用例：<br /><div class="codebox"><div class="codebox"><span style="color:#000000;font-weight:400">&lt;</span>?php<br />$str&nbsp;=&nbsp;&quot;AdaLogicss&quot;;<br />$pattern&nbsp;=&nbsp;&quot;fuzzing&nbsp;is&nbsp;cool&quot;;<br />echo&nbsp;preg_match($pattern,&nbsp;$str);<br />?<span style="color:#000000;font-weight:400">&gt;</span></div></div><br /><br />至此，编写我们的模糊器所需的步骤已完成：<br />1、在LLVMFuzzerInitialize内使用fuzzer_init_php函数初始化我们的模糊器。<br />2、在LLVMFuzzerTestOneInput内执行以下步骤：<br />	1、使用fuzzer_request_startup初始化PHP<br />	2、通过fuzzer_call_php_func调用具有随机输入的php函数preg_match<br />	3、通过PHP_request_shutdown来关闭PHP<br />	<br />以下源代码实现了这种确切的逻辑：<br />fuzzer-pregmatch.c<br /><div class="codebox"><div class="codebox">#include&nbsp;&quot;fuzzer.h&quot;<br /><br />#include&nbsp;&quot;Zend/zend.h&quot;<br />#include&nbsp;&quot;main/php_config.h&quot;<br />#include&nbsp;&quot;main/php_main.h&quot;<br />#include&nbsp;&quot;oniguruma.h&quot;<br /><br />#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;stdint.h&gt;<br />#include&nbsp;&lt;stdlib.h&gt;<br /><br />#include&nbsp;&quot;fuzzer-sapi.h&quot;<br /><br />int&nbsp;LLVMFuzzerTestOneInput(const&nbsp;uint8_t&nbsp;*Data,&nbsp;size_t&nbsp;Size)&nbsp;<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Ensure&nbsp;we&nbsp;have&nbsp;enough&nbsp;data&nbsp;since&nbsp;we&nbsp;will&nbsp;be&nbsp;using&nbsp;a&nbsp;bit&nbsp;of&nbsp;bytes<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(Size&nbsp;&lt;&nbsp;200)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Allocate&nbsp;two&nbsp;null-terminated&nbsp;strings.<br />&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*data&nbsp;=&nbsp;malloc(101);<br />&nbsp;&nbsp;&nbsp;&nbsp;memcpy(data,&nbsp;Data,&nbsp;100);<br />&nbsp;&nbsp;&nbsp;&nbsp;data[100]&nbsp;=&nbsp;&#39;\0&#39;;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*data2&nbsp;=&nbsp;malloc(Size&nbsp;-&nbsp;99);<br />&nbsp;&nbsp;&nbsp;&nbsp;Data&nbsp;+=&nbsp;100;<br />&nbsp;&nbsp;&nbsp;&nbsp;memcpy(data2,&nbsp;Data,&nbsp;Size-100);<br />&nbsp;&nbsp;&nbsp;&nbsp;data2[Size-100]&nbsp;=&nbsp;&#39;\0&#39;;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Start&nbsp;PHP&nbsp;and&nbsp;call&nbsp;into&nbsp;our&nbsp;target&nbsp;function<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(fuzzer_request_startup()&nbsp;!=&nbsp;FAILURE)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Successfully&nbsp;launched&nbsp;PHP,,&nbsp;now&nbsp;call&nbsp;into<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;preg_match&nbsp;with&nbsp;our&nbsp;random&nbsp;data.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*args[2];<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;args[0]&nbsp;=&nbsp;data;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;args[1]&nbsp;=&nbsp;data2;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fuzzer_call_php_func(&quot;preg_match&quot;,&nbsp;2,&nbsp;args);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Shutdown&nbsp;PHP<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;php_request_shutdown(NULL);<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Cleanup<br />&nbsp;&nbsp;&nbsp;&nbsp;free(data);<br />&nbsp;&nbsp;&nbsp;&nbsp;free(data2);<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br />}<br /><br />int&nbsp;LLVMFuzzerInitialize(int&nbsp;*argc,&nbsp;char&nbsp;***argv)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fuzzer_init_php();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br />}<br /></div></div><br /><br /><h2>添加我们的模糊器以进行设置</h2><br />我们将模糊器放置在以下位置：sapi / fuzzer / fuzzer-pregmatch.c。<br />   第一步是修改sapi / fuzzer / Makefile.frag的make文件。 在此文件中，我们看到以下几行： <br /><div class="codebox"><div class="codebox">...<br />$(SAPI_FUZZER_PATH)/php-fuzz-unserializehash:&nbsp;$(PHP_GLOBAL_OBJS)&nbsp;$(PHP_SAPI_OBJS)&nbsp;$(PHP_FUZZER_UNSERIALIZEHASH_OBJS)<br />&nbsp;&nbsp;&nbsp;&nbsp;$(FUZZER_BUILD)&nbsp;$(PHP_FUZZER_UNSERIALIZEHASH_OBJS)&nbsp;-o&nbsp;$@<br /><br />$(SAPI_FUZZER_PATH)/php-fuzz-json:&nbsp;$(PHP_GLOBAL_OBJS)&nbsp;$(PHP_SAPI_OBJS)&nbsp;$(PHP_FUZZER_JSON_OBJS)<br />&nbsp;&nbsp;&nbsp;&nbsp;$(FUZZER_BUILD)&nbsp;$(PHP_FUZZER_JSON_OBJS)&nbsp;-o&nbsp;$@<br /><br />$(SAPI_FUZZER_PATH)/php-fuzz-exif:&nbsp;$(PHP_GLOBAL_OBJS)&nbsp;$(PHP_SAPI_OBJS)&nbsp;$(PHP_FUZZER_EXIF_OBJS)<br />&nbsp;&nbsp;&nbsp;&nbsp;$(FUZZER_BUILD)&nbsp;$(PHP_FUZZER_EXIF_OBJS)&nbsp;-o&nbsp;$@<br /><br />$(SAPI_FUZZER_PATH)/php-fuzz-mbstring:&nbsp;$(PHP_GLOBAL_OBJS)&nbsp;$(PHP_SAPI_OBJS)&nbsp;$(PHP_FUZZER_MBSTRING_OBJS)<br />&nbsp;&nbsp;&nbsp;&nbsp;$(FUZZER_BUILD)&nbsp;$(PHP_FUZZER_MBSTRING_OBJS)&nbsp;-o&nbsp;$@<br />...&nbsp;&nbsp;&nbsp;&nbsp;</div></div><br /><br />我们可以观察到PHP源代码中每个模糊器都有一对行。 在这种情况下，我们要做的就是简单地添加一行，为我们的新pregmatch.c模糊器添加相同的逻辑。 因此，我们在文件末尾添加以下行：<br /><div class="codebox"><div class="codebox">$(SAPI_FUZZER_PATH)/php-fuzz-pregmatch:&nbsp;$(PHP_GLOBAL_OBJS)&nbsp;$(PHP_SAPI_OBJS)&nbsp;$(PHP_FUZZER_PREGMATCH_OBJS)<br />	$(FUZZER_BUILD)&nbsp;$(PHP_FUZZER_PREGMATCH_OBJS)&nbsp;-o&nbsp;$@</div></div><br /><br />下一步是修改sapi / fuzzer / config.m4文件。 在此文件的底部，我们找到以下几行：<br /><div class="codebox"><div class="codebox">PHP_FUZZER_TARGET([execute],&nbsp;PHP_FUZZER_EXECUTE_OBJS)<br />PHP_FUZZER_TARGET([unserialize],&nbsp;PHP_FUZZER_UNSERIALIZE_OBJS)<br />PHP_FUZZER_TARGET([unserializehash],&nbsp;PHP_FUZZER_UNSERIALIZEHASH_OBJS)<br />PHP_FUZZER_TARGET<span style="color:#000000;font-weight:400">(</span>[json],&nbsp;PHP_FUZZER_JSON_OBJS<span style="color:#000000;font-weight:400">)</span></div></div><br /><br />我们可以观察到每个模糊器都有一行，因此我们要做的是为模糊器添加类似的行：<br /><div class="codebox"><div class="codebox">PHP_FUZZER_TARGET<span style="color:#000000;font-weight:400">(</span>[pregmatch],&nbsp;PHP_FUZZER_PREGMATCH_OBJS<span style="color:#000000;font-weight:400">)</span></div></div><br /><br /><h2>重建并运行模糊器</h2><br />现在，我们可以通过重建PHP源代码来构建新的模糊器。 将Fuzzer集成到构建脚本中将有效地意味着我们可以以完全相同的方式构建项目，然后应该将Fuzzer放置在其他Fuzzer的位置。 因此，我们执行以下命令：<br />fuzz_build.sh<br /><div class="codebox"><div class="codebox">#&nbsp;Set&nbsp;several&nbsp;variables&nbsp;used&nbsp;by&nbsp;the&nbsp;PHP&nbsp;fuzzer&nbsp;build&nbsp;structure&nbsp;<br />export&nbsp;CC=clang<br />export&nbsp;CXX=clang++<br />export&nbsp;CFLAGS=&quot;-fsanitize=fuzzer-no-link,address&nbsp;&quot;<br />export&nbsp;CXXFLAGS=&quot;-fsanitize=fuzzer-no-link,address&nbsp;-stdlib=libc++&quot;<br />export&nbsp;LIB_FUZZING_ENGINE=&quot;-fsanitize=fuzzer&quot;<br /><br />#&nbsp;Move&nbsp;to&nbsp;the&nbsp;directory<br />cd&nbsp;/work/php-src<br /><br />#&nbsp;Clean&nbsp;up&nbsp;existing&nbsp;code<br />make&nbsp;clean<br /><br />#&nbsp;Compile&nbsp;oniguruma<br />cd&nbsp;/work/php-src/oniguruma<br />autoreconf&nbsp;-vfi<br />./configure<br />make&nbsp;-j$(nproc)<br />cd&nbsp;/work/php-src/<br /><br />export&nbsp;ONIG_CFLAGS=&quot;-I$PWD/oniguruma/src&quot;<br />export&nbsp;ONIG_LIBS=&quot;-L$PWD/oniguruma/src/.libs&nbsp;-l:libonig.a&quot;<br /><br />#&nbsp;Now&nbsp;compile&nbsp;the&nbsp;core&nbsp;PHP&nbsp;source&nbsp;code&nbsp;<br />./buildconf<br />./configure&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;--disable-all&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;--enable-debug-assertions&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;--enable-option-checking=fatal&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;--enable-fuzzer&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;--enable-exif&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;--enable-mbstring&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;--without-pcre-jit&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;--disable-phpdbg&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;--disable-cgi&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;--with-pic<br />make</div></div><br /><br />按照上述步骤操作，我们的模糊器将放置在sapi / fuzzer / php-fuzz-pregmatch中，我们可以按以下方式运行模糊器：<br /><div class="codebox"><div class="codebox">$&nbsp;./sapi/fuzzer/php-fuzz-pregmatch&nbsp;<br />INFO:&nbsp;Seed:&nbsp;3144203744<br />INFO:&nbsp;Loaded&nbsp;1&nbsp;modules&nbsp;&nbsp;&nbsp;(132836&nbsp;inline&nbsp;8-bit&nbsp;counters):&nbsp;132836&nbsp;[0x25a5e60,&nbsp;0x25c6544),&nbsp;<br />INFO:&nbsp;Loaded&nbsp;1&nbsp;PC&nbsp;tables&nbsp;(132836&nbsp;PCs):&nbsp;132836&nbsp;[0x25c6548,0x27cd388),&nbsp;<br />INFO:&nbsp;-max_len&nbsp;is&nbsp;not&nbsp;provided;&nbsp;libFuzzer&nbsp;will&nbsp;not&nbsp;generate&nbsp;inputs&nbsp;larger&nbsp;than&nbsp;4096&nbsp;bytes<br />INFO:&nbsp;A&nbsp;corpus&nbsp;is&nbsp;not&nbsp;provided,&nbsp;starting&nbsp;from&nbsp;an&nbsp;empty&nbsp;corpus<br />#2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;INITED&nbsp;cov:&nbsp;2&nbsp;ft:&nbsp;3&nbsp;corp:&nbsp;1/1b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;52Mb<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW_FUNC[1/290]:&nbsp;0x70a440&nbsp;in&nbsp;zm_activate_date&nbsp;/work/php-src/ext/date/php_date.c:233<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW_FUNC[2/290]:&nbsp;0x70a510&nbsp;in&nbsp;zm_deactivate_date&nbsp;/work/php-src/ext/date/php_date.c:247<br />#20646&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;792&nbsp;ft:&nbsp;794&nbsp;corp:&nbsp;2/206b&nbsp;lim:&nbsp;205&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;56Mb&nbsp;L:&nbsp;205/205&nbsp;MS:&nbsp;4&nbsp;InsertRepeatedBytes-ShuffleBytes-CopyPart-InsertRepeatedBytes-<br />#20656&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;794&nbsp;ft:&nbsp;796&nbsp;corp:&nbsp;3/411b&nbsp;lim:&nbsp;205&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;56Mb&nbsp;L:&nbsp;205/205&nbsp;MS:&nbsp;5&nbsp;InsertByte-ChangeBit-ChangeBit-InsertRepeatedBytes-CrossOver-<br />#20805&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;795&nbsp;ft:&nbsp;797&nbsp;corp:&nbsp;4/616b&nbsp;lim:&nbsp;205&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;63Mb&nbsp;L:&nbsp;205/205&nbsp;MS:&nbsp;4&nbsp;ChangeByte-ShuffleBytes-ChangeBinInt-ChangeBinInt-<br />#20809&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;795&nbsp;ft:&nbsp;798&nbsp;corp:&nbsp;5/816b&nbsp;lim:&nbsp;205&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;63Mb&nbsp;L:&nbsp;200/205&nbsp;MS:&nbsp;4&nbsp;ChangeByte-CopyPart-EraseBytes-InsertByte-<br />#20828&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;796&nbsp;ft:&nbsp;802&nbsp;corp:&nbsp;6/1021b&nbsp;lim:&nbsp;205&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;64Mb&nbsp;L:&nbsp;205/205&nbsp;MS:&nbsp;4&nbsp;ShuffleBytes-ChangeBit-ChangeBinInt-CrossOver-<br />#20831&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;796&nbsp;ft:&nbsp;803&nbsp;corp:&nbsp;7/1221b&nbsp;lim:&nbsp;205&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;64Mb&nbsp;L:&nbsp;200/205&nbsp;MS:&nbsp;3&nbsp;ChangeBit-EraseBytes-InsertRepeatedBytes-<br />#20892&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;796&nbsp;ft:&nbsp;804&nbsp;corp:&nbsp;8/1422b&nbsp;lim:&nbsp;205&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;67Mb&nbsp;L:&nbsp;201/205&nbsp;MS:&nbsp;1&nbsp;InsertByte-<br />#20910&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;796&nbsp;ft:&nbsp;805&nbsp;corp:&nbsp;9/1627b&nbsp;lim:&nbsp;205&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;68Mb&nbsp;L:&nbsp;205/205&nbsp;MS:&nbsp;3&nbsp;InsertByte-CopyPart-CopyPart-<br />#21032&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;796&nbsp;ft:&nbsp;806&nbsp;corp:&nbsp;10/1832b&nbsp;lim:&nbsp;205&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;74Mb&nbsp;L:&nbsp;205/205&nbsp;MS:&nbsp;2&nbsp;ChangeBinInt-CopyPart-<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW_FUNC[1/28]:&nbsp;0x862540&nbsp;in&nbsp;_pcre2_auto_possessify_8&nbsp;/work/php-src/ext/pcre/pcre2lib/pcre2_auto_possess.c:1115<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW_FUNC[2/28]:&nbsp;0x877df0&nbsp;in&nbsp;php_pcre2_compile&nbsp;/work/php-src/ext/pcre/pcre2lib/pcre2_compile.c:9640<br />#21324&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;1003&nbsp;ft:&nbsp;1059&nbsp;corp:&nbsp;11/2033b&nbsp;lim:&nbsp;205&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;90Mb&nbsp;L:&nbsp;201/205&nbsp;MS:&nbsp;1&nbsp;ChangeBinInt-<br />#21325&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;1004&nbsp;ft:&nbsp;1066&nbsp;corp:&nbsp;12/2234b&nbsp;lim:&nbsp;205&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;90Mb&nbsp;L:&nbsp;201/205&nbsp;MS:&nbsp;1&nbsp;ChangeBit-<br />#21535&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;1004&nbsp;ft:&nbsp;1066&nbsp;corp:&nbsp;12/2232b&nbsp;lim:&nbsp;205&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;98Mb&nbsp;L:&nbsp;203/205&nbsp;MS:&nbsp;5&nbsp;ChangeByte-EraseBytes-ChangeBinInt-ChangeBit-InsertRepeatedBytes-<br />#21595&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;1006&nbsp;ft:&nbsp;1068&nbsp;corp:&nbsp;13/2436b&nbsp;lim:&nbsp;205&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;101Mb&nbsp;L:&nbsp;204/205&nbsp;MS:&nbsp;5&nbsp;EraseBytes-ChangeBit-ChangeByte-ShuffleBytes-InsertRepeatedBytes-<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW_FUNC[1/1]:&nbsp;0xa11c20&nbsp;in&nbsp;calculate_unit_length&nbsp;/work/php-src/ext/pcre/php_pcre.c:578<br />#21681&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;1011&nbsp;ft:&nbsp;1073&nbsp;corp:&nbsp;14/2641b&nbsp;lim:&nbsp;205&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;105Mb&nbsp;L:&nbsp;205/205&nbsp;MS:&nbsp;1&nbsp;CrossOver-<br />#21740&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;1011&nbsp;ft:&nbsp;1073&nbsp;corp:&nbsp;14/2640b&nbsp;lim:&nbsp;205&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;109Mb&nbsp;L:&nbsp;200/205&nbsp;MS:&nbsp;4&nbsp;ChangeByte-ChangeBit-ShuffleBytes-CrossOver-<br />#21878&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;1016&nbsp;ft:&nbsp;1079&nbsp;corp:&nbsp;15/2845b&nbsp;lim:&nbsp;205&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;116Mb&nbsp;L:&nbsp;205/205&nbsp;MS:&nbsp;3&nbsp;ChangeBinInt-EraseBytes-CrossOver-<br />#21899&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;1016&nbsp;ft:&nbsp;1079&nbsp;corp:&nbsp;15/2840b&nbsp;lim:&nbsp;205&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;117Mb&nbsp;L:&nbsp;200/205&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#21917&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;1016&nbsp;ft:&nbsp;1081&nbsp;corp:&nbsp;16/3045b&nbsp;lim:&nbsp;205&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;118Mb&nbsp;L:&nbsp;205/205&nbsp;MS:&nbsp;3&nbsp;CMP-ChangeBit-CopyPart-&nbsp;DE:&nbsp;&quot;\x00\x00\x00\x00\x00\x00\x00\xb3&quot;-<br />#22175&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;1016&nbsp;ft:&nbsp;1083&nbsp;corp:&nbsp;17/3250b&nbsp;lim:&nbsp;205&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;119Mb&nbsp;L:&nbsp;205/205&nbsp;MS:&nbsp;3&nbsp;ShuffleBytes-CopyPart-CrossOver-<br />#22223&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;1016&nbsp;ft:&nbsp;1084&nbsp;corp:&nbsp;18/3451b&nbsp;lim:&nbsp;205&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;119Mb&nbsp;L:&nbsp;201/205&nbsp;MS:&nbsp;3&nbsp;ChangeBit-ChangeBinInt-ChangeBinInt-<br />#22321&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;1016&nbsp;ft:&nbsp;1084&nbsp;corp:&nbsp;18/3448b&nbsp;lim:&nbsp;205&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;119Mb&nbsp;L:&nbsp;202/205&nbsp;MS:&nbsp;3&nbsp;ChangeBinInt-CopyPart-EraseBytes-<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW_FUNC[1/2]:&nbsp;0x86fe60&nbsp;in&nbsp;php_pcre2_code_free&nbsp;/work/php-src/ext/pcre/pcre2lib/pcre2_compile.c:1259<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW_FUNC[2/2]:&nbsp;0x908270&nbsp;in&nbsp;php_pcre2_get_error_message&nbsp;/work/php-src/ext/pcre/pcre2lib/pcre2_error.c:297<br />#22542&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;1042&nbsp;ft:&nbsp;1115&nbsp;corp:&nbsp;19/3649b&nbsp;lim:&nbsp;205&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;119Mb&nbsp;L:&nbsp;201/205&nbsp;MS:&nbsp;1&nbsp;InsertByte-<br />#22585&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;1044&nbsp;ft:&nbsp;1117&nbsp;corp:&nbsp;20/3854b&nbsp;lim:&nbsp;205&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;119Mb&nbsp;L:&nbsp;205/205&nbsp;MS:&nbsp;3&nbsp;ChangeBinInt-ChangeBinInt-ChangeBit-<br />#22722&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;1044&nbsp;ft:&nbsp;1118&nbsp;corp:&nbsp;21/4059b&nbsp;lim:&nbsp;205&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;119Mb&nbsp;L:&nbsp;205/205&nbsp;MS:&nbsp;2&nbsp;CMP-CrossOver-&nbsp;DE:&nbsp;&quot;\x00\x00\x00\x00\x00\x00\x00\x01&quot;-<br />#22846&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;1045&nbsp;ft:&nbsp;1120&nbsp;corp:&nbsp;22/4264b&nbsp;lim:&nbsp;205&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;119Mb&nbsp;L:&nbsp;205/205&nbsp;MS:&nbsp;4&nbsp;CopyPart-CopyPart-ChangeBinInt-CrossOver-<br />#22858&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;1045&nbsp;ft:&nbsp;1120&nbsp;corp:&nbsp;22/4259b&nbsp;lim:&nbsp;205&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;119Mb&nbsp;L:&nbsp;200/205&nbsp;MS:&nbsp;2&nbsp;EraseBytes-CopyPart-<br />#23152&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;1045&nbsp;ft:&nbsp;1121&nbsp;corp:&nbsp;23/4460b&nbsp;lim:&nbsp;205&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;119Mb&nbsp;L:&nbsp;201/205&nbsp;MS:&nbsp;4&nbsp;CMP-CrossOver-ChangeByte-CopyPart-&nbsp;DE:&nbsp;&quot;\x00\x00\x00\x00\x00\x00\x00\x0c&quot;-<br />#23177&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;1045&nbsp;ft:&nbsp;1121&nbsp;corp:&nbsp;23/4455b&nbsp;lim:&nbsp;205&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;119Mb&nbsp;L:&nbsp;200/205&nbsp;MS:&nbsp;5&nbsp;ShuffleBytes-CrossOver-InsertRepeatedBytes-ChangeBit-InsertByte-<br />#23181&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;1045&nbsp;ft:&nbsp;1121&nbsp;corp:&nbsp;23/4450b&nbsp;lim:&nbsp;205&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;119Mb&nbsp;L:&nbsp;200/205&nbsp;MS:&nbsp;4&nbsp;ChangeBit-EraseBytes-InsertRepeatedBytes-InsertByte-<br />#23262&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;1045&nbsp;ft:&nbsp;1123&nbsp;corp:&nbsp;24/4655b&nbsp;lim:&nbsp;205&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;119Mb&nbsp;L:&nbsp;205/205&nbsp;MS:&nbsp;1&nbsp;CrossOver-<br />#23360&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;1045&nbsp;ft:&nbsp;1123&nbsp;corp:&nbsp;24/4651b&nbsp;lim:&nbsp;205&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;119Mb&nbsp;L:&nbsp;201/205&nbsp;MS:&nbsp;3&nbsp;ChangeBit-CopyPart-EraseBytes-<br />#23394&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;1045&nbsp;ft:&nbsp;1123&nbsp;corp:&nbsp;24/4648b&nbsp;lim:&nbsp;205&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;119Mb&nbsp;L:&nbsp;202/205&nbsp;MS:&nbsp;4&nbsp;ShuffleBytes-ChangeBit-ShuffleBytes-EraseBytes-<br />#23557&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;1045&nbsp;ft:&nbsp;1123&nbsp;corp:&nbsp;24/4647b&nbsp;lim:&nbsp;205&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;119Mb&nbsp;L:&nbsp;204/205&nbsp;MS:&nbsp;3&nbsp;ChangeByte-CrossOver-CopyPart-<br />#23609&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;1047&nbsp;ft:&nbsp;1128&nbsp;corp:&nbsp;25/4852b&nbsp;lim:&nbsp;205&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;119Mb&nbsp;L:&nbsp;205/205&nbsp;MS:&nbsp;1&nbsp;CrossOver-<br />#23615&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;1048&nbsp;ft:&nbsp;1129&nbsp;corp:&nbsp;26/5056b&nbsp;lim:&nbsp;205&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;119Mb&nbsp;L:&nbsp;204/205&nbsp;MS:&nbsp;1&nbsp;InsertRepeatedBytes-<br />#24036&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;1048&nbsp;ft:&nbsp;1129&nbsp;corp:&nbsp;26/5052b&nbsp;lim:&nbsp;205&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;119Mb&nbsp;L:&nbsp;200/205&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#24130&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;1049&nbsp;ft:&nbsp;1130&nbsp;corp:&nbsp;27/5257b&nbsp;lim:&nbsp;205&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;119Mb&nbsp;L:&nbsp;205/205&nbsp;MS:&nbsp;4&nbsp;InsertRepeatedBytes-CopyPart-ChangeByte-ChangeBit-<br />#24215&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;1049&nbsp;ft:&nbsp;1130&nbsp;corp:&nbsp;27/5255b&nbsp;lim:&nbsp;205&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;119Mb&nbsp;L:&nbsp;203/205&nbsp;MS:&nbsp;5&nbsp;EraseBytes-ChangeBinInt-CopyPart-ChangeByte-CopyPart-<br />#24478&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;1049&nbsp;ft:&nbsp;1130&nbsp;corp:&nbsp;27/5254b&nbsp;lim:&nbsp;205&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;119Mb&nbsp;L:&nbsp;200/205&nbsp;MS:&nbsp;3&nbsp;EraseBytes-InsertByte-InsertRepeatedBytes-<br />#25232&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;1049&nbsp;ft:&nbsp;1130&nbsp;corp:&nbsp;27/5253b&nbsp;lim:&nbsp;212&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;119Mb&nbsp;L:&nbsp;201/205&nbsp;MS:&nbsp;4&nbsp;ChangeByte-ChangeBinInt-EraseBytes-CopyPart-<br />#25654&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;1049&nbsp;ft:&nbsp;1130&nbsp;corp:&nbsp;27/5252b&nbsp;lim:&nbsp;212&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;119Mb&nbsp;L:&nbsp;202/205&nbsp;MS:&nbsp;2&nbsp;ChangeBinInt-EraseBytes-<br /></div></div><br /></div><div class='page'><h1 class='title level-3'>4_Chromium_fuzzing</h1><br/></div><div class='page'><h1 class='title level-4'>1_Chromium_introduction</h1><br/><h1>Chromium introduction</h1><br /><br />在本节中，我们将研究Chromium模糊测试。  Chromium是世界上最受欢迎的开源项目之一，对安全性至关重要。  Chromium中的错误会影响数亿用户，并且是目前存在的影响最大的目标之一。<br /><br />Chromium的大部分内容都是用C / C ++编写的，因此容易出现内存损坏漏洞，因此，这是基于LibFuzzer的模糊测试的理想目标。 在Chromium上已经进行了大量的模糊测试，Google团队甚至创建了专用的基于云的框架，从而可以对Chromium进行大规模的模糊测试。因此，与其他开放源代码项目相比，在Chromium中查找错误并非易事，尽管当然可以做到。<br /><br /></div><div class='page'><h1 class='title level-4'>2_Overview of Chromium fuzzing _ ADA Logics</h1><br/><h1>chromium源码</h1><br /><a href="https://chromium.googlesource.com/">https://chromium.googlesource.com/</a><br />基本上所有项目自带的fuzzer均可以在源码库中找到<br /><a href=""><img src="images\995-1.png" alt="images\995-1.png" /></a><br /><br /><h1>chromium覆盖率</h1><br /><a href="http://chromium-coverage.appspot.com/">http://chromium-coverage.appspot.com/</a><br />该处仅仅统计源码中所有c/c++代码的覆盖率，不包括makefile等文件的覆盖率<br />实际攻击中可以通过找到覆盖率较低的代码库，从而有针对地编写fuzzer<br /><a href=""><img src="images\995-2.png" alt="images\995-2.png" /></a><br /><br />点进任意一个fuzzer，可以看到chromium源码项目的结构<br />一般而言，项目自带的fuzzer会放置在其目标代码相同的路径下，例如针对device相关代码的fuzzer会放置在divice目录下<br /><a href=""><img src="images\995-3.png" alt="images\995-3.png" /></a><br /><br /><h2>fuzzer/url目录下</h2><br /><br />其中url目录中fuzzer覆盖率较高，而v8目录则保存javascrip解析引擎相关代码<br /><a href=""><img src="images\995-4.png" alt="images\995-4.png" /></a><br /><br />例如在url目录中，gurl_fuzzer.cc的目标代码就是gurl.cc<br /><a href=""><img src="images\995-5.png" alt="images\995-5.png" /></a><br /><br />进入gurl_fuzzer.cc文件，分析思路仍为查看data参数如何被使用，可以发现fuzzer思路与之前一样，均为尽可能多的使用随机数据调用项目的函数，从而尝试触发bug<br /><a href=""><img src="images\995-6.png" alt="images\995-6.png" /></a><br /><br /><h2>fuzzer/third_party目录下</h2><br /><a href=""><img src="images\995-7.png" alt="images\995-7.png" /></a><br /><br />该fuzzer/third_party目录下存在sqlite目录，该目录fuzzer覆盖率很高<br /><a href=""><img src="images\995-8.png" alt="images\995-8.png" /></a><br /><br />sqlite目录中可以看到fuzz目录以及src目录<br /><a href=""><img src="images\995-9.png" alt="images\995-9.png" /></a><br /><br />fuzzer目录下中的sql_fuzzer.cc中可以看到该fuzzer实际上使用了libprotobuf_mutatiom，即该fuzzer是语法感知类的fuzzer，通过定义语法，从而生成符合某种语法规定的随机数据对象，将该数据对象转为字符串传递给目标函数<br /><a href=""><img src="images\995-10.png" alt="images\995-10.png" /></a><br /><br />如果要查看libprotobuf_mutatiom所使用的protobuf文件，则需要查看chromium源码<br />对应的源码位于chromium/src/third_party_sqlite<br /><a href=""><img src="images\995-11.png" alt="images\995-11.png" /></a><br /><br />选择master<br /><a href=""><img src="images\995-12.png" alt="images\995-12.png" /></a><br /><br />进入fuzz文件夹<br /><a href=""><img src="images\995-13.png" alt="images\995-13.png" /></a><br /><br />找到proto语法文件<br /><a href=""><img src="images\995-14.png" alt="images\995-14.png" /></a><br /><br />对于proto文件中的数据结构（下左图），在sqlite的fuzzer中均有函数将该数据结构转为字符串（下右图）<br /><a href=""><img src="images\995-15.png" alt="images\995-15.png" /></a>  <a href=""><img src="images\995-16.png" alt="images\995-16.png" /></a><br /><br />源码中以及coverage报告中的sql_qurey_to_string.cc文件均用于将protobuf数据结构转为字符串<br /><a href=""><img src="images\995-17.png" alt="images\995-17.png" /></a><br /><a href=""><img src="images\995-18.png" alt="images\995-18.png" /></a><br /><br /><h2>fuzzer/third_party/pdfium目录下</h2><br /><a href=""><img src="images\995-19.png" alt="images\995-19.png" /></a><br /><a href=""><img src="images\995-20.png" alt="images\995-20.png" /></a><br /><br /><h2>fuzzer/third_party/pdfium/testing/fuzzers目录下</h2><br /><a href=""><img src="images\995-21.png" alt="images\995-21.png" /></a><br /><br />查看pdfium_fuzzer.cc，该fuzzer中可以看到关键类PDFiumFuzzer的父类为PDFiumFuzzerHelper，该类由对应头文件（pdfium_fuzzer_helper.h）引入<br /><a href=""><img src="images\995-22.png" alt="images\995-22.png" /></a><br /><br />查看pdfium_fuzzer_helper.h文件，该文件仅声明了类函数，函数具体实现位于pdfium_fuzzer_helper.cc<br /><a href=""><img src="images\995-23.png" alt="images\995-23.png" /></a><br /><br />pdfium_fuzzer_helper.cc<br /><a href=""><img src="images\995-24.png" alt="images\995-24.png" /></a> <a href=""><img src="images\995-25.png" alt="images\995-25.png" /></a><br /><br />查看pdf_codec_jpeg_fuzzer.cc，该函数中引用了工具类XFACodecFuzzer<br /><a href=""><img src="images\995-26.png" alt="images\995-26.png" /></a><br /><br />XFACodecFuzzer类实现在如下头文件中<br /><a href=""><img src="images\995-27.png" alt="images\995-27.png" /></a><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /></div><div class='page'><h1 class='title level-4'>3_Building and running Chromium fuzzers _ ADA Logics</h1><br/><h1>环境基础</h1><br />全新的ubuntu18.04虚拟机<br /><a href=""><img src="images\996-1.png" alt="images\996-1.png" /></a><br /><br />编译chromium官方指导<br /><a href="https://chromium.googlesource.com/chromium/src/+/master/docs/linux/build_instructions.md">https://chromium.googlesource.com/chromium/src/+/master/docs/linux/build_instructions.md</a><br /><br /><h1>获得chromium源码</h1><br />官方资料基础上对获得源码的过程进行了简化<br /><div class="codebox"><div class="codebox">sudo&nbsp;apt-get&nbsp;install&nbsp;git&nbsp;python<br />git&nbsp;clone&nbsp;https://chromium.googlesource.com/chromium/tools/depot_tools.git<br />export&nbsp;PATH=&quot;$PATH:/path/to/depot_tools&quot;<br />mkdir&nbsp;chromium&nbsp;&amp;&amp;&nbsp;cd&nbsp;~/chromium<br />fetch&nbsp;--nohooks&nbsp;chromium<br />cd&nbsp;src<br />./build/install-build-deps.sh<br />gclient&nbsp;runhooks</div></div><br /><br />实际执行过程<br /><a href=""><img src="images\996-2.png" alt="images\996-2.png" /></a><br /><a href=""><img src="images\996-3.png" alt="images\996-3.png" /></a><br /><a href=""><img src="images\996-4.png" alt="images\996-4.png" /></a><br /><br />depot_tools是编译chromium的必要工具<br />fetch是一个存在于depot_tools中的工具，且fetch步骤会耗时很久<br />gclient也是depot_tools中的工具<br /><br /><h1>编译chromium</h1><br />在之前命令执行的基础上，执行以下两条命令即可编译，（此步骤甚至可能耗时12小时）<br /><div class="codebox"><div class="codebox">gn&nbsp;gen&nbsp;out/Default<br />autoninja&nbsp;-C&nbsp;out/Default&nbsp;chrome</div></div><br /><br /><h1>总览项目中的fuzzer以及编译运行fuzzer</h1><br />通过grep命令确定项目中有多少个libfuzzer存在（部分使用了libprotobuf-mutatiom的libfuzzer入口点不是该函数）<br />同时使用wc -l参数可以确定fuzzer的数量<br /><a href=""><img src="images\996-5.png" alt="images\996-5.png" /></a><br /><br />查看即将被编译运行的fuzzer源码<br /><a href=""><img src="images\996-6.png" alt="images\996-6.png" /></a><br /><a href=""><img src="images\996-7.png" alt="images\996-7.png" /></a><br /><br /><h2>使用项目中提供的辅助脚本处理当前fuzzer</h2><br />首先使用tools/mb/mb.py脚本创建fuzzer对应的配置文件<br /><div class="codebox"><div class="codebox">$&nbsp;python&nbsp;tools/mb/mb.py&nbsp;gen&nbsp;-m&nbsp;chromium.fuzz&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-b&nbsp;&#39;Libfuzzer&nbsp;Upload&nbsp;Linux&nbsp;ASan&#39;&nbsp;out/pdfium-fuzzer</div></div><br /><a href=""><img src="images\996-8.png" alt="images\996-8.png" /></a><br />这里ASan表示使用address sanitizer<br />输出目录为out/pdfium-fuzzer，以上命令会在该目录中生成配置文件，通过修改配置文件，可以更改fuzer的编译过程<br /><br /><h2>修改配置文件，不使用goma编译器处理fuzzer</h2><br />goma是只有谷歌内部才能使用的编译器<br /><a href=""><img src="images\996-9.png" alt="images\996-9.png" /></a><br /><a href=""><img src="images\996-10.png" alt="images\996-10.png" /></a><br /><br /><h2>使用ninja编译器编译fuzzer</h2><br /><div class="codebox"><div class="codebox">$&nbsp;ninja&nbsp;-C&nbsp;out/pdfium-fuzzer&nbsp;pdfium_fuzzer</div></div><br /><a href=""><img src="images\996-11.png" alt="images\996-11.png" /></a><br /><br />对应源码文件<br /><a href=""><img src="images\996-12.png" alt="images\996-12.png" /></a><br /><br />编译完成后运行fuzzer，当前报错很常见，需要忽略<br /><a href=""><img src="images\996-13.png" alt="images\996-13.png" /></a><br /><br />设置环境变量忽略该错误<br /><a href=""><img src="images\996-14.png" alt="images\996-14.png" /></a><br /><br />为fuzzer创建种子文件以及语料库<br /><a href=""><img src="images\996-15.png" alt="images\996-15.png" /></a><br /><br /> 带种子和语料库运行fuzzer<br /> <a href=""><img src="images\996-16.png" alt="images\996-16.png" /></a><br /> <br /></div><div class='page'><h1 class='title level-4'>4_Studying_existing_Chromium_fuzzing_infrastructure</h1><br/><h1>Studying existing Chromium fuzzing infrastructure</h1><br />在本节中，我们研究使用LibFuzzer的Chromium模糊测试设置。  Chromium可能是LibFuzzer模糊测试人员最关注的代码库之一，而且LibFuzzer的许多核心开发人员也是协助Chromium模糊测试的Google员工。<br /><br />本部分的目的是：<br />1、研究Google LibFuzzer设置的基础结构。<br />2、构建支持模糊器的Chromium代码库<br />3、运行给定的一组现有Chromium模糊器<br />4、修改现有的模糊器以使其更精确<br />5、添加新的模糊器<br /><br /><h2>Chromium模糊器基础设施概述</h2><br />Chromium通过LibFuzzer为模糊测试提供了广泛的支持，其背后的关键基础设施之一称为ClusterFuzz。 尽管我们不会在此处详细研究ClusterFuzz，但将从基础架构的角度对其进行研究。<br /><br /><h3>Chromium源代码中的Fuzzers</h3><br />要大致了解Chromium代码库中存在的模糊器，我们可以对代码库进行简单的grep。 例如，我们可以查找常用的LLVMFuzzerTestOneInput函数的所有实例：<br /><div class="codebox"><div class="codebox">$&nbsp;grep&nbsp;-rn&nbsp;&quot;LLVMFuzzerTestOneInput&quot;&nbsp;./&nbsp;|&nbsp;wc&nbsp;-l<br />703</div></div><br /><br />并且我们观察到有超过700个此函数实例。<br /><br /><h3>观察现有模糊器的代码覆盖率</h3><br />进入Chromium模糊测试的一个好起点是观察现有模糊测试器的状态。Google为我们提供了便利，因为公众可以使用现有的模糊器实现的代码覆盖率。此URL显示针对给定版本的源代码，模糊测试所实现的Chromium覆盖率。<br /><br /><h3>Coverage overview.</h3><br /><a href=""><img src="images\997-1.png" alt="images\997-1.png" /></a><br /><br />通过选择Fuzzers URL之一，我们将进入一个类似于下图的页面：<br /><h3>Coverage code listing</h3><br /><a href=""><img src="images\997-2.png" alt="images\997-2.png" /></a><br /><br />这是我们在本课程前面看到的熟悉的代码覆盖率可视化。 在图的底部，我们可以看到在代码库中总共有大约600万行源代码，其中大约一半（47.26％）被chrome代码库的模糊测试击中。 该图的一个值得注意的部分是chrome文件夹本身的覆盖率为0.05％，这表明Google并未公开chrome文件夹的数据。<br /><br />Chrome的源代码很复杂，尝试理解所有内容都是不合理的。 但是，可以在第三方文件夹中找到一个有趣的文件夹，用于了解Chrome的模糊设置的工作方式，该文件夹如下所示：<br /><br />Coverage of thirdparty folder in Chrome source code.<br /><a href=""><img src="images\997-3.png" alt="images\997-3.png" /></a><br /><br />向下滚动third party tools的列表，我们可以找到一个名为pdfium的文件夹：<br /><br />thirdparty文件夹下chrome代码覆盖率情况<br /><a href=""><img src="images\997-4.png" alt="images\997-4.png" /></a><br /><br />此目录包含Chrome内部PDF解析器的源代码，并且是Google基础架构的重要组成部分。 尽管Pdfium源代码位于第三方文件夹中，但它是Chrome的关键部分，您可以在Google的源代码文档中找到该工具的文档。  PDFium的覆盖范围概述类似于：<br /><br />thirdparty/Pdfium下chrome代码覆盖率情况<br /><a href=""><img src="images\997-5.png" alt="images\997-5.png" /></a><br /><br />PDFium的模糊器位于testing / fuzzers目录中，其外观应如下所示：<br /><a href=""><img src="images\997-6.png" alt="images\997-6.png" /></a><br /><br />至此，我们已经有了PDFium模糊器的位置，下一步是在执行和改进模糊器之前研究这些模糊器的具体实现。由于PDFium是PDF解析器，因此就功能测试而言，我们可以期望的最基本的模糊器是模糊器，它仅提供随机数据供PDFium解释为PDF文件并进行解析。该模糊器位于pdfium_fuzzer.cc文件中，其外观如下<br /><a href=""><img src="images\997-7.png" alt="images\997-7.png" /></a><br /><br />从源代码本身来看，模糊器看起来非常简单。 但是，它利用了辅助类PDFiumFuzzer，这是一个专门为辅助为PDFium编写模糊器而开发的额外类，我们将不研究该C ++类的具体细节，而是继续我们的过程并开始构建模糊器，以便我们可以执行它。<br /><br /><h2>Preparing for fuzzing: Building Chromium from source</h2><br /><br />至此，我们对Chromium模糊测试的工作原理进行了概述，并看到了示例模糊测试程序的源代码。 下一步是构建并运行一些现有的模糊测试器，以便对模糊化Chromium进行明确的动手实践。<br /><br /><h3>构建虚拟机</h3><br />我们的第一步是构建一个方便的环境，在这里我们可以实际从源代码构建Chrome。 为此，我建议创建一个专用于您的Chrome模糊测试的新虚拟机，其原因纯粹是Chromium太大，以至于缩小它的大小可以拥有一个干净的工作场所。<br /><br />我们创建的虚拟机应具有大约100G的磁盘空间。<br /><br />机器标准：<br />操作系统：ubuntu<br />磁盘空间：100G<br />内存：16 GB<br /><br /><h3>首次编译Chrome。</h3><br />为了熟悉该过程，我们将首先完整构建Chromium。<br /><a href="https://chromium.googlesource.com/chromium/src/+/master/docs/linux/build_instructions.md">https://chromium.googlesource.com/chromium/src/+/master/docs/linux/build_instructions.md</a><br /><br /><h3>下载Chrome</h3><br />我们将遵循此处描述的Chrome编译过程。<br /><br /><h3>构建Chrome源代码</h3><br />为了安装Chrome，我们必须安装git，python和python-pip：<br /><div class="codebox"><div class="codebox">sudo&nbsp;apt-get&nbsp;install&nbsp;git&nbsp;python&nbsp;python-pip&nbsp;-y</div></div><br /><br />第一步是安装depot_tools。 为此，请克隆存储库：<br /><div class="codebox"><div class="codebox">$&nbsp;git&nbsp;clone&nbsp;https://chromium.googlesource.com/chromium/tools/depot_tools.git</div></div><br /><br />接下来，将depot_tools添加到您的PATH变量中：<br /><div class="codebox"><div class="codebox">$&nbsp;export&nbsp;PATH=&quot;$PATH:/path/to/depot_tools&quot;</div></div><br /><br />第二步是实际获取Chromium源代码。 为此，首先创建一个文件夹，我们将在其中放置源代码：<br /><div class="codebox"><div class="codebox">$&nbsp;mkdir&nbsp;chromium&nbsp;&amp;&amp;&nbsp;cd&nbsp;~/chromium</div></div><br /><br />然后，我们需要使用来自depot_tools的获取工具（应该在您的PATH变量中）：<br /><div class="codebox"><div class="codebox">$&nbsp;fetch&nbsp;--nohooks&nbsp;chromium</div></div><br /><br />提取源代码可能要花费很长时间，并且可能要花费几个小时。 接下来，我们导航到生成的src目录：<br /><div class="codebox"><div class="codebox">$&nbsp;cd&nbsp;src</div></div><br /><br />然后，我们需要安装Chromium依赖项：<br /><div class="codebox"><div class="codebox">$&nbsp;./build/install-build-deps.sh</div></div><br /><br />在这一点上，我们需要安装其他二进制文件，称为Chromium-hooks，这是使用gclient工具完成的：<br /><div class="codebox"><div class="codebox">$&nbsp;gclient&nbsp;runhooks</div></div><br /><br />现在我们有了Chromium的来源和依赖项。<br /><br /><br /><h2>Optional, build Chromium</h2><br />现在，我们可以构建Chromium，尽管不需要简单地构建fuzzer，但这需要很多小时，具体取决于您的系统（超过10个小时）。 但是，如果您感到好奇，我们将保留执行此操作所需的步骤。<br /><br />第三步是准备构建。  Chromium使用两步构建过程，首先创建必要的配置文件，以描述所需的build设置，然后第二步是使用给定的配置文件执行实际build。这将在以后派上用场，因为我们可以使用许多不同的配置进行构建，包括不同的消毒剂和类似的东西。 为了设置我们的第一个版本，我们需要使用gn工具：<br /><br /><div class="codebox"><div class="codebox">$&nbsp;gn&nbsp;gen&nbsp;out/Default</div></div><br /><br />此时，您将在out / Default目录中看到一组文件。<br /><br />最后一步是实际运行构建，而我们执行此操作的方法是使用autoninja工具，如下所示：<br /><div class="codebox"><div class="codebox">$&nbsp;autoninja&nbsp;-C&nbsp;out/Default&nbsp;chrome</div></div><br /><br />上面的命令将执行out / Default文件夹中指定的构建，并将构建目标chrome。 成功执行上述命令后，您可以按以下方式运行Chrome的编译版本：<br /><div class="codebox"><div class="codebox">$&nbsp;./out/Default/chrome</div></div><br /><br />总之，以下脚本将自动完成从源代码构建Chrome的整个过程：<br />获取和配置Chromium源的命令<br /><div class="codebox"><div class="codebox">sudo&nbsp;apt-get&nbsp;install&nbsp;git&nbsp;python<br />git&nbsp;clone&nbsp;https://chromium.googlesource.com/chromium/tools/depot_tools.git<br />export&nbsp;PATH=&quot;$PATH:/path/to/depot_tools&quot;<br />mkdir&nbsp;chromium&nbsp;&amp;&amp;&nbsp;cd&nbsp;~/chromium<br />fetch&nbsp;--nohooks&nbsp;chromium<br />cd&nbsp;src<br />./build/install-build-deps.sh<br />gclient&nbsp;runhooks<br /></div></div><br /><br />现在，我们还可以构建Chromium源代码，或者继续进行构建模糊器的下一步。<br /><div class="codebox"><div class="codebox">gn&nbsp;gen&nbsp;out/Default<br />autoninja&nbsp;-C&nbsp;out/Default&nbsp;chrome</div></div><br /><br /><h2>Building Chromium fuzzers</h2><br />至此，我们已经构建并运行了Chromium的第一个版本，并且还观察到了Chromium代码库中的一些模糊测试。 下一步是在代码库中构建一些现有的模糊器并运行它们。这是本节的目标，我们将在此处关注的文档。 从高级的角度来看，我们构建给定模糊器的方式与我们自己构建Chromium的方式非常相似。 特别是，我们采取两步方法，首先配置构建设置，然后执行此构建设置。<br /><br />第一步是准备构建设置。 为此，我们将使用位于tools / mb / mb.py的辅助脚本mb.py。 我们使用以下命令准备构建设置：<br /><div class="codebox"><div class="codebox">$&nbsp;python&nbsp;tools/mb/mb.py&nbsp;gen&nbsp;-m&nbsp;chromium.fuzz&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-b&nbsp;&#39;Libfuzzer&nbsp;Upload&nbsp;Linux&nbsp;ASan&#39;&nbsp;out/pdfium-fuzzer</div></div><br /><br />此步骤准备好我们的构建，实际上是对我们在构建整个Chromium浏览器时使用的gn命令的包装。<br /><br />第二步是稍微修改构建设置，专门避免使用goma编译器。 为此，我们需要修改文件out / pdfium-fuzzer / args.gn，尤其是应包含use_goma = false行，并确保文件中没有内容为use_goma = true的行。<br /><br />第三步是执行实际的构建，我们将使用以下命令执行此操作：<br /><div class="codebox"><div class="codebox">$&nbsp;ninja&nbsp;-C&nbsp;out/pdfium-fuzzer&nbsp;pdfium_fuzzer</div></div><br /><br />遵循此命令，您将看到构建过程开始，并且它应如下所示：<br /><div class="codebox"><div class="codebox">$&nbsp;ninja&nbsp;-C&nbsp;out/pdfium-fuzzer&nbsp;pdfium_fuzzer<br />ninja:&nbsp;Entering&nbsp;directory&nbsp;`out/pdfium-fuzzer&#39;<br />[38/3119]&nbsp;CXX&nbsp;obj/buildtools/third_party/libc++/libc++/string.o</div></div><br /><br />模糊器的构建过程将比整个Chromium浏览器的构建过程快得多，并且在现代台式机上应该花费不到15分钟的时间。 构建过程完成后，将在out / pdfium-fuzzer / pdfium-fuzzer中存在一个与我们的fuzzer相对应的二进制可执行文件。<br /><br /><h2>Running Chrome Fuzzers</h2><br />本节说明了如何运行PDF模糊器。 第一步是执行上面构建的模糊器，然后执行简单的二进制可执行文件，同时为fuzzer提供语料库文件夹<br /><div class="codebox"><div class="codebox">$&nbsp;mkdir&nbsp;Corpus<br />$&nbsp;ASAN_OPTIONS=detect_odr_violation=0&nbsp;./out/pdfium-fuzzer/pdfium_fuzzer&nbsp;./Corpus/<br />INFO:&nbsp;Seed:&nbsp;629343114<br />INFO:&nbsp;Loaded&nbsp;11&nbsp;modules&nbsp;&nbsp;&nbsp;(713051&nbsp;inline&nbsp;8-bit&nbsp;counters):&nbsp;14299&nbsp;[0x7fadab5362b0,&nbsp;0x7fadab539a8b),&nbsp;2565&nbsp;[0x7fadaa2ced2b,&nbsp;0x7fadaa2cf730),&nbsp;4316&nbsp;[0x7fadb4383bbb,&nbsp;0x7fadb4384c97),&nbsp;3565&nbsp;[0x7fadb444f9db,&nbsp;0x7fadb44507c8),&nbsp;34633&nbsp;[0x7fadb15e8cdb,&nbsp;0x7fadb15f1424),&nbsp;46444&nbsp;[0x7fadabcbedcb,&nbsp;0x7fadabcca337),&nbsp;2370&nbsp;[0x7fadb44c21ab,&nbsp;0x7fadb44c2aed),&nbsp;368077&nbsp;[0x7fadb0a1500b,&nbsp;0x7fadb0a6edd8),&nbsp;57647&nbsp;[0x7fadb210ffeb,&nbsp;0x7fadb211e11a),&nbsp;171435&nbsp;[0x7fadb3fd204b,&nbsp;0x7fadb3ffbdf6),&nbsp;7700&nbsp;[0x55d396525240,&nbsp;0x55d396527054),&nbsp;<br />INFO:&nbsp;Loaded&nbsp;11&nbsp;PC&nbsp;tables&nbsp;(713051&nbsp;PCs):&nbsp;14299&nbsp;[0x7fadab539a90,0x7fadab571840),&nbsp;2565&nbsp;[0x7fadaa2cf730,0x7fadaa2d9780),&nbsp;4316&nbsp;[0x7fadb4384c98,0x7fadb4395a58),&nbsp;3565&nbsp;[0x7fadb44507c8,0x7fadb445e698),&nbsp;34633&nbsp;[0x7fadb15f1428,0x7fadb16788b8),&nbsp;46444&nbsp;[0x7fadabcca338,0x7fadabd7f9f8),&nbsp;2370&nbsp;[0x7fadb44c2af0,0x7fadb44cbf10),&nbsp;368077&nbsp;[0x7fadb0a6edd8,0x7fadb100caa8),&nbsp;57647&nbsp;[0x7fadb211e120,0x7fadb21ff410),&nbsp;171435&nbsp;[0x7fadb3ffbdf8,0x7fadb42998a8),&nbsp;7700&nbsp;[0x55d396527058,0x55d396545198),&nbsp;<br />INFO:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;files&nbsp;found&nbsp;in&nbsp;./Corpus/<br />INFO:&nbsp;-max_len&nbsp;is&nbsp;not&nbsp;provided;&nbsp;libFuzzer&nbsp;will&nbsp;not&nbsp;generate&nbsp;inputs&nbsp;larger&nbsp;than&nbsp;4096&nbsp;bytes<br />INFO:&nbsp;A&nbsp;corpus&nbsp;is&nbsp;not&nbsp;provided,&nbsp;starting&nbsp;from&nbsp;an&nbsp;empty&nbsp;corpus<br />#2	INITED&nbsp;cov:&nbsp;1298&nbsp;ft:&nbsp;1284&nbsp;corp:&nbsp;1/1b&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;144Mb<br />	NEW_FUNC[1/35]:&nbsp;0x7fadb2e7d690&nbsp;&nbsp;(/home/dav/code/chromium/src/out/pdfium-fuzzer/libpdfium.so+0xc67690)<br />	NEW_FUNC[2/35]:&nbsp;0x7fadb2e85c30&nbsp;&nbsp;(/home/dav/code/chromium/src/out/pdfium-fuzzer/libpdfium.so+0xc6fc30)<br />#7	NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;1345&nbsp;ft:&nbsp;1375&nbsp;corp:&nbsp;2/5b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;147Mb&nbsp;L:&nbsp;4/4&nbsp;MS:&nbsp;5&nbsp;ChangeByte-ChangeBit-InsertByte-ChangeBinInt-CrossOver-<br />#216	NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;1345&nbsp;ft:&nbsp;1442&nbsp;corp:&nbsp;3/10b&nbsp;lim:&nbsp;6&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;148Mb&nbsp;L:&nbsp;5/5&nbsp;MS:&nbsp;4&nbsp;ChangeBit-ChangeByte-ChangeByte-InsertByte-<br />#219	NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;1345&nbsp;ft:&nbsp;1471&nbsp;corp:&nbsp;4/16b&nbsp;lim:&nbsp;6&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;148Mb&nbsp;L:&nbsp;6/6&nbsp;MS:&nbsp;3&nbsp;ChangeBinInt-ChangeBinInt-InsertByte-<br />#438	NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;1345&nbsp;ft:&nbsp;1535&nbsp;corp:&nbsp;5/24b&nbsp;lim:&nbsp;8&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;149Mb&nbsp;L:&nbsp;8/8&nbsp;MS:&nbsp;4&nbsp;EraseBytes-ChangeByte-InsertByte-InsertRepeatedBytes-<br />	NEW_FUNC[1/2]:&nbsp;0x7fadb3dd0bc0&nbsp;&nbsp;(/home/dav/code/chromium/src/out/pdfium-fuzzer/libpdfium.so+0x1bbabc0)<br />	NEW_FUNC[2/2]:&nbsp;0x7fadb3dd0e00&nbsp;&nbsp;(/home/dav/code/chromium/src/out/pdfium-fuzzer/libpdfium.so+0x1bbae00)<br />#748	NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;1348&nbsp;ft:&nbsp;1619&nbsp;corp:&nbsp;6/35b&nbsp;lim:&nbsp;11&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;150Mb&nbsp;L:&nbsp;11/11&nbsp;MS:&nbsp;5&nbsp;ChangeByte-ChangeBit-InsertByte-CMP-CrossOver-&nbsp;DE:&nbsp;&quot;\x00\x04&quot;-<br />	NEW_FUNC[1/107]:&nbsp;0x7fadb2e80510&nbsp;&nbsp;(/home/dav/code/chromium/src/out/pdfium-fuzzer/libpdfium.so+0xc6a510)<br />	NEW_FUNC[2/107]:&nbsp;0x7fadb2e811d0&nbsp;&nbsp;(/home/dav/code/chromium/src/out/pdfium-fuzzer/libpdfium.so+0xc6b1d0)<br />#894	NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;1480&nbsp;ft:&nbsp;1821&nbsp;corp:&nbsp;7/44b&nbsp;lim:&nbsp;11&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;151Mb&nbsp;L:&nbsp;9/11&nbsp;MS:&nbsp;1&nbsp;CMP-&nbsp;DE:&nbsp;&quot;%PDF&quot;-<br />	NEW_FUNC[1/200]:&nbsp;0x7fadb2e7d570&nbsp;&nbsp;(/home/dav/code/chromium/src/out/pdfium-fuzzer/libpdfium.so+0xc67570)<br />	NEW_FUNC[2/200]:&nbsp;0x7fadb2e7d5d0&nbsp;&nbsp;(/home/dav/code/chromium/src/out/pdfium-fuzzer/libpdfium.so+0xc675d0)<br />#954	NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;1749&nbsp;ft:&nbsp;2233&nbsp;corp:&nbsp;8/54b&nbsp;lim:&nbsp;11&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;152Mb&nbsp;L:&nbsp;10/11&nbsp;MS:&nbsp;5&nbsp;ChangeByte-ChangeBinInt-InsertByte-ChangeBit-PersAutoDict-&nbsp;DE:&nbsp;&quot;%PDF&quot;-<br />#979	NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;1750&nbsp;ft:&nbsp;2235&nbsp;corp:&nbsp;9/60b&nbsp;lim:&nbsp;11&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;152Mb&nbsp;L:&nbsp;6/11&nbsp;MS:&nbsp;5&nbsp;ShuffleBytes-PersAutoDict-ChangeBinInt-CrossOver-PersAutoDict-&nbsp;DE:&nbsp;&quot;\x00\x04&quot;-&quot;%PDF&quot;-<br />	NEW_FUNC[1/24]:&nbsp;0x7fadb2e7d4a0&nbsp;&nbsp;(/home/dav/code/chromium/src/out/pdfium-fuzzer/libpdfium.so+0xc674a0)<br />	NEW_FUNC[2/24]:&nbsp;0x7fadb2e812c0&nbsp;&nbsp;(/home/dav/code/chromium/src/out/pdfium-fuzzer/libpdfium.so+0xc6b2c0)<br />#1006	NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;1792&nbsp;ft:&nbsp;2396&nbsp;corp:&nbsp;10/71b&nbsp;lim:&nbsp;11&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;152Mb&nbsp;L:&nbsp;11/11&nbsp;MS:&nbsp;2&nbsp;EraseBytes-PersAutoDict-&nbsp;DE:&nbsp;&quot;%PDF&quot;-<br />#1045	NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;1792&nbsp;ft:&nbsp;2400&nbsp;corp:&nbsp;11/77b&nbsp;lim:&nbsp;11&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;152Mb&nbsp;L:&nbsp;6/11&nbsp;MS:&nbsp;4&nbsp;ChangeBit-EraseBytes-ShuffleBytes-PersAutoDict-&nbsp;DE:&nbsp;&quot;%PDF&quot;-<br />#1119	NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;1794&nbsp;ft:&nbsp;2402&nbsp;corp:&nbsp;12/88b&nbsp;lim:&nbsp;11&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;152Mb&nbsp;L:&nbsp;11/11&nbsp;MS:&nbsp;4&nbsp;CrossOver-CMP-ChangeByte-PersAutoDict-&nbsp;DE:&nbsp;&quot;\x0a\x00\x00\x00\x00\x00\x00\x00&quot;-&quot;%PDF&quot;-</div></div><br /><br />请注意，我们还必须传递选项ASAN_OPTIONS = detect_odr_violation = 0，因为否则运行我们时，模糊器会报错。<br /><br />保持模糊器大约一分钟，我们的覆盖范围达到3000左右，大概得到的700个测试用例：<br /><div class="codebox"><div class="codebox">$&nbsp;ls&nbsp;-la&nbsp;./Corpus/&nbsp;|&nbsp;wc&nbsp;-l<br />762</div></div><br /><br /><h2>Improving efficiency with seeds</h2><br />简单地执行没有任何种子输入的模糊器意味着模糊器必须花费大量时间探索目标的代码以生成类似于真实PDF文件的语料库文件。 因此，不是在没有种子文件的情况下对其进行模糊处理，我们将为模糊器提供一个有效的PDF文件作为种子，并且我们可以在网上轻松找到任何此类PDF文件，例如此处的简单PDF文件。 提供此种子文件将为我们提供以下结果：<br /><div class="codebox"><div class="codebox">$&nbsp;mkdir&nbsp;pdf_seed<br />$&nbsp;wget&nbsp;http://africau.edu/images/default/sample.pdf<br />$&nbsp;mv&nbsp;sample.pdf&nbsp;./pdf_seed/<br />$&nbsp;mkdir&nbsp;corpus-1<br />$&nbsp;ASAN_OPTIONS=detect_odr_violation=0&nbsp;./out/pdfium-fuzzer/pdfium_fuzzer&nbsp;./corpus-1&nbsp;./pdf_seed<br />INFO:&nbsp;Seed:&nbsp;1089310708<br />INFO:&nbsp;Loaded&nbsp;11&nbsp;modules&nbsp;&nbsp;&nbsp;(713051&nbsp;inline&nbsp;8-bit&nbsp;counters):&nbsp;14299&nbsp;[0x7fe9490852b0,&nbsp;0x7fe949088a8b),&nbsp;2565&nbsp;[0x7fe947e1dd2b,&nbsp;0x7fe947e1e730),&nbsp;4316&nbsp;[0x7fe951ed2bbb,&nbsp;0x7fe951ed3c97),&nbsp;3565&nbsp;[0x7fe951f9e9db,&nbsp;0x7fe951f9f7c8),&nbsp;34633&nbsp;[0x7fe94f137cdb,&nbsp;0x7fe94f140424),&nbsp;46444&nbsp;[0x7fe94980ddcb,&nbsp;0x7fe949819337),&nbsp;2370&nbsp;[0x7fe9520111ab,&nbsp;0x7fe952011aed),&nbsp;368077&nbsp;[0x7fe94e56400b,&nbsp;0x7fe94e5bddd8),&nbsp;57647&nbsp;[0x7fe94fc5efeb,&nbsp;0x7fe94fc6d11a),&nbsp;171435&nbsp;[0x7fe951b2104b,&nbsp;0x7fe951b4adf6),&nbsp;7700&nbsp;[0x55a7094fb240,&nbsp;0x55a7094fd054),&nbsp;<br />INFO:&nbsp;Loaded&nbsp;11&nbsp;PC&nbsp;tables&nbsp;(713051&nbsp;PCs):&nbsp;14299&nbsp;[0x7fe949088a90,0x7fe9490c0840),&nbsp;2565&nbsp;[0x7fe947e1e730,0x7fe947e28780),&nbsp;4316&nbsp;[0x7fe951ed3c98,0x7fe951ee4a58),&nbsp;3565&nbsp;[0x7fe951f9f7c8,0x7fe951fad698),&nbsp;34633&nbsp;[0x7fe94f140428,0x7fe94f1c78b8),&nbsp;46444&nbsp;[0x7fe949819338,0x7fe9498ce9f8),&nbsp;2370&nbsp;[0x7fe952011af0,0x7fe95201af10),&nbsp;368077&nbsp;[0x7fe94e5bddd8,0x7fe94eb5baa8),&nbsp;57647&nbsp;[0x7fe94fc6d120,0x7fe94fd4e410),&nbsp;171435&nbsp;[0x7fe951b4adf8,0x7fe951de88a8),&nbsp;7700&nbsp;[0x55a7094fd058,0x55a70951b198),&nbsp;<br />INFO:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;files&nbsp;found&nbsp;in&nbsp;./corpus-1<br />INFO:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;files&nbsp;found&nbsp;in&nbsp;./pdf_seed<br />INFO:&nbsp;-max_len&nbsp;is&nbsp;not&nbsp;provided;&nbsp;libFuzzer&nbsp;will&nbsp;not&nbsp;generate&nbsp;inputs&nbsp;larger&nbsp;than&nbsp;4096&nbsp;bytes<br />INFO:&nbsp;seed&nbsp;corpus:&nbsp;files:&nbsp;1&nbsp;min:&nbsp;3028b&nbsp;max:&nbsp;3028b&nbsp;total:&nbsp;3028b&nbsp;rss:&nbsp;141Mb<br />#3	INITED&nbsp;cov:&nbsp;12033&nbsp;ft:&nbsp;12029&nbsp;corp:&nbsp;1/3028b&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;171Mb<br />	NEW_FUNC[1/7]:&nbsp;0x7fe950a086e0&nbsp;&nbsp;(/home/dav/code/chromium/src/out/pdfium-fuzzer/libpdfium.so+0xca36e0)<br />	NEW_FUNC[2/7]:&nbsp;0x7fe950a08b90&nbsp;&nbsp;(/home/dav/code/chromium/src/out/pdfium-fuzzer/libpdfium.so+0xca3b90)<br />#4	NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;12063&nbsp;ft:&nbsp;13850&nbsp;corp:&nbsp;2/6056b&nbsp;lim:&nbsp;3028&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;179Mb&nbsp;L:&nbsp;3028/3028&nbsp;MS:&nbsp;1&nbsp;CopyPart-<br />	NEW_FUNC[1/155]:&nbsp;0x7fe9509cfcd0&nbsp;&nbsp;(/home/dav/code/chromium/src/out/pdfium-fuzzer/libpdfium.so+0xc6acd0)<br />	NEW_FUNC[2/155]:&nbsp;0x7fe9509cfed0&nbsp;&nbsp;(/home/dav/code/chromium/src/out/pdfium-fuzzer/libpdfium.so+0xc6aed0)<br />#5	NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;12315&nbsp;ft:&nbsp;15025&nbsp;corp:&nbsp;3/9084b&nbsp;lim:&nbsp;3028&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;185Mb&nbsp;L:&nbsp;3028/3028&nbsp;MS:&nbsp;1&nbsp;CopyPart-<br />	NEW_FUNC[1/6]:&nbsp;0x7fe950a04be0&nbsp;&nbsp;(/home/dav/code/chromium/src/out/pdfium-fuzzer/libpdfium.so+0xc9fbe0)<br />	NEW_FUNC[2/6]:&nbsp;0x7fe950c1d2e0&nbsp;&nbsp;(/home/dav/code/chromium/src/out/pdfium-fuzzer/libpdfium.so+0xeb82e0)<br />#6	NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;12333&nbsp;ft:&nbsp;15494&nbsp;corp:&nbsp;4/12112b&nbsp;lim:&nbsp;3028&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;185Mb&nbsp;L:&nbsp;3028/3028&nbsp;MS:&nbsp;1&nbsp;CrossOver-<br />#7	NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;12333&nbsp;ft:&nbsp;15500&nbsp;corp:&nbsp;5/14203b&nbsp;lim:&nbsp;3028&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;185Mb&nbsp;L:&nbsp;2091/3028&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#13	NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;12333&nbsp;ft:&nbsp;15502&nbsp;corp:&nbsp;6/16183b&nbsp;lim:&nbsp;3028&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;185Mb&nbsp;L:&nbsp;1980/3028&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />	NEW_FUNC[1/8]:&nbsp;0x7fe950a76860&nbsp;&nbsp;(/home/dav/code/chromium/src/out/pdfium-fuzzer/libpdfium.so+0xd11860)<br />	NEW_FUNC[2/8]:&nbsp;0x7fe950b5b090&nbsp;&nbsp;(/home/dav/code/chromium/src/out/pdfium-fuzzer/libpdfium.so+0xdf6090)<br />#14	NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;12371&nbsp;ft:&nbsp;20347&nbsp;corp:&nbsp;7/18Kb&nbsp;lim:&nbsp;3028&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;190Mb&nbsp;L:&nbsp;3028/3028&nbsp;MS:&nbsp;1&nbsp;ChangeBinInt-<br />#15	REDUCE&nbsp;cov:&nbsp;12371&nbsp;ft:&nbsp;20347&nbsp;corp:&nbsp;7/17Kb&nbsp;lim:&nbsp;3028&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;190Mb&nbsp;L:&nbsp;2048/3028&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />	NEW_FUNC[1/140]:&nbsp;0x7fe950a8fa30&nbsp;&nbsp;(/home/dav/code/chromium/src/out/pdfium-fuzzer/libpdfium.so+0xd2aa30)<br />	NEW_FUNC[2/140]:&nbsp;0x7fe950a9f750&nbsp;&nbsp;(/home/dav/code/chromium/src/out/pdfium-fuzzer/libpdfium.so+0xd3a750)<br />#16	NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;12568&nbsp;ft:&nbsp;21006&nbsp;corp:&nbsp;8/20Kb&nbsp;lim:&nbsp;3028&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;195Mb&nbsp;L:&nbsp;3028/3028&nbsp;MS:&nbsp;1&nbsp;ChangeByte-<br />#21	NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;12568&nbsp;ft:&nbsp;21007&nbsp;corp:&nbsp;9/22Kb&nbsp;lim:&nbsp;3028&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;195Mb&nbsp;L:&nbsp;1415/3028&nbsp;MS:&nbsp;5&nbsp;EraseBytes-CMP-ShuffleBytes-InsertRepeatedBytes-EraseBytes-&nbsp;DE:&nbsp;&quot;\x01\x00\x00\x00\x00\x00\x04\x04&quot;-<br />	NEW_FUNC[1/23]:&nbsp;0x7fe9509dad80&nbsp;&nbsp;(/home/dav/code/chromium/src/out/pdfium-fuzzer/libpdfium.so+0xc75d80)<br />	NEW_FUNC[2/23]:&nbsp;0x7fe950be4cc0&nbsp;&nbsp;(/home/dav/code/chromium/src/out/pdfium-fuzzer/libpdfium.so+0xe7fcc0)<br />#22	NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;12626&nbsp;ft:&nbsp;22115&nbsp;corp:&nbsp;10/24Kb&nbsp;lim:&nbsp;3028&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;195Mb&nbsp;L:&nbsp;1987/3028&nbsp;MS:&nbsp;1&nbsp;CrossOver-<br />#23	NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;12626&nbsp;ft:&nbsp;22121&nbsp;corp:&nbsp;11/26Kb&nbsp;lim:&nbsp;3028&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;195Mb&nbsp;L:&nbsp;1988/3028&nbsp;MS:&nbsp;1&nbsp;InsertByte-<br />#26	NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;12626&nbsp;ft:&nbsp;22122&nbsp;corp:&nbsp;12/28Kb&nbsp;lim:&nbsp;3028&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;195Mb&nbsp;L:&nbsp;2199/3028&nbsp;MS:&nbsp;3&nbsp;CMP-ChangeASCIIInt-InsertRepeatedBytes-&nbsp;DE:&nbsp;&quot;false&quot;-<br />#28	NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;12626&nbsp;ft:&nbsp;22140&nbsp;corp:&nbsp;13/30Kb&nbsp;lim:&nbsp;3028&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;195Mb&nbsp;L:&nbsp;2095/3028&nbsp;MS:&nbsp;2&nbsp;InsertByte-InsertRepeatedBytes-<br />#29	NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;12626&nbsp;ft:&nbsp;22245&nbsp;corp:&nbsp;14/33Kb&nbsp;lim:&nbsp;3028&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;195Mb&nbsp;L:&nbsp;3028/3028&nbsp;MS:&nbsp;1&nbsp;CrossOver-<br />#30	NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;12626&nbsp;ft:&nbsp;22249&nbsp;corp:&nbsp;15/35Kb&nbsp;lim:&nbsp;3028&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;195Mb&nbsp;L:&nbsp;2113/3028&nbsp;MS:&nbsp;1&nbsp;InsertRepeatedBytes-<br />#32	NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;12626&nbsp;ft:&nbsp;22250&nbsp;corp:&nbsp;16/36Kb&nbsp;lim:&nbsp;3028&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;195Mb&nbsp;L:&nbsp;1057/3028&nbsp;MS:&nbsp;2&nbsp;ChangeASCIIInt-CrossOver-<br />#33	REDUCE&nbsp;cov:&nbsp;12626&nbsp;ft:&nbsp;22250&nbsp;corp:&nbsp;16/35Kb&nbsp;lim:&nbsp;3028&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;195Mb&nbsp;L:&nbsp;1037/3028&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#36	REDUCE&nbsp;cov:&nbsp;12626&nbsp;ft:&nbsp;22251&nbsp;corp:&nbsp;17/37Kb&nbsp;lim:&nbsp;3028&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;195Mb&nbsp;L:&nbsp;2170/3028&nbsp;MS:&nbsp;3&nbsp;ChangeASCIIInt-InsertByte-InsertRepeatedBytes-</div></div><br /><br />使用我们的种子，cov指标直接上升到12000，执行模糊测试大约一分钟后，覆盖率达到15000。很明显，提供初始种子PDF对模糊测试的覆盖率有很大影响。<br /><br /><h3>Extracting the coverage of a Chromium fuzzer</h3><br />在本节中，我们将看到如何构建启用了覆盖范围的Chromium模糊测试，以观察模糊测试的效果。 为了从我们的模糊器中提取覆盖率信息，我们需要构建我们的模糊器及其针对覆盖率检测工具的代码。 为此，我们使用上面的gn工具和以下命令：<br /><div class="codebox"><div class="codebox">$&nbsp;gn&nbsp;gen&nbsp;out/coverage-pdfium&nbsp;--args=&quot;use_clang_coverage=true&nbsp;\&nbsp;is_component_build=false&nbsp;is_debug=false&nbsp;dcheck_always_on=true&nbsp;use_libfuzzer=true&quot;</div></div><br /><br />这将准备具有必要配置的构建文件夹。 为了运行构建和整个coverage提取步骤，我们将在Chromium基础结构中使用一个辅助脚本，该脚本位于tools / code_coverage / coverage.py中，名为coverage.py。 以下命令可实现此目的：<br /><br /><div class="codebox"><div class="codebox">$&nbsp;python&nbsp;tools/code_coverage/coverage.py&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pdfium_fuzzer&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-b&nbsp;out/coverage-pdfium&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-o&nbsp;out/report-pdfium&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-c&nbsp;&#39;out/coverage-pdfium/pdfium_fuzzer&nbsp;-runs=0&nbsp;./CORPUS_DIR&#39;</div></div><br /><br />上面的命令将编译具有coverage的pdfium_fuzzer并使用在out / coverage-pdfium文件夹中设置的配置，在out / report-pdfium文件夹中输出coverage HTML文件，而用于提取覆盖率信息的语料库是CORPUS_DIR。 我们可以确认覆盖率提取工作如下：<br /><div class="codebox"><div class="codebox">$&nbsp;ls&nbsp;-la&nbsp;./out/report-pdfium</div></div><br /><br />并启动coverage用户界面，如下所示：<br /><div class="codebox"><div class="codebox">$&nbsp;cd&nbsp;./out/report-pdfium<br />$&nbsp;python3&nbsp;-m&nbsp;http.server&nbsp;5001</div></div><br /><br />它将在端口5001上启动可视化服务器。<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /></div><div class='page'><h1 class='title level-4'>5_Creating a new Chromium fuzzer _ ADA Logics</h1><br/><h1>为项目创建一个空fuzzer</h1><br /><br />fuzzing的目标是PDFium，故将新fuzzer的源码文件写入对应目录<br /><a href=""><img src="images\998-1.png" alt="images\998-1.png" /></a><br /><br />空fuzzer<br /><a href=""><img src="images\998-2.png" alt="images\998-2.png" /></a><br /><br />修改third_party/pdfium/testing/fuzzers/BUILD.gn文件（需要修改两部分）<br /><a href=""><img src="images\998-3.png" alt="images\998-3.png" /></a>  <a href=""><img src="images\998-4.png" alt="images\998-4.png" /></a><br />第二处修改中设置public_fuzzer=true的原因在于其后有部分fuzzer也这样进行了设置，推测项目中部分fuzzer仅供谷歌内部使用，不对外调用，public_fuzzer=true可以实现公开fauzzer<br /><br />• pdf/pdfium/fuzzers/BUILD.gn（需要修改两部分）<br /><a href=""><img src="images\998-5.png" alt="images\998-5.png" /></a> <a href=""><img src="images\998-6.png" alt="images\998-6.png" /></a><br />若想弄清以上文件为何进行这样的修改，需要弄清gn编译系统<br /><br /><h2>编译新的fuzzer</h2><br />使用到的命令<br /><div class="codebox"><div class="codebox">$&nbsp;python&nbsp;tools/mb/mb.py&nbsp;gen&nbsp;-m&nbsp;chromium.fuzz&nbsp;-b&nbsp;&#39;Libfuzzer&nbsp;Upload&nbsp;Linux&nbsp;ASan&#39;&nbsp;out/custom_fuzzer<br />$&nbsp;sed&nbsp;-i&nbsp;&#39;s/use_goma&nbsp;=&nbsp;true/use_goma&nbsp;=&nbsp;false&#39;/g&nbsp;out/custom_fuzzer/args.gn<br />$&nbsp;ninja&nbsp;-C&nbsp;out/custom_fuzzer&nbsp;pdf_custom_fuzzer<br />...<br />...<br />...<br />$&nbsp;export&nbsp;ASAN_OPTIONS=&quot;detect_odr_violation=0&quot;<br />$&nbsp;./out/custom_fuzzer/pdf_custom_fuzzer</div></div><br /><br />使用mb.py将生成编译fuzzer所需的配置文件到out/custom_fuzzer目录<br /><a href=""><img src="images\998-7.png" alt="images\998-7.png" /></a><br /><br />修改out/custom_fuzzer/args.gn，不使用goma编译fuzzer，该编译器为谷歌内部专用，可以使用sed命令直接修改，或vim对应文件进行修改<br /><a href=""><img src="images\998-8.png" alt="images\998-8.png" /></a><br /><br />使用ninja编译器编译<br /><a href=""><img src="images\998-9.png" alt="images\998-9.png" /></a><br /><br />直接运行会报错，需要设置环境变量从而忽略该错误<br /><a href=""><img src="images\998-10.png" alt="images\998-10.png" /></a><br /><br /><h1>找到仍未被fuzzer覆盖且有bug报告的代码，fuzzing此类代码</h1><br /><br />chromium的bug报告<br /><a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1031523">https://bugs.chromium.org/p/chromium/issues/detail?id=1031523</a><br /><a href=""><img src="images\998-11.png" alt="images\998-11.png" /></a><br /><br />bug报告中存在bug函数以及函数所在文件，在chromium覆盖率信息中查找此类函数是否被fuzzer覆盖<br /><br />查找<h3>CFXJSE_FormCalcContext::Decode</h3>函数，发现其未被当前fuzzer覆盖<br /><a href=""><img src="images\998-12.png" alt="images\998-12.png" /></a><br /><br /><h3>DecodeHTML</h3>函数未被fuzzer覆盖，即bug报告的调用栈信息中，从<h3>CFXJSE_FormCalcContext::Decode</h3>函数开始，之后的函数均为被fuzzer覆盖<br /><a href=""><img src="images\998-13.png" alt="images\998-13.png" /></a><br /><br />bug报告中能够得到触发该bug的pdf文件<br /><a href=""><img src="images\998-14.png" alt="images\998-14.png" /></a><br /><br />pdf文件内容，其中&lt;script&gt;Decode(<span style="color:#edd400;">&quot;&amp;|&quot;</span>,<span style="color:#edd400;">&quot;HTML&quot;</span>)&lt;/script&gt;部分调用了Decode函数，从而导致了bug发生<br />且Decode函数的调用发生在&lt;xdp xmlns=<span style="color:#edd400;">&quot;http://ns.adobe.com/xdp/&quot;</span>&gt;内，xdp是<h3>xfa</h3>格式的标志<br /><div class="codebox"><div class="codebox">%PDF-1.7<br />1&nbsp;0&nbsp;obj<br />&lt;&lt;/Type&nbsp;/Catalog&nbsp;/Pages&nbsp;2&nbsp;0&nbsp;R&nbsp;/AcroForm&nbsp;&lt;&lt;/XFA&nbsp;30&nbsp;0&nbsp;R&gt;&gt;&nbsp;/NeedsRendering&nbsp;true&gt;&gt;<br />endobj<br />2&nbsp;0&nbsp;obj<br />&lt;&lt;/Type&nbsp;/Pages&nbsp;/Kids&nbsp;[3&nbsp;0&nbsp;R]&nbsp;/Count&nbsp;1&gt;&gt;<br />endobj<br />3&nbsp;0&nbsp;obj<br />&lt;&lt;/Type&nbsp;/Page&nbsp;/Parent&nbsp;2&nbsp;0&nbsp;R&nbsp;/MediaBox&nbsp;[0&nbsp;0&nbsp;3&nbsp;3]&gt;&gt;<br />endobj<br />30&nbsp;0&nbsp;obj<br />&lt;&lt;/Length&nbsp;145&gt;&gt;<br />stream<br />&lt;xdp&nbsp;xmlns=&quot;http://ns.adobe.com/xdp/&quot;&gt;&lt;template&gt;&lt;subform&gt;&lt;validate&gt;&lt;script&gt;Decode(&quot;&amp;|&quot;,&quot;HTML&quot;)&lt;/script&gt;&lt;/validate&gt;&lt;/subform&gt;&lt;/template&gt;&lt;/xdp&gt;<br />endstream<br />endobj<br />trailer<br />&lt;&lt;/Root&nbsp;1&nbsp;0&nbsp;R&nbsp;/Size&nbsp;31&gt;&gt;<br />%%EOF</div></div><br /><br />此时目标转换为编写fuzzer，触发未被覆盖的<h3>CFXJSE_FormCalcContext::Decode</h3>等函数，为了能够有效触发该函数，可以将上面触发bug的pdf文件集成到fuzzer中，在该pdf文件中加入随机数据，从而对目标函数进行fuzzer<br /><br />为编写新fuzzer，可以从已有fuzzer中入手寻找思路，<br />pdfium_xfa_fuzzer.cc中针对pdf中的xfa相关逻辑进行了fuzzer，而触发bug的pdf中存在xdp字段，xdp是<h3>xfa</h3>格式的标志，说明该fuzzer可以将触发bug的pdf作为输入，所以以该fuzzer作为模板创建新fuzzer<br /><h3>pdfium_xfa_fuzzer.cc</h3><br /><h3>OnFormFillEnvLoaded</h3>函数为回调函数，当pdf文件传输完毕后会调用，函数内判断当前pdf中是否存在xfa字段，若存在则调用FPDF_LoadXFA函数处理xfa逻辑<br /><div class="codebox"><div class="codebox">//&nbsp;Copyright&nbsp;2017&nbsp;The&nbsp;Chromium&nbsp;Authors.&nbsp;All&nbsp;rights&nbsp;reserved.<br />//&nbsp;Use&nbsp;of&nbsp;this&nbsp;source&nbsp;code&nbsp;is&nbsp;governed&nbsp;by&nbsp;a&nbsp;BSD-style&nbsp;license&nbsp;that&nbsp;can&nbsp;be<br />//&nbsp;found&nbsp;in&nbsp;the&nbsp;LICENSE&nbsp;file.<br /><br />#include&nbsp;&lt;stdint.h&gt;<br /><br />#include&nbsp;&quot;public/fpdf_formfill.h&quot;<br />#include&nbsp;&quot;testing/fuzzers/pdfium_fuzzer_helper.h&quot;<br /><br />class&nbsp;PDFiumXFAFuzzer&nbsp;:&nbsp;public&nbsp;PDFiumFuzzerHelper&nbsp;{<br />&nbsp;public:<br />&nbsp;&nbsp;PDFiumXFAFuzzer()&nbsp;=&nbsp;default;<br />&nbsp;&nbsp;~PDFiumXFAFuzzer()&nbsp;override&nbsp;=&nbsp;default;<br /><br />&nbsp;&nbsp;int&nbsp;GetFormCallbackVersion()&nbsp;const&nbsp;override&nbsp;{&nbsp;return&nbsp;2;&nbsp;}<br /><br />&nbsp;&nbsp;//&nbsp;Return&nbsp;false&nbsp;if&nbsp;XFA&nbsp;doesn&#39;t&nbsp;load&nbsp;as&nbsp;otherwise&nbsp;we&#39;re&nbsp;duplicating&nbsp;the&nbsp;work<br />&nbsp;&nbsp;//&nbsp;done&nbsp;by&nbsp;the&nbsp;non-xfa&nbsp;fuzzer.<br />&nbsp;&nbsp;bool&nbsp;OnFormFillEnvLoaded(FPDF_DOCUMENT&nbsp;doc)&nbsp;override&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;form_type&nbsp;=&nbsp;FPDF_GetFormType(doc);<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(form_type&nbsp;!=&nbsp;FORMTYPE_XFA_FULL&nbsp;&amp;&amp;&nbsp;form_type&nbsp;!=&nbsp;FORMTYPE_XFA_FOREGROUND)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;FPDF_LoadXFA(doc);<br />&nbsp;&nbsp;}<br />};<br /><br />extern&nbsp;&quot;C&quot;&nbsp;int&nbsp;LLVMFuzzerTestOneInput(const&nbsp;uint8_t*&nbsp;data,&nbsp;size_t&nbsp;size)&nbsp;<span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;PDFiumXFAFuzzer&nbsp;fuzzer;<br />&nbsp;&nbsp;fuzzer.RenderPdf(reinterpret_cast&lt;const&nbsp;char*&gt;(data),&nbsp;size);<br />&nbsp;&nbsp;return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />根据现有fuzzer创建新的fuzzer(将之前的空fuzzer内容替换为新fuzzer，编译时可以即可直接编译)<br /><h3>pdf_custom_fuzzer.cc</h3><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdlib.h&gt;<br />#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;stdint.h&gt;<br />#include&nbsp;&lt;unistd.h&gt;<br />#include&nbsp;&lt;iostream&gt;<br />#include&nbsp;&lt;sys/types.h&gt;<br /><br />#include&nbsp;&quot;public/fpdf_formfill.h&quot;<br />#include&nbsp;&quot;testing/fuzzers/pdfium_fuzzer_helper.h&quot;<br /><br />class&nbsp;PDFiumXFAFuzzer&nbsp;:&nbsp;public&nbsp;PDFiumFuzzerHelper&nbsp;{<br />&nbsp;public:<br />&nbsp;&nbsp;PDFiumXFAFuzzer()&nbsp;=&nbsp;default;<br />&nbsp;&nbsp;~PDFiumXFAFuzzer()&nbsp;override&nbsp;=&nbsp;default;<br /><br />&nbsp;&nbsp;int&nbsp;GetFormCallbackVersion()&nbsp;const&nbsp;override&nbsp;{&nbsp;return&nbsp;2;&nbsp;}<br /><br />&nbsp;&nbsp;//&nbsp;Return&nbsp;false&nbsp;if&nbsp;XFA&nbsp;doesn&#39;t&nbsp;load&nbsp;as&nbsp;otherwise&nbsp;we&#39;re&nbsp;duplicating&nbsp;the&nbsp;work<br />&nbsp;&nbsp;//&nbsp;done&nbsp;by&nbsp;the&nbsp;non-xfa&nbsp;fuzzer.<br />&nbsp;&nbsp;bool&nbsp;OnFormFillEnvLoaded(FPDF_DOCUMENT&nbsp;doc)&nbsp;override&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;form_type&nbsp;=&nbsp;FPDF_GetFormType(doc);<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(form_type&nbsp;!=&nbsp;FORMTYPE_XFA_FULL&nbsp;&amp;&amp;&nbsp;form_type&nbsp;!=&nbsp;FORMTYPE_XFA_FOREGROUND)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;FPDF_LoadXFA(doc);<br />&nbsp;&nbsp;}<br />};<br /><br />char&nbsp;pdf_generic_start[]&nbsp;=&nbsp;&quot;%PDF-1.7\n\<br />1&nbsp;0&nbsp;obj\n\<br />&lt;&lt;/Type&nbsp;/Catalog&nbsp;/Pages&nbsp;2&nbsp;0&nbsp;R&nbsp;/AcroForm&nbsp;&lt;&lt;/XFA&nbsp;30&nbsp;0&nbsp;R&gt;&gt;&nbsp;/NeedsRendering&nbsp;true&gt;&gt;\n\<br />endobj\n\<br />2&nbsp;0&nbsp;obj\n\<br />&lt;&lt;/Type&nbsp;/Pages&nbsp;/Kids&nbsp;[3&nbsp;0&nbsp;R]&nbsp;/Count&nbsp;1&gt;&gt;\n\<br />endobj\n\<br />3&nbsp;0&nbsp;obj\n\<br />&lt;&lt;/Type&nbsp;/Page&nbsp;/Parent&nbsp;2&nbsp;0&nbsp;R&nbsp;/MediaBox&nbsp;[0&nbsp;0&nbsp;3&nbsp;3]&gt;&gt;\n\<br />endobj\n\<br />30&nbsp;0&nbsp;obj\n\<br />&lt;&lt;/Length&nbsp;%d&gt;&gt;\n\<br />stream\n\<br />&lt;xdp&nbsp;xmlns=\&quot;http://ns.adobe.com/xdp/\&quot;&gt;&quot;;<br /><br />char&nbsp;pdf_generic_end[]&nbsp;=&nbsp;&quot;&lt;/xdp&gt;\n\<br />endstream\n\<br />endobj\n\<br />trailer\n\<br />&lt;&lt;/Root&nbsp;1&nbsp;0&nbsp;R&nbsp;/Size&nbsp;31&gt;&gt;\n\<br />%%EOF&quot;;<br /><br />std::string&nbsp;data_to_str(char&nbsp;*data,&nbsp;size_t&nbsp;size)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;std::string&nbsp;xfa_string&nbsp;=&nbsp;std::string(&quot;&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;xfa_string&nbsp;+=&nbsp;data;<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;xfa_string;<br />}<br /><br /><br /><br />extern&nbsp;&quot;C&quot;&nbsp;int&nbsp;LLVMFuzzerTestOneInput(const&nbsp;uint8_t&nbsp;*data,&nbsp;size_t&nbsp;size)&nbsp;<span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*null_terminated&nbsp;=&nbsp;(char*)malloc(size+1);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(null_terminated,&nbsp;data,&nbsp;size);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;null_terminated[size]&nbsp;=&nbsp;&#39;\0&#39;;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::string&nbsp;xfa_payload&nbsp;=&nbsp;data_to_str(null_terminated,&nbsp;size);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//int&nbsp;payload_size&nbsp;=&nbsp;xfa_string.length();<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*new_mem&nbsp;=&nbsp;(char*)malloc(strlen(pdf_generic_start)&nbsp;+<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;For&nbsp;the&nbsp;length&nbsp;number<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strlen(pdf_generic_end)&nbsp;+<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(xfa_payload.length()+44));<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*curr_offset&nbsp;=&nbsp;new_mem;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;First&nbsp;copy&nbsp;in&nbsp;the&nbsp;start&nbsp;of&nbsp;the&nbsp;PDF&nbsp;file&nbsp;with&nbsp;size&nbsp;of&nbsp;script.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;The&nbsp;44&nbsp;here&nbsp;is&nbsp;the&nbsp;size&nbsp;of&nbsp;the&nbsp;&quot;&lt;xdp&nbsp;...&nbsp;&lt;/xdp&gt;&nbsp;characters.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sprintf(curr_offset,&nbsp;pdf_generic_start,&nbsp;xfa_payload.length()+44);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;curr_offset&nbsp;+=&nbsp;strlen(curr_offset);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Append&nbsp;the&nbsp;xfa&nbsp;payload&nbsp;*/<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(curr_offset,&nbsp;xfa_payload.c_str(),&nbsp;xfa_payload.length());<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;curr_offset&nbsp;+=&nbsp;xfa_payload.length();<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Append&nbsp;the&nbsp;end&nbsp;of&nbsp;the&nbsp;PDF&nbsp;*/<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(curr_offset,&nbsp;pdf_generic_end,&nbsp;strlen(pdf_generic_end));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;curr_offset&nbsp;+=&nbsp;strlen(pdf_generic_end);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;NULL-terminate&nbsp;*/<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*curr_offset&nbsp;=&nbsp;&#39;\0&#39;;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Get&nbsp;the&nbsp;size&nbsp;*/<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;total_length&nbsp;=&nbsp;(int)(curr_offset&nbsp;-&nbsp;new_mem);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PDFiumXFAFuzzer&nbsp;fuzzer;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fuzzer.RenderPdf(reinterpret_cast&lt;const&nbsp;char*&gt;(new_mem),&nbsp;total_length);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(new_mem);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(null_terminated);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />sprintf(curr_offset, pdf_generic_start, xfa_payload.length()+<span style="color:#edd400;">44</span>);主要用于设置pdf_generic_start[]字符串中的&lt;&lt;/Length %d&gt;&gt;<span style="color:#edd400;"><br />即<br /></span><a href=""><img src="images\998-15.png" alt="images\998-15.png" /></a><br /><br />重新编译新的fuzzer<br /><a href=""><img src="images\998-16.png" alt="images\998-16.png" /></a><br /><br />运行fuzzer（带语料库）<br /><a href=""><img src="images\998-17.png" alt="images\998-17.png" /></a><br /><a href=""><img src="images\998-18.png" alt="images\998-18.png" /></a><br /><br />运行完毕，查看语料库大小<br /><a href=""><img src="images\998-19.png" alt="images\998-19.png" /></a><br /><br />分析本次fuzzer的覆盖率情况<br />使用以下命令生成新目录，并在该目录中生成配置文件<br /><a href=""><img src="images\998-20.png" alt="images\998-20.png" /></a><br /><br />重新编译fuzzer（带覆盖率分析）<br /><a href=""><img src="images\998-21.png" alt="images\998-21.png" /></a><br /><br />进入html报告目录，启动web服务器<br /><a href=""><img src="images\998-22.png" alt="images\998-22.png" /></a><br /><br />查看覆盖率报告<br /><a href=""><img src="images\998-23.png" alt="images\998-23.png" /></a><br /><br />看到Decode函数所在文件均未被fuzzing<br /><a href=""><img src="images\998-24.png" alt="images\998-24.png" /></a><br /><br />为触发目标代码，可以改进当前fuzzer，使得fuzzer中的pdf数据与触发bug的pdf文件更为接近<br /><h3>pdf_custom_fuzzer.cc</h3><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdlib.h&gt;<br />#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;stdint.h&gt;<br />#include&nbsp;&lt;unistd.h&gt;<br />#include&nbsp;&lt;iostream&gt;<br />#include&nbsp;&lt;sys/types.h&gt;<br /><br />#include&nbsp;&quot;public/fpdf_formfill.h&quot;<br />#include&nbsp;&quot;testing/fuzzers/pdfium_fuzzer_helper.h&quot;<br /><br />class&nbsp;PDFiumXFAFuzzer&nbsp;:&nbsp;public&nbsp;PDFiumFuzzerHelper&nbsp;{<br />&nbsp;public:<br />&nbsp;&nbsp;PDFiumXFAFuzzer()&nbsp;=&nbsp;default;<br />&nbsp;&nbsp;~PDFiumXFAFuzzer()&nbsp;override&nbsp;=&nbsp;default;<br /><br />&nbsp;&nbsp;int&nbsp;GetFormCallbackVersion()&nbsp;const&nbsp;override&nbsp;{&nbsp;return&nbsp;2;&nbsp;}<br /><br />&nbsp;&nbsp;//&nbsp;Return&nbsp;false&nbsp;if&nbsp;XFA&nbsp;doesn&#39;t&nbsp;load&nbsp;as&nbsp;otherwise&nbsp;we&#39;re&nbsp;duplicating&nbsp;the&nbsp;work<br />&nbsp;&nbsp;//&nbsp;done&nbsp;by&nbsp;the&nbsp;non-xfa&nbsp;fuzzer.<br />&nbsp;&nbsp;bool&nbsp;OnFormFillEnvLoaded(FPDF_DOCUMENT&nbsp;doc)&nbsp;override&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;form_type&nbsp;=&nbsp;FPDF_GetFormType(doc);<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(form_type&nbsp;!=&nbsp;FORMTYPE_XFA_FULL&nbsp;&amp;&amp;&nbsp;form_type&nbsp;!=&nbsp;FORMTYPE_XFA_FOREGROUND)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;FPDF_LoadXFA(doc);<br />&nbsp;&nbsp;}<br />};<br /><br /><br />/*&nbsp;Below&nbsp;is&nbsp;our&nbsp;custom&nbsp;fuzzer&nbsp;implementatino&nbsp;*/<br /><br />char&nbsp;pdf_generic_start[]&nbsp;=&nbsp;&quot;%PDF-1.7\n\<br />1&nbsp;0&nbsp;obj\n\<br />&lt;&lt;/Type&nbsp;/Catalog&nbsp;/Pages&nbsp;2&nbsp;0&nbsp;R&nbsp;/AcroForm&nbsp;&lt;&lt;/XFA&nbsp;30&nbsp;0&nbsp;R&gt;&gt;&nbsp;/NeedsRendering&nbsp;true&gt;&gt;\n\<br />endobj\n\<br />2&nbsp;0&nbsp;obj\n\<br />&lt;&lt;/Type&nbsp;/Pages&nbsp;/Kids&nbsp;[3&nbsp;0&nbsp;R]&nbsp;/Count&nbsp;1&gt;&gt;\n\<br />endobj\n\<br />3&nbsp;0&nbsp;obj\n\<br />&lt;&lt;/Type&nbsp;/Page&nbsp;/Parent&nbsp;2&nbsp;0&nbsp;R&nbsp;/MediaBox&nbsp;[0&nbsp;0&nbsp;3&nbsp;3]&gt;&gt;\n\<br />endobj\n\<br />30&nbsp;0&nbsp;obj\n\<br />&lt;&lt;/Length&nbsp;%d&gt;&gt;\n\<br />stream\n\<br />&lt;xdp&nbsp;xmlns=\&quot;http://ns.adobe.com/xdp/\&quot;&gt;&quot;;<br /><br />char&nbsp;pdf_generic_end[]&nbsp;=&nbsp;&quot;&lt;/xdp&gt;\n\<br />endstream\n\<br />endobj\n\<br />trailer\n\<br />&lt;&lt;/Root&nbsp;1&nbsp;0&nbsp;R&nbsp;/Size&nbsp;31&gt;&gt;\n\<br />%%EOF&quot;;<br /><br />std::string&nbsp;data_to_str(char&nbsp;*data,&nbsp;size_t&nbsp;size)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;std::string&nbsp;xfa_string&nbsp;=&nbsp;std::string(&quot;&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;xfa_string&nbsp;+=&nbsp;&quot;&lt;template&gt;&lt;subform&gt;&lt;validate&gt;&lt;script&gt;Decode(\&quot;&quot;;<br />&nbsp;&nbsp;&nbsp;&nbsp;xfa_string&nbsp;+=&nbsp;data;<br />&nbsp;&nbsp;&nbsp;&nbsp;xfa_string&nbsp;+=&nbsp;&quot;\&quot;,\&quot;HTML\&quot;)&lt;/script&gt;&lt;/validate&gt;&lt;/subform&gt;&lt;/template&gt;&quot;;<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;xfa_string;<br />}<br /><br />extern&nbsp;&quot;C&quot;&nbsp;int&nbsp;LLVMFuzzerTestOneInput(const&nbsp;uint8_t&nbsp;*data,&nbsp;size_t&nbsp;size)&nbsp;<span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*null_terminated&nbsp;=&nbsp;(char*)malloc(size+1);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(null_terminated,&nbsp;data,&nbsp;size);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;null_terminated[size]&nbsp;=&nbsp;&#39;\0&#39;;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::string&nbsp;xfa_payload&nbsp;=&nbsp;data_to_str(null_terminated,&nbsp;size);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//int&nbsp;payload_size&nbsp;=&nbsp;xfa_string.length();<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*new_mem&nbsp;=&nbsp;(char*)malloc(strlen(pdf_generic_start)&nbsp;+<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;For&nbsp;the&nbsp;length&nbsp;number<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strlen(pdf_generic_end)&nbsp;+<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(xfa_payload.length()+44));<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*curr_offset&nbsp;=&nbsp;new_mem;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;First&nbsp;copy&nbsp;in&nbsp;the&nbsp;start&nbsp;of&nbsp;the&nbsp;PDF&nbsp;file&nbsp;with&nbsp;size&nbsp;of&nbsp;script.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;The&nbsp;44&nbsp;here&nbsp;is&nbsp;the&nbsp;size&nbsp;of&nbsp;the&nbsp;&quot;&lt;xdp&nbsp;...&nbsp;&lt;/xdp&gt;&nbsp;characters.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sprintf(curr_offset,&nbsp;pdf_generic_start,&nbsp;xfa_payload.length()+44);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;curr_offset&nbsp;+=&nbsp;strlen(curr_offset);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Append&nbsp;the&nbsp;xfa&nbsp;payload&nbsp;*/<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(curr_offset,&nbsp;xfa_payload.c_str(),&nbsp;xfa_payload.length());<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;curr_offset&nbsp;+=&nbsp;xfa_payload.length();<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Append&nbsp;the&nbsp;end&nbsp;of&nbsp;the&nbsp;PDF&nbsp;*/<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(curr_offset,&nbsp;pdf_generic_end,&nbsp;strlen(pdf_generic_end));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;curr_offset&nbsp;+=&nbsp;strlen(pdf_generic_end);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;NULL-terminate&nbsp;*/<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*curr_offset&nbsp;=&nbsp;&#39;\0&#39;;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Get&nbsp;the&nbsp;size&nbsp;*/<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;total_length&nbsp;=&nbsp;(int)(curr_offset&nbsp;-&nbsp;new_mem);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//int&nbsp;total_length&nbsp;=&nbsp;nm_strlen&nbsp;+&nbsp;payload_size&nbsp;+&nbsp;strlen(pdf_generic_end);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//new_mem[total_length]&nbsp;=&nbsp;&#39;\0&#39;;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PDFiumXFAFuzzer&nbsp;fuzzer;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fuzzer.RenderPdf(reinterpret_cast&lt;const&nbsp;char*&gt;(new_mem),&nbsp;total_length);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(new_mem);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(null_terminated);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />该fuzzer与之前区别仅在于增加了以下两行，通过该两行可以将随机数据包装起来，从而使得fuzzer明确调用Decode函数<br /><a href=""><img src="images\998-25.png" alt="images\998-25.png" /></a><br /><br />重新编译fuzzer并运行fuzzer<br /><a href=""><img src="images\998-26.png" alt="images\998-26.png" /></a><br /><a href=""><img src="images\998-27.png" alt="images\998-27.png" /></a><br /><a href=""><img src="images\998-28.png" alt="images\998-28.png" /></a><br /><br />运行完成查看语料库<br /><a href=""><img src="images\998-29.png" alt="images\998-29.png" /></a><br /><br />此时统计覆盖率情况，使用之前的配置文件目录（out/coverage-custom-fuzzer），仅仅需要将语料库文件修改为CORPUS2即可<br /><a href=""><img src="images\998-30.png" alt="images\998-30.png" /></a><br /><br />启动服务器显示覆盖率情况<br /><a href=""><img src="images\998-31.png" alt="images\998-31.png" /></a><br /><br />Decode函数已经被fuzzer覆盖，经过分析，该fuzzer只要再继续运行一段时间，就可以触发bug报告中的crash，即该fuzzer可以复现已存在的bug，说明该fuzzer有效<br /><a href=""><img src="images\998-32.png" alt="images\998-32.png" /></a><br /><br /><br />接下来可以继续分析当前的bug列表，找到未被fuzzer覆盖的bug函数，并且编写相当具有针对性的fuzzer对此类函数进行fuzzing，（因为此时通用fuzzer总是无法覆盖到目标函数）<br /><br />可以从字典、语法感知类fuzzer、优秀种子文件、等多种途径继续优化当前fuzer，争取将Decode函数所在文件中所有函数均被fuzzer覆盖<br /><br />Decode函数所在文件中还有大量函数未被fuzzing，这些函数均可以作为目标<br /><a href=""><img src="images\998-33.png" alt="images\998-33.png" /></a></div><div class='page'><h1 class='title level-4'>6_Coming_up_with_a_new_Chromium_fuzzer</h1><br/><h1>Coming up with a new Chromium fuzzer</h1><br /><br />在本节中，我们将描述提出新的Chromium模糊器的过程。 在Chromium中集成新的模糊测试器需要：<br /><br />1、添加您的模糊器的源代码； <br />2、将模糊器集成到Chromium的构建系统中。 我们在本节中采用的方法是先将一个空的模糊器集成到Chromium中，然后再进行更高级的实现。我们将针对的代码是Pdfium工具的代码，这是Chromium中的PDF逻辑。<br /><br />在本节中，我们将导航Chromium源代码，默认情况下，我们开始的文件夹位于Chromium的src /文件夹中。 因此，如果您看到描述的路径，则该路径来自此文件夹，除非另有明确说明。<br /><br /><h2>在Chromium中添加一个空的模糊器</h2><br />首先要做的是构造一个空的模糊器，并将其放在适当的文件夹中。 在本例中，我们将其放置在文件夹third_party / pdfium / testing / fuzzers中，并将其命名为pdf_custom_fuzzer.cc。 由于这只是我们的第一种方法，因此我们将简单地创建一个空的模糊器：<br /><h3>pdf_custom_fuzzer.cc</h3><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdlib.h&gt;<br />#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;iostream&gt;<br /><br />extern&nbsp;&quot;C&quot;&nbsp;int&nbsp;LLVMFuzzerTestOneInput(const&nbsp;uint8_t&nbsp;*data,&nbsp;size_t&nbsp;size)&nbsp;<span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />接下来，我们需要修改两个构建文件，以便将我们的模糊器集成到Chromium的构建系统中：<br />• third_party/pdfium/testing/fuzzers/BUILD.gn<br />• pdf/pdfium/fuzzers/BUILD.gn<br /><br />我们修改的第一个文件是third_party / pdfium / testing / fuzzers / BUILD.gn，在此我们特别需要将pdf_custom_fuzzer添加到构建说明中。 首先，我们需要更改fuzzer_list，使其包含pdf_custom_fuzzer：<br /><div class="codebox"><div class="codebox">fuzzer_list&nbsp;=&nbsp;<span style="color:#000000;font-weight:400">[</span><br />&nbsp;&nbsp;&quot;pdf_custom_fuzzer&quot;,<br />&nbsp;&nbsp;&quot;pdf_cmap_fuzzer&quot;,<br />&nbsp;&nbsp;&quot;pdf_codec_a85_fuzzer&quot;,<br />&nbsp;&nbsp;&quot;pdf_codec_fax_fuzzer&quot;,<br />&nbsp;&nbsp;&quot;pdf_codec_icc_fuzzer&quot;,<br />&nbsp;&nbsp;&nbsp;...<br /><span style="color:#000000;font-weight:400">]</span></div></div><br /><br />然后，我们需要为pdf_custom_fuzzer添加一条规则。 为此，我们在if（pdf_enable_xfa）{...之后添加以下内容：<br /><div class="codebox"><div class="codebox">if&nbsp;(pdf_enable_xfa)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pdfium_fuzzer(&quot;pdf_custom_fuzzer&quot;)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sources&nbsp;=&nbsp;[&nbsp;&quot;pdf_custom_fuzzer.cc&quot;&nbsp;]<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deps&nbsp;=&nbsp;[<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;:fuzzer_helper&quot;,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public_fuzzer&nbsp;=&nbsp;true<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;...</div></div><br /><br />我们将修改的第二个文件是pdf / pdfium / fuzzers / BUILD.gn。 具体来说，在这里，我们将修改group（“ pdf_fuzzers）” {规则，以便我们包含pdf_custom_fuzer：<br /><div class="codebox"><div class="codebox">group(&quot;pdf_fuzzers&quot;)&nbsp;{<br />&nbsp;&nbsp;testonly&nbsp;=&nbsp;true<br />&nbsp;&nbsp;deps&nbsp;=&nbsp;[<br />&nbsp;&nbsp;&nbsp;&nbsp;&quot;:pdf_custom_fuzzer&quot;,<br />&nbsp;&nbsp;&nbsp;&nbsp;&quot;:pdf_cmap_fuzzer&quot;,<br />&nbsp;&nbsp;&nbsp;&nbsp;&quot;:pdf_codec_a85_fuzzer&quot;,<br />&nbsp;&nbsp;&nbsp;&nbsp;....<br /></div></div><br /><br />最后，我们在同一文件中的if（pdf_enable_xfa）{行之后继续修改，以使其变为：<br /><div class="codebox"><div class="codebox">if&nbsp;(pdf_enable_xfa)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;fuzzer_test(&quot;pdf_custom_fuzzer&quot;)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sources&nbsp;=&nbsp;[]<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deps&nbsp;=&nbsp;[&nbsp;&quot;//third_party/pdfium/testing/fuzzers:pdf_custom_fuzzer_src&quot;&nbsp;]<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />...<br />...<br /></div></div><br /><br />此时，我们可以通过在src /文件夹中执行以下命令来再次构建模糊器：<br /><div class="codebox"><div class="codebox">$&nbsp;python&nbsp;tools/mb/mb.py&nbsp;gen&nbsp;-m&nbsp;chromium.fuzz&nbsp;-b&nbsp;&#39;Libfuzzer&nbsp;Upload&nbsp;Linux&nbsp;ASan&#39;&nbsp;out/custom_fuzzer<br />$&nbsp;sed&nbsp;-i&nbsp;&#39;s/use_goma&nbsp;=&nbsp;true/use_goma&nbsp;=&nbsp;false&#39;/g&nbsp;out/custom_fuzzer/args.gn<br />$&nbsp;ninja&nbsp;-C&nbsp;out/custom-fuzzer&nbsp;pdf_custom_fuzzer<br />...<br />...<br />...<br />$&nbsp;export&nbsp;ASAN_OPTIONS=&quot;detect_odr_violation=0&quot;<br />$&nbsp;./out/custom_fuzzer/pdf_custom_fuzzer<br /></div></div><br /><br />现在我们可以运行模糊器了：<br /><div class="codebox"><div class="codebox">$&nbsp;./out/custom-fuzzer/pdf_custom_fuzzer<br />INFO:&nbsp;Seed:&nbsp;3910127911<br />INFO:&nbsp;Loaded&nbsp;11&nbsp;modules&nbsp;&nbsp;&nbsp;(730838&nbsp;inline&nbsp;8-bit&nbsp;counters):&nbsp;14280&nbsp;[0x7f868bd07590,&nbsp;0x7f868bd0ad58),&nbsp;2654&nbsp;[0x7f8694f738d6,&nbsp;0x7f8694f74334),&nbsp;3619&nbsp;[0x7f869501be06,&nbsp;0x7f869501cc29),&nbsp;6317&nbsp;[0x7f868be435a6,&nbsp;0x7f868be44e53),&nbsp;35127&nbsp;[0x7f86922168f6,&nbsp;0x7f869221f22d),&nbsp;48241&nbsp;[0x7f868c5e25f6,&nbsp;0x7f868c5ee267),&nbsp;2584&nbsp;[0x7f8695099476,&nbsp;0x7f8695099e8e),&nbsp;382076&nbsp;[0x7f86915e6436,&nbsp;0x7f86916438b2),&nbsp;58299&nbsp;[0x7f8692d69cb6,&nbsp;0x7f8692d78071),&nbsp;169784&nbsp;[0x7f8694babc16,&nbsp;0x7f8694bd534e),&nbsp;7857&nbsp;[0x556e5eb26508,&nbsp;0x556e5eb283b9),<br />INFO:&nbsp;Loaded&nbsp;11&nbsp;PC&nbsp;tables&nbsp;(730838&nbsp;PCs):&nbsp;14280&nbsp;[0x7f868bd0ad58,0x7f868bd429d8),&nbsp;2654&nbsp;[0x7f8694f74338,0x7f8694f7e918),&nbsp;3619&nbsp;[0x7f869501cc30,0x7f869502ae60),&nbsp;6317&nbsp;[0x7f868be44e58,0x7f868be5d928),&nbsp;35127&nbsp;[0x7f869221f230,0x7f86922a85a0),&nbsp;48241&nbsp;[0x7f868c5ee268,0x7f868c6aa978),&nbsp;2584&nbsp;[0x7f8695099e90,0x7f86950a4010),&nbsp;382076&nbsp;[0x7f86916438b8,0x7f8691c18078),&nbsp;58299&nbsp;[0x7f8692d78078,0x7f8692e5bc28),&nbsp;169784&nbsp;[0x7f8694bd5350,0x7f8694e6c6d0),&nbsp;7857&nbsp;[0x556e5eb283c0,0x556e5eb46ed0),<br />INFO:&nbsp;-max_len&nbsp;is&nbsp;not&nbsp;provided;&nbsp;libFuzzer&nbsp;will&nbsp;not&nbsp;generate&nbsp;inputs&nbsp;larger&nbsp;than&nbsp;4096&nbsp;bytes<br />INFO:&nbsp;A&nbsp;corpus&nbsp;is&nbsp;not&nbsp;provided,&nbsp;starting&nbsp;from&nbsp;an&nbsp;empty&nbsp;corpus<br />#2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;INITED&nbsp;cov:&nbsp;29&nbsp;ft:&nbsp;15&nbsp;corp:&nbsp;1/1b&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;313Mb<br />#65536&nbsp;&nbsp;pulse&nbsp;&nbsp;cov:&nbsp;29&nbsp;ft:&nbsp;15&nbsp;corp:&nbsp;1/1b&nbsp;lim:&nbsp;652&nbsp;exec/s:&nbsp;21845&nbsp;rss:&nbsp;324Mb<br />#131072&nbsp;pulse&nbsp;&nbsp;cov:&nbsp;29&nbsp;ft:&nbsp;15&nbsp;corp:&nbsp;1/1b&nbsp;lim:&nbsp;1300&nbsp;exec/s:&nbsp;18724&nbsp;rss:&nbsp;346Mb<br />^C==18511==&nbsp;libFuzzer:&nbsp;run&nbsp;interrupted;&nbsp;exiting</div></div><br /><br />这就足以在Chromium中添加我们自己的第一个模糊器。<br /><br /><h2>创建一个模糊器，该模糊器命中先前的错误和未触发的代码</h2><br />现在，下一步是创建一个有趣的模糊器。 我们的目标是：<br />1、Chromium模糊测试程序未覆盖的代码。<br />2、以前爆出过漏洞的代码。<br /><br />我们通过查看先前提交给Chromium错误跟踪器的错误报告来开始设计新的fuzzer：<br /><a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1031523">https://bugs.chromium.org/p/chromium/issues/detail?id=1031523</a><br />此错误报告带有堆栈跟踪的全局缓冲区溢出：<br /><span style="color:#ff0000;">根据已有程序bug报告，从而定位那些出现bug并仍未被fuzzing覆盖的函数，这是一个好思路</span><br /><div class="codebox"><div class="codebox">#0&nbsp;0x55c1961b532d&nbsp;in&nbsp;(anonymous&nbsp;namespace)::HTMLSTR2Code(fxcrt::WideString&nbsp;const&amp;,&nbsp;unsigned&nbsp;int*)&nbsp;fxjs/xfa/cfxjse_formcalc_context.cpp:848:37<br />#1&nbsp;0x55c1961b4e3f&nbsp;in&nbsp;(anonymous&nbsp;namespace)::DecodeMLInternal(fxcrt::WideString&nbsp;const&amp;,&nbsp;bool)&nbsp;fxjs/xfa/cfxjse_formcalc_context.cpp:947:11<br />#2&nbsp;0x55c1961a0022&nbsp;in&nbsp;(anonymous&nbsp;namespace)::DecodeHTML(fxcrt::WideString&nbsp;const&amp;)&nbsp;fxjs/xfa/cfxjse_formcalc_context.cpp:968:10<br />#3&nbsp;0x55c19619fb4d&nbsp;in&nbsp;CFXJSE_FormCalcContext::Decode(CFXJSE_Value*,&nbsp;fxcrt::StringViewTemplate,&nbsp;CFXJSE_Arguments&amp;)&nbsp;fxjs/xfa/cfxjse_formcalc_context.cpp:3602:15<br />#4&nbsp;0x55c196171d2f&nbsp;in&nbsp;(anonymous&nbsp;namespace)::V8FunctionCallback_Wrapper(v8::FunctionCallbackInfo&nbsp;const&amp;)&nbsp;fxjs/xfa/cfxjse_class.cpp:47:3<br />#5&nbsp;0x55c196381acd&nbsp;in&nbsp;v8::internal::FunctionCallbackArguments::Call(v8::internal::CallHandlerInfo)&nbsp;v8/src/api/api-arguments-inl.h:158:3<br />#6&nbsp;0x55c19637f76e&nbsp;in&nbsp;v8::internal::MaybeHandle&nbsp;v8::internal::(anonymous&nbsp;namespace)::HandleApiCallHelper(v8::internal::Isolate*,&nbsp;v8::internal::Handle,&nbsp;v8::internal::Handle,&nbsp;v8::internal::Handle,&nbsp;v8::internal::Handle,&nbsp;v8::internal::BuiltinArguments)&nbsp;v8/src/builtins/builtins-api.cc:111:36<br />#7&nbsp;0x55c19637c269&nbsp;in&nbsp;v8::internal::Builtin_Impl_HandleApiCall(v8::internal::BuiltinArguments,&nbsp;v8::internal::Isolate*)&nbsp;v8/src/builtins/builtins-api.cc:141:5<br />#8&nbsp;0x55c19637b81e&nbsp;in&nbsp;v8::internal::Builtin_HandleApiCall(int,&nbsp;unsigned&nbsp;long*,&nbsp;v8::internal::Isolate*)&nbsp;v8/src/builtins/builtins-api.cc:129:1<br />#9&nbsp;0x55c19821d9b8&nbsp;in&nbsp;Builtins_CEntry_Return1_DontSaveFPRegs_ArgvOnStack_BuiltinExit<br />#10&nbsp;0x55c1981a559a&nbsp;in&nbsp;Builtins_InterpreterEntryTrampoline<br />#11&nbsp;0x55c1981a559a&nbsp;in&nbsp;Builtins_InterpreterEntryTrampoline<br />#12&nbsp;0x55c19819f0f8&nbsp;in&nbsp;Builtins_ArgumentsAdaptorTrampoline<br />#13&nbsp;0x55c1981a559a&nbsp;in&nbsp;Builtins_InterpreterEntryTrampoline<br />#14&nbsp;0x55c19819f0f8&nbsp;in&nbsp;Builtins_ArgumentsAdaptorTrampoline<br />#15&nbsp;0x55c1981a2e99&nbsp;in&nbsp;Builtins_JSEntryTrampoline<br />#16&nbsp;0x55c1981a2c77&nbsp;in&nbsp;Builtins_JSEntry<br />#17&nbsp;0x55c196676cd3&nbsp;in&nbsp;v8::internal::(anonymous&nbsp;namespace)::Invoke(v8::internal::Isolate*,&nbsp;v8::internal::(anonymous&nbsp;namespace)::InvokeParams&nbsp;const&amp;)&nbsp;v8/src/execution/execution.cc:266:33<br />#18&nbsp;0x55c1966758ca&nbsp;in&nbsp;v8::internal::Execution::Call(v8::internal::Isolate*,&nbsp;v8::internal::Handle,&nbsp;v8::internal::Handle,&nbsp;int,&nbsp;v8::internal::Handle*)&nbsp;v8/src/execution/execution.cc:358:10<br />#19&nbsp;0x55c19625de1c&nbsp;in&nbsp;v8::Function::Call(v8::Local,&nbsp;v8::Local,&nbsp;int,&nbsp;v8::Local*)&nbsp;v8/src/api/api.cc:4918:7<br />#20&nbsp;0x55c196175f19&nbsp;in&nbsp;CFXJSE_Context::ExecuteScript(char&nbsp;const*,&nbsp;CFXJSE_Value*,&nbsp;CFXJSE_Value*)&nbsp;fxjs/xfa/cfxjse_context.cpp:301:21<br />#21&nbsp;0x55c19617b8d2&nbsp;in&nbsp;CFXJSE_Engine::RunScript(CXFA_Script::Type,&nbsp;fxcrt::StringViewTemplate,&nbsp;CFXJSE_Value*,&nbsp;CXFA_Object*)&nbsp;fxjs/xfa/cfxjse_engine.cpp:153:23<br />#22&nbsp;0x55c1985e1603&nbsp;in&nbsp;CXFA_Node::ExecuteBoolScript(CXFA_FFDocView*,&nbsp;CXFA_Script*,&nbsp;CXFA_EventParam*)&nbsp;xfa/fxfa/parser/cxfa_node.cpp:2696:22<br />#23&nbsp;0x55c1985e0dc1&nbsp;in&nbsp;CXFA_Node::ProcessValidate(CXFA_FFDocView*,&nbsp;int)&nbsp;xfa/fxfa/parser/cxfa_node.cpp:2598:28<br />#24&nbsp;0x55c1983f9175&nbsp;in&nbsp;XFA_ProcessEvent(CXFA_FFDocView*,&nbsp;CXFA_Node*,&nbsp;CXFA_EventParam*)&nbsp;xfa/fxfa/cxfa_ffdocview.cpp:349:23<br />#25&nbsp;0x55c1983f6cbc&nbsp;in&nbsp;CXFA_FFDocView::ExecEventActivityByDeepFirst(CXFA_Node*,&nbsp;XFA_EVENTTYPE,&nbsp;bool,&nbsp;bool)&nbsp;xfa/fxfa/cxfa_ffdocview.cpp:413:35<br />#26&nbsp;0x55c1983f6c1d&nbsp;in&nbsp;CXFA_FFDocView::ExecEventActivityByDeepFirst(CXFA_Node*,&nbsp;XFA_EVENTTYPE,&nbsp;bool,&nbsp;bool)&nbsp;xfa/fxfa/cxfa_ffdocview.cpp:400:20<br />#27&nbsp;0x55c1983f70bc&nbsp;in&nbsp;CXFA_FFDocView::InitValidate(CXFA_Node*)&nbsp;xfa/fxfa/cxfa_ffdocview.cpp:581:3<br />#28&nbsp;0x55c1983f6f1e&nbsp;in&nbsp;CXFA_FFDocView::StartLayout()&nbsp;xfa/fxfa/cxfa_ffdocview.cpp:89:3<br />#29&nbsp;0x55c1986a7331&nbsp;in&nbsp;CPDFXFA_Context::LoadXFADoc()&nbsp;fpdfsdk/fpdfxfa/cpdfxfa_context.cpp:123:22<br />#30&nbsp;0x55c195ab7056&nbsp;in&nbsp;FPDF_LoadXFA&nbsp;fpdfsdk/fpdf_view.cpp:261:32<br />#31&nbsp;0x55c195a0c7ae&nbsp;in&nbsp;(anonymous&nbsp;namespace)::RenderPdf(std::__1::basic_string,&nbsp;std::__1::allocator&nbsp;&gt;&nbsp;const&amp;,&nbsp;char&nbsp;const*,&nbsp;unsigned&nbsp;long,&nbsp;(anonymous&nbsp;namespace)::Options&nbsp;const&amp;,&nbsp;std::__1::basic_string,&nbsp;std::__1::allocator&nbsp;&gt;&nbsp;const&amp;)&nbsp;samples/pdfium_test.cc:899:12<br />#32&nbsp;0x55c195a0953d&nbsp;in&nbsp;main&nbsp;samples/pdfium_test.cc:1145:5<br /></div></div><br /><br />查看堆栈跟踪中的最后四个函数：<br /><div class="codebox"><div class="codebox">#0&nbsp;0x55c1961b532d&nbsp;in&nbsp;(anonymous&nbsp;namespace)::HTMLSTR2Code(fxcrt::WideString&nbsp;const&amp;,&nbsp;unsigned&nbsp;int*)&nbsp;fxjs/xfa/cfxjse_formcalc_context.cpp:848:37<br />#1&nbsp;0x55c1961b4e3f&nbsp;in&nbsp;(anonymous&nbsp;namespace)::DecodeMLInternal(fxcrt::WideString&nbsp;const&amp;,&nbsp;bool)&nbsp;fxjs/xfa/cfxjse_formcalc_context.cpp:947:11<br />#2&nbsp;0x55c1961a0022&nbsp;in&nbsp;(anonymous&nbsp;namespace)::DecodeHTML(fxcrt::WideString&nbsp;const&amp;)&nbsp;fxjs/xfa/cfxjse_formcalc_context.cpp:968:10<br />#3&nbsp;0x55c19619fb4d&nbsp;in&nbsp;CFXJSE_FormCalcContext::Decode(CFXJSE_Value*,&nbsp;fxcrt::StringViewTemplate,&nbsp;CFXJSE_Arguments&amp;)&nbsp;fxjs/xfa/cfxjse_formcalc_context.cpp:3602:15</div></div><br /><br />然后，我们可以看到该错误通过CFXJSE_FormCalcContext :: Decode函数传递。 该函数在此处声明，正如我们在“ Chromium Fuzzer覆盖率”报告中所看到的那样，该函数并未被当前现有的Fuzzer击中，即未对其进行分析以进行错误检查。 现在的下一个问题是，我们如何才能开发出触发此代码的模糊器？<br /><br />为此，我们将观察错误报告中附带的测试用例（即pdf文件）。 该PDF文件的原始字节如下：<br /><div class="codebox"><div class="codebox">%PDF-1.7<br />1&nbsp;0&nbsp;obj<br />&lt;&lt;/Type&nbsp;/Catalog&nbsp;/Pages&nbsp;2&nbsp;0&nbsp;R&nbsp;/AcroForm&nbsp;&lt;&lt;/XFA&nbsp;30&nbsp;0&nbsp;R&gt;&gt;&nbsp;/NeedsRendering&nbsp;true&gt;&gt;<br />endobj<br />2&nbsp;0&nbsp;obj<br />&lt;&lt;/Type&nbsp;/Pages&nbsp;/Kids&nbsp;[3&nbsp;0&nbsp;R]&nbsp;/Count&nbsp;1&gt;&gt;<br />endobj<br />3&nbsp;0&nbsp;obj<br />&lt;&lt;/Type&nbsp;/Page&nbsp;/Parent&nbsp;2&nbsp;0&nbsp;R&nbsp;/MediaBox&nbsp;[0&nbsp;0&nbsp;3&nbsp;3]&gt;&gt;<br />endobj<br />30&nbsp;0&nbsp;obj<br />&lt;&lt;/Length&nbsp;145&gt;&gt;<br />stream<br />&lt;xdp&nbsp;xmlns=&quot;http://ns.adobe.com/xdp/&quot;&gt;&lt;template&gt;&lt;subform&gt;&lt;validate&gt;&lt;script&gt;Decode(&quot;&amp;|&quot;,&quot;HTML&quot;)&lt;/script&gt;&lt;/validate&gt;&lt;/subform&gt;&lt;/template&gt;&lt;/xdp&gt;<br />endstream<br />endobj<br />trailer<br />&lt;&lt;/Root&nbsp;1&nbsp;0&nbsp;R&nbsp;/Size&nbsp;31&gt;&gt;<br />%%EOF</div></div><br /><br />上面的内容看起来像一个非常简单的PDF文件，我们可以清楚地看到在PDF文件的scripts标记内以某种形式调用了Decode函数。 现在的目标是创建一个能够生成类似于上面的测试用例的模糊器，就产生高概率的测试用例而言，在合理的范围内，即在模糊的几分钟内。<br /><br />如上所述的创建模糊器的策略是：<br />1、使用产生该错误的测试用例并将其集成到模糊器中，<br />2、对模糊器进行泛化，以便在每个模糊迭代中不仅仅是相同的数据。<br />3、通过不断优化模糊器达到以下目标：<br />	1、使其更通用，从而达到更多代码<br />	2、使其更加精确，以使其达到我们的目标代码，而不是其他地方<br />	<br />为此，我们将从Chromium代码库中的另一个模糊器中获得启发。 具体来说，我们将从中获得启发的模糊器是pdfium_xfa_fuzzer.cc，您可以在此处找到它，该模糊器的源代码如下：<br /><h3>pdfium_xfa_fuzzer.cc</h3><br /><div class="codebox"><div class="codebox">//&nbsp;Copyright&nbsp;2017&nbsp;The&nbsp;Chromium&nbsp;Authors.&nbsp;All&nbsp;rights&nbsp;reserved.<br />//&nbsp;Use&nbsp;of&nbsp;this&nbsp;source&nbsp;code&nbsp;is&nbsp;governed&nbsp;by&nbsp;a&nbsp;BSD-style&nbsp;license&nbsp;that&nbsp;can&nbsp;be<br />//&nbsp;found&nbsp;in&nbsp;the&nbsp;LICENSE&nbsp;file.<br /><br />#include&nbsp;&lt;stdint.h&gt;<br /><br />#include&nbsp;&quot;public/fpdf_formfill.h&quot;<br />#include&nbsp;&quot;testing/fuzzers/pdfium_fuzzer_helper.h&quot;<br /><br />class&nbsp;PDFiumXFAFuzzer&nbsp;:&nbsp;public&nbsp;PDFiumFuzzerHelper&nbsp;{<br />&nbsp;public:<br />&nbsp;&nbsp;PDFiumXFAFuzzer()&nbsp;=&nbsp;default;<br />&nbsp;&nbsp;~PDFiumXFAFuzzer()&nbsp;override&nbsp;=&nbsp;default;<br /><br />&nbsp;&nbsp;int&nbsp;GetFormCallbackVersion()&nbsp;const&nbsp;override&nbsp;{&nbsp;return&nbsp;2;&nbsp;}<br /><br />&nbsp;&nbsp;//&nbsp;Return&nbsp;false&nbsp;if&nbsp;XFA&nbsp;doesn&#39;t&nbsp;load&nbsp;as&nbsp;otherwise&nbsp;we&#39;re&nbsp;duplicating&nbsp;the&nbsp;work<br />&nbsp;&nbsp;//&nbsp;done&nbsp;by&nbsp;the&nbsp;non-xfa&nbsp;fuzzer.<br />&nbsp;&nbsp;bool&nbsp;OnFormFillEnvLoaded(FPDF_DOCUMENT&nbsp;doc)&nbsp;override&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;form_type&nbsp;=&nbsp;FPDF_GetFormType(doc);<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(form_type&nbsp;!=&nbsp;FORMTYPE_XFA_FULL&nbsp;&amp;&amp;&nbsp;form_type&nbsp;!=&nbsp;FORMTYPE_XFA_FOREGROUND)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;FPDF_LoadXFA(doc);<br />&nbsp;&nbsp;}<br />};<br /><br />extern&nbsp;&quot;C&quot;&nbsp;int&nbsp;LLVMFuzzerTestOneInput(const&nbsp;uint8_t*&nbsp;data,&nbsp;size_t&nbsp;size)&nbsp;<span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;PDFiumXFAFuzzer&nbsp;fuzzer;<br />&nbsp;&nbsp;fuzzer.RenderPdf(reinterpret_cast&lt;const&nbsp;char*&gt;(data),&nbsp;size);<br />&nbsp;&nbsp;return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />上面的模糊器针对的是与XFA相关的Chromium PDF逻辑的一部分。  XFA代表XML Forms Architecture，并且是可以在PDF文件中使用的专有XML规范。 到目前为止，我们还不需要了解XFA规范的全部知识，但是如果您有兴趣，这里和这里都有关于XFA的更多详细信息。<br /><br />我们采用此pdfium_xfa_fuzzer的原因是因为触发漏洞的PDF部分位于pdfium的XFA部分中，正如我们从xdp标签可以看到的那样。 因此，模糊器本身非常简单，但是，模糊器的关键在于，只有在存在有效的XFA脚本的情况下，它才调用代码的FPDF_LoadXFA（doc）部分。但是，为了为目标代码构建成功的模糊器，我们不需要了解这些功能的任何知识。<br /><br />考虑以下模糊器：<br />pdf_custom_fuzzer.cc<br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdlib.h&gt;<br />#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;stdint.h&gt;<br />#include&nbsp;&lt;unistd.h&gt;<br />#include&nbsp;&lt;iostream&gt;<br />#include&nbsp;&lt;sys/types.h&gt;<br /><br />#include&nbsp;&quot;public/fpdf_formfill.h&quot;<br />#include&nbsp;&quot;testing/fuzzers/pdfium_fuzzer_helper.h&quot;<br /><br />class&nbsp;PDFiumXFAFuzzer&nbsp;:&nbsp;public&nbsp;PDFiumFuzzerHelper&nbsp;{<br />&nbsp;public:<br />&nbsp;&nbsp;PDFiumXFAFuzzer()&nbsp;=&nbsp;default;<br />&nbsp;&nbsp;~PDFiumXFAFuzzer()&nbsp;override&nbsp;=&nbsp;default;<br /><br />&nbsp;&nbsp;int&nbsp;GetFormCallbackVersion()&nbsp;const&nbsp;override&nbsp;{&nbsp;return&nbsp;2;&nbsp;}<br /><br />&nbsp;&nbsp;//&nbsp;Return&nbsp;false&nbsp;if&nbsp;XFA&nbsp;doesn&#39;t&nbsp;load&nbsp;as&nbsp;otherwise&nbsp;we&#39;re&nbsp;duplicating&nbsp;the&nbsp;work<br />&nbsp;&nbsp;//&nbsp;done&nbsp;by&nbsp;the&nbsp;non-xfa&nbsp;fuzzer.<br />&nbsp;&nbsp;bool&nbsp;OnFormFillEnvLoaded(FPDF_DOCUMENT&nbsp;doc)&nbsp;override&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;form_type&nbsp;=&nbsp;FPDF_GetFormType(doc);<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(form_type&nbsp;!=&nbsp;FORMTYPE_XFA_FULL&nbsp;&amp;&amp;&nbsp;form_type&nbsp;!=&nbsp;FORMTYPE_XFA_FOREGROUND)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;FPDF_LoadXFA(doc);<br />&nbsp;&nbsp;}<br />};<br /><br />char&nbsp;pdf_generic_start[]&nbsp;=&nbsp;&quot;%PDF-1.7\n\<br />1&nbsp;0&nbsp;obj\n\<br />&lt;&lt;/Type&nbsp;/Catalog&nbsp;/Pages&nbsp;2&nbsp;0&nbsp;R&nbsp;/AcroForm&nbsp;&lt;&lt;/XFA&nbsp;30&nbsp;0&nbsp;R&gt;&gt;&nbsp;/NeedsRendering&nbsp;true&gt;&gt;\n\<br />endobj\n\<br />2&nbsp;0&nbsp;obj\n\<br />&lt;&lt;/Type&nbsp;/Pages&nbsp;/Kids&nbsp;[3&nbsp;0&nbsp;R]&nbsp;/Count&nbsp;1&gt;&gt;\n\<br />endobj\n\<br />3&nbsp;0&nbsp;obj\n\<br />&lt;&lt;/Type&nbsp;/Page&nbsp;/Parent&nbsp;2&nbsp;0&nbsp;R&nbsp;/MediaBox&nbsp;[0&nbsp;0&nbsp;3&nbsp;3]&gt;&gt;\n\<br />endobj\n\<br />30&nbsp;0&nbsp;obj\n\<br />&lt;&lt;/Length&nbsp;%d&gt;&gt;\n\<br />stream\n\<br />&lt;xdp&nbsp;xmlns=\&quot;http://ns.adobe.com/xdp/\&quot;&gt;&quot;;<br /><br />char&nbsp;pdf_generic_end[]&nbsp;=&nbsp;&quot;&lt;/xdp&gt;\n\<br />endstream\n\<br />endobj\n\<br />trailer\n\<br />&lt;&lt;/Root&nbsp;1&nbsp;0&nbsp;R&nbsp;/Size&nbsp;31&gt;&gt;\n\<br />%%EOF&quot;;<br /><br />std::string&nbsp;data_to_str(char&nbsp;*data,&nbsp;size_t&nbsp;size)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;std::string&nbsp;xfa_string&nbsp;=&nbsp;std::string(&quot;&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;xfa_string&nbsp;+=&nbsp;data;<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;xfa_string;<br />}<br /><br /><br /><br />extern&nbsp;&quot;C&quot;&nbsp;int&nbsp;LLVMFuzzerTestOneInput(const&nbsp;uint8_t&nbsp;*data,&nbsp;size_t&nbsp;size)&nbsp;<span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*null_terminated&nbsp;=&nbsp;(char*)malloc(size+1);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(null_terminated,&nbsp;data,&nbsp;size);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;null_terminated[size]&nbsp;=&nbsp;&#39;\0&#39;;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::string&nbsp;xfa_payload&nbsp;=&nbsp;data_to_str(null_terminated,&nbsp;size);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//int&nbsp;payload_size&nbsp;=&nbsp;xfa_string.length();<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*new_mem&nbsp;=&nbsp;(char*)malloc(strlen(pdf_generic_start)&nbsp;+<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;For&nbsp;the&nbsp;length&nbsp;number<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strlen(pdf_generic_end)&nbsp;+<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(xfa_payload.length()+44));<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*curr_offset&nbsp;=&nbsp;new_mem;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;First&nbsp;copy&nbsp;in&nbsp;the&nbsp;start&nbsp;of&nbsp;the&nbsp;PDF&nbsp;file&nbsp;with&nbsp;size&nbsp;of&nbsp;script.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;The&nbsp;44&nbsp;here&nbsp;is&nbsp;the&nbsp;size&nbsp;of&nbsp;the&nbsp;&quot;&lt;xdp&nbsp;...&nbsp;&lt;/xdp&gt;&nbsp;characters.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sprintf(curr_offset,&nbsp;pdf_generic_start,&nbsp;xfa_payload.length()+44);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;curr_offset&nbsp;+=&nbsp;strlen(curr_offset);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Append&nbsp;the&nbsp;xfa&nbsp;payload&nbsp;*/<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(curr_offset,&nbsp;xfa_payload.c_str(),&nbsp;xfa_payload.length());<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;curr_offset&nbsp;+=&nbsp;xfa_payload.length();<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Append&nbsp;the&nbsp;end&nbsp;of&nbsp;the&nbsp;PDF&nbsp;*/<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(curr_offset,&nbsp;pdf_generic_end,&nbsp;strlen(pdf_generic_end));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;curr_offset&nbsp;+=&nbsp;strlen(pdf_generic_end);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;NULL-terminate&nbsp;*/<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*curr_offset&nbsp;=&nbsp;&#39;\0&#39;;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Get&nbsp;the&nbsp;size&nbsp;*/<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;total_length&nbsp;=&nbsp;(int)(curr_offset&nbsp;-&nbsp;new_mem);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PDFiumXFAFuzzer&nbsp;fuzzer;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fuzzer.RenderPdf(reinterpret_cast&lt;const&nbsp;char*&gt;(new_mem),&nbsp;total_length);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(new_mem);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(null_terminated);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />现在，我们可以重新编译模糊器并运行它以再次提取覆盖率，如下所示：<br /><div class="codebox"><div class="codebox">#&nbsp;recompiile&nbsp;the&nbsp;fuzzer<br />$&nbsp;ninja&nbsp;-C&nbsp;out/custom_fuzzer&nbsp;pdf_custom_fuzzer<br />$&nbsp;mkdir&nbsp;../CORPUS1<br />$&nbsp;ASAN_OPTIONS=detect_odr_violation=0&nbsp;./out/custom_fuzzer/pdf_custom_fuzzer&nbsp;../CORPUS1/&nbsp;-max_total_time=600<br /><br />#&nbsp;Generate&nbsp;the&nbsp;config&nbsp;directory&nbsp;where&nbsp;we&nbsp;will&nbsp;place&nbsp;our&nbsp;stuff<br />$&nbsp;gn&nbsp;gen&nbsp;out/coverage-custom-fuzzer&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;--args=&quot;use_clang_coverage=true&nbsp;is_component_build=false&nbsp;is_debug=false&nbsp;dcheck_always_on=true&nbsp;use_libfuzzer=true&nbsp;pdf_enable_xfa=true&quot;<br /><br />#&nbsp;Collect&nbsp;coverage&nbsp;and&nbsp;extract&nbsp;the&nbsp;coverage&nbsp;report<br />$&nbsp;python&nbsp;tools/code_coverage/coverage.py&nbsp;pdf_custom_fuzzer&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;-b&nbsp;out/coverage-custom-fuzzer/&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;-o&nbsp;out/report-1&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;-c&nbsp;&#39;out/coverage-custom-fuzzer/pdf_custom_fuzzer&nbsp;-runs=0&nbsp;/home/dav/chromium/chromium/CORPUS1&#39;<br /><br />#&nbsp;Now&nbsp;navigate&nbsp;into&nbsp;the&nbsp;report&nbsp;and&nbsp;start&nbsp;the&nbsp;http&nbsp;server<br />$&nbsp;cd&nbsp;out/report-1<br />$&nbsp;python3&nbsp;-m&nbsp;http.server&nbsp;5001</div></div><br /><br />从模糊器中我们可以看到它以每秒大约15次执行的速度运行很慢：<br /><div class="codebox"><div class="codebox">$&nbsp;ASAN_OPTIONS=&quot;detect_odr_violation=0&quot;&nbsp;./out/custom_fuzzer/pdf_custom_fuzzer<br />INFO:&nbsp;Seed:&nbsp;1040727444<br />INFO:&nbsp;Loaded&nbsp;11&nbsp;modules&nbsp;&nbsp;&nbsp;(730840&nbsp;inline&nbsp;8-bit&nbsp;counters):&nbsp;14280&nbsp;[0x7f2cd512c590,&nbsp;0x7f2cd512fd58),&nbsp;2654&nbsp;[0x7f2cde3978d6,&nbsp;0x7f2cde398334),&nbsp;3619&nbsp;[0x7f2cde43fe06,&nbsp;0x7f2cde440c29),&nbsp;6317&nbsp;[0x7f2cd52685a6,&nbsp;0x7f2cd5269e53),&nbsp;35127&nbsp;[0x7f2cdb63b8f6,&nbsp;0x7f2cdb64422d),&nbsp;48241&nbsp;[0x7f2cd5a075f6,&nbsp;0x7f2cd5a13267),&nbsp;2584&nbsp;[0x7f2cde4bd476,&nbsp;0x7f2cde4bde8e),&nbsp;382076&nbsp;[0x7f2cdaa0b436,&nbsp;0x7f2cdaa688b2),&nbsp;58299&nbsp;[0x7f2cdc18ecb6,&nbsp;0x7f2cdc19d071),&nbsp;169786&nbsp;[0x7f2cddfd0796,&nbsp;0x7f2cddff9ed0),&nbsp;7857&nbsp;[0x55d0bbbf0508,&nbsp;0x55d0bbbf23b9),<br />INFO:&nbsp;Loaded&nbsp;11&nbsp;PC&nbsp;tables&nbsp;(730840&nbsp;PCs):&nbsp;14280&nbsp;[0x7f2cd512fd58,0x7f2cd51679d8),&nbsp;2654&nbsp;[0x7f2cde398338,0x7f2cde3a2918),&nbsp;3619&nbsp;[0x7f2cde440c30,0x7f2cde44ee60),&nbsp;6317&nbsp;[0x7f2cd5269e58,0x7f2cd5282928),&nbsp;35127&nbsp;[0x7f2cdb644230,0x7f2cdb6cd5a0),&nbsp;48241&nbsp;[0x7f2cd5a13268,0x7f2cd5acf978),&nbsp;2584&nbsp;[0x7f2cde4bde90,0x7f2cde4c8010),&nbsp;382076&nbsp;[0x7f2cdaa688b8,0x7f2cdb03d078),&nbsp;58299&nbsp;[0x7f2cdc19d078,0x7f2cdc280c28),&nbsp;169786&nbsp;[0x7f2cddff9ed0,0x7f2cde291270),&nbsp;7857&nbsp;[0x55d0bbbf23c0,0x55d0bbc10ed0),<br />INFO:&nbsp;-max_len&nbsp;is&nbsp;not&nbsp;provided;&nbsp;libFuzzer&nbsp;will&nbsp;not&nbsp;generate&nbsp;inputs&nbsp;larger&nbsp;than&nbsp;4096&nbsp;bytes<br />==19745==AddressSanitizer:&nbsp;WARNING:&nbsp;unexpected&nbsp;format&nbsp;specifier&nbsp;in&nbsp;printf&nbsp;interceptor:&nbsp;%P&nbsp;(reported&nbsp;once&nbsp;per&nbsp;process)<br />INFO:&nbsp;A&nbsp;corpus&nbsp;is&nbsp;not&nbsp;provided,&nbsp;starting&nbsp;from&nbsp;an&nbsp;empty&nbsp;corpus<br />#2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;INITED&nbsp;cov:&nbsp;17273&nbsp;ft:&nbsp;17228&nbsp;corp:&nbsp;1/1b&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;326Mb<br />#4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;17278&nbsp;ft:&nbsp;17326&nbsp;corp:&nbsp;2/2b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;329Mb&nbsp;L:&nbsp;1/1&nbsp;MS:&nbsp;1&nbsp;ChangeBit-<br />#6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;17279&nbsp;ft:&nbsp;17349&nbsp;corp:&nbsp;3/4b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;331Mb&nbsp;L:&nbsp;2/2&nbsp;MS:&nbsp;1&nbsp;InsertByte-<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW_FUNC[1/328]:&nbsp;0x7f2cde36c6d0&nbsp;&nbsp;(/home/dav/chromium/chromium/src/out/custom_fuzzer/libv8_libbase.so+0x4c6d0)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW_FUNC[2/328]:&nbsp;0x7f2cde3e5180&nbsp;&nbsp;(/home/dav/chromium/chromium/src/out/custom_fuzzer/libv8_libplatform.so+0x41180)<br />#8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;17692&nbsp;ft:&nbsp;17936&nbsp;corp:&nbsp;4/6b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;341Mb&nbsp;L:&nbsp;2/2&nbsp;MS:&nbsp;1&nbsp;ShuffleBytes-<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW_FUNC[1/12]:&nbsp;0x7f2cde36fbf0&nbsp;&nbsp;(/home/dav/chromium/chromium/src/out/custom_fuzzer/libv8_libbase.so+0x4fbf0)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW_FUNC[2/12]:&nbsp;0x7f2cde4033d0&nbsp;&nbsp;(/home/dav/chromium/chromium/src/out/custom_fuzzer/libv8_libplatform.so+0x5f3d0)<br />#10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;17714&nbsp;ft:&nbsp;18050&nbsp;corp:&nbsp;5/8b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;344Mb&nbsp;L:&nbsp;2/2&nbsp;MS:&nbsp;1&nbsp;ShuffleBytes-<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW_FUNC[1/2339]:&nbsp;0x7f2cd4fe69d0&nbsp;&nbsp;(/home/dav/chromium/chromium/src/out/custom_fuzzer/libc++.so+0x1439d0)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW_FUNC[2/2339]:&nbsp;0x7f2cd5090f60&nbsp;&nbsp;(/home/dav/chromium/chromium/src/out/custom_fuzzer/libc++.so+0x1edf60)<br />#11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;21008&nbsp;ft:&nbsp;22150&nbsp;corp:&nbsp;6/10b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;346Mb&nbsp;L:&nbsp;2/2&nbsp;MS:&nbsp;1&nbsp;ShuffleBytes-<br />#13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;21008&nbsp;ft:&nbsp;22154&nbsp;corp:&nbsp;7/12b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;13&nbsp;rss:&nbsp;348Mb&nbsp;L:&nbsp;2/2&nbsp;MS:&nbsp;1&nbsp;CopyPart-<br />#15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;21008&nbsp;ft:&nbsp;22166&nbsp;corp:&nbsp;8/15b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;15&nbsp;rss:&nbsp;349Mb&nbsp;L:&nbsp;3/3&nbsp;MS:&nbsp;1&nbsp;InsertByte-<br />#17&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;21008&nbsp;ft:&nbsp;22172&nbsp;corp:&nbsp;9/17b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;17&nbsp;rss:&nbsp;352Mb&nbsp;L:&nbsp;2/3&nbsp;MS:&nbsp;1&nbsp;InsertByte-<br />#19&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;21012&nbsp;ft:&nbsp;22211&nbsp;corp:&nbsp;10/19b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;19&nbsp;rss:&nbsp;353Mb&nbsp;L:&nbsp;2/3&nbsp;MS:&nbsp;1&nbsp;ChangeBinInt-<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW_FUNC[1/1]:&nbsp;0x7f2cd8119b70&nbsp;&nbsp;(/home/dav/chromium/chromium/src/out/custom_fuzzer/libv8.so+0x263fb70)<br />#21&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;21015&nbsp;ft:&nbsp;22361&nbsp;corp:&nbsp;11/20b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;21&nbsp;rss:&nbsp;356Mb&nbsp;L:&nbsp;1/3&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;21015&nbsp;ft:&nbsp;22364&nbsp;corp:&nbsp;12/21b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;23&nbsp;rss:&nbsp;358Mb&nbsp;L:&nbsp;1/3&nbsp;MS:&nbsp;1&nbsp;ChangeBit-<br />#25&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;21015&nbsp;ft:&nbsp;22368&nbsp;corp:&nbsp;13/23b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;12&nbsp;rss:&nbsp;361Mb&nbsp;L:&nbsp;2/3&nbsp;MS:&nbsp;1&nbsp;ShuffleBytes-<br />#27&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;21015&nbsp;ft:&nbsp;22377&nbsp;corp:&nbsp;14/25b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;13&nbsp;rss:&nbsp;363Mb&nbsp;L:&nbsp;2/3&nbsp;MS:&nbsp;1&nbsp;ShuffleBytes-<br />#31&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;21015&nbsp;ft:&nbsp;22442&nbsp;corp:&nbsp;15/26b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;15&nbsp;rss:&nbsp;367Mb&nbsp;L:&nbsp;1/3&nbsp;MS:&nbsp;2&nbsp;EraseBytes-CrossOver-<br />#32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pulse&nbsp;&nbsp;cov:&nbsp;21015&nbsp;ft:&nbsp;22477&nbsp;corp:&nbsp;15/26b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;16&nbsp;rss:&nbsp;368Mb<br />#33&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;21018&nbsp;ft:&nbsp;22477&nbsp;corp:&nbsp;16/27b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;16&nbsp;rss:&nbsp;369Mb&nbsp;L:&nbsp;1/3&nbsp;MS:&nbsp;1&nbsp;ChangeBinInt-<br />#35&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;21019&nbsp;ft:&nbsp;22489&nbsp;corp:&nbsp;17/31b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;11&nbsp;rss:&nbsp;371Mb&nbsp;L:&nbsp;4/4&nbsp;MS:&nbsp;1&nbsp;CrossOver-<br />#37&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;21023&nbsp;ft:&nbsp;22508&nbsp;corp:&nbsp;18/35b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;12&nbsp;rss:&nbsp;379Mb&nbsp;L:&nbsp;4/4&nbsp;MS:&nbsp;1&nbsp;CrossOver-<br />#39&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;21023&nbsp;ft:&nbsp;22570&nbsp;corp:&nbsp;19/37b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;13&nbsp;rss:&nbsp;380Mb&nbsp;L:&nbsp;2/4&nbsp;MS:&nbsp;1&nbsp;ChangeByte-<br />#41&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;21024&nbsp;ft:&nbsp;22575&nbsp;corp:&nbsp;20/40b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;13&nbsp;rss:&nbsp;382Mb&nbsp;L:&nbsp;3/4&nbsp;MS:&nbsp;1&nbsp;ChangeBinInt-<br />#43&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;21024&nbsp;ft:&nbsp;22576&nbsp;corp:&nbsp;21/41b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;14&nbsp;rss:&nbsp;383Mb&nbsp;L:&nbsp;1/4&nbsp;MS:&nbsp;1&nbsp;CrossOver-<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW_FUNC[1/4]:&nbsp;0x7f2cd81484d0&nbsp;&nbsp;(/home/dav/chromium/chromium/src/out/custom_fuzzer/libv8.so+0x266e4d0)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW_FUNC[2/4]:&nbsp;0x7f2cd81487a0&nbsp;&nbsp;(/home/dav/chromium/chromium/src/out/custom_fuzzer/libv8.so+0x266e7a0)<br />#45&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;21035&nbsp;ft:&nbsp;22880&nbsp;corp:&nbsp;22/42b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;15&nbsp;rss:&nbsp;385Mb&nbsp;L:&nbsp;1/4&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#47&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;21035&nbsp;ft:&nbsp;22893&nbsp;corp:&nbsp;23/44b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;11&nbsp;rss:&nbsp;387Mb&nbsp;L:&nbsp;2/4&nbsp;MS:&nbsp;1&nbsp;CopyPart-<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW_FUNC[1/18]:&nbsp;0x7f2cd79a0970&nbsp;&nbsp;(/home/dav/chromium/chromium/src/out/custom_fuzzer/libv8.so+0x1ec6970)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW_FUNC[2/18]:&nbsp;0x7f2cd79a09d0&nbsp;&nbsp;(/home/dav/chromium/chromium/src/out/custom_fuzzer/libv8.so+0x1ec69d0)<br />#48&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;21090&nbsp;ft:&nbsp;23967&nbsp;corp:&nbsp;24/47b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;12&nbsp;rss:&nbsp;389Mb&nbsp;L:&nbsp;3/4&nbsp;MS:&nbsp;1&nbsp;ChangeBit-<br />#50&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;21091&nbsp;ft:&nbsp;23998&nbsp;corp:&nbsp;25/49b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;12&nbsp;rss:&nbsp;390Mb&nbsp;L:&nbsp;2/4&nbsp;MS:&nbsp;1&nbsp;ChangeBit-</div></div><br /><br />但是，正如我们从覆盖率报告中可以看到的那样，我们要击中的代码没有被击中。 因此，我们需要在模糊器的开发方面取得进步。<br /><br /><h2>完善模糊器</h2><br />短时间内，上述模糊器未执行Decode函数。 因此，为了更好地控制模糊器，我们将尝试进一步完善它，以使它更加发挥作用。因此，现在的想法是将来自核心模糊引擎的随机数据包装到对Decode（）函数的调用中。请考虑以下实现此设置的模糊器：<br /><h3>pdf_custom_fuzzer.cc</h3><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdlib.h&gt;<br />#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;stdint.h&gt;<br />#include&nbsp;&lt;unistd.h&gt;<br />#include&nbsp;&lt;iostream&gt;<br />#include&nbsp;&lt;sys/types.h&gt;<br /><br />#include&nbsp;&quot;public/fpdf_formfill.h&quot;<br />#include&nbsp;&quot;testing/fuzzers/pdfium_fuzzer_helper.h&quot;<br /><br />class&nbsp;PDFiumXFAFuzzer&nbsp;:&nbsp;public&nbsp;PDFiumFuzzerHelper&nbsp;{<br />&nbsp;public:<br />&nbsp;&nbsp;PDFiumXFAFuzzer()&nbsp;=&nbsp;default;<br />&nbsp;&nbsp;~PDFiumXFAFuzzer()&nbsp;override&nbsp;=&nbsp;default;<br /><br />&nbsp;&nbsp;int&nbsp;GetFormCallbackVersion()&nbsp;const&nbsp;override&nbsp;{&nbsp;return&nbsp;2;&nbsp;}<br /><br />&nbsp;&nbsp;//&nbsp;Return&nbsp;false&nbsp;if&nbsp;XFA&nbsp;doesn&#39;t&nbsp;load&nbsp;as&nbsp;otherwise&nbsp;we&#39;re&nbsp;duplicating&nbsp;the&nbsp;work<br />&nbsp;&nbsp;//&nbsp;done&nbsp;by&nbsp;the&nbsp;non-xfa&nbsp;fuzzer.<br />&nbsp;&nbsp;bool&nbsp;OnFormFillEnvLoaded(FPDF_DOCUMENT&nbsp;doc)&nbsp;override&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;form_type&nbsp;=&nbsp;FPDF_GetFormType(doc);<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(form_type&nbsp;!=&nbsp;FORMTYPE_XFA_FULL&nbsp;&amp;&amp;&nbsp;form_type&nbsp;!=&nbsp;FORMTYPE_XFA_FOREGROUND)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;FPDF_LoadXFA(doc);<br />&nbsp;&nbsp;}<br />};<br /><br /><br />/*&nbsp;Below&nbsp;is&nbsp;our&nbsp;custom&nbsp;fuzzer&nbsp;implementatino&nbsp;*/<br /><br />char&nbsp;pdf_generic_start[]&nbsp;=&nbsp;&quot;%PDF-1.7\n\<br />1&nbsp;0&nbsp;obj\n\<br />&lt;&lt;/Type&nbsp;/Catalog&nbsp;/Pages&nbsp;2&nbsp;0&nbsp;R&nbsp;/AcroForm&nbsp;&lt;&lt;/XFA&nbsp;30&nbsp;0&nbsp;R&gt;&gt;&nbsp;/NeedsRendering&nbsp;true&gt;&gt;\n\<br />endobj\n\<br />2&nbsp;0&nbsp;obj\n\<br />&lt;&lt;/Type&nbsp;/Pages&nbsp;/Kids&nbsp;[3&nbsp;0&nbsp;R]&nbsp;/Count&nbsp;1&gt;&gt;\n\<br />endobj\n\<br />3&nbsp;0&nbsp;obj\n\<br />&lt;&lt;/Type&nbsp;/Page&nbsp;/Parent&nbsp;2&nbsp;0&nbsp;R&nbsp;/MediaBox&nbsp;[0&nbsp;0&nbsp;3&nbsp;3]&gt;&gt;\n\<br />endobj\n\<br />30&nbsp;0&nbsp;obj\n\<br />&lt;&lt;/Length&nbsp;%d&gt;&gt;\n\<br />stream\n\<br />&lt;xdp&nbsp;xmlns=\&quot;http://ns.adobe.com/xdp/\&quot;&gt;&quot;;<br /><br />char&nbsp;pdf_generic_end[]&nbsp;=&nbsp;&quot;&lt;/xdp&gt;\n\<br />endstream\n\<br />endobj\n\<br />trailer\n\<br />&lt;&lt;/Root&nbsp;1&nbsp;0&nbsp;R&nbsp;/Size&nbsp;31&gt;&gt;\n\<br />%%EOF&quot;;<br /><br />std::string&nbsp;data_to_str(char&nbsp;*data,&nbsp;size_t&nbsp;size)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;std::string&nbsp;xfa_string&nbsp;=&nbsp;std::string(&quot;&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;xfa_string&nbsp;+=&nbsp;&quot;&lt;template&gt;&lt;subform&gt;&lt;validate&gt;&lt;script&gt;Decode(\&quot;&quot;;<br />&nbsp;&nbsp;&nbsp;&nbsp;xfa_string&nbsp;+=&nbsp;data;<br />&nbsp;&nbsp;&nbsp;&nbsp;xfa_string&nbsp;+=&nbsp;&quot;\&quot;,\&quot;HTML\&quot;)&lt;/script&gt;&lt;/validate&gt;&lt;/subform&gt;&lt;/template&gt;&quot;;<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;xfa_string;<br />}<br /><br />extern&nbsp;&quot;C&quot;&nbsp;int&nbsp;LLVMFuzzerTestOneInput(const&nbsp;uint8_t&nbsp;*data,&nbsp;size_t&nbsp;size)&nbsp;<span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*null_terminated&nbsp;=&nbsp;(char*)malloc(size+1);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(null_terminated,&nbsp;data,&nbsp;size);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;null_terminated[size]&nbsp;=&nbsp;&#39;\0&#39;;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::string&nbsp;xfa_payload&nbsp;=&nbsp;data_to_str(null_terminated,&nbsp;size);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//int&nbsp;payload_size&nbsp;=&nbsp;xfa_string.length();<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*new_mem&nbsp;=&nbsp;(char*)malloc(strlen(pdf_generic_start)&nbsp;+<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;For&nbsp;the&nbsp;length&nbsp;number<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strlen(pdf_generic_end)&nbsp;+<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(xfa_payload.length()+44));<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*curr_offset&nbsp;=&nbsp;new_mem;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;First&nbsp;copy&nbsp;in&nbsp;the&nbsp;start&nbsp;of&nbsp;the&nbsp;PDF&nbsp;file&nbsp;with&nbsp;size&nbsp;of&nbsp;script.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;The&nbsp;44&nbsp;here&nbsp;is&nbsp;the&nbsp;size&nbsp;of&nbsp;the&nbsp;&quot;&lt;xdp&nbsp;...&nbsp;&lt;/xdp&gt;&nbsp;characters.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sprintf(curr_offset,&nbsp;pdf_generic_start,&nbsp;xfa_payload.length()+44);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;curr_offset&nbsp;+=&nbsp;strlen(curr_offset);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Append&nbsp;the&nbsp;xfa&nbsp;payload&nbsp;*/<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(curr_offset,&nbsp;xfa_payload.c_str(),&nbsp;xfa_payload.length());<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;curr_offset&nbsp;+=&nbsp;xfa_payload.length();<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Append&nbsp;the&nbsp;end&nbsp;of&nbsp;the&nbsp;PDF&nbsp;*/<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(curr_offset,&nbsp;pdf_generic_end,&nbsp;strlen(pdf_generic_end));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;curr_offset&nbsp;+=&nbsp;strlen(pdf_generic_end);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;NULL-terminate&nbsp;*/<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*curr_offset&nbsp;=&nbsp;&#39;\0&#39;;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Get&nbsp;the&nbsp;size&nbsp;*/<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;total_length&nbsp;=&nbsp;(int)(curr_offset&nbsp;-&nbsp;new_mem);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//int&nbsp;total_length&nbsp;=&nbsp;nm_strlen&nbsp;+&nbsp;payload_size&nbsp;+&nbsp;strlen(pdf_generic_end);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//new_mem[total_length]&nbsp;=&nbsp;&#39;\0&#39;;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PDFiumXFAFuzzer&nbsp;fuzzer;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fuzzer.RenderPdf(reinterpret_cast&lt;const&nbsp;char*&gt;(new_mem),&nbsp;total_length);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(new_mem);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(null_terminated);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />现在，我们可以重新编译模糊器并运行它以再次提取覆盖率，如下所示：<br /><div class="codebox"><div class="codebox">#&nbsp;recompiile&nbsp;the&nbsp;fuzzer<br />$&nbsp;ninja&nbsp;-C&nbsp;out/custom_fuzzer&nbsp;pdf_custom_fuzzer<br />$&nbsp;mkdir&nbsp;../CORPUS2<br />$&nbsp;ASAN_OPTIONS=detect_odr_violation=0&nbsp;./out/custom_fuzzer/pdf_custom_fuzzer&nbsp;../CORPUS2/&nbsp;-max_total_time=600<br /><br />#&nbsp;Generate&nbsp;the&nbsp;config&nbsp;directory&nbsp;where&nbsp;we&nbsp;will&nbsp;place&nbsp;our&nbsp;stuff<br />$&nbsp;gn&nbsp;gen&nbsp;out/coverage-custom-fuzzer&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;--args=&quot;use_clang_coverage=true&nbsp;is_component_build=false&nbsp;is_debug=false&nbsp;dcheck_always_on=true&nbsp;use_libfuzzer=true&nbsp;pdf_enable_xfa=true&quot;<br /><br />#&nbsp;Collect&nbsp;coverage&nbsp;and&nbsp;extract&nbsp;the&nbsp;coverage&nbsp;report<br />$&nbsp;python&nbsp;tools/code_coverage/coverage.py&nbsp;pdf_custom_fuzzer&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;-b&nbsp;out/coverage-custom-fuzzer/&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;-o&nbsp;out/report-1&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;-c&nbsp;&#39;out/coverage-custom-fuzzer/pdf_custom_fuzzer&nbsp;-runs=0&nbsp;/home/dav/chromium/chromium/CORPUS2&#39;<br /><br />#&nbsp;Now&nbsp;navigate&nbsp;into&nbsp;the&nbsp;report&nbsp;and&nbsp;start&nbsp;the&nbsp;http&nbsp;server<br />$&nbsp;cd&nbsp;out/report-1<br />$&nbsp;python3&nbsp;-m&nbsp;http.server&nbsp;5001</div></div><br /><br />至此，我们的模糊器成功了，我们已经达到了目标代码：<br />我们的自定义模糊器和语料库成功命中了Decode函数178次。<br /><a href=""><img src="images\999-1.png" alt="images\999-1.png" /></a><br /><br />自然地，我们上面开发的模糊器已经在原有目标（创建一个可以触发PDFium源代码大部分内容的模糊器。）的基础上取得了很大进展，这样，为了创建一个或多个真正触发PDFium源代码的模糊器，我们需要开始抽象模糊器的思想。 有几种方法可以做到这一点，包括：<br />1、基于XFA数据结构实现语法感知的模糊器<br />2、基于PDF数据结构实现语法感知的模糊器<br />3、较长时间运行我们本已通用的模糊器。<br />4、将适当的种子整合到我们的模糊器中<br />5、寻找适合XFA结构的种子<br />6、将字典与来自XFA数据格式的适当关键字一起使用<br />7、依靠其他结构感知方法来构建格式良好或接近XFA的数据</div><div class='page'><h1 class='title level-2'>6_Fuzzing_managed_languages</h1><br/></div><div class='page'><h1 class='title level-3'>1_Introduction</h1><br/></div><div class='page'><h1 class='title level-4'>1_Introduction_to_fuzzing_managed_languages</h1><br/><h1>模糊化托管语言简介</h1><br />在本节之前，我们介绍了如何使用C和C ++编写的应用程序模糊。 现在，我们将研究如何以托管语言模糊应用程序，重点是Python。 思路仍然是将伪随机输入传递到感兴趣目标。从模糊本地语言到模糊托管语言时，最大的变化也许就是我们可以找到的错误类型。 通常，在托管语言中，我们最常发现的是未处理的异常。尽管它们不像内存损坏漏洞那样对安全性至关重要，但是从可靠性角度来看，它们仍然至关重要。</div><div class='page'><h1 class='title level-3'>2_Python_fuzzing</h1><br/></div><div class='page'><h1 class='title level-4'>1_Demonstration of Python fuzzing _ ADA Logics</h1><br/>暂略</div><div class='page'><h1 class='title level-4'>2_Introduction_to_Python_Fuzzing</h1><br/><h1>Python Fuzzing简介</h1><br /><br />在本节中，我们介绍Python模糊测试。 我们将使用Google开发的Python模糊测试工具Atheris，它是开源的，可以在这里找到存储库。<a href="https://github.com/google/atheris">https://github.com/google/atheris</a><br /><br />Atheris是一个Python模糊器，能够对纯Python库以及用C / C ++编写的本地Python库进行模糊测试。 这也意味着Atheris可以使用sanitizers对本机库进行模糊处理，从而可以在本机Python扩展中查找内存损坏漏洞。<br /><br /><h2>在我们的Docker容器中安装Atheris</h2><br />我们可以通过pip来安装Atheris，我们将在我们通常的Docker容器中进行安装。 但是，首先，我们必须确保已安装Python虚拟环境以及用于Python的开发包。 以下命令将Atheris安装在Docker映像中：<br /><div class="codebox"><div class="codebox">$&nbsp;mkdir&nbsp;atheris<br />$&nbsp;cd&nbsp;atheris<br />$&nbsp;apt-get&nbsp;install&nbsp;-y&nbsp;python3-venv&nbsp;python3-dev<br />$&nbsp;python3&nbsp;-m&nbsp;venv&nbsp;venv<br />$&nbsp;.&nbsp;venv/bin/activate<br />$&nbsp;pip&nbsp;install&nbsp;wheel<br />$&nbsp;pip&nbsp;install&nbsp;atheris<br /></div></div><br /><br /><h2>Hello-World Python模糊测试</h2><br />Atheris模糊器依赖于libFuzzer作为后端，因此使用Atheris的方法本质上类似于使用libFuzzer。 考虑以下Python脚本，其中包含目标模糊器功能以及模糊器驱动程序本身：<br /><h3>python_fuzz.py</h3><br /><div class="codebox"><div class="codebox">import&nbsp;atheris<br />import&nbsp;sys<br /><br />def&nbsp;TestOneInput(data):<br />&nbsp;&nbsp;if&nbsp;data&nbsp;==&nbsp;b&quot;BOOM&quot;:<br />&nbsp;&nbsp;&nbsp;&nbsp;raise&nbsp;RuntimeError(&quot;Bug&nbsp;found!&quot;)<br /><br />atheris.Setup(sys.argv,&nbsp;TestOneInput)<br />atheris.Fuzz<span style="color:#000000;font-weight:400">()</span></div></div><br /><br />设置非常直观。 我们通过直接调用atheris模块中的函数来配置模糊设置，而我们仅对Setup和Fuzz这两个函数感兴趣。Setup程序的第一个参数应该只是sys.argv，因为在运行模糊器时传递的commandline参数将进一步传递给libFuzzer核心，这使得可以将常规libFuzzer参数与Atheris一起使用。<br /><br />Setup的第二个参数是将成为我们入口点的函数，即我们习惯使用的LLVMFuzzerTestOneInput。 但是，在这种情况下，我们的模糊器入口点仅使用一个参数，这是一个包含随机数据的字节数组，因此没有大小参数，因为我们可以在字节上使用len参数来获取字节的长度。<br /><br />atheris模块中的Fuzz函数将启动模糊测试，因此当我们准备进行模糊测试时，只需调用此函数即可。<br />我们可以通过简单地使用Python运行脚本来针对该目标运行Atheris：<br /><div class="codebox"><div class="codebox">$&nbsp;python3&nbsp;./python_fuzz.py<br />INFO:&nbsp;Configured&nbsp;for&nbsp;Python&nbsp;tracing&nbsp;with&nbsp;opcodes.<br />WARNING:&nbsp;Failed&nbsp;to&nbsp;find&nbsp;function&nbsp;&quot;__sanitizer_acquire_crash_state&quot;.<br />WARNING:&nbsp;Failed&nbsp;to&nbsp;find&nbsp;function&nbsp;&quot;__sanitizer_print_stack_trace&quot;.<br />WARNING:&nbsp;Failed&nbsp;to&nbsp;find&nbsp;function&nbsp;&quot;__sanitizer_set_death_callback&quot;.<br />INFO:&nbsp;Seed:&nbsp;906627541<br />INFO:&nbsp;Loaded&nbsp;2&nbsp;modules&nbsp;&nbsp;&nbsp;(1024&nbsp;inline&nbsp;8-bit&nbsp;counters):&nbsp;512&nbsp;[0x2873bd0,&nbsp;0x2873dd0),&nbsp;512&nbsp;[0x2876600,&nbsp;0x2876800),<br />INFO:&nbsp;Loaded&nbsp;2&nbsp;PC&nbsp;tables&nbsp;(1024&nbsp;PCs):&nbsp;512&nbsp;[0x28745f0,0x28765f0),&nbsp;512&nbsp;[0x2877020,0x2879020),<br />INFO:&nbsp;-max_len&nbsp;is&nbsp;not&nbsp;provided;&nbsp;libFuzzer&nbsp;will&nbsp;not&nbsp;generate&nbsp;inputs&nbsp;larger&nbsp;than&nbsp;4096&nbsp;bytes<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW_PY_FUNC[1/2]:&nbsp;TestOneInput()&nbsp;./python_fuzz.py:4<br />INFO:&nbsp;A&nbsp;corpus&nbsp;is&nbsp;not&nbsp;provided,&nbsp;starting&nbsp;from&nbsp;an&nbsp;empty&nbsp;corpus<br />#2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;INITED&nbsp;cov:&nbsp;7&nbsp;ft:&nbsp;7&nbsp;corp:&nbsp;1/1b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;30Mb<br /><br />&nbsp;===&nbsp;Uncaught&nbsp;Python&nbsp;exception:&nbsp;===<br />RuntimeError:&nbsp;Bug&nbsp;found!<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW_PY_FUNC[1/2]:&nbsp;_find_and_load()&nbsp;:986<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW_PY_FUNC[2/2]:&nbsp;__init__()&nbsp;:143<br />Traceback&nbsp;(most&nbsp;recent&nbsp;call&nbsp;last):<br />&nbsp;&nbsp;File&nbsp;&quot;./python_fuzz.py&quot;,&nbsp;line&nbsp;6,&nbsp;in&nbsp;TestOneInput<br />&nbsp;&nbsp;&nbsp;&nbsp;raise&nbsp;RuntimeError(&quot;Bug&nbsp;found!&quot;)<br /><br />==797==&nbsp;ERROR:&nbsp;libFuzzer:&nbsp;fuzz&nbsp;target&nbsp;exited<br />SUMMARY:&nbsp;libFuzzer:&nbsp;fuzz&nbsp;target&nbsp;exited<br />MS:&nbsp;3&nbsp;InsertByte-CMP-CMP-&nbsp;DE:&nbsp;&quot;\x01\x00&quot;-&quot;BOOM&quot;-;&nbsp;base&nbsp;unit:&nbsp;adc83b19e793491b1c6ea0fd8b46cd9f32e592fc<br />0x42,0x4f,0x4f,0x4d,<br />BOOM<br />artifact_prefix=&#39;./&#39;;&nbsp;Test&nbsp;unit&nbsp;written&nbsp;to&nbsp;./crash-2deb1bb4344e17f4b9f2c1063fc8a02b2fe6dc86<br />Base64:&nbsp;Qk9PTQ==</div></div><br /><br />调查崩溃后，我们迅速发现了触发异常所需的内容：<br /><div class="codebox"><div class="codebox">$&nbsp;hexdump&nbsp;-C&nbsp;./crash-2deb1bb4344e17f4b9f2c1063fc8a02b2fe6dc86<br />00000000&nbsp;&nbsp;42&nbsp;4f&nbsp;4f&nbsp;4d&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|BOOM|<br />00000004</div></div><br /><br /><h2>发现bug</h2><br />通常，在Python模糊测试中会发现两种bug，而预期能找到的错误类型取决于是模糊测试的纯Python目标还是包含native代码的Python库。 我们可以通过Python模糊测试找到以下错误：<br />1、未处理的异常<br />2、本机库中的内存损坏问题<br /><br />未处理的异常是指API抛出异常但该异常无法被当前代码处理 例如，如果API旨在在发生错误的情况下引发特定于项目的异常，但实际异常发生时却抛出了有关<h3> native Python</h3>的异常，则这是一个问题，因为未指定根据API进行编码的应用程序来处理此类问题。Python的native异常可以在这里找到。 常见的未处理异常的示例包括：<br />• <code>IndexError</code> for out-of-bounds accesses.<br />• <code>KeyError</code> for incorrect dictionary accesses.<br />• <code>ValueError</code> for incorrect value passing to a given operation of function.<br />• <code>ZeroDivisionError</code> for division-by-zero errors.<br /><br />特别是，为了捕获纯Python库中的问题（此时不支持sanitizers），我们依靠Python自身的异常来识别缺陷。<br /><br />Native Python库中的内存损坏是指Python库包装以C / C ++编写的代码。 多数情况下，作者将Python代码包装在Native库中的原因是为了获得一定程度的加速或接近系统代码。<br /><br />为了捕获内存损坏问题，我们可以依靠我们现有的消毒器，这将在本课程的下一部分中显示。<br /><br />未处理异常的性质通常不如内存损坏问题那么重要。 但是，就可靠性而言，它们仍然是重要的因素，并且鉴于Python的扩展，很可能存在许多通过模糊测试发现的可靠性问题。<br /></div><div class='page'><h1 class='title level-4'>3_Targetting_pure_Python_code</h1><br/><h1>Targetting pure Python code</h1><br />在本节中，我们将展示如何模糊一个名为simplejson的纯Python库。 这里提供了simplejson的源代码。  simplejson是一个小型库，用于快速，完整和正确的json编码和解码。<br /><br />为了为simplejson写一个模糊器，我们看一下解码器的测试用例，可以在这里找到。 我们感兴趣的代码片段如下：<br /><h3>test_decode.py</h3><br /><div class="codebox"><div class="codebox">from&nbsp;__future__&nbsp;import&nbsp;absolute_import<br />import&nbsp;decimal<br />from&nbsp;unittest&nbsp;import&nbsp;TestCase<br /><br />import&nbsp;simplejson&nbsp;as&nbsp;json<br />from&nbsp;simplejson.compat&nbsp;import&nbsp;StringIO,&nbsp;b,&nbsp;binary_type<br />from&nbsp;simplejson&nbsp;import&nbsp;OrderedDict<br /><br />class&nbsp;TestDecode(TestCase):<br />&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;test_decoder_optimizations(self):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Several&nbsp;optimizations&nbsp;were&nbsp;made&nbsp;that&nbsp;skip&nbsp;over&nbsp;calls&nbsp;to<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;the&nbsp;whitespace&nbsp;regex,&nbsp;so&nbsp;this&nbsp;test&nbsp;is&nbsp;designed&nbsp;to&nbsp;try&nbsp;and<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;exercise&nbsp;the&nbsp;uncommon&nbsp;cases.&nbsp;The&nbsp;array&nbsp;cases&nbsp;are&nbsp;already&nbsp;covered.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rval&nbsp;=&nbsp;json.loads(&#39;{&nbsp;&nbsp;&nbsp;&quot;key&quot;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;&nbsp;&quot;value&quot;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;&nbsp;&quot;k&quot;:&quot;v&quot;&nbsp;&nbsp;&nbsp;&nbsp;}&#39;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertEqual<span style="color:#000000;font-weight:400">(</span>rval,&nbsp;{&quot;key&quot;:&quot;value&quot;,&nbsp;&quot;k&quot;:&quot;v&quot;}<span style="color:#000000;font-weight:400">)</span></div></div><br /><br />测试用例将simplejson库作为json导入，因此对json.loads（&#39;{“ key”：“ value”，“ k”：“ v”}&#39;）的调用实际上是simplejson库内部的调用。 我们将对此精确功能进行模糊处理。<br /><br />模糊化simplejson.fuzz函数很简单，我们可以使用以下模糊器实现它：<br /><h3>fuzz_loadjs.py</h3><br /><div class="codebox"><div class="codebox">import&nbsp;atheris<br />import&nbsp;sys<br />import&nbsp;simplejson<br /><br />#&nbsp;Fuzz&nbsp;simplejson.loads&nbsp;<br />def&nbsp;TestOneInput(data):<br />&nbsp;&nbsp;fdp&nbsp;=&nbsp;atheris.FuzzedDataProvider(data)<br />&nbsp;&nbsp;original&nbsp;=&nbsp;fdp.ConsumeUnicode(sys.maxsize)<br />&nbsp;&nbsp;try:<br />&nbsp;&nbsp;&nbsp;&nbsp;simplejson.loads(original)<br />&nbsp;&nbsp;except&nbsp;simplejson.JSONDecodeError:<br />&nbsp;&nbsp;&nbsp;&nbsp;None<br />&nbsp;&nbsp;return<br /><br />atheris.Setup(sys.argv,&nbsp;TestOneInput)<br />atheris.Fuzz<span style="color:#000000;font-weight:400">()</span></div></div><br /><br />为了fuzzing这段代码，我们只需克隆simplejson Github存储库并在其中运行我们的模糊器：<br /><div class="codebox"><div class="codebox">$&nbsp;git&nbsp;clone&nbsp;https://github.com/simplejson/simplejson<br />$&nbsp;cd&nbsp;simplejson</div></div><br /><br />现在将模糊器放置在simplejson的根目录中，我们可以启动它：<br /><div class="codebox"><div class="codebox">$&nbsp;&nbsp;python&nbsp;./fuzz_loadjs.py&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />INFO:&nbsp;Configured&nbsp;for&nbsp;Python&nbsp;tracing&nbsp;with&nbsp;opcodes.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />WARNING:&nbsp;Failed&nbsp;to&nbsp;find&nbsp;function&nbsp;&quot;__sanitizer_acquire_crash_state&quot;.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />WARNING:&nbsp;Failed&nbsp;to&nbsp;find&nbsp;function&nbsp;&quot;__sanitizer_print_stack_trace&quot;.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />WARNING:&nbsp;Failed&nbsp;to&nbsp;find&nbsp;function&nbsp;&quot;__sanitizer_set_death_callback&quot;.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />INFO:&nbsp;Seed:&nbsp;3705150189&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />INFO:&nbsp;Loaded&nbsp;2&nbsp;modules&nbsp;&nbsp;&nbsp;(1024&nbsp;inline&nbsp;8-bit&nbsp;counters):&nbsp;512&nbsp;[0x2805aa0,&nbsp;0x2805ca0),&nbsp;512&nbsp;[0x280bb20,&nbsp;0x280bd20),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />INFO:&nbsp;Loaded&nbsp;2&nbsp;PC&nbsp;tables&nbsp;(1024&nbsp;PCs):&nbsp;512&nbsp;[0x27f6030,0x27f8030),&nbsp;512&nbsp;[0x27f26d0,0x27f46d0),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />INFO:&nbsp;-max_len&nbsp;is&nbsp;not&nbsp;provided;&nbsp;libFuzzer&nbsp;will&nbsp;not&nbsp;generate&nbsp;inputs&nbsp;larger&nbsp;than&nbsp;4096&nbsp;bytes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW_PY_FUNC[1/2]:&nbsp;TestOneInput()&nbsp;./fuzz_loadjs.py:6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW_PY_FUNC[2/2]:&nbsp;loads()&nbsp;/atheris/simplejson/simplejson/simplejson/__init__.py:474&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />INFO:&nbsp;A&nbsp;corpus&nbsp;is&nbsp;not&nbsp;provided,&nbsp;starting&nbsp;from&nbsp;an&nbsp;empty&nbsp;corpus&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />#2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;INITED&nbsp;cov:&nbsp;247&nbsp;ft:&nbsp;247&nbsp;corp:&nbsp;1/1b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;32Mb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />#3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;315&nbsp;ft:&nbsp;315&nbsp;corp:&nbsp;2/4b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;32Mb&nbsp;L:&nbsp;3/3&nbsp;MS:&nbsp;1&nbsp;CMP-&nbsp;DE:&nbsp;&quot;\x01\x00&quot;-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />#11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;324&nbsp;ft:&nbsp;324&nbsp;corp:&nbsp;3/8b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;32Mb&nbsp;L:&nbsp;4/4&nbsp;MS:&nbsp;3&nbsp;ChangeBit-CrossOver-CrossOver-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />#27&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;324&nbsp;ft:&nbsp;324&nbsp;corp:&nbsp;3/6b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;32Mb&nbsp;L:&nbsp;2/3&nbsp;MS:&nbsp;1&nbsp;EraseBytes-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW_PY_FUNC[1/2]:&nbsp;JSONArray()&nbsp;/atheris/simplejson/simplejson/simplejson/decoder.py:236&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW_FUNC[1/1]:&nbsp;0x27f8065&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />#58&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;382&nbsp;ft:&nbsp;382&nbsp;corp:&nbsp;4/9b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;32Mb&nbsp;L:&nbsp;3/3&nbsp;MS:&nbsp;1&nbsp;InsertByte-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />#88&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;382&nbsp;ft:&nbsp;382&nbsp;corp:&nbsp;4/8b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;32Mb&nbsp;L:&nbsp;2/3&nbsp;MS:&nbsp;5&nbsp;PersAutoDict-EraseBytes-InsertByte-ChangeByte-EraseBytes-&nbsp;DE:&nbsp;&quot;<br />\x01\x00&quot;-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />#95&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;389&nbsp;ft:&nbsp;463&nbsp;corp:&nbsp;5/12b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;32Mb&nbsp;L:&nbsp;4/4&nbsp;MS:&nbsp;2&nbsp;CopyPart-CopyPart-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />#98&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;471&nbsp;ft:&nbsp;568&nbsp;corp:&nbsp;6/16b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;32Mb&nbsp;L:&nbsp;4/4&nbsp;MS:&nbsp;3&nbsp;ShuffleBytes-ChangeBinInt-CrossOver-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />#139&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;471&nbsp;ft:&nbsp;577&nbsp;corp:&nbsp;7/20b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;32Mb&nbsp;L:&nbsp;4/4&nbsp;MS:&nbsp;1&nbsp;CrossOver-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />#154&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;477&nbsp;ft:&nbsp;583&nbsp;corp:&nbsp;8/23b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;32Mb&nbsp;L:&nbsp;3/4&nbsp;MS:&nbsp;5&nbsp;CrossOver-CMP-EraseBytes-CopyPart-ChangeByte-&nbsp;DE:&nbsp;&quot;\xff\xff&quot;-&nbsp;<br />#200&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;477&nbsp;ft:&nbsp;583&nbsp;corp:&nbsp;8/22b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;32Mb&nbsp;L:&nbsp;2/4&nbsp;MS:&nbsp;1&nbsp;EraseBytes-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />#211&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;477&nbsp;ft:&nbsp;583&nbsp;corp:&nbsp;8/21b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;32Mb&nbsp;L:&nbsp;3/4&nbsp;MS:&nbsp;1&nbsp;EraseBytes-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW_PY_FUNC[1/2]:&nbsp;py_scanstring()&nbsp;/atheris/simplejson/simplejson/simplejson/decoder.py:49&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW_FUNC[1/1]:&nbsp;0x27f8069&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />#247&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;514&nbsp;ft:&nbsp;620&nbsp;corp:&nbsp;9/23b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;32Mb&nbsp;L:&nbsp;2/4&nbsp;MS:&nbsp;1&nbsp;ChangeByte-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />#298&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;711&nbsp;ft:&nbsp;817&nbsp;corp:&nbsp;10/27b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;32Mb&nbsp;L:&nbsp;4/4&nbsp;MS:&nbsp;1&nbsp;CrossOver-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />...<br />...<br />...<br />#469535&nbsp;REDUCE&nbsp;cov:&nbsp;1340&nbsp;ft:&nbsp;4240&nbsp;corp:&nbsp;160/9157b&nbsp;lim:&nbsp;2435&nbsp;exec/s:&nbsp;13042&nbsp;rss:&nbsp;34Mb&nbsp;L:&nbsp;9/999&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#471613&nbsp;REDUCE&nbsp;cov:&nbsp;1340&nbsp;ft:&nbsp;4240&nbsp;corp:&nbsp;160/9085b&nbsp;lim:&nbsp;2446&nbsp;exec/s:&nbsp;13100&nbsp;rss:&nbsp;34Mb&nbsp;L:&nbsp;332/999&nbsp;MS:&nbsp;3&nbsp;ChangeByte-ChangeByte-EraseBytes-<br />#471635&nbsp;REDUCE&nbsp;cov:&nbsp;1340&nbsp;ft:&nbsp;4240&nbsp;corp:&nbsp;160/9008b&nbsp;lim:&nbsp;2446&nbsp;exec/s:&nbsp;13100&nbsp;rss:&nbsp;34Mb&nbsp;L:&nbsp;255/999&nbsp;MS:&nbsp;2&nbsp;ChangeASCIIInt-EraseBytes-<br />#472808&nbsp;REDUCE&nbsp;cov:&nbsp;1340&nbsp;ft:&nbsp;4240&nbsp;corp:&nbsp;160/8893b&nbsp;lim:&nbsp;2457&nbsp;exec/s:&nbsp;13133&nbsp;rss:&nbsp;34Mb&nbsp;L:&nbsp;140/999&nbsp;MS:&nbsp;3&nbsp;InsertByte-ChangeASCIIInt-EraseBytes-<br />#473379&nbsp;REDUCE&nbsp;cov:&nbsp;1340&nbsp;ft:&nbsp;4240&nbsp;corp:&nbsp;160/8886b&nbsp;lim:&nbsp;2457&nbsp;exec/s:&nbsp;13149&nbsp;rss:&nbsp;34Mb&nbsp;L:&nbsp;16/999&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#473396&nbsp;REDUCE&nbsp;cov:&nbsp;1340&nbsp;ft:&nbsp;4240&nbsp;corp:&nbsp;160/8848b&nbsp;lim:&nbsp;2457&nbsp;exec/s:&nbsp;13149&nbsp;rss:&nbsp;34Mb&nbsp;L:&nbsp;102/999&nbsp;MS:&nbsp;2&nbsp;ChangeBit-EraseBytes-<br />#473612&nbsp;REDUCE&nbsp;cov:&nbsp;1340&nbsp;ft:&nbsp;4240&nbsp;corp:&nbsp;160/8839b&nbsp;lim:&nbsp;2457&nbsp;exec/s:&nbsp;13155&nbsp;rss:&nbsp;34Mb&nbsp;L:&nbsp;47/999&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#474488&nbsp;REDUCE&nbsp;cov:&nbsp;1340&nbsp;ft:&nbsp;4240&nbsp;corp:&nbsp;160/8833b&nbsp;lim:&nbsp;2457&nbsp;exec/s:&nbsp;13180&nbsp;rss:&nbsp;34Mb&nbsp;L:&nbsp;96/999&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#476397&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;1345&nbsp;ft:&nbsp;4245&nbsp;corp:&nbsp;161/8843b&nbsp;lim:&nbsp;2468&nbsp;exec/s:&nbsp;13233&nbsp;rss:&nbsp;34Mb&nbsp;L:&nbsp;10/999&nbsp;MS:&nbsp;4&nbsp;EraseBytes-PersAutoDict-ChangeBinInt-ChangeBit-&nbsp;DE:&nbsp;&quot;\xff\xff\xff\xff\xff\xff\xff\x02&quot;-<br />#476813&nbsp;REDUCE&nbsp;cov:&nbsp;1345&nbsp;ft:&nbsp;4245&nbsp;corp:&nbsp;161/8842b&nbsp;lim:&nbsp;2468&nbsp;exec/s:&nbsp;13244&nbsp;rss:&nbsp;34Mb&nbsp;L:&nbsp;273/999&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#478591&nbsp;REDUCE&nbsp;cov:&nbsp;1345&nbsp;ft:&nbsp;4245&nbsp;corp:&nbsp;161/8836b&nbsp;lim:&nbsp;2479&nbsp;exec/s:&nbsp;12934&nbsp;rss:&nbsp;34Mb&nbsp;L:&nbsp;90/999&nbsp;MS:&nbsp;3&nbsp;ChangeBinInt-ChangeByte-EraseBytes-<br />#479373&nbsp;REDUCE&nbsp;cov:&nbsp;1345&nbsp;ft:&nbsp;4245&nbsp;corp:&nbsp;161/8835b&nbsp;lim:&nbsp;2479&nbsp;exec/s:&nbsp;12956&nbsp;rss:&nbsp;34Mb&nbsp;L:&nbsp;106/999&nbsp;MS:&nbsp;2&nbsp;InsertByte-EraseBytes-<br />#479692&nbsp;REDUCE&nbsp;cov:&nbsp;1345&nbsp;ft:&nbsp;4245&nbsp;corp:&nbsp;161/8832b&nbsp;lim:&nbsp;2479&nbsp;exec/s:&nbsp;12964&nbsp;rss:&nbsp;34Mb&nbsp;L:&nbsp;87/999&nbsp;MS:&nbsp;4&nbsp;InsertByte-ChangeBit-InsertByte-EraseBytes-<br />#480025&nbsp;REDUCE&nbsp;cov:&nbsp;1345&nbsp;ft:&nbsp;4245&nbsp;corp:&nbsp;161/8828b&nbsp;lim:&nbsp;2479&nbsp;exec/s:&nbsp;12973&nbsp;rss:&nbsp;34Mb&nbsp;L:&nbsp;6/999&nbsp;MS:&nbsp;3&nbsp;InsertByte-ChangeASCIIInt-EraseBytes-<br /><br />&nbsp;===&nbsp;Uncaught&nbsp;Python&nbsp;exception:&nbsp;===<br />ValueError:&nbsp;chr()&nbsp;arg&nbsp;not&nbsp;in&nbsp;range(0x110000)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW_PY_FUNC[1/2]:&nbsp;_find_and_load()&nbsp;:986<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW_PY_FUNC[2/2]:&nbsp;__init__()&nbsp;:143<br />Traceback&nbsp;(most&nbsp;recent&nbsp;call&nbsp;last):<br />&nbsp;&nbsp;File&nbsp;&quot;./fuzz_loadjs.py&quot;,&nbsp;line&nbsp;10,&nbsp;in&nbsp;TestOneInput<br />&nbsp;&nbsp;&nbsp;&nbsp;simplejson.loads(original)<br />&nbsp;&nbsp;File&nbsp;&quot;/atheris/simplejson/simplejson/simplejson/__init__.py&quot;,&nbsp;line&nbsp;525,&nbsp;in&nbsp;loads<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;_default_decoder.decode(s)<br />&nbsp;&nbsp;File&nbsp;&quot;/atheris/simplejson/simplejson/simplejson/decoder.py&quot;,&nbsp;line&nbsp;370,&nbsp;in&nbsp;decode<br />&nbsp;&nbsp;&nbsp;&nbsp;obj,&nbsp;end&nbsp;=&nbsp;self.raw_decode(s)<br />&nbsp;&nbsp;File&nbsp;&quot;/atheris/simplejson/simplejson/simplejson/decoder.py&quot;,&nbsp;line&nbsp;400,&nbsp;in&nbsp;raw_decode<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;self.scan_once(s,&nbsp;idx=_w(s,&nbsp;idx).end())<br />&nbsp;&nbsp;File&nbsp;&quot;/atheris/simplejson/simplejson/simplejson/scanner.py&quot;,&nbsp;line&nbsp;79,&nbsp;in&nbsp;scan_once<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;_scan_once(string,&nbsp;idx)<br />&nbsp;&nbsp;File&nbsp;&quot;/atheris/simplejson/simplejson/simplejson/scanner.py&quot;,&nbsp;line&nbsp;42,&nbsp;in&nbsp;_scan_once<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;parse_string(string,&nbsp;idx&nbsp;+&nbsp;1,&nbsp;encoding,&nbsp;strict)<br />&nbsp;&nbsp;File&nbsp;&quot;/atheris/simplejson/simplejson/simplejson/decoder.py&quot;,&nbsp;line&nbsp;130,&nbsp;in&nbsp;py_scanstring<br />&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;=&nbsp;unichr(uni)<br /><br />==295==&nbsp;ERROR:&nbsp;libFuzzer:&nbsp;fuzz&nbsp;target&nbsp;exited<br />SUMMARY:&nbsp;libFuzzer:&nbsp;fuzz&nbsp;target&nbsp;exited<br />MS:&nbsp;1&nbsp;ChangeByte-;&nbsp;base&nbsp;unit:&nbsp;b65693c90be416c52957328f3a4d77064a07f8af<br />0x13,0x22,0x5c,0x75,0x2d,0xb1,0xb9,0xb9,<br />\x13\&quot;\\u-\xb1\xb9\xb9<br />artifact_prefix=&#39;./&#39;;&nbsp;Test&nbsp;unit&nbsp;written&nbsp;to&nbsp;./crash-6a493f66bb10a052ec7397afc6ff8053583928d4<br />Base64:&nbsp;EyJcdS2xubk=</div></div><br /><br />在这种情况下，根据文档中的功能，如果发生错误，loads函数会抛出JSonDecodeError。<br />simplejson.loads文档，可在此处获得。<br /><a href="https://simplejson.readthedocs.io/en/latest/#simplejson.loads">https://simplejson.readthedocs.io/en/latest/#simplejson.loads</a><br /><a href=""><img src="images\1010-1.png" alt="images\1010-1.png" /></a><br /><br />由于我们的模糊器找到了触发附加异常的输入（在本例中为ValueError异常），因此根据simplejson库进行编码的任何库都可能会遇到可靠性问题，因为我们可以在simplejson库中触发异常。</div><div class='page'><h1 class='title level-4'>4_Python_fuzzer_completion_0</h1><br/><h1>Python fuzzer completion 0</h1><br /><h3>Please complete the following missing piece in the fuzzer</h3><br /><a href="http://fuzzer.py/">fuzzer.py</a><br /><div class="codebox"><div class="codebox">import&nbsp;os<br />import&nbsp;sys<br />import&nbsp;atheris<br />import&nbsp;target_to_hit<br /><br />def&nbsp;OurFuzzerEntryFunc(data):<br />&nbsp;&nbsp;&nbsp;&nbsp;fdp&nbsp;=&nbsp;atheris.FuzzedDataProvider(data)<br />&nbsp;&nbsp;&nbsp;&nbsp;target_to_hit.target_func(fdp.ConsumeString())<br /><br />#&nbsp;Modify&nbsp;code&nbsp;below&nbsp;here<br />atheris.Setup(sys.argv,&nbsp;XXX)<br />#&nbsp;Modify&nbsp;code&nbsp;above&nbsp;here<br /><br />atheris.Fuzz<span style="color:#000000;font-weight:400">()</span></div></div></div><div class='page'><h1 class='title level-4'>5_Python_fuzzer_completion_1</h1><br/><h1>Python fuzzer completion 1</h1><br />考虑下面的simple_fuzzer.c文件，其中包含两个函数。 一个函数LLVMFuzzerTestOneInput，其中包含模糊器逻辑，然后是一个函数Attack_me，它是模糊器的目标。<br /><h3>simple_target.py</h3><br /><div class="codebox"><div class="codebox">import&nbsp;os<br />import&nbsp;sys<br /><br />def&nbsp;attack_me(i1,&nbsp;i2,&nbsp;i3):<br />&nbsp;&nbsp;&nbsp;&nbsp;&#39;&#39;&#39;<br />&nbsp;&nbsp;&nbsp;&nbsp;Takes&nbsp;three&nbsp;integers&nbsp;and&nbsp;returns&nbsp;the&nbsp;sum&nbsp;of&nbsp;them&nbsp;all.<br />&nbsp;&nbsp;&nbsp;&nbsp;&#39;&#39;&#39;<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(i1&nbsp;+&nbsp;i2&nbsp;+&nbsp;i3&nbsp;==&nbsp;45):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;raise&nbsp;RuntimeError(&quot;Got&nbsp;the&nbsp;bug!&quot;)<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;i1&nbsp;+&nbsp;i2&nbsp;+&nbsp;i3</div></div><br /><br />请提供使用正确的编译标志编译模糊器的命令，以便我们可以在启用Libfuzzer的情况下编译此代码：<br /><a href="http://fuzzer.py/">fuzzer.py</a><br /><div class="codebox"><div class="codebox">import&nbsp;os<br />import&nbsp;sys<br />import&nbsp;atheris<br />import&nbsp;simple_target<br /><br />def&nbsp;TestOneInput(data):<br />&nbsp;&nbsp;&nbsp;&nbsp;fdp&nbsp;=&nbsp;atheris.FuzzedDataProvider(data)<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Insert&nbsp;code&nbsp;below&nbsp;here<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Insert&nbsp;code&nbsp;above&nbsp;here<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;simple_target.attack_me(i1,&nbsp;i2,&nbsp;i3)<br /><br />atheris.Setup(sys.argv,&nbsp;TestOneInput)<br />atheris.Fuzz()<br /></div></div><br /><br />我们需要将三个整数传递给目标。<br />我们可以使用fdp.ConsumeInt（）生成随机整数。<br />目标的第一个参数将被赋值为i1 = fdp.ConsumeInt（）</div><div class='page'><h1 class='title level-4'>6_Python_fuzzer_completion_1</h1><br/><h1>Python fuzzer completion 2</h1><br />lxml库是Python模块众所周知的且广泛使用的库，它是解析xml数据的一种方式。 下面的模糊器以该库为目标，但缺少一个库。 请完成模糊器：<br /><h3>fuzz_lxml.py</h3><br /><div class="codebox"><div class="codebox">import&nbsp;atheris<br />import&nbsp;sys<br /><br />from&nbsp;lxml&nbsp;import&nbsp;etree&nbsp;as&nbsp;et<br /><br />def&nbsp;TestOneInput(data):<br />&nbsp;&nbsp;fdp&nbsp;=&nbsp;atheris.FuzzedDataProvider(data)<br />&nbsp;&nbsp;U1&nbsp;=&nbsp;fdp.ConsumeUnicode(sys.maxsize)<br />&nbsp;&nbsp;try:<br />&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Please&nbsp;modify&nbsp;below&nbsp;here<br />&nbsp;&nbsp;&nbsp;&nbsp;et.XML(XXX)<br />&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Please&nbsp;modify&nbsp;above&nbsp;here<br />&nbsp;&nbsp;except&nbsp;et.XMLSyntaxError:<br />&nbsp;&nbsp;&nbsp;&nbsp;None<br />&nbsp;&nbsp;return<br /><br />atheris.Setup(sys.argv,&nbsp;TestOneInput,&nbsp;enable_python_coverage=True)<br />atheris.Fuzz<span style="color:#000000;font-weight:400">()</span></div></div><br /><br />我们需要将三个整数传递给目标。<br />我们可以使用fdp.ConsumeInt（）生成随机整数。<br />目标的第一个参数将被赋值为i1 = fdp.ConsumeInt（）</div><div class='page'><h1 class='title level-4'>7_Demonstration of Native Python fuzzing _ ADA Logics</h1><br/>暂略</div><div class='page'><h1 class='title level-4'>8_Fuzzing_native_Python_libraries</h1><br/><h1>Fuzzing native Python libraries</h1><br />在本节中，我们将研究如何通过Atheris模糊器来模糊Native python库。<br /><br /><h2>Native Python扩展样本</h2><br />为了可视化如何模糊Native Python代码，我们首先必须有一个示例应用程序。 考虑以下用C编写的Python扩展的源代码：<br /><h3>native_extension.c</h3><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;Python.h&gt;<br /><br />static&nbsp;PyObject&nbsp;*method_overflow(PyObject&nbsp;*self,&nbsp;PyObject&nbsp;*args)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;arr[10];<br />&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*str,&nbsp;*filename&nbsp;=&nbsp;NULL;<br />&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;bytes_copied&nbsp;=&nbsp;-1;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Parse&nbsp;arguments<br />&nbsp;&nbsp;&nbsp;&nbsp;if(!PyArg_ParseTuple(args,&nbsp;&quot;y*s&quot;,&nbsp;&amp;str,&nbsp;&amp;filename))&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(str&nbsp;!=&nbsp;NULL)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FILE&nbsp;*fp&nbsp;=&nbsp;fopen(filename,&nbsp;&quot;w&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(strcmp(str,&nbsp;&quot;AAAAAAAAA&quot;)&nbsp;==&nbsp;0)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Trigger&nbsp;overflow<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;idx=&nbsp;*(int*)str;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[idx]&nbsp;=&nbsp;&#39;c&#39;;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bytes_copied&nbsp;=&nbsp;fputs(arr,&nbsp;fp);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fclose(fp);<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;PyLong_FromLong(bytes_copied);<br />}<br /><br />static&nbsp;PyMethodDef&nbsp;VulnMethods[]&nbsp;=&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;{&quot;overflow&quot;,&nbsp;method_overflow,&nbsp;METH_VARARGS,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Python&nbsp;interface&nbsp;to&nbsp;expose&nbsp;overflow&quot;},<br />&nbsp;&nbsp;&nbsp;&nbsp;{NULL,&nbsp;NULL,&nbsp;0,&nbsp;NULL}<br />};<br /><br />static&nbsp;struct&nbsp;PyModuleDef&nbsp;vulnmodule&nbsp;=&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;PyModuleDef_HEAD_INIT,<br />&nbsp;&nbsp;&nbsp;&nbsp;&quot;overflow&quot;,<br />&nbsp;&nbsp;&nbsp;&nbsp;&quot;Python&nbsp;interface&nbsp;to&nbsp;expose&nbsp;overflow&quot;,<br />&nbsp;&nbsp;&nbsp;&nbsp;-1,<br />&nbsp;&nbsp;&nbsp;&nbsp;VulnMethods<br />};<br /><br />PyMODINIT_FUNC&nbsp;PyInit_vuln(void)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;PyModule_Create(&amp;vulnmodule);<br />}<br /></div></div><br /><br />上面的源代码公开了一个名为vuln的模块，该模块具有VulnMethods数组定义的名为overflow的函数。 overflow函数的功能的实现由C代码中的method_overflow给出。<br /><br />method_overflow方法包含对PyArg_ParseTuple的调用。 此函数的第二个参数是y * s，这意味着本机函数需要Python提供两个参数，即原始字节数组和常规Python字符串。 我们很快将看到如何从Python调用它。<br /><br />method_overflow函数在arr [idx] =&#39;c&#39;;行上包含堆溢出，因为idx变量被分配为等于传递给该函数的字节数组的前四个字节。 这可以是任意大的值。<br /><br />最后，我们需要一个setup.py文件来进行编译并将其放入Python包中：<br /><a href="http://setup.py/">setup.py</a><br /><div class="codebox"><div class="codebox">from&nbsp;distutils.core&nbsp;import&nbsp;setup,&nbsp;Extension<br /><br />def&nbsp;main():<br />&nbsp;&nbsp;&nbsp;&nbsp;setup(name=&quot;vuln&quot;,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;version=&quot;1.0.0&quot;,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;description=&quot;Python&nbsp;interface&nbsp;for&nbsp;exposing&nbsp;an&nbsp;overflow&quot;,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;author=&quot;David&nbsp;Korczynski&quot;,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;author_email=&quot;david@adalogics.com&quot;,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ext_modules=[Extension(&quot;vuln&quot;,&nbsp;[&quot;native_extension.c&quot;])])<br /><br />if&nbsp;__name__&nbsp;==&nbsp;&quot;__main__&quot;:<br />&nbsp;&nbsp;&nbsp;&nbsp;main<span style="color:#000000;font-weight:400">()</span></div></div><br /><br />现在，我们可以开始编译模块了。 我们要在启用address sanitizer的情况下对其进行编译，我们可以通过设置CFLAGS环境变量来简单地进行此操作。 请注意，情况并非总是如此，因为它取决于setup.py的实现，有时，您可能需要对setup.py进行重大修改才能使其起作用。 最后，我们还需要告诉distutils（setup.py使用的代码）通过clang进行链接，我们可以通过设置环境变量LDSHARED =“ clang -shared”来实现。 现在，我们可以开始编译模块了：<br /><div class="codebox"><div class="codebox">$&nbsp;CC=&quot;/usr/bin/clang&quot;&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;CFLAGS=&quot;-fsanitize=address&quot;&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;LDSHARED=&quot;clang&nbsp;-shared&quot;&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;python3&nbsp;./setup.py&nbsp;install<br />running&nbsp;install<br />running&nbsp;build<br />running&nbsp;build_ext<br />building&nbsp;&#39;vuln&#39;&nbsp;extension<br />/usr/bin/clang&nbsp;-Wno-unused-result&nbsp;-Wsign-compare&nbsp;-DNDEBUG&nbsp;-g&nbsp;-fwrapv&nbsp;-O2&nbsp;-Wall&nbsp;-g&nbsp;-fstack-protector-strong&nbsp;-Wformat&nbsp;-Werror=format-security&nbsp;-g&nbsp;-fwrapv&nbsp;-O2&nbsp;-fsanitize=address&nbsp;-Wdate-time&nbsp;-D_FORTIFY_SOURCE=2&nbsp;-fPIC&nbsp;-I/atheris/venv/include&nbsp;-I/usr/include/python3.8&nbsp;-c&nbsp;native_extension.c&nbsp;-o&nbsp;build/temp.linux-x86_64-3.8/native_extension.o<br />creating&nbsp;build/lib.linux-x86_64-3.8<br />clang&nbsp;-shared&nbsp;-Wl,-Bsymbolic-functions&nbsp;-Wl,-z,relro&nbsp;-g&nbsp;-fwrapv&nbsp;-O2&nbsp;-fsanitize=address&nbsp;-Wdate-time&nbsp;-D_FORTIFY_SOURCE=2&nbsp;build/temp.linux-x86_64-3.8/native_extension.o&nbsp;-o&nbsp;build/lib.linux-x86_64-3.8/vuln.cpython-38-x86_64-linux-gnu.so<br />running&nbsp;install_lib<br />copying&nbsp;build/lib.linux-x86_64-3.8/vuln.cpython-38-x86_64-linux-gnu.so&nbsp;-&gt;&nbsp;/atheris/venv/lib/python3.8/site-packages<br />running&nbsp;install_egg_info<br />Writing&nbsp;/atheris/venv/lib/python3.8/site-packages/vuln-1.0.0.egg-info</div></div><br /><br />在编译输出中，我们可以看到对clang的调用包括标志-fsanitize = address，它向我们展示了native_extension.c是使用address sanitizer编译的。<br /><br /><h2>将Naitve python库作为fuzzing目标</h2><br />现在，我们需要为我们的模块创建一个Python模糊器：<br />native_fuzz.py<br /><div class="codebox"><div class="codebox">import&nbsp;atheris<br />import&nbsp;sys<br />import&nbsp;vuln<br /><br />def&nbsp;TestOneInput(data):<br />&nbsp;&nbsp;vuln.overflow(data,&nbsp;&quot;writex23.txt&quot;)<br />&nbsp;&nbsp;return<br /><br />atheris.Setup(sys.argv,&nbsp;TestOneInput)<br />atheris.Fuzz<span style="color:#000000;font-weight:400">()</span></div></div><br /><br />该模糊器非常简单，只需将Atheris的随机数据作为第一个参数传递给vuln.overflow函数即可。 溢出函数的第二个参数是我们要将数据写入其中的文件的名称。<br /><br />最后，我们可以针对测试模块运行Python模糊测试器：<br /><div class="codebox"><div class="codebox">$&nbsp;LD_PRELOAD=&quot;$(python&nbsp;-c&nbsp;&quot;import&nbsp;atheris;&nbsp;import&nbsp;os;&nbsp;print(os.path.dirname(atheris.path()))&quot;)/asan_with_fuzzer.so&quot;&nbsp;python3&nbsp;./native_fuzz.py&nbsp;-detect_leaks=0<br />INFO:&nbsp;Configured&nbsp;for&nbsp;Python&nbsp;tracing&nbsp;with&nbsp;opcodes.<br />INFO:&nbsp;Seed:&nbsp;2871916214<br />INFO:&nbsp;Loaded&nbsp;2&nbsp;modules&nbsp;&nbsp;&nbsp;(1024&nbsp;inline&nbsp;8-bit&nbsp;counters):&nbsp;512&nbsp;[0x615000001700,&nbsp;0x615000001900),&nbsp;512&nbsp;[0x615000001980,&nbsp;0x615000001b80),<br />INFO:&nbsp;Loaded&nbsp;2&nbsp;PC&nbsp;tables&nbsp;(1024&nbsp;PCs):&nbsp;512&nbsp;[0x62500001b900,0x62500001d900),&nbsp;512&nbsp;[0x62500001e100,0x625000020100),<br />INFO:&nbsp;-max_len&nbsp;is&nbsp;not&nbsp;provided;&nbsp;libFuzzer&nbsp;will&nbsp;not&nbsp;generate&nbsp;inputs&nbsp;larger&nbsp;than&nbsp;4096&nbsp;bytes<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW_PY_FUNC[1/2]:&nbsp;TestOneInput()&nbsp;./native_fuzz.py:7<br />INFO:&nbsp;A&nbsp;corpus&nbsp;is&nbsp;not&nbsp;provided,&nbsp;starting&nbsp;from&nbsp;an&nbsp;empty&nbsp;corpus<br />#2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;INITED&nbsp;cov:&nbsp;20&nbsp;ft:&nbsp;20&nbsp;corp:&nbsp;1/1b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;37Mb<br />AddressSanitizer:DEADLYSIGNAL<br />=================================================================<br />==325==ERROR:&nbsp;AddressSanitizer:&nbsp;SEGV&nbsp;on&nbsp;unknown&nbsp;address&nbsp;0x7ffe4ed7b8e1&nbsp;(pc&nbsp;0x7fa4bd3663ec&nbsp;bp&nbsp;0x7ffe0d9678a0&nbsp;sp&nbsp;0x7ffe0d967780&nbsp;T0)<br />==325==The&nbsp;signal&nbsp;is&nbsp;caused&nbsp;by&nbsp;a&nbsp;WRITE&nbsp;memory&nbsp;access.<br />&nbsp;&nbsp;&nbsp;&nbsp;#0&nbsp;0x7fa4bd3663eb&nbsp;in&nbsp;method_overflow&nbsp;/atheris/native_example/native_extension.c:18:22<br />&nbsp;&nbsp;&nbsp;&nbsp;#1&nbsp;0x5f42e9&nbsp;in&nbsp;PyCFunction_Call&nbsp;(/usr/bin/python3.8+0x5f42e9)<br />&nbsp;&nbsp;&nbsp;&nbsp;#2&nbsp;0x5f46d5&nbsp;in&nbsp;_PyObject_MakeTpCall&nbsp;(/usr/bin/python3.8+0x5f46d5)<br />&nbsp;&nbsp;&nbsp;&nbsp;#3&nbsp;0x5724a3&nbsp;in&nbsp;_PyEval_EvalFrameDefault&nbsp;(/usr/bin/python3.8+0x5724a3)<br />&nbsp;&nbsp;&nbsp;&nbsp;#4&nbsp;0x5f7145&nbsp;in&nbsp;_PyFunction_Vectorcall&nbsp;(/usr/bin/python3.8+0x5f7145)<br />&nbsp;&nbsp;&nbsp;&nbsp;#5&nbsp;0x5f6e26&nbsp;in&nbsp;PyObject_CallObject&nbsp;(/usr/bin/python3.8+0x5f6e26)<br />&nbsp;&nbsp;&nbsp;&nbsp;#6&nbsp;0x7fa4bd38bfcf&nbsp;in&nbsp;pybind11::detail::simple_collector&lt;(pybind11::return_value_policy)1&gt;::call(_object*)&nbsp;const&nbsp;/tmp/pip-install-ncs7u8_w/atheris/.eggs/pybind11-2.6.1-py3.8.egg/pybind11/include/pybind1<br />1/cast.h:2032:47<br />&nbsp;&nbsp;&nbsp;&nbsp;#7&nbsp;0x7fa4bd38bfcf&nbsp;in&nbsp;pybind11::object&nbsp;pybind11::detail::object_api::operator()&lt;(pybind11::return_value_policy)1,&nbsp;pybind11::bytes&gt;(pybind11::bytes&amp;&amp;)&nbsp;const&nbsp;/tmp/pip-install-ncs7u8_w/at<br />heris/.eggs/pybind11-2.6.1-py3.8.egg/pybind11/include/pybind11/cast.h:2187:95<br />&nbsp;&nbsp;&nbsp;&nbsp;#8&nbsp;0x7fa4bd38bfcf&nbsp;in&nbsp;pybind11::detail::type_caster,&nbsp;void&gt;::load(pybind11::handle,&nbsp;bool)::func_wrapper::operator()(pybind11::bytes)&nbsp;const&nbsp;/tmp/pip-install-ncs7u8_w/<br />atheris/.eggs/pybind11-2.6.1-py3.8.egg/pybind11/include/pybind11/functional.h:77:24<br />&nbsp;&nbsp;&nbsp;&nbsp;#9&nbsp;0x7fa4bd38bfcf&nbsp;in&nbsp;std::_Function_handler,&nbsp;void&gt;::load(pybind11::handle,&nbsp;bool)::func_wrapper&gt;::_M_invoke(st<br />d::_Any_data&nbsp;const&amp;,&nbsp;pybind11::bytes&amp;&amp;)&nbsp;/usr/include/c++/9/bits/std_function.h:300:37<br />&nbsp;&nbsp;&nbsp;&nbsp;#10&nbsp;0x7fa4bd38efab&nbsp;in&nbsp;std::function::operator()(pybind11::bytes)&nbsp;const&nbsp;/usr/include/c++/9/bits/std_function.h:688:14<br />&nbsp;&nbsp;&nbsp;&nbsp;#11&nbsp;0x7fa4bd38efab&nbsp;in&nbsp;atheris::TestOneInput(unsigned&nbsp;char&nbsp;const*,&nbsp;unsigned&nbsp;long)&nbsp;/tmp/pip-install-ncs7u8_w/atheris/libfuzzer.cc:148:26<br />&nbsp;&nbsp;&nbsp;&nbsp;#12&nbsp;0x7fa4c0a3231a&nbsp;in&nbsp;fuzzer::Fuzzer::ExecuteCallback(unsigned&nbsp;char&nbsp;const*,&nbsp;unsigned&nbsp;long)&nbsp;(/atheris/venv/lib/python3.8/site-packages/asan_with_fuzzer.so+0x3a31a)<br />&nbsp;&nbsp;&nbsp;&nbsp;#13&nbsp;0x7fa4c0a31ae5&nbsp;in&nbsp;fuzzer::Fuzzer::RunOne(unsigned&nbsp;char&nbsp;const*,&nbsp;unsigned&nbsp;long,&nbsp;bool,&nbsp;fuzzer::InputInfo*,&nbsp;bool*)&nbsp;(/atheris/venv/lib/python3.8/site-packages/asan_with_fuzzer.so+0x39ae5)<br />&nbsp;&nbsp;&nbsp;&nbsp;#14&nbsp;0x7fa4c0a33b09&nbsp;in&nbsp;fuzzer::Fuzzer::MutateAndTestOne()&nbsp;(/atheris/venv/lib/python3.8/site-packages/asan_with_fuzzer.so+0x3bb09)<br />&nbsp;&nbsp;&nbsp;&nbsp;#15&nbsp;0x7fa4c0a347e5&nbsp;in&nbsp;fuzzer::Fuzzer::Loop(std::vector,&nbsp;std::allocator&nbsp;&gt;,&nbsp;fuzzer::fuzzer_allocator,&nbsp;std::allocator&nbsp;&gt;&nbsp;&gt;&nbsp;&gt;&nbsp;const&amp;)&nbsp;(/atheris/venv/lib/python3.8/site-packages/asan_with_fuzzer.so+0x3c7e5)<br />&nbsp;&nbsp;&nbsp;&nbsp;#16&nbsp;0x7fa4c0a29178&nbsp;in&nbsp;fuzzer::FuzzerDriver(int*,&nbsp;char***,&nbsp;int&nbsp;(*)(unsigned&nbsp;char&nbsp;const*,&nbsp;unsigned&nbsp;long))&nbsp;(/atheris/venv/lib/python3.8/site-packages/asan_with_fuzzer.so+0x31178)<br />&nbsp;&nbsp;&nbsp;&nbsp;#17&nbsp;0x7fa4c0a4c864&nbsp;in&nbsp;LLVMFuzzerRunDriver&nbsp;(/atheris/venv/lib/python3.8/site-packages/asan_with_fuzzer.so+0x54864)<br />&nbsp;&nbsp;&nbsp;&nbsp;#18&nbsp;0x7fa4bd38f323&nbsp;in&nbsp;atheris::Fuzz()&nbsp;/tmp/pip-install-ncs7u8_w/atheris/libfuzzer.cc:185:7<br />&nbsp;&nbsp;&nbsp;&nbsp;#19&nbsp;0x7fa4bd37892b&nbsp;in&nbsp;void&nbsp;pybind11::detail::argument_loader&lt;&gt;::call_impl(void&nbsp;(*&amp;)(),&nbsp;std::integer_sequence,&nbsp;pybind11::detail::void_type&amp;<br />&amp;)&nbsp;&amp;&amp;&nbsp;/tmp/pip-install-ncs7u8_w/atheris/.eggs/pybind11-2.6.1-py3.8.egg/pybind11/include/pybind11/cast.h:2010:37<br />&nbsp;&nbsp;&nbsp;&nbsp;#20&nbsp;0x7fa4bd37892b&nbsp;in&nbsp;_ZNO8pybind116detail15argument_loaderIJEE4callIvNS0_9void_typeERPFvvEEENSt9enable_ifIXsrSt7is_voidIT_E5valueES4_E4typeEOT1_&nbsp;/tmp/pip-install-ncs7u8_w/atheris/.eggs/pybind11-2.6.1-<br />py3.8.egg/pybind11/include/pybind11/cast.h:1987:9<br />&nbsp;&nbsp;&nbsp;&nbsp;#21&nbsp;0x7fa4bd37892b&nbsp;in&nbsp;void&nbsp;pybind11::cpp_function::initialize(void&nbsp;(*&amp;)(),&nbsp;void&nbsp;(*)(),&nbsp;pybind11::name&nbsp;const&amp;,&nbsp;pybind11::scope&nbsp;cons<br />t&amp;,&nbsp;pybind11::sibling&nbsp;const&amp;)::&#39;lambda1&#39;(pybind11::detail::function_call&amp;)::operator()(pybind11::detail::function_call&amp;)&nbsp;const&nbsp;/tmp/pip-install-ncs7u8_w/atheris/.eggs/pybind11-2.6.1-py3.8.egg/pybind11/incl<br />ude/pybind11/pybind11.h:183:43<br />&nbsp;&nbsp;&nbsp;&nbsp;#22&nbsp;0x7fa4bd37892b&nbsp;in&nbsp;void&nbsp;pybind11::cpp_function::initialize(void&nbsp;(*&amp;)(),&nbsp;void&nbsp;(*)(),&nbsp;pybind11::name&nbsp;const&amp;,&nbsp;pybind11::scope&nbsp;cons<br />t&amp;,&nbsp;pybind11::sibling&nbsp;const&amp;)::&#39;lambda1&#39;(pybind11::detail::function_call&amp;)::_FUN(pybind11::detail::function_call&amp;)&nbsp;/tmp/pip-install-ncs7u8_w/atheris/.eggs/pybind11-2.6.1-py3.8.egg/pybind11/include/pybind11<br />/pybind11.h:161:21<br />&nbsp;&nbsp;&nbsp;&nbsp;#23&nbsp;0x7fa4bd38583a&nbsp;in&nbsp;pybind11::cpp_function::dispatcher(_object*,&nbsp;_object*,&nbsp;_object*)&nbsp;/tmp/pip-install-ncs7u8_w/atheris/.eggs/pybind11-2.6.1-py3.8.egg/pybind11/include/pybind11/pybind11.h:717:35<br />&nbsp;&nbsp;&nbsp;&nbsp;#24&nbsp;0x5f4248&nbsp;in&nbsp;PyCFunction_Call&nbsp;(/usr/bin/python3.8+0x5f4248)<br />&nbsp;&nbsp;&nbsp;&nbsp;#25&nbsp;0x5f46d5&nbsp;in&nbsp;_PyObject_MakeTpCall&nbsp;(/usr/bin/python3.8+0x5f46d5)<br />&nbsp;&nbsp;&nbsp;&nbsp;#26&nbsp;0x5724a3&nbsp;in&nbsp;_PyEval_EvalFrameDefault&nbsp;(/usr/bin/python3.8+0x5724a3)<br />&nbsp;&nbsp;&nbsp;&nbsp;#27&nbsp;0x569559&nbsp;in&nbsp;_PyEval_EvalCodeWithName&nbsp;(/usr/bin/python3.8+0x569559)<br />&nbsp;&nbsp;&nbsp;&nbsp;#28&nbsp;0x68c4a6&nbsp;in&nbsp;PyEval_EvalCode&nbsp;(/usr/bin/python3.8+0x68c4a6)<br />&nbsp;&nbsp;&nbsp;&nbsp;#29&nbsp;0x67bc90&nbsp;&nbsp;(/usr/bin/python3.8+0x67bc90)<br />&nbsp;&nbsp;&nbsp;&nbsp;#30&nbsp;0x67bd0e&nbsp;&nbsp;(/usr/bin/python3.8+0x67bd0e)<br />&nbsp;&nbsp;&nbsp;&nbsp;#31&nbsp;0x67bdca&nbsp;in&nbsp;PyRun_FileExFlags&nbsp;(/usr/bin/python3.8+0x67bdca)<br />&nbsp;&nbsp;&nbsp;&nbsp;#32&nbsp;0x67de4d&nbsp;in&nbsp;PyRun_SimpleFileExFlags&nbsp;(/usr/bin/python3.8+0x67de4d)<br />&nbsp;&nbsp;&nbsp;&nbsp;#33&nbsp;0x6b6031&nbsp;in&nbsp;Py_RunMain&nbsp;(/usr/bin/python3.8+0x6b6031)<br />&nbsp;&nbsp;&nbsp;&nbsp;#34&nbsp;0x6b63bc&nbsp;in&nbsp;Py_BytesMain&nbsp;(/usr/bin/python3.8+0x6b63bc)<br />&nbsp;&nbsp;&nbsp;&nbsp;#35&nbsp;0x7fa4c08260b2&nbsp;in&nbsp;__libc_start_main&nbsp;(/lib/x86_64-linux-gnu/libc.so.6+0x270b2)<br />&nbsp;&nbsp;&nbsp;&nbsp;#36&nbsp;0x5fa4dd&nbsp;in&nbsp;_start&nbsp;(/usr/bin/python3.8+0x5fa4dd)<br /><br />AddressSanitizer&nbsp;can&nbsp;not&nbsp;provide&nbsp;additional&nbsp;info.<br />SUMMARY:&nbsp;AddressSanitizer:&nbsp;SEGV&nbsp;/atheris/native_example/native_extension.c:18:22&nbsp;in&nbsp;method_overflow<br />==325==ABORTING<br />MS:&nbsp;2&nbsp;CMP-CMP-&nbsp;DE:&nbsp;&quot;\x00\x00\x00\x00\x00\x00\x00\x00&quot;-&quot;AAAAAAAAA&quot;-;&nbsp;base&nbsp;unit:&nbsp;adc83b19e793491b1c6ea0fd8b46cd9f32e592fc<br />0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,<br />AAAAAAAAA<br />artifact_prefix=&#39;./&#39;;&nbsp;Test&nbsp;unit&nbsp;written&nbsp;to&nbsp;./crash-1cbbd7d768f77d4d3f24de43238979aa9fa1cd2f<br />Base64:&nbsp;QUFBQUFBQUFB</div></div><br /><br />快速调查崩溃会向我们揭示触发内存损坏问题的内容：<br /><div class="codebox"><div class="codebox"><br />$&nbsp;hexdump&nbsp;-C&nbsp;./crash-1cbbd7d768f77d4d3f24de43238979aa9fa1cd2f&nbsp;<br />00000000&nbsp;&nbsp;41&nbsp;41&nbsp;41&nbsp;41&nbsp;41&nbsp;41&nbsp;41&nbsp;41&nbsp;&nbsp;41&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|AAAAAAAAA|<br />00000009</div></div></div><div class='page'><h1 class='title level-4'>9_Targetting_simplejson_native_code</h1><br/><h1>将simplejson Native代码作为目标</h1><br /><br />在前面的使simplejson模糊化的示例中，我们以Native Python代码为目标。 但是，simplejson也带有本机扩展，即在simplejson / _speedups.c文件中。 现在，我们将继续我们的示例，并研究如何确保在启用address sanitizer的情况下也对simplejson的这一部分进行模糊处理。<br />以前，当我们对simplejson进行模糊处理时，我们只是从Github中克隆了存储库，并直接从其源代码树中模糊了源代码。 但是，为了模糊Native代码，我们必须编译该代码，最简单的方法是像在前面的本机代码示例中一样进行操作，即通过运行setup.py安装代码。<br /><br />为了构建simplejson项目，我们与之前类似地设置CC，CFLAGS和LDSHARED标志，即：<br /><div class="codebox"><div class="codebox">$&nbsp;git&nbsp;clone&nbsp;https://github.com/simplejson/simplejson<br />$&nbsp;cd&nbsp;simplejson<br />$&nbsp;CC=&quot;/usr/bin/clang&quot;&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;CFLAGS=&quot;-fsanitize=address&quot;&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;LDSHARED=&quot;clang&nbsp;-shared&quot;&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;python3&nbsp;./setup.py&nbsp;install<br />running&nbsp;install&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />running&nbsp;bdist_egg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />running&nbsp;egg_info&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />creating&nbsp;simplejson.egg-info&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />writing&nbsp;simplejson.egg-info/PKG-INFO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />writing&nbsp;dependency_links&nbsp;to&nbsp;simplejson.egg-info/dependency_links.txt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />writing&nbsp;top-level&nbsp;names&nbsp;to&nbsp;simplejson.egg-info/top_level.txt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />writing&nbsp;manifest&nbsp;file&nbsp;&#39;simplejson.egg-info/SOURCES.txt&#39;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />reading&nbsp;manifest&nbsp;file&nbsp;&#39;simplejson.egg-info/SOURCES.txt&#39;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />reading&nbsp;manifest&nbsp;template&nbsp;&#39;MANIFEST.in&#39;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />writing&nbsp;manifest&nbsp;file&nbsp;&#39;simplejson.egg-info/SOURCES.txt&#39;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />installing&nbsp;library&nbsp;code&nbsp;to&nbsp;build/bdist.linux-x86_64/egg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />running&nbsp;install_lib&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />running&nbsp;build_py&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />creating&nbsp;build&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />creating&nbsp;build/lib.linux-x86_64-3.8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />creating&nbsp;build/lib.linux-x86_64-3.8/simplejson&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />copying&nbsp;simplejson/scanner.py&nbsp;-&gt;&nbsp;build/lib.linux-x86_64-3.8/simplejson&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />copying&nbsp;simplejson/ordered_dict.py&nbsp;-&gt;&nbsp;build/lib.linux-x86_64-3.8/simplejson&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />copying&nbsp;simplejson/__init__.py&nbsp;-&gt;&nbsp;build/lib.linux-x86_64-3.8/simplejson&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />copying&nbsp;simplejson/tool.py&nbsp;-&gt;&nbsp;build/lib.linux-x86_64-3.8/simplejson&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />copying&nbsp;simplejson/compat.py&nbsp;-&gt;&nbsp;build/lib.linux-x86_64-3.8/simplejson&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />copying&nbsp;simplejson/raw_json.py&nbsp;-&gt;&nbsp;build/lib.linux-x86_64-3.8/simplejson&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />copying&nbsp;simplejson/encoder.py&nbsp;-&gt;&nbsp;build/lib.linux-x86_64-3.8/simplejson&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />copying&nbsp;simplejson/errors.py&nbsp;-&gt;&nbsp;build/lib.linux-x86_64-3.8/simplejson&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />copying&nbsp;simplejson/decoder.py&nbsp;-&gt;&nbsp;build/lib.linux-x86_64-3.8/simplejson&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />creating&nbsp;build/lib.linux-x86_64-3.8/simplejson/tests&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />copying&nbsp;simplejson/tests/test_indent.py&nbsp;-&gt;&nbsp;build/lib.linux-x86_64-3.8/simplejson/tests<br />copying&nbsp;simplejson/tests/test_encode_for_html.py&nbsp;-&gt;&nbsp;build/lib.linux-x86_64-3.8/simplejson/tests<br />copying&nbsp;simplejson/tests/test_pass2.py&nbsp;-&gt;&nbsp;build/lib.linux-x86_64-3.8/simplejson/tests&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />copying&nbsp;simplejson/tests/test_namedtuple.py&nbsp;-&gt;&nbsp;build/lib.linux-x86_64-3.8/simplejson/tests&nbsp;<br />copying&nbsp;simplejson/tests/test_separators.py&nbsp;-&gt;&nbsp;build/lib.linux-x86_64-3.8/simplejson/tests&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />copying&nbsp;simplejson/tests/test_iterable.py&nbsp;-&gt;&nbsp;build/lib.linux-x86_64-3.8/simplejson/tests&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />copying&nbsp;simplejson/tests/test_pass3.py&nbsp;-&gt;&nbsp;build/lib.linux-x86_64-3.8/simplejson/tests&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />copying&nbsp;simplejson/tests/test_bitsize_int_as_string.py&nbsp;-&gt;&nbsp;build/lib.linux-x86_64-3.8/simplejson/tests&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />copying&nbsp;simplejson/tests/__init__.py&nbsp;-&gt;&nbsp;build/lib.linux-x86_64-3.8/simplejson/tests&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />copying&nbsp;simplejson/tests/test_tuple.py&nbsp;-&gt;&nbsp;build/lib.linux-x86_64-3.8/simplejson/tests&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />copying&nbsp;simplejson/tests/test_for_json.py&nbsp;-&gt;&nbsp;build/lib.linux-x86_64-3.8/simplejson/tests&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />copying&nbsp;simplejson/tests/test_decode.py&nbsp;-&gt;&nbsp;build/lib.linux-x86_64-3.8/simplejson/tests&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />copying&nbsp;simplejson/tests/test_tool.py&nbsp;-&gt;&nbsp;build/lib.linux-x86_64-3.8/simplejson/tests&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />copying&nbsp;simplejson/tests/test_float.py&nbsp;-&gt;&nbsp;build/lib.linux-x86_64-3.8/simplejson/tests&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />copying&nbsp;simplejson/tests/test_str_subclass.py&nbsp;-&gt;&nbsp;build/lib.linux-x86_64-3.8/simplejson/tests&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />copying&nbsp;simplejson/tests/test_default.py&nbsp;-&gt;&nbsp;build/lib.linux-x86_64-3.8/simplejson/tests&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />copying&nbsp;simplejson/tests/test_errors.py&nbsp;-&gt;&nbsp;build/lib.linux-x86_64-3.8/simplejson/tests&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />copying&nbsp;simplejson/tests/test_encode_basestring_ascii.py&nbsp;-&gt;&nbsp;build/lib.linux-x86_64-3.8/simplejson/tests<br />copying&nbsp;simplejson/tests/test_bigint_as_string.py&nbsp;-&gt;&nbsp;build/lib.linux-x86_64-3.8/simplejson/tests&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />copying&nbsp;simplejson/tests/test_check_circular.py&nbsp;-&gt;&nbsp;build/lib.linux-x86_64-3.8/simplejson/tests&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />copying&nbsp;simplejson/tests/test_fail.py&nbsp;-&gt;&nbsp;build/lib.linux-x86_64-3.8/simplejson/tests&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />copying&nbsp;simplejson/tests/test_pass1.py&nbsp;-&gt;&nbsp;build/lib.linux-x86_64-3.8/simplejson/tests&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />copying&nbsp;simplejson/tests/test_recursion.py&nbsp;-&gt;&nbsp;build/lib.linux-x86_64-3.8/simplejson/tests&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />copying&nbsp;simplejson/tests/test_scanstring.py&nbsp;-&gt;&nbsp;build/lib.linux-x86_64-3.8/simplejson/tests&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />copying&nbsp;simplejson/tests/test_raw_json.py&nbsp;-&gt;&nbsp;build/lib.linux-x86_64-3.8/simplejson/tests&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />copying&nbsp;simplejson/tests/test_decimal.py&nbsp;-&gt;&nbsp;build/lib.linux-x86_64-3.8/simplejson/tests&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />copying&nbsp;simplejson/tests/test_item_sort_key.py&nbsp;-&gt;&nbsp;build/lib.linux-x86_64-3.8/simplejson/tests&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />copying&nbsp;simplejson/tests/test_dump.py&nbsp;-&gt;&nbsp;build/lib.linux-x86_64-3.8/simplejson/tests&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />copying&nbsp;simplejson/tests/test_speedups.py&nbsp;-&gt;&nbsp;build/lib.linux-x86_64-3.8/simplejson/tests&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />copying&nbsp;simplejson/tests/test_unicode.py&nbsp;-&gt;&nbsp;build/lib.linux-x86_64-3.8/simplejson/tests&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />copying&nbsp;simplejson/tests/test_subclass.py&nbsp;-&gt;&nbsp;build/lib.linux-x86_64-3.8/simplejson/tests&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />running&nbsp;build_ext&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />building&nbsp;&#39;simplejson._speedups&#39;&nbsp;extension&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />creating&nbsp;build/temp.linux-x86_64-3.8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />creating&nbsp;build/temp.linux-x86_64-3.8/simplejson&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />/usr/bin/clang&nbsp;-Wno-unused-result&nbsp;-Wsign-compare&nbsp;-DNDEBUG&nbsp;-g&nbsp;-fwrapv&nbsp;-O2&nbsp;-Wall&nbsp;-g&nbsp;-fstack-protector-strong&nbsp;-Wformat&nbsp;-Werror=format-security&nbsp;-g&nbsp;-fwrapv&nbsp;-O2&nbsp;-fsanitize=address&nbsp;-Wdate-time&nbsp;-D_FORTIFY_SOURCE=2&nbsp;-fPIC&nbsp;-I/atheris/venv/inlude&nbsp;-I/usr/include/python3.8&nbsp;-c&nbsp;simplejson/_speedups.c&nbsp;-o&nbsp;build/temp.linux-x86_64-3.8/simplejson/_speedups.o<br />clang&nbsp;-shared&nbsp;-Wl,-Bsymbolic-functions&nbsp;-Wl,-z,relro&nbsp;-g&nbsp;-fwrapv&nbsp;-O2&nbsp;-fsanitize=address&nbsp;-Wdate-time&nbsp;-D_FORTIFY_SOURCE=2&nbsp;build/temp.linux-x86_64-3.8/simplejson/_speedups.o&nbsp;-o&nbsp;build/lib.linux-x86_64-3.8/simplejson/_speedups.cpython-38-x86_64-linux-gnu.so&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />creating&nbsp;build/bdist.linux-x86_64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />creating&nbsp;build/bdist.linux-x86_64/egg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />creating&nbsp;build/bdist.linux-x86_64/egg/simplejson&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />copying&nbsp;build/lib.linux-x86_64-3.8/simplejson/scanner.py&nbsp;-&gt;&nbsp;build/bdist.linux-x86_64/egg/simplejson<br />copying&nbsp;build/lib.linux-x86_64-3.8/simplejson/_speedups.cpython-38-x86_64-linux-gnu.so&nbsp;-&gt;&nbsp;build/bdist.linux-x86_64/egg/simplejson<br /><br />...<br />...<br /><br />byte-compiling&nbsp;build/bdist.linux-x86_64/egg/simplejson/tests/test_item_sort_key.py&nbsp;to&nbsp;test_item_sort_key.cpython-38.pyc<br />byte-compiling&nbsp;build/bdist.linux-x86_64/egg/simplejson/tests/test_dump.py&nbsp;to&nbsp;test_dump.cpython-38.pyc<br />byte-compiling&nbsp;build/bdist.linux-x86_64/egg/simplejson/tests/test_speedups.py&nbsp;to&nbsp;test_speedups.cpython-38.pyc<br />byte-compiling&nbsp;build/bdist.linux-x86_64/egg/simplejson/tests/test_unicode.py&nbsp;to&nbsp;test_unicode.cpython-38.pyc<br />byte-compiling&nbsp;build/bdist.linux-x86_64/egg/simplejson/tests/test_subclass.py&nbsp;to&nbsp;test_subclass.cpython-38.pyc<br />byte-compiling&nbsp;build/bdist.linux-x86_64/egg/simplejson/errors.py&nbsp;to&nbsp;errors.cpython-38.pyc<br />byte-compiling&nbsp;build/bdist.linux-x86_64/egg/simplejson/decoder.py&nbsp;to&nbsp;decoder.cpython-38.pyc<br />creating&nbsp;stub&nbsp;loader&nbsp;for&nbsp;simplejson/_speedups.cpython-38-x86_64-linux-gnu.so<br />byte-compiling&nbsp;build/bdist.linux-x86_64/egg/simplejson/_speedups.py&nbsp;to&nbsp;_speedups.cpython-38.pyc<br />creating&nbsp;build/bdist.linux-x86_64/egg/EGG-INFO<br />copying&nbsp;simplejson.egg-info/PKG-INFO&nbsp;-&gt;&nbsp;build/bdist.linux-x86_64/egg/EGG-INFO<br />copying&nbsp;simplejson.egg-info/SOURCES.txt&nbsp;-&gt;&nbsp;build/bdist.linux-x86_64/egg/EGG-INFO<br />copying&nbsp;simplejson.egg-info/dependency_links.txt&nbsp;-&gt;&nbsp;build/bdist.linux-x86_64/egg/EGG-INFO<br />copying&nbsp;simplejson.egg-info/top_level.txt&nbsp;-&gt;&nbsp;build/bdist.linux-x86_64/egg/EGG-INFO<br />writing&nbsp;build/bdist.linux-x86_64/egg/EGG-INFO/native_libs.txt<br />zip_safe&nbsp;flag&nbsp;not&nbsp;set;&nbsp;analyzing&nbsp;archive&nbsp;contents...<br />simplejson.__pycache__._speedups.cpython-38:&nbsp;module&nbsp;references&nbsp;__file__<br />simplejson.tests.__pycache__.__init__.cpython-38:&nbsp;module&nbsp;references&nbsp;__file__<br />creating&nbsp;dist<br />creating&nbsp;&#39;dist/simplejson-3.17.2-py3.8-linux-x86_64.egg&#39;&nbsp;and&nbsp;adding&nbsp;&#39;build/bdist.linux-x86_64/egg&#39;&nbsp;to&nbsp;it<br />removing&nbsp;&#39;build/bdist.linux-x86_64/egg&#39;&nbsp;(and&nbsp;everything&nbsp;under&nbsp;it)<br />Processing&nbsp;simplejson-3.17.2-py3.8-linux-x86_64.egg<br />creating&nbsp;/atheris/venv/lib/python3.8/site-packages/simplejson-3.17.2-py3.8-linux-x86_64.egg<br />Extracting&nbsp;simplejson-3.17.2-py3.8-linux-x86_64.egg&nbsp;to&nbsp;/atheris/venv/lib/python3.8/site-packages<br />Adding&nbsp;simplejson&nbsp;3.17.2&nbsp;to&nbsp;easy-install.pth&nbsp;file<br /><br />Installed&nbsp;/atheris/venv/lib/python3.8/site-packages/simplejson-3.17.2-py3.8-linux-x86_64.egg<br />Processing&nbsp;dependencies&nbsp;for&nbsp;simplejson==3.17.2<br />Finished&nbsp;processing&nbsp;dependencies&nbsp;for&nbsp;simplejson==3.17.2</div></div><br /><br />编译的重要部分是几行，其中看到了使用sanitizer编译的_speedups.c文件并制成了动态库：<br /><div class="codebox"><div class="codebox">/usr/bin/clang&nbsp;-Wno-unused-result&nbsp;-Wsign-compare&nbsp;-DNDEBUG&nbsp;-g&nbsp;-fwrapv&nbsp;-O2&nbsp;-Wall&nbsp;-g&nbsp;-fstack-protector-strong&nbsp;-Wformat&nbsp;-Werror=format-security&nbsp;-g&nbsp;-fwrapv&nbsp;-O2&nbsp;-fsanitize=address&nbsp;-Wdate-time&nbsp;-D_FORTIFY_SOURCE=2&nbsp;-fPIC&nbsp;-I/atheris/venv/inlude&nbsp;-I/usr/include/python3.8&nbsp;-c&nbsp;simplejson/_speedups.c&nbsp;-o&nbsp;build/temp.linux-x86_64-3.8/simplejson/_speedups.o<br />clang&nbsp;-shared&nbsp;-Wl,-Bsymbolic-functions&nbsp;-Wl,-z,relro&nbsp;-g&nbsp;-fwrapv&nbsp;-O2&nbsp;-fsanitize=address&nbsp;-Wdate-time&nbsp;-D_FORTIFY_SOURCE=2&nbsp;build/temp.linux-x86_64-3.8/simplejson/_speedups.o&nbsp;-o&nbsp;build/lib.linux-x86_64-3.8/simplejson/_speedups.cpython-38-x86_64-linux-gnu.so</div></div><br /><br />现在，使用address sanitizer编译的本机代码位于我们的Python软件包目录中的_speedups.cpython-38-x86_64-linux-gnu.so文件中。<br /><br /><h2>验证我们使用sanitizer进行了编译</h2><br />为了验证我们使用sanitizer进行了编译，我们可以尝试加载模块而不预加载ASan库。 为此，我们在代码顶部修改/atheris/venv/lib/python3.8/site-packages/simplejson-3.17.2-py3.8-linux-x86_64.egg/simplejson/encoder.py：<div class="codebox"><div class="codebox">def&nbsp;_import_speedups():<br />&nbsp;&nbsp;&nbsp;&nbsp;try:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from&nbsp;.&nbsp;import&nbsp;_speedups<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;_speedups.encode_basestring_ascii,&nbsp;_speedups.make_encoder<br />&nbsp;&nbsp;&nbsp;&nbsp;except&nbsp;ImportError:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;None,&nbsp;None</div></div><br /><br />成为：<br /><div class="codebox"><div class="codebox">def&nbsp;_import_speedups():<br />&nbsp;&nbsp;&nbsp;&nbsp;#try:<br />&nbsp;&nbsp;&nbsp;&nbsp;from&nbsp;.&nbsp;import&nbsp;_speedups<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;_speedups.encode_basestring_ascii,&nbsp;_speedups.make_encoder<br />&nbsp;&nbsp;&nbsp;&nbsp;#except&nbsp;ImportError:<br />&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;None,&nbsp;None</div></div><br /><br />现在，当我们打开Python并加载simplejson模块时，我们看到：<br /><div class="codebox"><div class="codebox">$&nbsp;python<br />Python&nbsp;3.8.5&nbsp;(default,&nbsp;Jul&nbsp;28&nbsp;2020,&nbsp;12:59:40)&nbsp;<br />[GCC&nbsp;9.3.0]&nbsp;on&nbsp;linux<br />Type&nbsp;&quot;help&quot;,&nbsp;&quot;copyright&quot;,&nbsp;&quot;credits&quot;&nbsp;or&nbsp;&quot;license&quot;&nbsp;for&nbsp;more&nbsp;information.<br />&gt;&gt;&gt;&nbsp;import&nbsp;simplejson<br />Traceback&nbsp;(most&nbsp;recent&nbsp;call&nbsp;last):<br />&nbsp;&nbsp;File&nbsp;&quot;&quot;,&nbsp;line&nbsp;1,&nbsp;in&nbsp;<br />&nbsp;&nbsp;File&nbsp;&quot;/atheris/venv/lib/python3.8/site-packages/simplejson-3.17.2-py3.8-linux-x86_64.egg/simplejson/__init__.py&quot;,&nbsp;line&nbsp;135,&nbsp;in&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;from&nbsp;.encoder&nbsp;import&nbsp;JSONEncoder,&nbsp;JSONEncoderForHTML<br />&nbsp;&nbsp;File&nbsp;&quot;/atheris/venv/lib/python3.8/site-packages/simplejson-3.17.2-py3.8-linux-x86_64.egg/simplejson/encoder.py&quot;,&nbsp;line&nbsp;17,&nbsp;in&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;c_encode_basestring_ascii,&nbsp;c_make_encoder&nbsp;=&nbsp;_import_speedups()<br />&nbsp;&nbsp;File&nbsp;&quot;/atheris/venv/lib/python3.8/site-packages/simplejson-3.17.2-py3.8-linux-x86_64.egg/simplejson/encoder.py&quot;,&nbsp;line&nbsp;12,&nbsp;in&nbsp;_import_speedups<br />&nbsp;&nbsp;&nbsp;&nbsp;from&nbsp;.&nbsp;import&nbsp;_speedups<br />ImportError:&nbsp;/atheris/venv/lib/python3.8/site-packages/simplejson-3.17.2-py3.8-linux-x86_64.egg/simplejson/_speedups.cpython-38-x86_64-linux-gnu.so:&nbsp;undefined&nbsp;symbol:&nbsp;__asan_option_detect_stack_use_after_return</div></div><br /><br />这表明确实确实由于缺少__asan_option_detect_stack_use_after_return形式的符号而无法加载_speedups.cpython-38-x86_64-linux-gnu.so，这是因为我们没有预加载ASan库。<br /><br />另一方面，如果我们预加载ASan库：<br /><div class="codebox"><div class="codebox">#&nbsp;LD_PRELOAD=&quot;$(python&nbsp;-c&nbsp;&quot;import&nbsp;atheris;&nbsp;import&nbsp;os;&nbsp;print(os.path.dirname(atheris.path()))&quot;)/asan_with_fuzzer.so&quot;&nbsp;python<br />Python&nbsp;3.8.5&nbsp;(default,&nbsp;Jul&nbsp;28&nbsp;2020,&nbsp;12:59:40)&nbsp;<br />[GCC&nbsp;9.3.0]&nbsp;on&nbsp;linux<br />Type&nbsp;&quot;help&quot;,&nbsp;&quot;copyright&quot;,&nbsp;&quot;credits&quot;&nbsp;or&nbsp;&quot;license&quot;&nbsp;for&nbsp;more&nbsp;information.<br />&gt;&gt;&gt;&nbsp;import&nbsp;simplejson</div></div><br /><br />确实，所有预加载的ASan库都可以正常工作。<br /><br /><h2>再Native代码上运行我们的模糊器</h2><br />现在，我们可以再次执行模糊测试，但是，必须导航到其他目录，以确保我们使用安装在Pyhon软件包系统内部的simplejson版本而不是源代码存储库。 因此，我们只需创建一个新目录并在其中执行我们的工作即可：<br /><div class="codebox"><div class="codebox">$&nbsp;mkdir&nbsp;native_fuzz&nbsp;&amp;&amp;&nbsp;cd&nbsp;native_fuzz<br />$&nbsp;touch&nbsp;native_fuzz.py</div></div><br /><br />确保native_fuzz.py中的内容是我们之前的模糊器，然后启动该模糊器：<br /><div class="codebox"><div class="codebox">$&nbsp;#&nbsp;LD_PRELOAD=&quot;$(python&nbsp;-c&nbsp;&quot;import&nbsp;atheris;&nbsp;import&nbsp;os;&nbsp;print(os.path.dirname(atheris.path()))&quot;)/asan_with_fuzzer.so&quot;&nbsp;python&nbsp;./native_fuzz.py<br />INFO:&nbsp;Configured&nbsp;for&nbsp;Python&nbsp;tracing&nbsp;with&nbsp;opcodes.<br />INFO:&nbsp;Seed:&nbsp;1535700839<br />INFO:&nbsp;Loaded&nbsp;2&nbsp;modules&nbsp;&nbsp;&nbsp;(1024&nbsp;inline&nbsp;8-bit&nbsp;counters):&nbsp;512&nbsp;[0x615000001480,&nbsp;0x615000001680),&nbsp;512&nbsp;[0x615000001700,&nbsp;0x615000001900),&nbsp;<br />INFO:&nbsp;Loaded&nbsp;2&nbsp;PC&nbsp;tables&nbsp;(1024&nbsp;PCs):&nbsp;512&nbsp;[0x625000034900,0x625000036900),&nbsp;512&nbsp;[0x625000037100,0x625000039100),&nbsp;<br />INFO:&nbsp;-max_len&nbsp;is&nbsp;not&nbsp;provided;&nbsp;libFuzzer&nbsp;will&nbsp;not&nbsp;generate&nbsp;inputs&nbsp;larger&nbsp;than&nbsp;4096&nbsp;bytes<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW_PY_FUNC[1/2]:&nbsp;TestOneInput()&nbsp;./native_fuzz.py:7<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW_PY_FUNC[2/2]:&nbsp;loads()&nbsp;/atheris/venv/lib/python3.8/site-packages/simplejson-3.17.2-py3.8-linux-x86_64.egg/simplejson/__init__.py:474<br />INFO:&nbsp;A&nbsp;corpus&nbsp;is&nbsp;not&nbsp;provided,&nbsp;starting&nbsp;from&nbsp;an&nbsp;empty&nbsp;corpus<br />#2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;INITED&nbsp;cov:&nbsp;212&nbsp;ft:&nbsp;212&nbsp;corp:&nbsp;1/1b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;40Mb<br />#14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;235&nbsp;ft:&nbsp;235&nbsp;corp:&nbsp;2/3b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;40Mb&nbsp;L:&nbsp;2/2&nbsp;MS:&nbsp;1&nbsp;InsertByte-<br />#29&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;258&nbsp;ft:&nbsp;258&nbsp;corp:&nbsp;3/7b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;41Mb&nbsp;L:&nbsp;4/4&nbsp;MS:&nbsp;4&nbsp;ChangeBit-ChangeBit-CrossOver-InsertByte-<br />#110&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;258&nbsp;ft:&nbsp;258&nbsp;corp:&nbsp;3/6b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;41Mb&nbsp;L:&nbsp;3/3&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#122&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;299&nbsp;ft:&nbsp;322&nbsp;corp:&nbsp;4/9b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;41Mb&nbsp;L:&nbsp;3/3&nbsp;MS:&nbsp;1&nbsp;ChangeByte-<br />#320&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;299&nbsp;ft:&nbsp;322&nbsp;corp:&nbsp;4/8b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;42Mb&nbsp;L:&nbsp;2/3&nbsp;MS:&nbsp;3&nbsp;ChangeBit-ChangeByte-EraseBytes-<br />#445&nbsp;&nbsp;&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;299&nbsp;ft:&nbsp;331&nbsp;corp:&nbsp;5/12b&nbsp;lim:&nbsp;4&nbsp;exec/s:&nbsp;0&nbsp;rss:&nbsp;43Mb&nbsp;L:&nbsp;4/4&nbsp;MS:&nbsp;5&nbsp;CrossOver-ChangeASCIIInt-ChangeByte-ChangeBinInt-CrossOver-<br />#88090&nbsp;&nbsp;NEW&nbsp;&nbsp;&nbsp;&nbsp;cov:&nbsp;304&nbsp;ft:&nbsp;336&nbsp;corp:&nbsp;6/22b&nbsp;lim:&nbsp;868&nbsp;exec/s:&nbsp;44045&nbsp;rss:&nbsp;304Mb&nbsp;L:&nbsp;10/10&nbsp;MS:&nbsp;4&nbsp;ShuffleBytes-ShuffleBytes-InsertByte-CMP-&nbsp;DE:&nbsp;&quot;\xff\xfe\x00\x00\x00\x00\x00\x00&quot;-<br />#88251&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;304&nbsp;ft:&nbsp;336&nbsp;corp:&nbsp;6/21b&nbsp;lim:&nbsp;868&nbsp;exec/s:&nbsp;44125&nbsp;rss:&nbsp;304Mb&nbsp;L:&nbsp;9/9&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#88333&nbsp;&nbsp;REDUCE&nbsp;cov:&nbsp;304&nbsp;ft:&nbsp;336&nbsp;corp:&nbsp;6/17b&nbsp;lim:&nbsp;868&nbsp;exec/s:&nbsp;44166&nbsp;rss:&nbsp;305Mb&nbsp;L:&nbsp;5/5&nbsp;MS:&nbsp;2&nbsp;ShuffleBytes-EraseBytes-<br />#101545&nbsp;REDUCE&nbsp;cov:&nbsp;304&nbsp;ft:&nbsp;336&nbsp;corp:&nbsp;6/15b&nbsp;lim:&nbsp;994&nbsp;exec/s:&nbsp;33848&nbsp;rss:&nbsp;349Mb&nbsp;L:&nbsp;3/4&nbsp;MS:&nbsp;2&nbsp;EraseBytes-ChangeByte-<br />#131072&nbsp;pulse&nbsp;&nbsp;cov:&nbsp;304&nbsp;ft:&nbsp;336&nbsp;corp:&nbsp;6/15b&nbsp;lim:&nbsp;1280&nbsp;exec/s:&nbsp;43690&nbsp;rss:&nbsp;429Mb<br />#137664&nbsp;REDUCE&nbsp;cov:&nbsp;314&nbsp;ft:&nbsp;346&nbsp;corp:&nbsp;7/26b&nbsp;lim:&nbsp;1350&nbsp;exec/s:&nbsp;34416&nbsp;rss:&nbsp;436Mb&nbsp;L:&nbsp;11/11&nbsp;MS:&nbsp;3&nbsp;ChangeByte-ChangeByte-CMP-&nbsp;DE:&nbsp;&quot;\xef\x00\x00\x00\x00\x00\x00\x00&quot;-<br />#138165&nbsp;REDUCE&nbsp;cov:&nbsp;314&nbsp;ft:&nbsp;346&nbsp;corp:&nbsp;7/23b&nbsp;lim:&nbsp;1350&nbsp;exec/s:&nbsp;34541&nbsp;rss:&nbsp;437Mb&nbsp;L:&nbsp;8/8&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#138266&nbsp;REDUCE&nbsp;cov:&nbsp;314&nbsp;ft:&nbsp;346&nbsp;corp:&nbsp;7/19b&nbsp;lim:&nbsp;1350&nbsp;exec/s:&nbsp;34566&nbsp;rss:&nbsp;437Mb&nbsp;L:&nbsp;4/4&nbsp;MS:&nbsp;1&nbsp;EraseBytes-<br />#140027&nbsp;REDUCE&nbsp;cov:&nbsp;314&nbsp;ft:&nbsp;346&nbsp;corp:&nbsp;7/18b&nbsp;lim:&nbsp;1360&nbsp;exec/s:&nbsp;35006&nbsp;rss:&nbsp;439Mb&nbsp;L:&nbsp;3/4&nbsp;MS:&nbsp;1&nbsp;EraseBytes-</div></div><br /><br />Fuzzer照常运行，但是运行约20分钟不会发现任何内存损坏漏洞。</div><div class='page'><h1 class='title level-2'>7_Futher_studied_and_outlook</h1><br/>1_Fuzzing_conslusion</div><div class='page'><h1 class='title level-3'>1_Fuzzing_conslusion</h1><br/></div><div class='page'><h1 class='title level-4'>Further_fuzzing_studies_and_course conclusion</h1><br/><h1>进一步的模糊研究和课程结论</h1><br /><br />这标志着我们课程的结束。 在本讲义中，我们将从较高的角度总结课程内容，并讨论潜在的进一步学习途径。<br /><br /><h2>涵盖摘要</h2><br />该课程首先概述了模糊测试，并介绍了围绕现代模糊测试的各种高级主题。 这包括不同类型的模糊器，基于覆盖范围的模糊器，突变等。 第一章的主要目的是为后续课程奠定基础。<br /><br />在第二章中，我们完整介绍了LibFuzzer。 本章介绍了如何使用LibFuzzer进行模糊测试的第一步，例如 设置正确的编译器标志，实现LLVMFuzzerTestOneInput，什么是sanitizer工具，以及如何将模糊测试从头集成到新项目中。 本节介绍了在实际项目中开始使用LibFuzzer并获得发现错误方面的结果所需的一切。<br /><br />在第三章中，我们研究了围绕LibFuzzer的技术，例如字典，种子和覆盖率，这些技术均用于改善模糊测试的体验。 这包括通过提高您的模糊器效率来改善体验，例如 在您的目标中实现更高的覆盖率。 在这种情况下，覆盖率对于自省您的模糊器并获得有关您在目标中击中什么代码的具体见解特别有用。<br /><br />在第四章中，我们通过了解结构感知的模糊测试提高了模糊测试的技能。 结构感知的模糊测试是关于将输入随机化到需要高度结构化数据的应用程序。 结构感知的模糊测试是一个通用术语，涉及许多概念，我们介绍的一些概念包括状态应用程序的模糊测试和语法感知的模糊测试。<br /><br />最后，在第五章中，我们深入研究了几个实际项目。 其中包括Fluent Bit，PHP和Chromium。 本章的主要目的是提供有关大型现实项目以专业意义部署模糊测试的见解。<br /><br /><h2>进一步的研究和展望</h2><br />那么，您的模糊之旅的下一步是什么？ 有几种合适的途径<br /><br /><h3>将技术应用于实际项目</h3><br />此时自然要做的另一件事是通过从真实的模糊测试中获得经验来练习您的模糊测试技能。 您可以在这里采用多种方法，我们建议尝试所有方法。 第一种方法是选择一个以前从未进行过模糊测试的全新目标，并将完整的端到端模糊测试集成到项目中。第二种方法是在现有的主流项目中实现新颖的模糊测试。 例如，这可能是PHP语言，您可以在其中继续进行现有的PHP模糊器基础结构的工作。最后，我们还建议您尝试使用经过充分分析且具有高度安全性的关键代码库，在这种情况下，我们建议使用Chromium。 执行上述所有步骤将为您提供有关模糊测试的丰富经验，并就可以通过模糊测试实现或不达到的目标提供更好的见解。<br /><br /><h3>开发LibFuzzer扩展</h3><br />进一步研究和增强技能的另一种途径是在LibFuzzer上开发类似于Libfuzzer-mutator的扩展。  Libfuzzer-mutator只是一个大型的fuzzer扩展，它将LibFuzzer核心引擎提供的数据转换为基于protobuf的CPP代码。 可以进行其他有趣的扩展，例如，使协议模糊化变得容易的扩展。 创建采用协议规范的扩展，然后执行所有必要的后端工作，将来自LibFuzzer核心的随机数据转换为满足规范的随机协议消息，将是非常有价值的。可以进行大量其他有趣的扩展，提出新扩展的最简单方法可能是识别一组都需要相似类型的结构化输入的目标。<br /><br /><h3>自定义模糊器开发</h3><br />研究LibFuzzer的核心引擎以及开发自己的自定义模糊器引擎是进一步工作和研究的另一条有趣的途径。 最好的方法可能是研究LibFuzzer的核心引擎，同时尝试对其进行修改并进行细微更改，也许，短期内可以产生的最大影响是尝试新的变异策略。另一个有趣的途径是剥离LibFuzzer内部存在的一些逻辑，以提高其性能。 即使只是一点点的性能改进，对于长时间运行Fuzzer的成本也具有重要意义。<br /><br /><h3>研究进一步的程序分析技术</h3><br />进一步研究的一个有趣途径是更深入地进入程序分析领域。 本质上，模糊化作为一个概念存在于“软件分析”的领域内，并且这个领域本身是巨大的。如果您还不熟悉程序分析的其他方面，那么您可能需要研究它们的，并按特定顺序（也可能是感兴趣的主题）对它们进行研究：<br />1. Automated fuzzer generation, such as FuzzGen<br />2. Symbolic executions<br />3. Abstract interpretation 抽象解释<br />4. Program synthesis 程序合成<br />5. Automated test-case generation<br />6. LLVM<br />7. Compilers and compiler passes<br />8. Static program analysis<br />9. Datalog<br />10. CodeQL <a href="https://xz.aliyun.com/t/7657">https://xz.aliyun.com/t/7657</a><br />11. Taint analysis  动态污点分析<br />12. Automating reverse engineering<br /></div><div class='page'><h1 class='title level-2'>libfuzzer使用经验</h1><br/></div><div class='page'><h1 class='title level-3'>address sanitizer使用</h1><br/>关于address sanitizer的使用<br /><a href="https://blog.csdn.net/yunlianglinfeng/article/details/106639516">(6条消息) ASAN_yunlianglinfeng的专栏-CSDN博客_asan</a><br /><a href="https://blog.csdn.net/biqioso/article/details/82875310">(6条消息) Linux下内存检测工具：asan【转】_biqioso的博客-CSDN博客</a><br /><br />运行fuzer（带address sanitizer，及ASAN），输出显示程序申请了0x1d1a71c78字节内存，换算下来大约7gb，<br />注意此时程序并未崩溃，仅仅是realloc程序申请较大内存块失败，从而导致realloc返回null，而该过程被ASAN捕获<br />此时提示信息显示，如果想忽略该问题（及内存申请函数realloc申请内存失败返回0），可以设置allocator_may_return_null=1<br /><a href=""><img src="images\936-1.png" alt="images\936-1.png" /></a><br /><br />根据查阅资料发现 ASAN作为linux下提供的内存泄露检测工具，可以通过修改环境变量改变ASAN检测逻辑<br />通过执行<br />export ASAN_OPTION=allocator_may_return_null=1<br />修改环境变量之后重新运行fuzzer<br /><a href=""><img src="images\936-2.png" alt="images\936-2.png" /></a><br /><br />重新运行fuzzer后，程序由于引用未分配内存而崩溃，而崩溃位置位于之前realloc申请内存失败位置的附近，说明当前错误可能是之前realloc申请内存失败引起的<br /><a href=""><img src="images\936-3.png" alt="images\936-3.png" /></a><br /><br />此时的crash文件<br />./crash-35e667082b8dd0cf38d7602ad74105bd84b4c637<br /><br />~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br /><br />ASAN_OPTIONS = detect_odr_violation = 0<br />请注意，我们还必须传递选项ASAN_OPTIONS = detect_odr_violation = 0，因为否则运行我们时，模糊器会抱怨。<br /><div class="codebox"><div class="codebox">$&nbsp;mkdir&nbsp;Corpus<br />$&nbsp;ASAN_OPTIONS=detect_odr_violation=<span style="color:#ff0044;font-weight:400">0</span>&nbsp;./out/pdfium-fuzzer/pdfium_fuzzer&nbsp;./Corpus/<br />INFO:&nbsp;Seed:&nbsp;<span style="color:#ff0044;font-weight:400">629343114</span><br />INFO:&nbsp;Loaded&nbsp;<span style="color:#ff0044;font-weight:400">11</span>&nbsp;modules&nbsp;&nbsp;&nbsp;(<span style="color:#ff0044;font-weight:400">713051</span>&nbsp;<span style="color:#7f0044;font-weight:400">inline</span>&nbsp;<span style="color:#ff0044;font-weight:400">8</span>-bit&nbsp;counters):&nbsp;<span style="color:#ff0044;font-weight:400">14299</span>&nbsp;[<span style="color:#ff0044;font-weight:400">0x7fadab5362b0</span>,&nbsp;<span style="color:#ff0044;font-weight:400">0x7fadab539a8b</span>),&nbsp;<span style="color:#ff0044;font-weight:400">2565</span>&nbsp;[<span style="color:#ff0044;font-weight:400">0x7fadaa2ced2b</span>,&nbsp;<span style="color:#ff0044;font-weight:400">0x7fadaa2cf730</span>),&nbsp;<span style="color:#ff0044;font-weight:400">4316</span>&nbsp;[<span style="color:#ff0044;font-weight:400">0x7fadb4383bbb</span>,&nbsp;<span style="color:#ff0044;font-weight:400">0x7fadb4384c97</span>),&nbsp;<span style="color:#ff0044;font-weight:400">3565</span>&nbsp;[<span style="color:#ff0044;font-weight:400">0x7fadb444f9db</span>,&nbsp;<span style="color:#ff0044;font-weight:400">0x7fadb44507c8</span>),&nbsp;<span style="color:#ff0044;font-weight:400">34633</span>&nbsp;[<span style="color:#ff0044;font-weight:400">0x7fadb15e8cdb</span>,&nbsp;<span style="color:#ff0044;font-weight:400">0x7fadb15f1424</span>),&nbsp;<span style="color:#ff0044;font-weight:400">46444</span>&nbsp;[<span style="color:#ff0044;font-weight:400">0x7fadabcbedcb</span>,&nbsp;<span style="color:#ff0044;font-weight:400">0x7fadabcca337</span>),&nbsp;<span style="color:#ff0044;font-weight:400">2370</span>&nbsp;[<span style="color:#ff0044;font-weight:400">0x7fadb44c21ab</span>,&nbsp;<span style="color:#ff0044;font-weight:400">0x7fadb44c2aed</span>),&nbsp;<span style="color:#ff0044;font-weight:400">368077</span>&nbsp;[<span style="color:#ff0044;font-weight:400">0x7fadb0a1500b</span>,&nbsp;<span style="color:#ff0044;font-weight:400">0x7fadb0a6edd8</span>),&nbsp;<span style="color:#ff0044;font-weight:400">57647</span>&nbsp;[<span style="color:#ff0044;font-weight:400">0x7fadb210ffeb</span>,</div></div><br />ASAN_OPTIONS=detect_odr_violation=<span style="color:#edd400;">0</span>的设置用于忽略如下错误，该错误在fuzzing chrome过程中很常见<br /><a href=""><img src="images\936-4.png" alt="images\936-4.png" /></a><br /></div><div class='page'><h1 class='title level-3'>clang编译过程</h1><br/>clang编译过程（参数使用上和gcc相同）<br /><a href=""><img src="images\935-1.png" alt="images\935-1.png" /></a><br /><br />clang编译器参数手册<br /><a href="https://clang.llvm.org/docs/ClangCommandLineReference.html">https://clang.llvm.org/docs/ClangCommandLineReference.html</a><br /><br /><br />直接使用如下命令查找帮助<br /><h3>clang -help</h3><br /><br />常用编译flag<br />-I &lt;value&gt;              Add directory to include search path，用于指定源码中引用的头文件的位置<br /><br />-fprofile-instr-generate -fcoverage-mapping  开启代码覆盖率统计<br /><div class="codebox"><div class="codebox"><span style="color:#ff9d00;font-weight:700">if</span>&nbsp;[&nbsp;$#&nbsp;-eq&nbsp;<span style="color:#ff0044;font-weight:400">0</span>&nbsp;]<br />then<br />&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;<span style="color:#3ad900;font-weight:400">&quot;Please&nbsp;give&nbsp;a&nbsp;filename&quot;</span><br />&nbsp;&nbsp;&nbsp;&nbsp;exit&nbsp;<span style="color:#ff0044;font-weight:400">1</span><br />fi<br /><br />FUZZ_FLAGS=<span style="color:#3ad900;font-weight:400">&quot;-fsanitize=fuzzer&nbsp;-fprofile-instr-generate&nbsp;-fcoverage-mapping&nbsp;&quot;</span><br />clang&nbsp;$FUZZ_FLAGS&nbsp;$<span style="color:#ff0044;font-weight:400">1</span></div></div><br /><br />~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br /><br /><h1>编译器中-std和-stdlib含义</h1><br /><br />1. -std= &lt;c++11/gnu++11/c99&gt;<br />-std指编译器编译时采用的C/C++标准，用哪种标准进行编译。<br />-std=  c++11，支持C++11标准； -std=gnu++11，支持C++11标准和GNU扩展特性；-std=c99开启c语言c99支持； -std=c11开启c语言c11库的支持；<br /><br />2. -stdlib= &lt;libstdc++/libc++&gt;<br />-stdlib指编译器编译时依赖的标准库。<br />gcc编译器没有-stdlib 这样命令行选项，LLVM clang编译器支持。 这是因为clang为您提供链接LLVM标准C ++库（ libc ++ ）或GNU标准C ++库（ libstdc ++ ），而gcc只支持 libstdc ++ 。 简单说就是两个都是 C++ 标准库，libc++ 是针对 Clang 编译器特别重写的 C++ 标准库，而 libstdc++ 则是 GCC 的对应 C++ 标准库。<br /><br />编译程序范例指定CXXFLAGS = -std=c++11 -stdlib=libstdc++<br /><br />链接时使用静态主机OpenMP例程<br /><strong><span style="color:#8ae234;">export</span></strong> CXXFLAGS=<span style="color:#edd400;">&quot;-fsanitize=fuzzer-no-link,address -stdlib=libc++&quot;</span><br /><br />~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br /><br />除了在编译过程中使用-fsanitize = fuzzer从而指定使用libfuzz，也可以将目标代码链接到/usr/lib/libFuzzingEngine.a中从而使用libfuzzer，只不过前者性能更好<br /><br />~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br /><br /><strong><span style="color:#8ae234;">export</span></strong> LIB_FUZZING_ENGINE=<span style="color:#edd400;">&quot;-fsanitize=fuzzer&quot;</span><br />该环境变量常在OSS-fuzz项目中用于指定使用libfuzzer对项目进行fuzzing<br /><a href="https://github.com/google/oss-fuzz/issues/2317">https://github.com/google/oss-fuzz/issues/2317</a></div><div class='page'><h1 class='title level-3'>libfuzzer的参数</h1><br/>libfuzzer官方参数手册<br /><a href="https://llvm.org/docs/LibFuzzer.html">https://llvm.org/docs/LibFuzzer.html</a><br /><br />第一个参数为语料库目录<br /><br />第二个参数为种子文件的目录<br /><br />-max_total_time=90  即fuzzer运行时常最多为90s<br /><a href=""><img src="images\943-1.png" alt="images\943-1.png" /></a><br /><br />-dict=字典目录<br /><a href=""><img src="images\943-2.png" alt="images\943-2.png" /></a><br /><br />-dump_coverage = 1 保存覆盖率报告到文件系统<br /><br />LLVM_PROFILE_FILE环境变量指定覆盖率报告的名称<br /><br />-timeout<br />	超时（以秒为单位），默认值为1200。如果输入的时间长于此超时时间，则该过程将视为失败情况。<br /><br /><span style="color:#17191c;">-close_fd_mask</span>	<br />	指示输出流在启动时关闭。 请注意，这将从目标代码中删除诊断输出（例如，断言失败时的消息）。<br />	0（默认）：不关闭stdout或stderr <br />	1：关闭stdout <br />	2：关闭stderr <br />	3：关闭stdout和stderr。<br /><br /><span style="color:#17191c;">-runs</span><br />	单个测试运行的次数，-1（默认）为无限期运行。<br /><a href=""><img src="images\943-3.png" alt="images\943-3.png" /></a><br /><br />-merge=1 <br />	语料库蒸馏<br />	如果您拥有庞大的语料库（无论是通过模糊处理生成还是通过其他方式获取），您都可能希望将其最小化，同时又要保留完整的覆盖范围。 一种方法是使用-merge = 1标志：<br />	<span style="color:#9d9488;">mkdir NEW_CORPUS_DIR  # Store minimized corpus here.</span><br />	<span style="color:#9d9488;">./my_fuzzer -merge=1 NEW_CORPUS_DIR FULL_CORPUS_DIR</span><br /><br />您可以使用相同的标志将更多有趣的项目添加到现有语料库中。 仅触发新覆盖率的输入将被添加到第一个语料库。<br /><span style="color:#9d9488;">./my_fuzzer -merge=1 CURRENT_CORPUS_DIR NEW_POTENTIALLY_INTERESTING_INPUTS_DIR</span><br /></div></body></html>