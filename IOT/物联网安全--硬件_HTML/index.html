<!doctype html><html>
    <head>
      <meta http-equiv="content-type" content="text/html; charset=utf-8">
      <title>sqliteNoteBook.ctb</title>
      <meta name="generator" content="CherryTree">
      <link rel="stylesheet" href="res/styles3.css" type="text/css" />
    </head>
    <body><div class='page'><h1 class='title level-1'>硬件</h1><br/></div><div class='page'><h1 class='title level-2'>AT命令</h1><br/>AT指令<br /><a href="https://blog.csdn.net/zqixiao_09/article/details/52506452">https://blog.csdn.net/zqixiao_09/article/details/52506452</a><br />AT指令常在uart串口调试中输出<br /><br /><a href="中汽研实习--tbox硬件分析--哪吒.html#哪吒AT指令">哪吒tbox通讯模块分析</a><br /><br /><h1>移远ec20 4G无线通讯模块AT指令手册</h1><br /><a href="https://www.quectel.com/UploadImage/Downlad/Quectel_EC20_AT_Commands_Manual_V1.3.pdf">Quectel_EC20_AT_Commands_Manual_V1.3.pdf</a><br /><br /><h1>AT指令使用实例</h1><br /><a href="http://www.mcublog.cn/esp32/2019_12/esp32tongguouartchuankoushiyongatzhiling/">ESP32通过UART串口使用AT指令 | MCU起航 (mcublog.cn)</a><br /><br />对于芯片，某些uart仅输出启动日志，并不接收AT指令，需要寻找其他uart引脚<br /><br /><a href=""><img src="images\62-1.png" alt="images\62-1.png" /></a><br /><a href=""><img src="images\62-2.png" alt="images\62-2.png" /></a><br /><br /><a href="https://blog.csdn.net/blog_xu/article/details/99676812?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.not_use_machine_learn_pai&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.not_use_machine_learn_pai">Linux系统下使用4G模块EC20实现拨号上网_blog_xu的博客-CSDN博客</a><br />ls /dev/ttyUSB*<br />echo -e “AT+CSQ\r\n” &gt; /dev/ttyUSB3<br /><a href=""><img src="images\62-3.png" alt="images\62-3.png" /></a><br /><br /><a href="https://www.it610.com/article/1296140741730443264.htm">EC20模块GPS功能的使用 - it610.com</a><br /><br />AT命令输出和回显的COM口可能不是一个<br /><a href=""><img src="images\62-4.png" alt="images\62-4.png" /></a><br /><br /><br /><a href=""><img src="images\62-5.png" alt="images\62-5.png" /></a><br /><br />将AT命令从ttyUSB2输入设备，而AT命令回显在ttyUSB1中<br /><br /><a href=""><img src="images\62-6.png" alt="images\62-6.png" /></a><br /><br /><h1>移远ec20通过AT指令调试</h1><br /><a href=""><img src="images\62-7.png" alt="images\62-7.png" /></a><br /><a href=""><img src="images\62-8.png" alt="images\62-8.png" /></a></div><div class='page'><h1 class='title level-2'>datasheet查询网站</h1><br/><a href="https://www.datasheets.com/en">Find Datasheets, Electronic Parts, Components – Datasheets.com</a><br /><a href="https://www.alldatasheet.com/">ALLDATASHEET.COM - Datasheet search site for Electronic Components and Semiconductors and other semiconductors.</a><br /><a href="https://www.findchips.com/">FindChips: Electronic Components, Distributor Inventories, Datasheets</a><br /><a href="https://www.datasheetlocator.com/zh/">Global Electronic Components Datasheet Locator</a><br /><a href="https://www.21icserach.com">https://www.21icserach.com</a><br /><a href="https://www.21icserach.com">https://</a><a href="http://www.datasheets.com/zh-cn">www.datasheets.com/zh-cn</a><br /><a href="https://www.21icserach.com">https://</a><a href="http://www.datasheet-pdf.com">www.datasheet-pdf.com</a><br /><a href="https://www.21icserach.com">https://</a><a href="http://www.ifixit.com">www.ifixit.com</a><br /><a href="https://fiicd.io">https://fiicd.io</a><br /><a href="https://www.worldwayelec.com/">https://www.worldwayelec.com/</a><br /><a href="https://datasheet4u.com/share_search.php?sWord=KLM8G1GESD-B04Q">https://datasheet4u.com/share_search.php?sWord=KLM8G1GESD-B04Q</a><br /><a href=""><img src="images\162-1.png" alt="images\162-1.png" /></a><br />其他芯片资料来源<br /><strong><h3>· </h3></strong><h3>Google：没有什么比Google更好的搜索引擎了。</h3><br /><strong><h3>· </h3></strong><h3>类似Yandex.ru的网站：Yandex是俄罗斯网络拥有用户最多的网站，不要低估非英语搜索引擎和论坛的威力。</h3><br /><strong><h3>· </h3></strong><h3>Alibaba：大部分芯片在这里有卖的，一些列表将链接到你可能无法在其他任何地方找到的数据表，你也可以通过直接与供应商交谈来获取数据表。</h3><br /><br /><br />相关网站查询datasheet<br />alldatasheet.com<br /><a href=""><img src="images\162-2.png" alt="images\162-2.png" /></a><br /></div><div class='page'><h1 class='title level-2'>波特率检测</h1><br/><br /></div><div class='page'><h1 class='title level-3'>使用脚本检测</h1><br/>安装所需环境<br />sudo pip install serial<br />sudo pip install pyserial<br />sudo pip install getch<br />运行脚本开始检测<br />sudo python3 python3-baudrate\(RunAble\).py -a<br />(-a 为自动检测模式)<br /><br />注意该脚本需要设备持续输出数据<br /><br /><br />使用脚本<br />	<a href="https://github.com/devttys0/baudrate">https://github.com/devttys0/baudrate</a><br />		attify原版的python2.x编写的，运行过程中会报错<br />	<a href="https://github.com/biw/Baudrate.py">https://github.com/biw/Baudrate.py</a><br />	<a href="https://github.com/interference-security/baudrate">https://github.com/interference-security/baudrate</a><br />	只能检测几个特定的波特率，具体使用方法存疑<br /><br /><h1>脚本自动探测波特率成功实践</h1><br />attify脚本新版支持python3<br /><a href="https://github.com/sickcodes/python3-baudrate/blob/master/baudrate.py">https://github.com/sickcodes/python3-baudrate/blob/master/baudrate.py</a><br />可能报错AttributeError: module &#39;serial&#39; has no attribute &#39;Serial&#39;<br />pip3 install serial  之后 pip3 install pyserial<br />该脚本将所检测的几个波特率固定在数组中，如果要测量大范围的波特率，需要重新设置该数组<br />安装依赖以及使用<br />sudo pip install serial<br />sudo pip install pyserial<br />sudo pip install getch<br />sudo python3 python3-baudrate\(RunAble\).py -a<br />(-a 为自动检测模式)<br /><br /><h2>脚本自动探测设备波特率的原理：</h2><br />脚本会使用python第三方库从当前串口设备中以不同的波特率读取数据，如果读取出的数据看似为正常数据，则脚本判断当前对应的波特率为正确波特率<br />所以如果脚本要正确工作，需要在脚本运行期间，设备不断向串口输出数据，脚本内部通过read函数读取串口的输出数据，从而判断，对于索纳塔车机设备，如果将车机pcb板上的执行GPS信号收发的小pcb板拔出，则车机pcb板会一直向串口输出GPS信号缺失的信息，利用该特点，可以运行脚本，从而找到正确的波特率<br /><br /><br /></div><div class='page'><h1 class='title level-4'>脚本检测波特率成功实践</h1><br/><a href="https://github.com/sickcodes/python3-baudrate/blob/master/baudrate.py">https://github.com/sickcodes/python3-baudrate/blob/master/baudrate.py</a><br />该脚本需要使用python3运行，且脚本的-a 参数可以让脚本自动运行，从而检测指定的波特率<br />	sudo python3 baudrate.py -a<br />该语句可以产生特定范围的待测试的波特率字符串数组，可以用在脚本代码中，从而自行指定要检测的波特率<br />	BAUDRATES = [str(x) for x in range(9600, 500000, 10)]<br />	<br />	具体脚本代码	<div class="codebox"><div class="codebox">#!/usr/bin/env&nbsp;python3<br />#&nbsp;License:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MIT<br />#&nbsp;Authors:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />#&nbsp;Craig&nbsp;Heffner&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@devttys0&nbsp;&nbsp;&nbsp;https://github.com/devttys0<br />#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Loris1123&nbsp;&nbsp;https://github.com/Loris1123<br />#&nbsp;Sick.Codes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@sickcodes&nbsp;&nbsp;https://github.com/sickcodes<br />#&nbsp;Usage:<br />#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pip&nbsp;install&nbsp;-r&nbsp;requirements.txt<br />#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sudo&nbsp;python&nbsp;baudrate.py&nbsp;/dev/ttyUSB0<br /><br />import&nbsp;sys<br />import&nbsp;time<br />import&nbsp;serial<br />from&nbsp;threading&nbsp;import&nbsp;Thread<br />import&nbsp;tty<br />import&nbsp;termios<br />import&nbsp;subprocess<br />from&nbsp;getopt&nbsp;import&nbsp;getopt&nbsp;as&nbsp;GetOpt,&nbsp;GetoptError<br />import&nbsp;getch<br /><br />class&nbsp;RawInput:<br />&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Gets&nbsp;a&nbsp;single&nbsp;character&nbsp;from&nbsp;standard&nbsp;input.&nbsp;&nbsp;Does&nbsp;not&nbsp;echo&nbsp;to&nbsp;the&nbsp;screen.&quot;&quot;&quot;<br />&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;__init__(self):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.impl&nbsp;=&nbsp;RawInputWindows()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;except&nbsp;ImportError:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.impl&nbsp;=&nbsp;RawInputUnix()<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;__call__(self):&nbsp;return&nbsp;self.impl()<br /><br /><br />class&nbsp;RawInputUnix:<br />&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;__call__(self):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fd&nbsp;=&nbsp;sys.stdin.fileno()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;old_settings&nbsp;=&nbsp;termios.tcgetattr(fd)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tty.setraw(sys.stdin.fileno())<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ch&nbsp;=&nbsp;sys.stdin.read(1)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finally:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;termios.tcsetattr(fd,&nbsp;termios.TCSADRAIN,&nbsp;old_settings)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;ch<br /><br /><br />class&nbsp;RawInputWindows:<br />&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;__call__(self):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;getch.getch()<br /><br />class&nbsp;Baudrate:<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;VERSION&nbsp;=&nbsp;&#39;3.0&#39;<br />&nbsp;&nbsp;&nbsp;&nbsp;READ_TIMEOUT&nbsp;=&nbsp;5<br />&nbsp;&nbsp;&nbsp;&nbsp;BAUDRATES&nbsp;=&nbsp;[<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;110&quot;,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;300&quot;,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;600&quot;,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;1200&quot;,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;1800&quot;,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;2400&quot;,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;4800&quot;,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;9600&quot;,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;14400&quot;,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;19200&quot;,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;28800&quot;,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;38400&quot;,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;57600&quot;,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;115200&quot;,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;128000&quot;,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;230400&quot;,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;250000&quot;,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;256000&quot;,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;460800&quot;,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;500000&quot;,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;921600&quot;,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;2500000&quot;,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;3000000&quot;,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;3686400&quot;,<br />&nbsp;&nbsp;&nbsp;&nbsp;]<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;UPKEYS&nbsp;=&nbsp;[&#39;u&#39;,&nbsp;&#39;U&#39;,&nbsp;&#39;A&#39;]<br />&nbsp;&nbsp;&nbsp;&nbsp;DOWNKEYS&nbsp;=&nbsp;[&#39;d&#39;,&nbsp;&#39;D&#39;,&nbsp;&#39;B&#39;]<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;MIN_CHAR_COUNT&nbsp;=&nbsp;25<br />&nbsp;&nbsp;&nbsp;&nbsp;WHITESPACE&nbsp;=&nbsp;[&#39;&nbsp;&#39;,&nbsp;&#39;\t&#39;,&nbsp;&#39;\r&#39;,&nbsp;&#39;\n&#39;]<br />&nbsp;&nbsp;&nbsp;&nbsp;PUNCTUATION&nbsp;=&nbsp;[&#39;.&#39;,&nbsp;&#39;,&#39;,&nbsp;&#39;:&#39;,&nbsp;&#39;;&#39;,&nbsp;&#39;?&#39;,&nbsp;&#39;!&#39;]<br />&nbsp;&nbsp;&nbsp;&nbsp;VOWELS&nbsp;=&nbsp;[&#39;a&#39;,&nbsp;&#39;A&#39;,&nbsp;&#39;e&#39;,&nbsp;&#39;E&#39;,&nbsp;&#39;i&#39;,&nbsp;&#39;I&#39;,&nbsp;&#39;o&#39;,&nbsp;&#39;O&#39;,&nbsp;&#39;u&#39;,&nbsp;&#39;U&#39;]<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;__init__(self,&nbsp;port=None,&nbsp;threshold=MIN_CHAR_COUNT,&nbsp;timeout=READ_TIMEOUT,&nbsp;name=None,&nbsp;auto=True,&nbsp;verbose=False):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.port&nbsp;=&nbsp;port<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.threshold&nbsp;=&nbsp;threshold<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.timeout&nbsp;=&nbsp;timeout<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.name&nbsp;=&nbsp;name<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.auto_detect&nbsp;=&nbsp;auto<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.verbose&nbsp;=&nbsp;verbose<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.index&nbsp;=&nbsp;len(self.BAUDRATES)&nbsp;-&nbsp;1<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.valid_characters&nbsp;=&nbsp;[]<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.ctlc&nbsp;=&nbsp;False<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.thread&nbsp;=&nbsp;None<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._gen_char_list()<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;_gen_char_list(self):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;&#39;&nbsp;&#39;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;c&nbsp;&lt;=&nbsp;&#39;~&#39;:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.valid_characters.append(c)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;chr(ord(c)&nbsp;+&nbsp;1)<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;c&nbsp;in&nbsp;self.WHITESPACE:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;c&nbsp;not&nbsp;in&nbsp;self.valid_characters:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.valid_characters.append(c)<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;_print(self,&nbsp;data):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;self.verbose:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sys.stderr.buffer.write(data)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sys.stderr.buffer.flush()<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;Open(self):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pass<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.serial&nbsp;=&nbsp;serial.Serial(self.port,&nbsp;timeout=self.timeout)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.NextBaudrate(0)<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;NextBaudrate(self,&nbsp;updn):<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.index&nbsp;+=&nbsp;updn<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;self.index&nbsp;&gt;=&nbsp;len(self.BAUDRATES):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.index&nbsp;=&nbsp;0<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif&nbsp;self.index&nbsp;&lt;&nbsp;0:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.index&nbsp;=&nbsp;len(self.BAUDRATES)&nbsp;-&nbsp;1<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sys.stderr.write(&#39;\n\n@@@@@@@@@@@@@@@@@@@@@&nbsp;Baudrate:&nbsp;%s&nbsp;@@@@@@@@@@@@@@@@@@@@@\n\n&#39;&nbsp;%&nbsp;self.BAUDRATES[self.index])<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.serial.flush()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.serial.baudrate&nbsp;=&nbsp;self.BAUDRATES[self.index]<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.serial.flush()<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;Detect(self):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count&nbsp;=&nbsp;0<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;whitespace&nbsp;=&nbsp;0<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;punctuation&nbsp;=&nbsp;0<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vowels&nbsp;=&nbsp;0<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;start_time&nbsp;=&nbsp;0<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timed_out&nbsp;=&nbsp;False<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clear_counters&nbsp;=&nbsp;False<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;self.auto_detect:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.thread&nbsp;=&nbsp;Thread(None,&nbsp;self.HandleKeypress,&nbsp;None,&nbsp;(self,&nbsp;1))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.thread.start()<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;True:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;start_time&nbsp;==&nbsp;0:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;start_time&nbsp;=&nbsp;time.time()<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte&nbsp;=&nbsp;self.serial.read(1)<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;byte:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;self.auto_detect&nbsp;and&nbsp;byte&nbsp;in&nbsp;self.valid_characters:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;byte&nbsp;in&nbsp;self.WHITESPACE:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;whitespace&nbsp;+=&nbsp;1<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif&nbsp;byte&nbsp;in&nbsp;self.PUNCTUATION:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;punctuation&nbsp;+=&nbsp;1<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif&nbsp;byte&nbsp;in&nbsp;self.VOWELS:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vowels&nbsp;+=&nbsp;1<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count&nbsp;+=&nbsp;1<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clear_counters&nbsp;=&nbsp;True<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._print(byte)<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;count&nbsp;&gt;=&nbsp;self.threshold&nbsp;and&nbsp;whitespace&nbsp;&gt;&nbsp;0&nbsp;and&nbsp;punctuation&nbsp;&gt;&nbsp;0&nbsp;and&nbsp;vowels&nbsp;&gt;&nbsp;0:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif&nbsp;(time.time()&nbsp;-&nbsp;start_time)&nbsp;&gt;=&nbsp;self.timeout:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timed_out&nbsp;=&nbsp;True<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timed_out&nbsp;=&nbsp;True<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;timed_out&nbsp;and&nbsp;self.auto_detect:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;start_time&nbsp;=&nbsp;0<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.NextBaudrate(-1)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clear_counters&nbsp;=&nbsp;True<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timed_out&nbsp;=&nbsp;False<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;clear_counters:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;whitespace&nbsp;=&nbsp;0<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;punctuation&nbsp;=&nbsp;0<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vowels&nbsp;=&nbsp;0<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count&nbsp;=&nbsp;0<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clear_counters&nbsp;=&nbsp;False<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;self.ctlc:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;self.BAUDRATES[self.index]<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;HandleKeypress(self,&nbsp;*args):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;userinput&nbsp;=&nbsp;RawInput()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;not&nbsp;self.ctlc:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;userinput()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;c&nbsp;in&nbsp;self.UPKEYS:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.NextBaudrate(1)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif&nbsp;c&nbsp;in&nbsp;self.DOWNKEYS:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.NextBaudrate(-1)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif&nbsp;c&nbsp;==&nbsp;&#39;\x03&#39;:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.ctlc&nbsp;=&nbsp;True<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;MinicomConfig(self,&nbsp;name=None):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;success&nbsp;=&nbsp;True<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;name&nbsp;is&nbsp;None:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name&nbsp;=&nbsp;self.name<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;config&nbsp;=&nbsp;&nbsp;&quot;########################################################################\n&quot;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;config&nbsp;+=&nbsp;&quot;#&nbsp;Minicom&nbsp;configuration&nbsp;file&nbsp;-&nbsp;use&nbsp;\&quot;minicom&nbsp;-s\&quot;&nbsp;to&nbsp;change&nbsp;parameters.\n&quot;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;config&nbsp;+=&nbsp;&quot;pu&nbsp;port&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%s\n&quot;&nbsp;%&nbsp;self.port<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;config&nbsp;+=&nbsp;&quot;pu&nbsp;baudrate&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%s\n&quot;&nbsp;%&nbsp;self.BAUDRATES[self.index]<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;config&nbsp;+=&nbsp;&quot;pu&nbsp;bits&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8\n&quot;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;config&nbsp;+=&nbsp;&quot;pu&nbsp;parity&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;N\n&quot;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;config&nbsp;+=&nbsp;&quot;pu&nbsp;stopbits&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1\n&quot;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;config&nbsp;+=&nbsp;&quot;pu&nbsp;rtscts&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No\n&quot;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;config&nbsp;+=&nbsp;&quot;########################################################################\n&quot;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;name&nbsp;is&nbsp;not&nbsp;None&nbsp;and&nbsp;name:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;open(&quot;/etc/minicom/minirc.%s&quot;&nbsp;%&nbsp;name,&nbsp;&quot;w&quot;).write(config)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;except&nbsp;Exception&nbsp;as&nbsp;e:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(&quot;Error&nbsp;saving&nbsp;minicom&nbsp;config&nbsp;file:&quot;,&nbsp;str(e))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;success&nbsp;=&nbsp;False<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(success,&nbsp;config)<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;Close(self):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.ctlc&nbsp;=&nbsp;True<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.serial.close()<br /><br /><br /><br />if&nbsp;__name__&nbsp;==&nbsp;&#39;__main__&#39;:<br /><br /><br />&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;usage():<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;baud&nbsp;=&nbsp;Baudrate()<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(&quot;Baudrate&nbsp;v%s&quot;&nbsp;%&nbsp;baud.VERSION)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(&quot;Craig&nbsp;Heffner,&nbsp;http://www.devttys0.com&quot;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(&quot;@Loris1123,&nbsp;https://github.com/Loris1123&quot;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(&quot;Sick.Codes,&nbsp;https://sick.codes&quot;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(&quot;&quot;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(&quot;Usage:&nbsp;%s&nbsp;[OPTIONS]&quot;&nbsp;%&nbsp;sys.argv[0])<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(&quot;&quot;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(&quot;\t-p&nbsp;&lt;serial&nbsp;port&gt;&nbsp;&nbsp;&nbsp;Specify&nbsp;the&nbsp;serial&nbsp;port&nbsp;to&nbsp;use&nbsp;[/dev/ttyUSB0]&quot;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(&quot;\t-t&nbsp;&lt;seconds&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set&nbsp;the&nbsp;timeout&nbsp;period&nbsp;used&nbsp;when&nbsp;switching&nbsp;baudrates&nbsp;in&nbsp;auto&nbsp;detect&nbsp;mode&nbsp;[%d]&quot;&nbsp;%&nbsp;baud.READ_TIMEOUT)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(&quot;\t-c&nbsp;&lt;num&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set&nbsp;the&nbsp;minimum&nbsp;ASCII&nbsp;character&nbsp;threshold&nbsp;used&nbsp;during&nbsp;auto&nbsp;detect&nbsp;mode&nbsp;[%d]&quot;&nbsp;%&nbsp;baud.MIN_CHAR_COUNT)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(&quot;\t-n&nbsp;&lt;name&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Save&nbsp;the&nbsp;resulting&nbsp;serial&nbsp;configuration&nbsp;as&nbsp;&lt;name&gt;&nbsp;and&nbsp;automatically&nbsp;invoke&nbsp;minicom&nbsp;(implies&nbsp;-a)&quot;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(&quot;\t-a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enable&nbsp;auto&nbsp;detect&nbsp;mode&quot;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(&quot;\t-b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Display&nbsp;supported&nbsp;baud&nbsp;rates&nbsp;and&nbsp;exit&quot;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(&quot;\t-q&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Do&nbsp;not&nbsp;display&nbsp;data&nbsp;read&nbsp;from&nbsp;the&nbsp;serial&nbsp;port&quot;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(&quot;\t-h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Display&nbsp;help&quot;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(&quot;&quot;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sys.exit(1)<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;main():<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;display&nbsp;=&nbsp;False<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;verbose&nbsp;=&nbsp;True<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;auto&nbsp;=&nbsp;False<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;run&nbsp;=&nbsp;False<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;threshold&nbsp;=&nbsp;25<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timeout&nbsp;=&nbsp;1<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name&nbsp;=&nbsp;None<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;port&nbsp;=&nbsp;&#39;/dev/ttyUSB0&#39;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(opts,&nbsp;args)&nbsp;=&nbsp;GetOpt(sys.argv[1:],&nbsp;&#39;p:t:c:n:abqh&#39;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;except&nbsp;GetoptError&nbsp;as&nbsp;e:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(e)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;usage()<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;opt,&nbsp;arg&nbsp;in&nbsp;opts:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;opt&nbsp;==&nbsp;&#39;-t&#39;:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timeout&nbsp;=&nbsp;int(arg)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif&nbsp;opt&nbsp;==&nbsp;&#39;-c&#39;:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;threshold&nbsp;=&nbsp;int(arg)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif&nbsp;opt&nbsp;==&nbsp;&#39;-p&#39;:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;port&nbsp;=&nbsp;arg<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif&nbsp;opt&nbsp;==&nbsp;&#39;-n&#39;:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name&nbsp;=&nbsp;arg<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;auto&nbsp;=&nbsp;True<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;run&nbsp;=&nbsp;True<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif&nbsp;opt&nbsp;==&nbsp;&#39;-a&#39;:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;auto&nbsp;=&nbsp;True<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif&nbsp;opt&nbsp;==&nbsp;&#39;-b&#39;:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;display&nbsp;=&nbsp;True<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif&nbsp;opt&nbsp;==&nbsp;&#39;-q&#39;:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;verbose&nbsp;=&nbsp;False<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;usage()<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;baud&nbsp;=&nbsp;Baudrate(port,&nbsp;threshold=threshold,&nbsp;timeout=timeout,&nbsp;name=name,&nbsp;verbose=verbose,&nbsp;auto=auto)<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;display:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(&quot;&quot;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;rate&nbsp;in&nbsp;baud.BAUDRATES:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(&quot;\t{}&quot;.format(rate))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(&quot;&quot;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(&quot;&quot;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(&quot;Starting&nbsp;baudrate&nbsp;detection&nbsp;on&nbsp;%s,&nbsp;turn&nbsp;on&nbsp;your&nbsp;serial&nbsp;device&nbsp;now.&quot;&nbsp;%&nbsp;port)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(&quot;Press&nbsp;Up/Down&nbsp;to&nbsp;switch&nbsp;baudrates.&quot;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(&quot;Press&nbsp;Ctl+C&nbsp;to&nbsp;quit.&quot;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(&quot;&quot;)<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;baud.Open()<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rate&nbsp;=&nbsp;baud.Detect()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(&quot;\nDetected&nbsp;baudrate:&nbsp;{}&quot;.format(rate))<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;name&nbsp;is&nbsp;None:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(&quot;\nSave&nbsp;minicom&nbsp;configuration&nbsp;as:&nbsp;&quot;,&nbsp;end=&quot;&nbsp;&quot;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name&nbsp;=&nbsp;sys.stdin.readline().strip()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(&quot;&quot;)<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ok,&nbsp;config)&nbsp;=&nbsp;baud.MinicomConfig(name)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;name&nbsp;and&nbsp;name&nbsp;is&nbsp;not&nbsp;None:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;ok:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;run:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(&quot;Configuration&nbsp;saved.&nbsp;Run&nbsp;minicom&nbsp;now&nbsp;[n/Y]?&nbsp;&quot;,&nbsp;end=&quot;&nbsp;&quot;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yn&nbsp;=&nbsp;sys.stdin.readline().strip()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(&quot;&quot;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;yn&nbsp;==&nbsp;&quot;&quot;&nbsp;or&nbsp;yn.lower().startswith(&#39;y&#39;):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;run&nbsp;=&nbsp;True<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;run:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subprocess.call([&quot;minicom&quot;,&nbsp;name])<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(config)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(config)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;except&nbsp;KeyboardInterrupt:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pass<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;baud.Close()<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;main()</div></div><br />	<br />	<br />	<br />	</div><div class='page'><h1 class='title level-3'>使用逻辑分析检测</h1><br/><a href="物联网安全--硬件--逻辑分析仪使用--通过逻辑分析仪测量波特率.html">使用逻辑分析仪测波特率</a></div><div class='page'><h1 class='title level-2'>电工基础</h1><br/>电压表测量电压常识<br />	<a href=""><img src="images\247-1.png" alt="images\247-1.png" /></a><br />	<br />	<br />串口电压不超过 1.7V，焊接容易造成信号衰减，因此采用夹具进行连接读取<br /><br />焊接技巧<br />	<a href="https://space.bilibili.com/399210127/channel/detail?cid=96969">https://space.bilibili.com/399210127/channel/detail?cid=96969</a><br />	<br />QFP封装<br /><a href=""><img src="images\247-2.png" alt="images\247-2.png" /></a><br /><br />QFN封装<br /><a href=""><img src="images\247-3.png" alt="images\247-3.png" /></a><br /><br />SOP封装<br /><a href=""><img src="images\247-4.png" alt="images\247-4.png" /></a></div><div class='page'><h1 class='title level-2'>逻辑分析仪使用</h1><br/><br /><br /></div><div class='page'><h1 class='title level-3'>逻辑分析仪基础概念</h1><br/>逻辑分析仪对电压的具体值和被测信号的一些模拟特性都不进行测量，而是专门针对信号的电平进行测量。事实上，逻辑分析器非常适合目前单片机这一类型的数字系统的测量，非常的便捷。<br /><br />逻辑分析仪的测量原理是采用一定的频率，对输入信号与设定的门限电压进行比较，当输入电平大于门槛电压时为逻辑1，当输入电平低于门槛电压时为逻辑0。</div><div class='page'><h1 class='title level-3'>逻辑分析仪实例</h1><br/>逻辑分析仪实例<br />	例如：一个待测信号使用200Hz采样率的逻辑分析仪，当参考电压设定为1.5V时，在测量时逻辑分析仪就会平均每5ms采取一个点，超过1.5V者为High(逻辑1)，低于1.5V者为Low（逻辑0），而后的逻辑1和0可连接成一个简单波形，工程师便可在此连续波形中找出异常错误（bug）之处。整体而言，逻辑分析仪测量被测信号时，并不会显示出电压值，只是High跟Low的差别；如果要测量电压就一定需要使用示波器。除了电压值的显示不同外，逻辑分析仪与示波器的另一个差别在于通道数量。一般的示波器只有2个通道或4个通道，而逻辑分析仪可以拥有从16个通道、32个通道、64个通道和上百个通道数不等，因此逻辑分析仪具备同时进行多通道测试的优势。<br />	<br />	逻辑分析仪器测量实例<br />	<a href="https://zhuanlan.zhihu.com/p/45728136">https://zhuanlan.zhihu.com/p/45728136</a></div><div class='page'><h1 class='title level-3'>如何选择逻辑分析仪</h1><br/>如何选择逻辑分析仪<br />1. 采样频率。被测信号的频率最好不超过逻辑分析仪最大定时采样频率的1/3，要是想测信号间的时序，那得保证采样频率是被测信号的10倍以上。<br />2. 存储深度。存储深度直接决定了存储数据的时间长短。没有使用压缩存储的情况下，存储深度=采样时间*采样频率 ；使用压缩存储情况下，存储时间就跟信号的变化频率有关。<br />3. 协议插件。确定所购买的逻辑分析仪是否支持所要分析的协议信号。<br />4. 信号通道数。所需测量的信号数量，一般来说，逻辑分析仪有16通道、32通道，64通道，甚至更多。不过关键还是看自己的需要。<br />5. 带宽。被测信号的频率超过逻辑分析仪的带宽，逻辑分析仪就没办法准确捕获信号。<br />6. 输入电平范围。倘若被测信号的电平高于逻辑分析仪的输入电平范围，是会烧坏仪器的。<br />		<br />总线数据抓取能力和协议解析能力是衡量逻辑分析仪性能的重要指标，总线数据抓取能力主要体现在采样率和采样深度两个参数上，通常而言采样率和采样深度越高，数据的失真性就越低，反而则越高，而协议解析能力则是指逻辑分析仪支持解析的硬件协议种类的多寡，逻辑分析仪性能越好，<br />			<br />触发：在测量中,逻辑分析仪必须了解何时开始采集数据，触发设置就是设置在某个特定的状态开始采集，触发包括码型触发、时钟沿触发、定时触发等等，并可结合多种触发方式设置，触发条件是采集数据是否完整的关键。<br /><br />采样率：定每秒从连续信号中提取并组成离散信号的采样个数，单位赫兹（Hz）。采样频率的倒数是采样周期或者叫作采样时间，它是采样之间的时间间隔。通俗而言就是逻辑分析仪每秒钟采集多少个信号样本。<br /><br />存储深度：存储深度是逻辑分析仪每个通道能够连续保存采样点的数量，也就是逻辑分析仪能够测量多长时间的波形。</div><div class='page'><h1 class='title level-3'>通过逻辑分析仪测量波特率</h1><br/>逻辑分析仪测量波特率<br />开始采样之前，需要进行设置,<br />异步采样表示使用逻辑分析仪自身的采样率进行采样，其具体采样频次可以在下面设置，一般而言，采样频率越高越好（过高可能将干扰信号也采集进去，不过软件层面可以进行修正）<br />门限设置表示一个阈值，高于该电压阈值的信号会被识别为1，反之识别为0，因为本次设备uart口电压为3.3v，所以阈值设置为1.65v即可<br /><a href=""><img src="images\716-1.png" alt="images\716-1.png" /></a><br /><br /><br />使用逻辑分析仪上位机软件分析电信号，找到最小的单线脉宽，该数据即发动1bit所耗费的时间，是波特率的倒数<br /><a href=""><img src="images\716-2.png" alt="images\716-2.png" /></a><br /><br />此时最小脉宽为8.66us,接近于常见波特率115200的倒数，所以可以确定该设备波特率为115200<br /><a href=""><img src="images\716-3.png" alt="images\716-3.png" /></a><br /><br />逻辑分析体提供大量的引脚（即通路）以供连接，每一个通路对应被测设备的一路变化的电信号，可以类比为一个uart引脚，逻辑分析仪一个通路测量一路变化的电信号，并将其变化显示在上位机对应通道上<br /><a href=""><img src="images\716-4.png" alt="images\716-4.png" /></a><br /><br />本次使用的逻辑分析仪支持32个通路，分别对应上位机软件中的A0-A15 B0-B15，除此之外，设备还提供了地线接口以及T接口（推测用于连接时钟频率信号）<br /><a href=""><img src="images\716-5.png" alt="images\716-5.png" /></a></div><div class='page'><h1 class='title level-3'>通过逻辑分析仪固件提取</h1><br/><h1>逻辑分析仪固件提取</h1><br />用逻辑分析仪监听flash，ram获取信息。它的优点是不用拆东西，只要把这个东西接上去就可以了，而且这个东西也挺好接的。但缺点是逻辑分析仪目前价格便宜的频率低，但flash一般频率比较高，都是100兆、200兆。我做了一个实验，结果发现确实是可以的。需要把这几个脚引出来，在它启动的时候抓取数据，用夹子夹在芯片上，那个标红色的脚是第一脚。抓在上面以后，通过SPI接口把传输的这个数据保存。<br /><a href=""><img src="images\718-1.png" alt="images\718-1.png" /></a><br />		<br />前面是SPI的命令，命令里面这个是输出的数据。前面第一个是读的意思，这三个应该是地址，后面的是数据。这边是发出的命令，那边是接收的命令，结果是这个逻辑分析仪提取出的东西跟flash里的固件的二进制是一致的，说明这个思路是可行的，我当时找了一个速度稍微慢点的设备，也是可以把固件提取出来的。<br /><a href=""><img src="images\718-2.png" alt="images\718-2.png" /></a><br /><br />通过连接芯片的spi相关引脚是，在设备启动时通过逻辑分析仪抓取其中的数据，因为设备启动时需要从flash芯片中读取固件然后执行，所以会使用spi接口向flash芯片发送命令，读取数据，被读取的数据也从spi引脚上传输，所以如果能识别相关spi命令，即可找到命令中传输的数据，<br /><br />此时需要将逻辑分析仪捕获的电平信号转为十六进制数，将电平信号以8个最小脉宽的长度为一组进行分割，（一个最小脉宽传递1bit数据，8个最小脉宽即为一字节，可以转换为两个十六进制数）每一组代表一个十六进制数，从从而识别spi命令与传输的数据</div><div class='page'><h1 class='title level-3'>周立功逻辑分析手册</h1><br/>使用手册<br /><h1>设置适当的阈值电压</h1><br /><br />阈值电平设置过高<br /><a href=""><img src="images\715-1.png" alt="images\715-1.png" /></a><br /><br />阈值电平设置过低<br /><a href=""><img src="images\715-2.png" alt="images\715-2.png" /></a><br /><br />设置合适的阈值电平<br /> <a href=""><img src="images\715-3.png" alt="images\715-3.png" /></a><br /> <br /><h2>设置适当采样率</h2><br /><br />采样率越高越好<br /><a href=""><img src="images\715-4.png" alt="images\715-4.png" /></a><br /><br /><a href=""><img src="images\715-5.png" alt="images\715-5.png" /></a><br /><br /><a href=""><img src="images\715-6.png" alt="images\715-6.png" /></a><br /><br /><a href=""><img src="images\715-7.png" alt="images\715-7.png" /></a><br />			<br />				<br />					</div><div class='page'><h1 class='title level-2'>硬件操作</h1><br/><br /></div><div class='page'><h1 class='title level-3'>打磨芯片</h1><br/>芯片研磨<br />	通过研磨cpu芯片上层，可以发现芯片引脚的内部连接通路，通过直接连接该内部通路，可以让上位机软件直接与cpu进行通讯，从而进行调试交互（如果直接连接芯片的引脚，则调试可能会受到芯片外部设备的干扰或保护，从而读取失败）<br />	 <br /><br />NAND Flash 使用了环氧树脂防拆，强行拆会把PCB也破坏<br /><a href=""><img src="images\83-1.png" alt="images\83-1.png" /></a><br /><br />因此我们使用砂纸打磨，露出焊盘<br /><a href=""><img src="images\83-2.png" alt="images\83-2.png" /></a><br /><br /><br /><br /></div><div class='page'><h1 class='title level-3'>飞线</h1><br/>飞线操作<br /><a href=""><img src="images\702-1.png" alt="images\702-1.png" /></a><br />推荐使用针管注射器将锡浆注射到对应引脚点位，之后使用飞线连接，电烙铁加热飞线从而间接融化锡球</div><div class='page'><h1 class='title level-3'>清理芯片引脚多余锡</h1><br/>1、通过吸锡带，对芯片引脚进行处理<br />2、通过上松香等助焊膏，用烙铁头将引脚上多余锡浆拖走<br /></div><div class='page'><h1 class='title level-3'>使用烧录座读取emmc</h1><br/>常见烧录座针脚排布情况<br /><a href=""><img src="images\821-1.png" alt="images\821-1.png" /></a><br /><br /><a href=""><img src="images\821-2.png" alt="images\821-2.png" /></a><br /><br />烧录座与编程器锁紧座最下方对齐<br /><a href=""><img src="images\821-3.png" alt="images\821-3.png" /></a><br /><br />芯片摆放<br /><a href=""><img src="images\821-4.png" alt="images\821-4.png" /></a><br />点击智能识别，选择要目标芯片类型，芯片电压，emmc离线读取使用3.3v电压<br />部分emmc工作电压为1.8v<br />但是emmc大多为宽电压供电，可以使用3.3v或1.8v，供电引脚<br />vcc3.3v<br />vccq 根据主控芯片io电压需求决定，如果cpu通讯io电压为1.8v，则该引脚电压即1.8v  <br /><a href=""><img src="images\821-5.png" alt="images\821-5.png" /></a><br /><br /><br /><br />如果芯片读取过程中读取错误，可以尝试按紧烧录座，从而使芯片充分接触<br />或者可以使用EMMC_AUTO_4BIT读取数据，此时使用四根数据线读取数据，<br />而默认的EMMC_AUTO使用8条数据线读取数据，但是可能不稳定（针对闪迪和东芝可能出现该问题）<br /><a href=""><img src="images\821-6.png" alt="images\821-6.png" /></a><br /><br /><br />emmc模式下，点击设置按钮，出现选择emmc区域的选项<br />可以选择读取指定内存区域的数据，rpmb区域一般使用SHA-256加密方式加密，厂商一般不使用，如果使用了，即用于保存加密数据，同时很难被解密<br /><a href=""><img src="images\821-7.png" alt="images\821-7.png" /></a><br /></div><div class='page'><h1 class='title level-3'>使用烧录座写入向emmc写数据</h1><br/><a href=""><img src="images\822-1.png" alt="images\822-1.png" /></a><br /><br /></div><div class='page'><h1 class='title level-3'>芯片植锡</h1><br/>清理植锡网、芯片-》植锡-》上助焊剂用热风枪加热，保证锡球成型-》清理助焊剂<br /><br />热风枪温度<br />锡浆分为低温（138°C），常温（183°C），高温（228°C）三种，热风枪温度设定为锡浆熔点温度增加150°C左右为宜。<br /><br />热风枪风速<br />应设置在2—4档位之间（经典858旋风风枪为例），热风枪的风速或温度过高都会直接影响锡浆成球的效果，温度过高会使锡浆直接沸腾而无法“成球”，风速过快导致锡浆对温度的吸收不充分。<br /><br /><br /><br />• 植锡网需清理干净，上下两个表面清洗，做到无锡球、无杂物、无助焊剂。使用<strong>无铅洗板水</strong>配合小刷子清洗，清洗力度均匀，以免损坏植锡网，每次植锡完成后都应清洗植锡网。<br /><br />◇ 锡浆的选用直接影响热风枪的温度设定，锡浆分为低温（138°C），常温（183°C），高温（228°C）三种，热风枪温度设定为锡浆熔点温度增加150°C左右为宜。<br /><br />• 热风枪风速不宜过大，应设置在2—4档位之间（经典858旋风风枪为例），热风枪的风速或温度过高都会直接影响锡浆成球的效果，温度过高会使锡浆直接沸腾而无法“成球”，风速过快导致锡浆对温度的吸收不充分。<br /><br />◇ <strong>涂铲</strong>锡浆时，锡浆水分不宜过大，水分过大在吹锡成球过程中水分受热蒸发直接影响锡球的成形。<br /><br />◇ 涂抹锡浆时力度要适中，涂锡浆的量不宜过多或过少，过多的涂抹锡浆会造成吹锡成球时锡浆直接冒出植锡网孔；过少的涂抹量将使成形的锡球不够饱满圆润；锡浆刚好填满网孔即可，这样的涂抹量最为合适。<br /><br />◇ 吹锡成球时，热风枪应侧吹，依据芯片的大小选择尺寸相近的热风枪风嘴，最好去掉热风枪风嘴，侧斜方向吹锡成球。<br /><br />◇ BGA芯片经植锡网吹锡成球后，待冷却10s—20s后，轻轻使用镊子或振动植锡网取下植锡完成后的芯片，然后给芯片加适量助焊剂，调高热风枪风量和温度，用防静电镊子适度夹紧芯片，热风枪直吹芯片，这样可以让每个成形的锡球归位至自身焊盘位置，锡球颜色变为<strong>亮白银色</strong>即可。助焊剂的活性温度为320°C左右，把控热风枪出风口温度、风嘴与芯片距离、加热时间、电路板散热情况等因素才能使助焊剂发挥最大作用。<br /><br />◇ 处理芯片焊盘时，电烙铁配合助焊剂，烙铁温度在360°C左右，<strong>电烙铁头轻轻“浮”于焊盘上方，切勿用力过猛损坏焊盘。</strong><br /><br />◇ 芯片除去周围黑胶时，利用热风枪和小号手术刀配合，热风枪间隔给芯片周围加热，用手术刀刀背或刀尖一点点<strong>向上挑起芯片周围黑胶</strong>。电路板焊盘上的黑胶也可以使用手术刀刀背轻轻刮除，切记力度不宜过大。<br /><br />◇ 除胶或者多余锡时，注意电路板降温以及保护周围芯片、元器件不受损伤。<br />◇ <br />◇ 涂抹锡浆、用热风枪加热涂抹完成的锡浆表面时，请特别注意按压<strong>植锡网</strong>力度，<strong>力度做到植锡板与芯片完全接触无多余的缝隙</strong>。<br /><br /><br /><br /></div><div class='page'><h1 class='title level-2'>硬件调试</h1><br/><br /></div><div class='page'><h1 class='title level-3'>JTAG调试</h1><br/>jlink用于调试pcb板上的JTAG接口、ulink类似，也是用于调试某一种类型的接口、stlink用于调试stm开发板</div><div class='page'><h1 class='title level-3'>串口调试</h1><br/>存在可能性，已经正确识别uart口的波特率，但是仍无法正确读取设备输出的数据，可能的原因是设备生产厂商对设备输出进行验证处理，此时在不知道验证机制的情况下，只能尝试直接从芯片中读取数据（将芯片吹下等方法）<br /><br />uart口进行调试时，如果设备供电，可以仅使用TXD RXD两个串口进行调试，无需vcc和gnd<br />	有时如果仅连接TXD RXD，设备在未启动情况下，串口会一直输出异常数据，此时需要同时连接GND引脚，才能保证正确输出<br /><br />如果设备波特率设置正确，但是串口调试输出被加密，此时多需要直接从芯片中读取固件，除非串口调试使用简单的异或加密方法，可以通过观察特定模式，从而解密</div><div class='page'><h1 class='title level-4'>串口调试上位机软件</h1><br/>使用putty进行串口调试可以通过键盘直接与串口进行交互<br /><a href=""><img src="images\747-1.png" alt="images\747-1.png" /></a><br /><br />有时MobaXtermPersonal工具用于串口调试时会显示乱码，因为该工具封装较多，可以使用sscom针对串口消息进行简单查看<br /><br />SecureCRT用法<br />用secureCRT串口工具发送hex字符串的方法<br />		<a href="https://blog.csdn.net/zkw_1998/article/details/103889724">https://blog.csdn.net/zkw_1998/article/details/103889724</a><br />SecureCRT 用法总结<br />		<a href="https://www.jianshu.com/p/8472dcad2e6d?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation">https://www.jianshu.com/p/8472dcad2e6d?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation</a><br />		<br />不同的串口连接软件（putty、串口连接助手、SecureCRT、sscom、minicom）对于串口输出的数据解析方法不同，部分乱码数据可以通过更换串口连接工具从而正常显示<br />putty解析串口输出<br /><a href=""><img src="images\747-2.png" alt="images\747-2.png" /></a><br />sscom对串口的解析<br /><a href=""><img src="images\747-3.png" alt="images\747-3.png" /></a><br /><br /><br />使用SecureCRT连接串口时，需要取消勾选RTS/CTS<br />	用 SecureCRT 连接串口，给机器通上电之后，串口立马输出了启动信息，并可以执行命令，说明串口正确，如果遇到无法输入的情况，首先检查接线是否松动，然后在 SecureCRT 中的， Session Options -&gt; Connection -&gt; Serial -&gt; Flow Control，将原先选中的 RTS/CTS 取消掉，这是因为如果选中了 RTS/CTS ，则硬件上要有对应接口，软件上实现对应协议，才能实现此流控制。如果串口输出为乱码，则需要切换波特率，直至输出正常。<br /><br />连接串口时，键盘选择美式键盘，不要选择中文输入法</div><div class='page'><h1 class='title level-4'>串口调试无法输入输出</h1><br/>厂商硬件做了处理<br /><br />设备出厂前可能做过手脚，将cpu至指定uart引脚之间断路处理，如果将cpu的RXD引脚与uart调试口断路，则uart调试时无法进行输入，反之若TXD引脚断路处理，则设备无法输出信息<br /><br />通过查询芯片手册，确定芯片RXD TXD引脚，追踪新品啊引脚到调试接口的电路（或万用表测通断）确定是否被断路，如果断路，可以尝试使用飞线等方法连接<br />实际工作中，常见电路由于一个缺少一个电阻而断路，所以可以通过增加电阻或连锡联通电路<br /><br />给万用表笔绑上铜线，可以在狭小范围内测量通断情况<br /><a href=""><img src="images\748-1.png" alt="images\748-1.png" /></a><br /><br />实际案例<br /><a href="https://zhuanlan.zhihu.com/p/73875084">https://zhuanlan.zhihu.com/p/73875084</a><br /><a href=""><img src="images\748-2.png" alt="images\748-2.png" /></a><br /><br /><a href=""><img src="images\748-3.png" alt="images\748-3.png" /></a><br /><br /><a href=""><img src="images\748-4.png" alt="images\748-4.png" /></a>		<br />			<br /><a href=""><img src="images\748-5.png" alt="images\748-5.png" /></a><br /><br /><a href=""><img src="images\748-6.png" alt="images\748-6.png" /></a><br /><br /><a href=""><img src="images\748-7.png" alt="images\748-7.png" /></a></div><div class='page'><h1 class='title level-3'>远程调试</h1><br/>使用GDB结合gdbserver远程调试<br /><a href=""><img src="images\344-1.png" alt="images\344-1.png" /></a><br /><br /><br /></div><div class='page'><h1 class='title level-4'>远程调试实例</h1><br/>串口命令开启 telnet 或者 ssh 服务，远程登陆设备。通过系统命令、程序的输出以及 gdb 进行 远程调试，提高调试的便捷性。<br />	<a href=""><img src="images\364-1.png" alt="images\364-1.png" /></a></div><div class='page'><h1 class='title level-2'>硬件仿真器</h1><br/>jlink ulink stlink三种仿真器均可调试jtag<br /><br />资料<br />	各种调试接口与仿真器<br />浅论各种调试接口（SWD、JTAG、Jlink、Ulink、STlink）的区别<br />		<a href="https://www.cnblogs.com/neverguveip/p/9457261.html">https://www.cnblogs.com/neverguveip/p/9457261.html</a><br />	Jlink使用技巧之读取STM32内部的程序<br />（网页已保存为同名截图到本地）<br />		<a href="https://www.cnblogs.com/whik/p/10230141.html">https://www.cnblogs.com/whik/p/10230141.html</a><br />	Jlink使用技巧之单独下载HEX文件到单片机<br />（网页已保存为同名截图到本地）<br />		<a href="https://brands.cnblogs.com/aws/free?source=blog-bannerbar">https://brands.cnblogs.com/aws/free?source=blog-bannerbar</a><br />	jlink使用技巧系列<br />		<a href="https://www.cnblogs.com/whik/p/10282644.html">https://www.cnblogs.com/whik/p/10282644.html</a><br />	jlink指导手册<br />（网页已保存为同名截图到本地）<br />		<a href="https://blog.csdn.net/u013517122/article/details/104008986">https://blog.csdn.net/u013517122/article/details/104008986</a></div><div class='page'><h1 class='title level-3'>jlink</h1><br/><h1>jlink仿真器</h1><br />J-Link接法：VCC（1），SWIO（7），SWCLK（9），GND。使用J-Link在GD32开发板测试通过，最大速度可以设置成50MHz。<br /><a href=""><img src="images\743-1.png" alt="images\743-1.png" /></a><br /><br />在J-Flash中选择调试模式（JTAG或SWD）<br /><a href=""><img src="images\743-2.png" alt="images\743-2.png" /></a><br /><br />针对已经打开的项目选择调试模式<br /><a href=""><img src="images\743-3.png" alt="images\743-3.png" /></a><br /><br />注意速率可以选择自动<br /><a href=""><img src="images\743-4.png" alt="images\743-4.png" /></a><br /><br /><br /><h1>工具包及官方文档</h1><br /><a href="https://wiki.segger.com/J-Link_Commander">https://wiki.segger.com/J-Link_Commander</a><br />官方命令行手册<br /><br /><a href="https://www.segger.com/downloads/jlink/">https://www.segger.com/downloads/jlink/</a><br />选择程序包以及文档下载<br /><a href=""><img src="images\743-5.png" alt="images\743-5.png" /></a><br /><br />工具包中提供的工具<br /><a href=""><img src="images\743-6.png" alt="images\743-6.png" /></a><br /><br />J-Link Commander常用命令<br /><br />usb--------连接目标板<br />r----------重启目标板<br />halt-------停止cpu运行的程序<br />loadbin----加载可执行的二进制文件<br />g----------跳到代码段地址执行<br />s----------单步执行（调试用）<br />setpc-----设置pc寄存器的值（调试用）<br />setbp-----设置断点<br />Regs-------读寄存器组织<br />wreg-------写寄存器<br />mem--------读内存<br />w4---------写内存<br />power off mmu---关闭mmu，这个对于裸板调试很重要<br />w4 cpsr,0x0000001f------切换到系统模式<br />speed------设置jtag的传输速率<br />rce 0,c0,c0,0-----设置cp15寄存器的第1个寄存器为0<br /><br />输vcom enable是开启串口，输vcom disable是关闭串口<br />打开串口后可以通过sscom等串口调试工具查看其发送出来的消息<br /><br /><h1>jlink读取与写入芯片</h1><br />	Jlink使用技巧之读取STM32内部的程序<br />（网页已保存为同名截图到本地）<br />		<a href="https://yq.aliyun.com/articles/686047">https://yq.aliyun.com/articles/686047</a><br />	Jlink使用技巧之单独下载HEX文件到单片机<br />（网页已保存为同名截图到本地）<br />		<a href="https://www.cnblogs.com/whik/p/10223855.html?spm=a2c4e.10696291.0.0.206819a4yqG0NF">https://www.cnblogs.com/whik/p/10223855.html?spm=a2c4e.10696291.0.0.206819a4yqG0NF</a><br />	jlink使用技巧系列<br />（网页已保存为同名截图到本地）<br />		<a href="https://www.cnblogs.com/whik/p/10282644.html">https://www.cnblogs.com/whik/p/10282644.html</a><br /><br /><br /><h1>jlink指导手册</h1><br /><a href="https://blog.csdn.net/u013517122/article/details/104008986">https://blog.csdn.net/u013517122/article/details/104008986</a><br />jlink工具包中的软件<br /><a href=""><img src="images\743-7.png" alt="images\743-7.png" /></a><br /><br /><br />jlink v9仿真器<br /><a href=""><img src="images\743-8.png" alt="images\743-8.png" /></a><br /><br /><a href=""><img src="images\743-9.png" alt="images\743-9.png" /></a><br /><br /><a href=""><img src="images\743-10.png" alt="images\743-10.png" /></a><br /><br /><a href=""><img src="images\743-11.png" alt="images\743-11.png" /></a><br /><br />使用jlink连接swd接口，通过jflash上位机软件直接尝试读取固件，但是jlink不支持高通芯片，导致无法读取<br /><br />	<br />	<br />		<br />		<br /></div><div class='page'><h1 class='title level-3'>stlink</h1><br/>stlink仿真器<br /><br />1. ST-LINK接法：VCC（1），SWIO（7），SWCLK（9），GND。<br />使用STlink在GD32开发板测试通过，最大速度可以设置为4MHz。其中vcc脚作检测目标板电压用，接到目标板的vcc 3.3v上（即目标板的电源），而不是向目标板供电。<br /><a href=""><img src="images\745-1.png" alt="images\745-1.png" /></a><br /><br />stlink文档<br /><a href="https://wiki.diustou.com/ST-LINK/V2_(CN)">https://wiki.diustou.com/ST-LINK/V2_(CN)</a></div><div class='page'><h1 class='title level-3'>ulink</h1><br/>ulink仿真器<br />ulink仿真器（必须配合keli使用）<br /><a href=""><img src="images\744-1.png" alt="images\744-1.png" /></a></div><div class='page'><h1 class='title level-2'>硬件概念</h1><br/><br /></div><div class='page'><h1 class='title level-3'>MCP</h1><br/>Space-saving multichip package (MCP)<br />MCP存储器<br />MCP (Multiple Chip Package) 存储器，MCP是在一个塑料封装外壳内，垂直堆叠大小不同的各类存储器或非存储器芯片，是一种一级单封装的混合技术，用此方法节约小巧印刷电路板PCB空间。</div><div class='page'><h1 class='title level-3'>MCU</h1><br/>为了满足系统集成的需要，主控器厂商（如 ST、NXP 等）把系统正常运行所需的内存（RAM），硬盘（Flash 等可重复擦写、掉电数据不丢失的存储器），CPU（计算核心）和外围接口（用于同外围设备通信）集成到一个芯片中，由于这个芯片通常用于对传感器、电机等外围设备的简单控制，又被称为微型控制单元（MCU）<br /><br /><a href=""><img src="images\357-1.png" alt="images\357-1.png" /></a><br /><a href=""><img src="images\357-2.png" alt="images\357-2.png" /></a></div><div class='page'><h1 class='title level-2'>硬件接口</h1><br/><br /></div><div class='page'><h1 class='title level-3'>I2C</h1><br/><h3>集成电路间是一种短距离通信协议，用于在同一板上的芯片之间进行通信。它是由飞利浦（现在为NXP）发明的。它具有主从（多）架构，并使用两线总线</h3><br />1. SDA –串行数据<br />2. SCL –串行时钟<br /><h3>I2C的一种使用情况是在EEPROM芯片中，该芯片连接到微控制器的I2C引脚，通常存储数据或代码。典型的攻击包括篡改数据，提取敏感信息，破坏数据等。我们应该分析EEPROM芯片上的静态数据，以及通过嗅探I2C通信执行运行时分析以了解行为和安全隐患。如前所述，我们将在系列文章中专门写一篇博客文章，以了解和分析I2C通信。</h3><br /><a href=""><img src="images\393-1.png" alt="images\393-1.png" /></a></div><div class='page'><h1 class='title level-3'>JTAG</h1><br/>JTAG 和 SBW 调试，对连线的长度有严格要求，超过 20 厘米信号会大幅衰减，造成无法调试，因此在探针上利用夹子和铜导线缩小接线距离。<br /><br />引脚<br />TMS –测试模式选择<br />TCK –测试时钟<br />TDI –测试数据输入<br />TDO –测试数据输出<br />TRST –测试复位（可选引脚）<br /></div><div class='page'><h1 class='title level-4'>接口调试</h1><br/><a href=""><img src="images\148-1.png" alt="images\148-1.png" /></a><br /><br />JTAG调试接口<br /><br />JTAG（JTAG和SWD对应arm芯片两种调试模式）<br /><a href=""><img src="images\148-2.png" alt="images\148-2.png" /></a>		<br /><br /><a href=""><img src="images\148-3.png" alt="images\148-3.png" /></a><br /><br /><a href=""><img src="images\148-4.png" alt="images\148-4.png" /></a><br /><br /><a href=""><img src="images\148-5.png" alt="images\148-5.png" /></a></div><div class='page'><h1 class='title level-4'>接口定义</h1><br/><a href=""><img src="images\150-1.png" alt="images\150-1.png" /></a><br />	<br /><a href=""><img src="images\150-2.png" alt="images\150-2.png" /></a><br /><br /></div><div class='page'><h1 class='title level-4'>指令</h1><br/><a href=""><img src="images\149-1.png" alt="images\149-1.png" /></a></div><div class='page'><h1 class='title level-3'>LVDS</h1><br/><a href="中汽研实习--tbox硬件分析--哪吒.html#LVDS(4 pin HSD)">LVDS(4 pin HSD)</a></div><div class='page'><h1 class='title level-3'>RDI</h1><br/>RDI调试接口<br />RDI<br /><a href=""><img src="images\739-1.png" alt="images\739-1.png" /></a></div><div class='page'><h1 class='title level-3'>SPI</h1><br/><h3>串行外设接口也是一种短距离通信协议，用于在同一板上的芯片之间进行通信。它是由摩托罗拉公司开发的。它是全双工的，并使用主从结构（单个主服务器）。与I2C相比，它还具有更高的吞吐量。它使用四线串行总线：</h3><br />1. SCLK –串行时钟。其他名称包括SCK<br />2. MOSI –主输出从站输入。其他名称包括SIMO，SDI，DI，DIN，SI，MTSR。<br />3. MISO –主进从出。其他名称包括SOMI，SDO，DO，DOUT，SO，MRST。<br />4. SS –从机选择。其他名称包括S?S?，SSEL，CS，C?S?，CE，nSS，/ SS，SS＃<br /><h3>它用于与各种外围设备通信。闪存和EEPROM芯片也使用SPI。测试和分析的方法类似于I2C，只是我们具有不同的总线接口。我们将在后面的博客文章中详细讨论SPI。</h3><br /><a href=""><img src="images\394-1.png" alt="images\394-1.png" /></a></div><div class='page'><h1 class='title level-3'>SWD</h1><br/><a href=""><img src="images\146-1.png" alt="images\146-1.png" /></a><br /><br /><h3>SWDIO（双向） SWCLK（时钟）</h3></div><div class='page'><h1 class='title level-4'>仿真器对SWD模式的支持</h1><br/>仿真器对SWD模式的支持情况<br />SWD接口<br /><a href=""><img src="images\740-1.png" alt="images\740-1.png" /></a><br /><a href=""><img src="images\740-2.png" alt="images\740-2.png" /></a><br />		<br />不同版本的jlink所需的swd接口不一样<br /><a href=""><img src="images\740-3.png" alt="images\740-3.png" /></a></div><div class='page'><h1 class='title level-4'>接口调试</h1><br/>SWD调试接口<br /><a href=""><img src="images\738-1.png" alt="images\738-1.png" /></a><br /><br /><a href=""><img src="images\738-2.png" alt="images\738-2.png" /></a><br /><br /><a href=""><img src="images\738-3.png" alt="images\738-3.png" /></a>	<br /><br />SWD接口读取实例<br />电路分析+测试，找到SWDIO和SWDCLK两个关键引脚<br />使用jlink对其进行连接，从而读取其中数据<br /><a href=""><img src="images\738-4.png" alt="images\738-4.png" /></a><br /><br />通过j-flash读取tbox中数据，<br /><a href=""><img src="images\738-5.png" alt="images\738-5.png" /></a><br /><br />经过深入分析固件的信息后，可以分析得到登入的私网 APN 的名称<br />“XXXXXXXXXXXXXXXXXXXXXXXXXAPN”，<br />然后该 APN 的名字可以作为接入内网时的依据<br /><a href=""><img src="images\738-6.png" alt="images\738-6.png" /></a><br /><br />在拆解测试 T-BOX 过程中，经过对硬件模块的分析，发现在 T-BOX 中的<br />EC20 模块的焊接方式未采用 FPGA 的方式。通过飞线接入电脑后可以识别出移<br />远的模块，通过调试安装后得到该模块的对应的驱动程序后，可以获取模块中的<br />APN 内网标识。<br />如下图所示：下图的 EC20 模块通过动态调试接入后可以获取模块中的 APN<br />信息。<br /><a href=""><img src="images\738-7.png" alt="images\738-7.png" /></a><br /><br /><br />通过适配对应驱动程序后可以在电脑中虚拟出一个网卡，虚拟出的该网卡<br />本身就处于 APN 内网中，可以随意访问内网资源。<br /><a href=""><img src="images\738-8.png" alt="images\738-8.png" /></a><br /><br /><a href=""><img src="images\738-9.png" alt="images\738-9.png" /></a><br />				</div><div class='page'><h1 class='title level-3'>TAP</h1><br/><a href=""><img src="images\147-1.png" alt="images\147-1.png" /></a><br /><a href=""><img src="images\147-2.png" alt="images\147-2.png" /></a></div><div class='page'><h1 class='title level-3'>UART</h1><br/><h1>1.UART和RS232是什么关系？</h1><br />	<h3>嵌入式里面说的串口，一般是指UART口， 但是我们经常搞不清楚它和COM口的区别,  以及RS232, TTL等关系,  实际上UART,COM指的物理接口形式(硬件), 而TTL、RS-232是指的电平标准(电信号).</h3><br />	<h3>UART有4个pin（VCC, GND, RX, TX）, 用的TTL电平,  低电平为0(0V)，高电平为1（3.3V或以上）。</h3><br /><a href=""><img src="images\186-1.png" alt="images\186-1.png" /></a>	<br />	<h3>COM口是我们台式机上面常用的口(下图)，9个pin， 用的RS232电平,  它是负逻辑电平，它定义+5~+12V为低电平，而-12~-5V为高电平</h3><br /><a href=""><img src="images\186-2.png" alt="images\186-2.png" /></a><br /><br /><br /><strong><h3>UART的特征</h3></strong><br /><h3>一般uart控制器在嵌入式系统里面都做在cpu一起，像飞思卡尔的IMX6芯片就是这样，有多个uart控制器。</h3><br /><br /><h3>UART(Universal Asynchronization Receviver/Transmite) 可以作为一种软件接口协议来看，包括RS232、RS485、RS422等接口标准规范和总线标准规范，这些标准规定了接口的电气特性(如电平)、传输速率、连接特性等，实际上属于通信网络中的物理层的概念，与通信协议没有直接关系，通信协议一般属于链路层即link层的概念。</h3><br /><h3>那么RS232和TTL的uart什么关系呢？都是uart协议，就像上述提到的，只是电气特性如电平不同。</h3><br /><br /><br /><br /><h1>常见串口引脚定义</h1><br /><a href=""><img src="images\186-3.png" alt="images\186-3.png" /></a><br /><br /><h1>uart数据位</h1><br /><a href=""><img src="images\186-4.png" alt="images\186-4.png" /></a><br /><br /><br /><a href=""><img src="images\186-5.png" alt="images\186-5.png" /></a><br />uart直接与cpu相连，从而进行调试<br /><br /><br />电脑直接连接uart接口<br /><a href=""><img src="images\186-6.png" alt="images\186-6.png" /></a></div><div class='page'><h1 class='title level-4'>uart输出数据格式</h1><br/>uart输出数据传输格式<br /><a href=""><img src="images\719-1.png" alt="images\719-1.png" /></a><br /><a href=""><img src="images\719-2.png" alt="images\719-2.png" /></a><br />	<br />（1）空闲为高电平<br />（2）当要发送数据时，UART 改变 TxD 数据线的状态(变为 0 状态)并维持 1 位的时间──这<br />样接收方检测到开始位后，再等待 1.5 位的时间就开始一位一位地检测数据线的状态得到所传输的数据。<br />（3）UART 一帧中可以有 5、6、7 或 8 位的数据，发送方一位一位地改变数据线的状态将它<br />们发送出去，首先发送最低位。<br />（4）如果使用较验功能，UART 在发送完数据位后，还要发送 1 个较验位。有两种较验方法：<br />奇较验、偶较验──数据位连同较验位中，“1”的数目等于奇数或偶数。<br />（5）最后，发送停止位，数据线恢复到“空闭”状态(1 状态)。停止位的长度有 3 种：1 位、<br />1.5 位、2 位。<br />		<br />一般波特率：波特率115200，8n1  （数据位8位，无奇偶校验，1位停止位）</div><div class='page'><h1 class='title level-4'>uart引脚识别</h1><br/><a href=""><img src="images\363-1.png" alt="images\363-1.png" /></a><br /><br />uart四个引脚的识别<br />vcc和gnd相接会短路，测量两者电压，vcc为供电引脚，故电压为正，接红表笔电压会显示正数<br />红表笔借gnd，黑表笔接地线，电压为零可以用于判断gnd引脚<br />	<br />目测法：供电引脚或地线引脚的形状可能与其他引脚不同，为方形<br />通过测量与设备金属外壳之间的电阻值，从而确定地线（阻值接近于0，万用表带电阻，可以通过短接看待万用表自身阻值）<br />设备启动后，电压稳定为3.3v的引脚一般就是vcc，因为其为供电引脚<br /><br />tx引脚在数据发送时，电压会降低为0，所以该引脚电压特征是从3.3v骤降，然后恢复<br />rx引脚，使用排除法</div><div class='page'><h1 class='title level-4'>数据流控制</h1><br/>	<h3>流控，顾名思义就是流量控制的意思。目的是协调收发双方，使数据不会丢失。</h3><br /><h3> </h3><br />	<h3>很多人用了串口很久都不知道这回事，这是因为很多场合确实没有必要。收发双方波特率固定，并且接受数组足够大，这时不会出现接收方接受数组溢出导致数据丢失的情况，所以，以我的理解，使用流控的主要目的就是在数据量大，有可能出现接受数组溢出的时候，采取的一种协调收发双方的措施。</h3>	<br />	<br />	<a href="https://www.cnblogs.com/aaronLinux/p/5668414.html">[uart]UART中的硬件流控RTS与CTS - aaronGao - 博客园 (cnblogs.com)</a><br /></div><div class='page'><h1 class='title level-5'>软件数据流控制</h1><br/><h1>XON/XOFF</h1><br /><h3>软件流控就不需要RTS和CTS两引脚了，当接收方不想继续接收数据时，通过接收方的TXD给发送方发送一个XOFF信号，发送方接收到这个字符就暂停发送数据；等到接收方可以继续接收数据时，接收方再给发送方发送一个XON信号，于是发送方继续发送数据。因为XON、XOFF信号也是通过数据信号线发送的，所以软件流控在传输二进制数据时可能会出现错误，因为可能你发送的数据里面也有XON、XOFF对应的二进制值。但是这种情况也可以解决，比如对XON、XOFF进行转义。</h3><br /><br />	<h3>一般通过XON/XOFF来实现软件流控制。常用方法是：当接收端的输入缓冲区内数据量超过设定的高位时，就向数据发送端发出XOFF字符（十进制的19或Control-S，设备编程说明书应该有详细阐述），发送端收到XOFF字符后就立即停止发送数据；当接收端的输入缓冲区内数据量低于设定的低位时，就向数据发送端发出XON字符（十进制的17或Control-Q），发送端收到XON字符后就立即开始发送数据。一般可以从设备配套源程序中找到发送的是什么字符。</h3><br /><br /><h3>应该注意，若传输的是二进制数据，标志字符也有可能在数据流中出现而引起误操作，这是软件流控制的缺陷，而硬件流控制不会有这个问题。</h3><br /><br /><br /><br /></div><div class='page'><h1 class='title level-5'>硬件数据流控制</h1><br/><h1>RTS/CTS</h1><br />• RTS - Request To Send<br />• CTS - Clear To Send<br /><br /><h3>流控设计到RTS和CTS两个口，收发双方都有各自的RTS和CTS，如通信双方A,B。那么A的RTS就与B的CTS相连，A的CTS就与B的RTS相连。</h3><br /><br /><h3>RTS的作用是告诉对方我可以接受数据，是输出口；CTS的作用是根据电平高低控制发送或不发生数据。</h3><br /><br /><h3>如：A与B通信，现在A给B发送数据，当B出现某种情况（可能是接受缓存快要满了）的时候，B的RTS拉低（一般拉低表示有效，但也不一定），A的CTS是与B的RTS相连的，则A检测到它的CTS拉低，就知道B在告诉他暂时不要再发了。他就乖乖地停止发送。等到B可以继续接收数据的时候，B的RTS拉高，这时候A的CTS也拉高，A就知道可以继续发送数据了。如果A和B收发情况换一下也是一样的道理。</h3><br /><br /><h3>接收方通过引脚的高低来告知或叫做控制发送方的发送。这种方式不管发送的数据是二进制格式还是字符格式都试用。</h3><br /><br /><h3>硬件流控制必须将相应的电缆线连上，用RTS/CTS（请求发送/清除发送）流控制时，应将通讯两端的RTS、CTS线对应相连，数据终端设备（如计算机）使用RTS来起始调制解调器或其它数据通讯设备的数据流，而数据通讯设备（如调制解调器）则用CTS来起动和暂停来自计算机的数据流。这种硬件握手方式的过程为：我们在编程时根据接收端缓冲区大小设置一个高位标志（可为缓冲区大小的75％）和一个低位标志（可为缓冲区大小的25％），当缓冲区内数据量达到高位时，我们在接收端将CTS线置低电平（送逻辑0），当发送端的程序检测到CTS为低后，就停止发送数据，直到接收端缓冲区的数据量低于低位而将CTS置高电平。RTS则用来标明接收设备有没有准备好接收数据。</h3><br /><h3>常用的流控制还有还有DTR/DSR（数据终端就绪/数据设置就绪）。我们在此不再详述。由于流控制的多样性，我个人认为，当软件里用了流控制时，应做详细的说明，如何接线，如何应用。</h3><br /><br /><br /><h1>DTR/DSR</h1><br />• DTR - Data Terminal Ready<br />• DSR - Data Set Ready<br /><br />。。。。<br /></div><div class='page'><h1 class='title level-3'>USB</h1><br/><a href=""><img src="images\64-1.png" alt="images\64-1.png" /></a></div><div class='page'><h1 class='title level-2'>硬件修改</h1><br/><a href="https://iot-security.wiki/hardware-security/modification/hardware.html">2.6.1 硬改 · 物联网安全百科 (iot-security.wiki)</a><br /></div><div class='page'><h1 class='title level-2'>硬件组成</h1><br/><h1>物联网硬件组成</h1><br /><h2>1.印刷电路板</h2><br /><h2>2.存储芯片可分为</h2><br />ROM芯片（PROM,EPROM,EEPROM，FLASH-ROM）<br />RAM芯片（静态RAM，动态RAM）<br />Flash芯片（SPI/NAND/eMMC）<br />Flash分类<br />NOR Flash<br />CFI Flash<br />SPI Flash<br />NAND Flash<br />MLC Flash<br />SLC Flash<br />TLC Flash<br />TFNAND<br />EMMC<br /><h2>3.电子元器件</h2><br />二极管，三极管，电阻，电解电容，贴片电容，贴片电阻等<br /><h2>4.调试接口</h2><br />UART、JTAG、I2C、SPI等<br /><h2>5.模块</h2><br />蓝牙模块，WiFi模块等<br /><br /></div><div class='page'><h1 class='title level-3'>pcb</h1><br/><a href=""><img src="images\170-1.png" alt="images\170-1.png" /></a><br /></div><div class='page'><h1 class='title level-3'>常见芯片厂商</h1><br/></div><div class='page'><h1 class='title level-4'>NXP</h1><br/><a href=""><img src="images\539-1.png" alt="images\539-1.png" /></a><br /><a href="http://www.nxp.com/">http://www.nxp.com/</a><br /></div><div class='page'><h1 class='title level-4'>TEXAS</h1><br/><a href=""><img src="images\540-1.png" alt="images\540-1.png" /></a><br /><a href="https://www.ti.com/">https://www.ti.com/</a></div><div class='page'><h1 class='title level-4'>飞思卡尔</h1><br/><a href=""><img src="images\836-1.png" alt="images\836-1.png" /></a></div><div class='page'><h1 class='title level-4'>镁光</h1><br/>常见厂商logo 镁光<br /><a href=""><img src="images\538-1.png" alt="images\538-1.png" /></a><br /><a href="https://cn.micron.com/">https://cn.micron.com/</a><br /><br />镁光官网提供支持、包括文档下载功能（仅限英文）<br /><a href="https://www.micron.com/support">https://www.micron.com/support</a><br /><br />镁光支持中提供的使用工具，可以提供芯片功耗计算等功能<br /><a href="https://www.micron.com/support/tools-and-utilities">https://www.micron.com/support/tools-and-utilities</a><br /><br />镁光芯片印字格式解析文档<br /><a href="https://media-www.micron.com/-/media/client/global/documents/products/customer-service-note/csn11.pdf?la=en&rev=5304efc4e5ab4d45bfb1d68d3fb6309a">https://media-www.micron.com/-/media/client/global/documents/products/customer-service-note/csn11.pdf?la=en&amp;rev=5304efc4e5ab4d45bfb1d68d3fb6309a</a><br /><br />镁光提供的FBGA芯片印字查询服务<br /><a href="https://www.micron.com/support/tools-and-utilities/fbga">https://www.micron.com/support/tools-and-utilities/fbga</a><br /><br />搜索jy990找到了对应型号芯片，从而进一步下载datasheet，<br />JY990标号对应MT29RZ4B2DZZHHWD-18I类型芯片<br />下载需要注册<br /><a href="https://www.micron.com/support/tools-and-utilities/fbga?fbga=jy990#pnlFBGA">https://www.micron.com/support/tools-and-utilities/fbga?fbga=jy990#pnlFBGA</a><br /></div><div class='page'><h1 class='title level-4'>三星</h1><br/>芯片印字sec开头<br />例如下图，搜索data时，搜b04q datasheet<br /><a href=""><img src="images\824-1.png" alt="images\824-1.png" /></a><br /><a href=""><img src="images\824-2.png" alt="images\824-2.png" /></a></div><div class='page'><h1 class='title level-3'>存储芯片</h1><br/>存储器类型（除了下图，还有emmc）<br /><a href=""><img src="images\173-1.png" alt="images\173-1.png" /></a><br /><br />存储器特点<br /><a href=""><img src="images\173-2.png" alt="images\173-2.png" /></a><br />NOR FLASH与Nand flash的区别<br />	Nor Flash因为支持单独bit的读写操作，所以可以作为rom存储设备开机的bootloader等代码<br />	Nand flash因为仅支持按块读写内存，所以不能用于带代码执行，常用于存储数据以及系统OS<br /><br />EEPROM与flash的区别<br />	<a href="https://blog.csdn.net/yuanlulu/article/details/6163106">https://blog.csdn.net/yuanlulu/article/details/6163106</a><br />	<br />emmc与Nand flash、Nor flash之间的区别<br /><a href="https://blog.csdn.net/woshishui918/article/details/85056958">https://blog.csdn.net/woshishui918/article/details/85056958</a><br /><a href="https://www.jianshu.com/p/ea84db15c1fa">https://www.jianshu.com/p/ea84db15c1fa</a><br /><br />emmc：全称为embeded MultiMedia Card，是一种嵌入式非易失性存储器系统，由Nand flash和Nand flash控制器组成，以BGA方式封装在一款chip上。<br /><br />Nand flash：一种存储数据介质；若要读取其中的数据，需要外接的主控电路。<br /><br />Nor flash：也是一种存储介质；它的存储空间一般比较小，但它可以不用初始化，可以在其内部运行程序，一般在其存储一些初始化内存的固件代码；<br /><br />这里主要重点讲的是emmc 和Nand flash 之间的区别，主要区别如下：<br />根据工作电压的不同，MMC卡可以分为两类：<br />High Voltage MultiMediaCard，工作电压为3.3V左右。<br />Dual Voltage MultiMediaCard，工作电压有两种，1.70V~1.95V和2.7V~3.6V，CPU可以根据需要切换<br />我所使用的eMMC实测工作电压VCC为2.80V~2.96V，VCCQ为1.70V~1.82V。<br />其中VCC为MMC Controller/Flash Controller的供电电压，VCCQ为Memory和Controller之间I/O的供电。<br />上电初始化阶段MMC时钟频率为400KHz，需要等电压调整到它要求的VCC时（host去获取OCR中记录的电压值，上面有说），MMC时钟才会调整到更高的正常工作频率。<br /><br /><h1>NorFlash</h1><br />NOR Flash需要很长的时间进行抹写，但是它提供完整的寻址与数据总线，并允许随机存取存储器上的任何区域，这使的它非常适合取代老式的ROM芯片。当时ROM芯片主要用来存储几乎不需更新的代码，例如电脑的BIOS或机上盒(Set-top Box)的固件。NOR Flash可以忍受一万到一百万次抹写循环，它同时也是早期的可移除式快闪存储媒体的基础。CompactFlash本来便是以NOR Flash为基础的，虽然它之后跳槽到成本较低的 NAND Flash。<br /><br /><h1>NandFlash</h1><br />NAND Flash式东芝在1989年的国际固态电路研讨会(ISSCC)上发表的， 要在NandFlash上面读写数据，要外部加主控和电路设计。。NAND Flash具有较快的抹写时间, 而且每个存储单元的面积也较小，这让NAND Flash相较于NOR Flash具有较高的存储密度与较低的每比特成本。同时它的可抹除次数也高出NOR Flash十倍。然而NAND Flash 的I/O接口并没有随机存取外部地址总线，它必须以区块性的方式进行读取，NAND Flash典型的区块大小是数百至数千比特。<br />因为多数微处理器与微控制器要求字节等级的随机存取，所以NAND Flash不适合取代那些用以装载程序的ROM。从这样的角度看来，NAND Flash比较像光盘、硬盘这类的次级存储设备。NAND Flash非常适合用于储存卡之类的大量存储设备。第一款创建在NAND Flash基础上的可移除式存储媒体是SmartMedia，此后许多存储媒体也跟着采用NAND Flash，包括MultiMediaCard、Secure Digital、Memory Stick与xD卡。<br /><br /><h1>eMMC</h1><br />eMMC (Embedded Multi Media Card) 为MMC协会所订立的，eMMC 相当于 NandFlash+主控IC ，对外的接口协议与SD、TF卡一样，主要是针对手机或平板电脑等产品的内嵌式存储器标准规格。eMMC的一个明显优势是在封装中集成了一个控制器，它提供标准接口并管理闪存，使得手机厂商就能专注于产品开发的其它部分，并缩短向市场推出产品的时间。这些特点对于希望通过缩小光刻尺寸和降低成本的NAND供应商来说，同样的重要。<br />eMMC由一个嵌入式存储解决方案组成，带有MMC（多媒体卡）接口、快闪存储器设备（Nand Flash）及主控制器，所有都在一个小型的BGA 封装。接口速度高达每秒52MBytes，eMMC具有快速、可升级的性能。同时其接口电压可以是 1.8v 或者是 3.3v。<br /><br /><br />attify课程中对存储芯片的描述<br />内存芯片种类<br /><a href=""><img src="images\173-3.png" alt="images\173-3.png" /></a><br /><br />根据数据存储的时间长短区分SRAM和DRAM<br /><a href=""><img src="images\173-4.png" alt="images\173-4.png" /></a><br />根据数据写入次数将rom分为PROM和EPROMs<br /><a href=""><img src="images\173-5.png" alt="images\173-5.png" /></a><br />EEPROM支持按位擦除数据，flash只能按块擦除数据，前者比后者更昂贵，但后者写入速度更快，<br /><a href=""><img src="images\173-6.png" alt="images\173-6.png" /></a><br /><br />从渗透测试角度看，芯片最重要的点在于其所使用的协议，通过查看datasheet，可以弄清当设备打开时EEPROM或flash芯片是如何通讯的，根据该通讯协议，我们可以与目标设备交互甚至dump固件</div><div class='page'><h1 class='title level-4'>emcp</h1><br/>emcp：即emmc+DDR内存，将rom和ram结合在一起，常用于手机中<br /><br />emmc即控制器+NAND FLASH，向外界提供统一的接口<br /><br />编程器读取而言，emcp和emmc相同，仅仅两者封装不同，转接座不同<br /><br />搜索转接座时，可以同时使用emcp和emmc两个关键字<br /><br />索纳塔10 tbox通讯模块中的存储芯片使用emmcp<br /></div><div class='page'><h1 class='title level-4'>RAM</h1><br/><a href=""><img src="images\175-1.png" alt="images\175-1.png" /></a><br /><br /><a href=""><img src="images\175-2.png" alt="images\175-2.png" /></a><br /><br /><a href=""><img src="images\175-3.png" alt="images\175-3.png" /></a></div><div class='page'><h1 class='title level-4'>ROM</h1><br/><a href=""><img src="images\174-1.png" alt="images\174-1.png" /></a><br />ROM种类<br /><a href=""><img src="images\174-2.png" alt="images\174-2.png" /></a><br /><br /><a href=""><img src="images\174-3.png" alt="images\174-3.png" /></a></div><div class='page'><h1 class='title level-5'>FLASH</h1><br/><a href=""><img src="images\176-1.png" alt="images\176-1.png" /></a><br /><br /><h3>NAND对比NOR，支持XIP，而且读取速度很快，但是写入和擦除速度很慢。NAND 的容量要大很多，速度快，价格也相对便宜，但是可靠性较低。 NAND以块为单位来访问数据，而NOR Flash可以随机访问数据。 </h3><br /><br /><h3>NOR Flash和普通的内存比较像的一点是他们都可以支持随机访问，这使它也具有支持片内执行(XIP, eXecute In Place)的特性，可以像普通ROM一样执行程序。这点让它成为BIOS等开机就要执行的代码的绝佳载体。 与NOR Flash不同的是，NAND不支持XIP，因此不能存放最开始的Bootloader。 </h3><br /><br /><h3> NAND Flash相对NOR Flash更可能发生比特翻转，就必须采用错误探测/错误更正(EDC/ECC)算法，同时NAND Flash随着使用会渐渐产生坏块；通常需要有一个特殊的软件层，实现坏块管理、擦写均衡、ECC、垃圾回收等的功能，这一个软件层称为 FTL（Flash Translation Layer）。根据 FTL 所在的位置的不同，可以把 Flash Memory 分为 Raw Flash 和 Managed Flash 两类： 最早大家都是使用Raw Flash，FTL全由驱动程序实现。后来发展到SD和eMMC等，则由硬主控实现。</h3><br /><a href=""><img src="images\176-2.png" alt="images\176-2.png" /></a><br />CFI SPI是两种接口<br /><br /><br />单级单元 (SLC) NAND 每个单元存储一位信息。一个单元存储 0 或 1，因此可以更快地写入和检索数据。SLC 提供最佳性能和最高耐久性<br />多级单元 (MLC) NAND 每单元存储多个位，尽管 MLC 一词通常意味着每单元两位。MLC 的数据密度比 SLC 高，因此可以实现更大的容量。MLC 在价格、性能和耐久性之间取得良好平衡。<br />三级单元 (TLC) NAND 每单元存储三个位。通过向每单元添加更多位，可以降低成本并提高容量。不过，这对性能和耐久性具有负面影响，<br /><br /></div><div class='page'><h1 class='title level-6'>EMMC</h1><br/><a href=""><img src="images\179-1.png" alt="images\179-1.png" /></a><br /><br />emmc即控制器+NAND FLASH，向外界提供统一的接口<br /><br />其底层还是NAND flash<br /><br />Flash Memory：<br />分为四种区块 ，操作的还是NAND Flash<br />boot：启动相关信息<br />RPMB：安全数据（指纹、密码等），emmc能够检测该块的恶意篡改<br />General Purpose：出厂时一般没有该中区块，类似于磁盘分区，用于存储不同功能数据，可以不划分，可存放操作系统<br />User Data ：可存放操作系统或普通数据<br /><a href=""><img src="images\179-2.png" alt="images\179-2.png" /></a><br /><br /><br />Flash Controller<br /><a href=""><img src="images\179-3.png" alt="images\179-3.png" /></a><br /><br />Host Interface<br /><a href=""><img src="images\179-4.png" alt="images\179-4.png" /></a><br /><br /></div><div class='page'><h1 class='title level-7'>emmc</h1><br/>emmc内存布局以及boot读取<br /><a href="https://www.cnblogs.com/arnoldlu/p/10762009.html">https://www.cnblogs.com/arnoldlu/p/10762009.html</a><br /><a href=""><img src="images\721-1.png" alt="images\721-1.png" /></a><br /><br />eMMC=NAND Flash+闪存控制芯片+标准接口封装<br />emmc支持sd卡协议，可以将emmc数据引脚连接到sd读卡器主控芯片上，从而绕过emmc上自身的主控读取数据<br /><br />emmc封装方式<br />最常见的为BGA153，即回字型的针脚，除此之外还是有BGA162 、BGA169等，数字表示针脚的个数<br /><a href=""><img src="images\721-2.png" alt="images\721-2.png" /></a><br /><br />引脚定义<br /><a href=""><img src="images\721-3.png" alt="images\721-3.png" /></a><br /><br /><a href=""><img src="images\721-4.png" alt="images\721-4.png" /></a><br />			<br /><br />emmc引脚 该种封装方式为BGA153<br /><a href=""><img src="images\721-5.png" alt="images\721-5.png" /></a><br /><br />引脚<br /><a href=""><img src="images\721-6.png" alt="images\721-6.png" /></a><br /><br />实例<br /><a href=""><img src="images\721-7.png" alt="images\721-7.png" /></a><br /><br />引脚功能<br /><a href=""><img src="images\721-8.png" alt="images\721-8.png" /></a><br /><br />VCC 和VCCQ是eMMC的供电脚，VSS通常为线路板的GND地，CLK作为时钟信号，CMD作为双向命令和响应信号，DAT0-DAT7为数据传输接口，当使用烧录座以8BIT模式进行读写时会用到DAT0-DAT7共8个数据接口，使用RT809H编程器飞线读写时只需要用到DAT0（简称D0）数据接口，电源直接由主板供电，再飞线CMD、CLK即可。<br /><br />emmc厂商<br /><a href=""><img src="images\721-9.png" alt="images\721-9.png" /></a><br />emmc烧录器<br /><a href=""><img src="images\721-10.png" alt="images\721-10.png" /></a>		<br /><a href=""><img src="images\721-11.png" alt="images\721-11.png" /></a><br /><br />sd卡接口读取emmc<br /><a href=""><img src="images\721-12.png" alt="images\721-12.png" /></a><br /><br />emmc内部寄存器<br /><a href=""><img src="images\721-13.png" alt="images\721-13.png" /></a><br /><br />内部寄存器<br /><a href=""><img src="images\721-14.png" alt="images\721-14.png" /></a><br /><br />工作模式<br /><a href=""><img src="images\721-15.png" alt="images\721-15.png" /></a><br /><br />nand flash引脚<br /><a href=""><img src="images\721-16.png" alt="images\721-16.png" /></a><br /><br />nand flash中的文件系统<br /><a href=""><img src="images\721-17.png" alt="images\721-17.png" /></a><br /><br />yaffs文件系统<br /><a href=""><img src="images\721-18.png" alt="images\721-18.png" /></a><br /><br />资料来源<br /><a href="https://wenku.baidu.com/view/d50196926bec0975f465e24e.html">https://wenku.baidu.com/view/d50196926bec0975f465e24e.html</a><br /><a href="https://wenku.baidu.com/view/ee1e82ce25c52cc58ad6be0f.html?rec_flag=default">https://wenku.baidu.com/view/ee1e82ce25c52cc58ad6be0f.html?rec_flag=default</a><br /><a href="https://wenku.baidu.com/view/30e483ba960590c69ec376d5.html?rec_flag=default">https://wenku.baidu.com/view/30e483ba960590c69ec376d5.html?rec_flag=default</a></div><div class='page'><h1 class='title level-6'>NAND Flash</h1><br/>NAND Flash<br /><a href=""><img src="images\178-1.png" alt="images\178-1.png" /></a><br /><a href=""><img src="images\178-2.png" alt="images\178-2.png" /></a><br /><br />接口<br /><a href=""><img src="images\178-3.png" alt="images\178-3.png" /></a><br /><br /><br />SPI封装通常应用于NOR flash，但是部分NAND flash也使用了SPI封装，此类NAND的SPI Flash不能直接通过RT809H编程器读取固件，（只有REVELPROG-IS编程器支持读写）需要使用树莓派运行开源FlashROM项目从而提取固件<br /><a href="https://gorgias.me/2019/07/20/%E5%9B%BA%E4%BB%B6%E6%8F%90%E5%8F%96%E7%B3%BB%E5%88%97-%E4%BD%BF%E7%94%A8FlashROM%E8%AF%BB%E5%8F%96Flash/">固件提取系列-使用FlashROM读取Flash - Gorgias&#39;Blog</a><br /><br /><br /></div><div class='page'><h1 class='title level-6'>NOR Flash</h1><br/><h2>NOR Flash</h2><br /><a href=""><img src="images\177-1.png" alt="images\177-1.png" /></a><br /><br /><a href=""><img src="images\177-2.png" alt="images\177-2.png" /></a><br /><br />CFI Flash<br /><a href=""><img src="images\177-3.png" alt="images\177-3.png" /></a><br /><br />SPI Flash<br /><a href=""><img src="images\177-4.png" alt="images\177-4.png" /></a><br /></div><div class='page'><h1 class='title level-3'>模块</h1><br/><a href=""><img src="images\180-1.png" alt="images\180-1.png" /></a><br /><a href=""><img src="images\180-2.png" alt="images\180-2.png" /></a></div><div class='page'><h1 class='title level-3'>通过芯片印字查找datasheet</h1><br/>芯片印字一般分为若干段，如果搜索全部芯片印字没有查找到，可以单独搜索芯片印字部分字段+datasheet，从而找到对应芯片<br /><br />目标芯片<br /><a href=""><img src="images\815-1.png" alt="images\815-1.png" /></a><br /><br />搜索部分芯片印字，<br /><a href=""><img src="images\815-2.png" alt="images\815-2.png" /></a><br /><br /><br />芯片印字可能与芯片实际编号不同，该对应关系需要到对应网站进行查询<br /><a href=""><img src="images\815-3.png" alt="images\815-3.png" /></a><br /><br /></div><div class='page'><h1 class='title level-4'>镁光</h1><br/>镁光FBGA查询：<br />下两图为索纳塔10通讯模块中的存储芯片，均为FBGA162封装，厂商为镁光，而JY990为该类芯片型号关键字，FBGA相关资料如下<br /><a href=""><img src="images\820-1.png" alt="images\820-1.png" /></a><a href=""><img src="images\820-2.png" alt="images\820-2.png" /></a><br /><br /><br />镁光官网提供支持、包括文档下载功能（仅限英文）<br /><a href="https://www.micron.com/support">https://www.micron.com/support</a><br /><br />镁光支持中提供的使用工具，可以提供芯片功耗计算等功能<br /><a href="https://www.micron.com/support/tools-and-utilities">https://www.micron.com/support/tools-and-utilities</a><br /><br />镁光芯片印字格式解析文档<br /><a href="https://media-www.micron.com/-/media/client/global/documents/products/customer-service-note/csn11.pdf?la=en&rev=5304efc4e5ab4d45bfb1d68d3fb6309a">https://media-www.micron.com/-/media/client/global/documents/products/customer-service-note/csn11.pdf?la=en&amp;rev=5304efc4e5ab4d45bfb1d68d3fb6309a</a><br /><br />镁光提供的FBGA芯片印字查询服务<br /><a href="https://www.micron.com/support/tools-and-utilities/fbga">https://www.micron.com/support/tools-and-utilities/fbga</a><br />经查找<br />JY990标号对应MT29RZ4B2DZZHHWD-18I类型芯片<br />搜索jy990找到了对应型号芯片，从而进一步下载datasheet，下载需要注册<br /><a href="https://www.micron.com/support/tools-and-utilities/fbga?fbga=jy990#pnlFBGA">https://www.micron.com/support/tools-and-utilities/fbga?fbga=jy990#pnlFBGA</a><br /></div><div class='page'><h1 class='title level-3'>芯片厂商丝印logo</h1><br/><a href=""><img src="images\536-1.png" alt="images\536-1.png" /></a><br /><a href=""><img src="images\536-2.png" alt="images\536-2.png" /></a><br />该网址用于提供芯片厂商logo<br /><a href="https://www.elnec.com/en/support/ic-logos">https://www.elnec.com/en/support/ic-logos</a><br /></div><div class='page'><h1 class='title level-3'>芯片尺寸</h1><br/>常见BGA封装芯片尺寸<br /><h3>eMMC153/169：10×11mm，11.5×13mm,11.5×13.5mm,12×16mm,12×18mm，14×18mm</h3><br /><br /><h3>eMCP162/186:8×10.5mm，11.5×13mm，12×16mm</h3><br /><br /><h3>eMCP221:11.5×13mm</h3><br /><br />EMMC153/169、EMCP162/186、EMCP221、529翻盖测试座<br />常见限位框尺寸有：10*11、11.5*13、12*16、12*18、14*18、15*15<br /><br />BGA100、BGA152/132翻盖弹片/探针测试座<br />常见限位框尺寸：12*18、14*18<br /><br /></div><div class='page'><h1 class='title level-3'>芯片封装</h1><br/>IC芯片封装大致发展历史<br /><h3>TO→DIP→PLCC→QFP→PGA→BGA→CSP→MCM</h3><br /><br /><a href=""><img src="images\532-1.png" alt="images\532-1.png" /></a><br /><a href=""><img src="images\532-2.png" alt="images\532-2.png" /></a><br /></div><div class='page'><h1 class='title level-4'>28种封装方式</h1><br/><br /><a href=""><img src="images\534-1.png" alt="images\534-1.png" /></a></div><div class='page'><h1 class='title level-4'>FBGA</h1><br/><h2>如果封装尺寸相同，则BGA153/162和FBGA153/162的烧录器可以通用,如果封装尺寸不同，注意需要为烧录座更换对应尺寸的限位框</h2><br />	<br /><h2>对于编程器，即使BGA153和FBGA153引脚定义不相同，但编程器会对芯片引脚进行检测，从而判断芯片类型</h2><br /><br /><h2>在上位机软件中搜索指定封装型号，可以查看编程器是否支持该类芯片</h2><br /><br /><strong>注意</strong>，通讯模块SoC中使用的存储芯片多为FBGA162封装，该种封装类型的芯片与BGA162很相似，并且引脚位置均相同，但是FBGA封装比BGA封装体积小很多，并且虽然引脚位置相同，但是引脚定义完全不一样，所以不能使用读取BGA162的方法读取FBGA162<br /><br />通讯模块中的FBGA162芯片尺寸常为10.5mm x 8mm<br /><br />下两图为索纳塔10通讯模块中的存储芯片，均为FBGA162封装，厂商为镁光，而JY990为该类芯片型号关键字，FBGA相关资料如下<br /><a href=""><img src="images\810-1.png" alt="images\810-1.png" /></a><a href=""><img src="images\810-2.png" alt="images\810-2.png" /></a><br />JY990芯片淘宝<br /><a href="https://item.taobao.com/item.htm?spm=a230r.1.14.16.3063e3aaIbiKSR&id=610829835968&ns=1&abbucket=9#detail">https://item.taobao.com/item.htm?spm=a230r.1.14.16.3063e3aaIbiKSR&amp;id=610829835968&amp;ns=1&amp;abbucket=9#detail</a><br /><br />FBGA封装芯片的datasheet<br /><a href="https://s1.dtsheet.com/store/data/001273105.pdf?key=a7b164a1540d912c4ba6c64073e08e4d&r=1">https://s1.dtsheet.com/store/data/001273105.pdf?key=a7b164a1540d912c4ba6c64073e08e4d&amp;r=1</a><br /><br /><br />镁光FBGA芯片型号搜索<br /><a href="https://www.micron.com/support/tools-and-utilities/fbga">https://www.micron.com/support/tools-and-utilities/fbga</a><br />镁光芯片使用如图5位精简code标识FBGA芯片型号<br />通过搜索该5位精简code标识，可以找到芯片完整定义<br /><a href=""><img src="images\810-3.png" alt="images\810-3.png" /></a><br /><br /><br /><br /></div><div class='page'><h1 class='title level-4'>常见封装方式</h1><br/><br /><a href=""><img src="images\533-1.png" alt="images\533-1.png" /></a></div><div class='page'><h1 class='title level-4'>芯片封装大全</h1><br/><a href="http://www.51hei.com/bbs/dpj-132867-1.html">http://www.51hei.com/bbs/dpj-132867-1.html</a><br /><a href=""><img src="images\811-1.png" alt="images\811-1.png" /></a></div><div class='page'><h1 class='title level-4'>芯片封装技术发展</h1><br/><a href="https://baijiahao.baidu.com/s?id=1610323653705135071&wfr=spider&for=pc">https://baijiahao.baidu.com/s?id=1610323653705135071&amp;wfr=spider&amp;for=pc</a><br /><br /><h3>近世纪，随着集成电路的迅速发展，IC封装技术也随着提高，IC行业应用需求越来越大，集成度也越来越高，封装大致发展历程：TO→DIP→PLCC→QFP→PGA→BGA→CSP→MCM，技术指标一代比一代先进，芯片面积与封装面积比例越来越接近1，电器性能以及可靠性也逐渐提高，体积更加小型化和薄型化。</h3><br /><h3>一、MCM（多芯片组件）</h3><br /><h3>其实这是一种芯片组件，是一种最新技术，它是将多块半导体裸芯片组装在一块布线基板上的一种封装技术，因此它省去了IC的封装材料和工艺，从而节省了材料，同时减少了必要的制造工艺，因此严格的是一种高密度组装产品</h3><br /><a href="https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=469507189,411680538&fm=173&app=25&f=JPEG?w=388&h=384&s=F1B63FD14AB6C4CE1025209E0300F0D0"><img src="images\813-1.png" alt="images\813-1.png" /></a><br /><h3>二、CSP （芯片规模封装）</h3><br /><h3>CSP封装是一种芯片级封装，我们都知道芯片基本上都是以小型化著称，因此CSP封装最新一代的内存芯片封装技术，可以让芯片面积与封装面积之比超过1:1.14，已经相当接近1:1的理想情况，被行业界评为单芯片的最高形式，与BGA封装相比，同等空间下CSP封装可以将存储容量提高三倍。这种封装特点是体积小、输入/输出端数可以很多以及电气性能很好，有CSP BGA(球栅阵列)、LFCSP（引脚架构）、LGA（栅格阵列）、WLCSP（晶圆级）等</h3><br /><h3>1、CSP BGA(球栅阵列)</h3><br /><a href="https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=3637022800,1429535698&fm=173&app=25&f=JPEG?w=343&h=238&s=008C35721EE5528E7DB84C470300A0E2"><img src="images\813-2.png" alt="images\813-2.png" /></a><br /><h3>2、LFCSP（引脚架构）</h3><br /><h3>LFCSP，这种封装类似使用常规塑封电路的引线框架，只是它的尺寸要小些，厚度也薄，并且它的指状焊盘伸人到了芯片内部区域。LFCSP是一种基于引线框的塑封封，封装内部的互连通常是由线焊实现，外部电气连接是通过将外围引脚焊接到PCB来实现。除引脚外，LFCSP常常还有较大的裸露热焊盘，可将其焊接到PCB以改善散热。</h3><br /><a href="https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=1442996576,1126584088&fm=173&app=25&f=JPEG?w=483&h=384&s=4908BF52B0E65EA74F95E01C0100C0E3"><img src="images\813-3.png" alt="images\813-3.png" /></a><br /><h3>3、LGA（栅格阵列）</h3><br /><h3>这是一种栅格阵列封装，有点类似与BGA，只不过BGA是用锡焊死，而LGA则是可以随时解开扣架更换芯片。也就是说相比于BGA而言具有更换性，但是在更换过程当中需要很小心。</h3><br /><a href="https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=3512830130,426869726&fm=173&app=25&f=JPEG?w=538&h=482&s=8EA2EC031890F3ED6A15854B0300A0E3"><img src="images\813-4.png" alt="images\813-4.png" /></a><br /><h3>4、WLCSP（晶圆级）</h3><br /><h3>晶圆片级芯片规模封装不同于传统的芯片封装方式，传统的是先切割再封测，而封装后至少增加原芯片20%的体积，此种最新技术是先在整片晶圆上进行封装和测试，然后才切割成一个个的IC颗粒，因此封装后的体积即等同IC裸晶的原尺寸。</h3><br /><a href="https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=3619455081,1626866005&fm=173&app=25&f=JPEG?w=371&h=285&s=AAA4EC07CCF191FB00295E7C0300F066"><img src="images\813-5.png" alt="images\813-5.png" /></a><br /><h3>三、BGA （球栅阵列）</h3><br /><h3>球形触点阵列，表面贴装型封装之一。在印刷基板的背面按陈列方式制作出球形凸点用以代替引脚，在印刷基板的正面装配LSI 芯片，然后用模压树脂或灌封方法进行密封。也称为凸点陈列载体(PAC)。BGA主要有：PBGA（塑料封装的BGA）、CBGA（陶瓷封装的BGA）、CCBGA（陶瓷柱状封装的BGA）、TBGA（载带状封装的BGA）等。目前应用的BGA封装器件, 按基板的种类,主要CBGA（陶瓷球栅阵列封装）、 PBGA（塑料球栅阵列封装）、TBGA（载带球栅阵列封装）、FC-BGA（倒装球栅阵列封装）、EPBG（增强的塑胶球栅阵列封装）等。</h3><br /><h3>1、CBGA（陶瓷）</h3><br /><h3>CBGA在BGA 封装系列中的历史最长，它的基板是多层陶瓷，金属盖板用密封焊料焊接在基板上，用以保护芯片、引线及焊盘。这是一种为了便于接触, 在底部具有一个焊球阵列的表面安装封装。</h3><br /><h3>2、FCBGA（倒装芯片）</h3><br /><h3>FCBGA通过倒装芯片实现芯片焊料凸点与BGA 基板的直接连接, 在BGA类产品中可实现较高的封装密度,获得更优良的电性能和热性能。</h3><br /><a href="https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=2377324066,1635461666&fm=173&app=25&f=JPEG?w=639&h=534&s=9F032DC847ABBB490ED8050E0300E0D2"><img src="images\813-6.png" alt="images\813-6.png" /></a><br /><h3>3、PBGA（塑料）</h3><br /><h3>BGA封装，它采用BT树脂/玻璃层压板作为基板，以塑料环氧模塑混合物作为密封材料。这种封装芯片对对湿气敏感，不适用于有气密性要求和可靠性要求高的器件的封装场合。</h3><br /><a href="https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=3619711722,1654001326&fm=173&app=25&f=JPEG?w=413&h=348&s=D928AD53C7E776A6EAA49B46030060E1"><img src="images\813-7.png" alt="images\813-7.png" /></a><br /><h3>4、SBGA （带散热器）</h3><br /><h3>SBGA运用先进的基片设计,内含铜质沉热器, 增强散热能力,同时利用可靠的组装工序及物料,确保高度可靠的超卓性能。把高性能与轻巧体积互相结合，典型的35mm SBGA封装的安装后高度少于1.4mm,重量仅有7.09。</h3><br /><a href="https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=3989264704,1659899355&fm=173&app=25&f=JPEG?w=326&h=239&s=21C03C7242F7578A7574954F0300E0E3"><img src="images\813-8.png" alt="images\813-8.png" /></a><br /><h3>四、PGA（引脚栅阵列）</h3><br /><h3>陈列引脚封装。插装型封装之一，其底面的垂直引脚呈陈列状排列。封装基材基本上都采用多层陶瓷基板。用于高速大规模逻辑LSI电路。管脚在芯片底部，一般为正方形，引脚中心距通常为2.54mm，引脚数从64到447左右。一般有CPGA（陶瓷针栅阵列封装）以及PPGA（塑料针栅阵列封装）两种。</h3><br /><a href="https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=2325178094,2017788477&fm=173&app=25&f=JPEG?w=492&h=374&s=49D0AC53F3EED2EC1D75C05E030010E2"><img src="images\813-9.png" alt="images\813-9.png" /></a><br /><h3>五、QFP （四方扁平封装）</h3><br /><h3>这种封装是方型扁平式封装，一般为正方形，四边均有管脚，采用该封装实现的CPU芯片引脚之间距离很小，管脚很细，一般大规模或超大规模集成电路采用这种封装形式，其引脚数一般都在100以上。因其其封装外形尺寸较小，寄生参数减小，适合高频应用。这类封装有：CQFP（陶瓷四方扁平封装）、 PQFP（塑料四方扁平封装）、SSQFP（自焊接式四方扁平封装）、TQFP（纤薄四方扁平封装）、SQFP（缩小四方扁平封装）</h3><br /><h3>1、LQFP（薄型）</h3><br /><h3>这是薄型QFP。指封装本体厚度为1.4mm 的QFP，是日本电子机械工业会根据制定的新QFP外形规格所用的名称。</h3><br /><a href="https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=4153219431,1170533136&fm=173&app=25&f=JPEG?w=391&h=344&s=DEA83C62F39D77C61DD445DE0000E0E2"><img src="images\813-10.png" alt="images\813-10.png" /></a><br /><h3>2、TQFP（纤薄四方扁平）</h3><br /><a href="https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=3118243839,3981603216&fm=173&app=25&f=JPEG?w=317&h=241&s=58083C72538573451F7415CE0000E0A0"><img src="images\813-11.png" alt="images\813-11.png" /></a><br /><h3>六、LCC（带引脚或无引脚芯片载体）</h3><br /><h3>带引脚的陶瓷芯片载体，表面贴装型封装之一，引脚从封装的四个侧面引出，是高速和高频IC用封装，也称为陶瓷QFN或QFN－C。</h3><br /><h3>1、CLCC（翼形引脚）</h3><br /><a href="https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=1490424582,2139629697&fm=173&app=25&f=JPEG?w=524&h=397&s=92B07C23B3C777E7471DD9C40300B0A3"><img src="images\813-12.png" alt="images\813-12.png" /></a><br /><h3>2、LDCC</h3><br /><h3>C型引脚芯片载体,引脚从芯片上方引出向下弯曲成C字型</h3><br /><a href="https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=50089930,1157172970&fm=173&app=25&f=JPEG?w=304&h=210&s=19843C7A555263C40F54D5CE0000E0A1"><img src="images\813-13.png" alt="images\813-13.png" /></a><br /><h3>3、PLCC</h3><br /><h3>引脚从封装的四个侧面引出，呈丁字形,是塑料制品。引脚中心距1.27mm，引脚数从18到84，比QFP容易操作，但焊接后外观检查较为困难。</h3><br /><a href="https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=1727969221,861465952&fm=173&app=25&f=JPEG?w=296&h=215&s=5AA03C6372A553071FD068D60000C0E0"><img src="images\813-14.png" alt="images\813-14.png" /></a><br /><h3>七、SIP（单列直插封装）</h3><br /><h3>单列直插式封装引脚从封装一个侧面引出，排列成一条直线。通常它们是通孔式的，引脚从封装一个侧面引出，排列成一条直线。当装配到印刷基板上时封装呈侧立状。引脚中心距通常为2.54mm，引脚数从2 至23，多数为定制产品。封装的形状各异。</h3><br /><a href="https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=1836121051,2654390051&fm=173&app=25&f=JPEG?w=461&h=419&s=2B94E40229D17EDE14D2567E03008062"><img src="images\813-15.png" alt="images\813-15.png" /></a><br /><h3>八、SOIC（小型IC）</h3><br /><h3>SOIC是一种小外形集成电路封装，外引线数不超过28条的小外形集成电路，一般有宽体和窄体两种封装形式，它比同等的DIP封装减少约30-50%的空间，厚度方面减少约70%。</h3><br /><a href="https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=2905055993,3417375547&fm=173&app=25&f=JPEG?w=291&h=217&s=59883C7273A553076F7D15CE0000A0A3"><img src="images\813-16.png" alt="images\813-16.png" /></a><br /><h3>九、SOP（小型封装）</h3><br /><h3>SOP封装是一种元件封装形式，常见的封装材料有:塑料、陶瓷、玻璃、金属等，现在基本采用塑料封装.，应用范围很广，主要用在各种集成电路中。后面就逐渐有TSOP(薄小外形封装)、VSOP(甚小外形封装)、SSOP(缩小型SOP)、TSSOP(薄的缩小型SOP）、MSOP（微型外廓封装）、 QSOP（四分之一尺寸外形封装）、QVSOP（四分之一体积特小外形封装）等封装。</h3><br /><h3>1、SSOP（缩小型）</h3><br /><a href="https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=738122453,2335834384&fm=173&app=25&f=JPEG?w=300&h=244&s=1AAA7023B3F577863D99D0D60100E0E0"><img src="images\813-17.png" alt="images\813-17.png" /></a><br /><h3>2、TSOP(薄小外形封装)</h3><br /><a href="https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=3928546636,3839083878&fm=173&app=25&f=JPEG?w=305&h=242&s=5AA23C63D3A577175DBC10CE010070E0"><img src="images\813-18.png" alt="images\813-18.png" /></a><br /><h3>3、TSSOP（薄的缩小型）</h3><br /><br /><a href="https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=2431609184,1289747027&fm=173&app=25&f=JPEG?w=343&h=237&s=7BAE3462F9FD5786FF3C11CE000070E0"><img src="images\813-19.png" alt="images\813-19.png" /></a><br /><br /><h3>十、SOT（小型晶体管）</h3><br /><h3>SOT是一种贴片封装，通常引脚在5脚或以下（3脚、4脚）器件的贴片封装形式，尺寸较小，很多晶体管采用此类封装。</h3><br /><a href="https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=3067793605,1302716591&fm=173&app=25&f=JPEG?w=554&h=257&s=C88B62929C3284825401BC4A030030FE"><img src="images\813-20.png" alt="images\813-20.png" /></a><br /><h3>十一、DIP（双列封装）</h3><br /><h3>DIP封装也叫双列直插式封装或者双入线封装，绝大多数中小规模集成电路均采用这种封装形式，其引脚数一般不超过100，采用这种封装方式的芯片有两排引脚，可以直接焊在有DIP结构的芯片插座上或焊在有相同焊孔数的焊位中。其特点是可以很方便地实现PCB板的穿孔焊接，和主板有很好的兼容性。</h3><br /><h3>1、CerDIP（陶瓷双列直插式封装）</h3><br /><h3>Cerdip 陶瓷双列直插式封装，用于ECL RAM，DSP(数字信号处理器)等电路。带有 玻璃窗口的Cerdip 用于紫外线擦除型EPROM 以及内部带有EPROM 的微机电路等</h3><br /><a href="https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=3896015972,619463628&fm=173&app=25&f=JPEG?w=560&h=483&s=50908572A0E74AB66594F8DE0300E0E0"><img src="images\813-21.png" alt="images\813-21.png" /></a><br /><h3>2、PDIP（塑封）</h3><br /><h3>这种我们较为常见，是一种塑料双列直插式封装，适合PCB的穿孔安装，操作方便，可加IC插座调试，但是这种封装尺寸远比芯片大，封装效率很低，占去了很多有效安装面积。</h3><br /><br /><a href="https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=432563423,2629140231&fm=173&app=25&f=JPEG?w=543&h=408&s=03B2EC2223C64AE60D1DA54E0100C0E2"><img src="images\813-22.png" alt="images\813-22.png" /></a><br /><br /><h3>十二、TO（晶体管外形封装）</h3><br /><h3>TO是晶体管外形封装，一类是晶体管封装类，这种能够使引线被表面贴装，另一类是圆形金属外壳封装无表面贴装部件类。这种封装应用很广泛，很多三极管、MOS管、晶闸管等均采用这种封装。</h3><br /><br /><a href="https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=1081625917,1526555520&fm=173&app=25&f=JPEG?w=554&h=378&s=88D867928E2A74884AF04B53030090F5"><img src="images\813-23.png" alt="images\813-23.png" /></a><br /><a href="https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=602477969,3880545765&fm=173&app=25&f=JPEG?w=502&h=468&s=88187392D2CF6DE90250CF43030030F5"><img src="images\813-24.png" alt="images\813-24.png" /></a><br /></div><div class='page'><h1 class='title level-5'>截图</h1><br/><br /><a href=""><img src="images\814-1.png" alt="images\814-1.png" /></a></div></body></html>