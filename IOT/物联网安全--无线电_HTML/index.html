<!doctype html><html>
    <head>
      <meta http-equiv="content-type" content="text/html; charset=utf-8">
      <title>sqliteNoteBook.ctb</title>
      <meta name="generator" content="CherryTree">
      <link rel="stylesheet" href="res/styles3.css" type="text/css" />
    </head>
    <body><div class='page'><h1 class='title level-1'>无线电</h1><br/>看雪iot初级-物联网协议<br />看雪iot中级<br />attify课程无线电部分<br /></div><div class='page'><h1 class='title level-2'>BlueTooth&BLE</h1><br/>看雪iot初级-物联网协议<br />看雪iot中级<br />attify课程无线电部分<br />相关资料 <br /><a href="file://D:\CherryTreeNoteBook\技术思维导图\物联网安全\物联网安全9-BlueTooth和BLE协议初探.xmind">物联网安全9-BlueTooth和BLE协议初探</a>  <br /><a href="file://D:\CherryTreeNoteBook\技术思维导图\物联网安全\物联网安全10-BLE协议嗅探与重放实战.xmind">物联网安全10-BLE协议嗅探与重放实战</a><br /><br /><a href=""><img src="images\314-1.png" alt="images\314-1.png" /></a><br /><br /><a href=""><img src="images\314-2.png" alt="images\314-2.png" /></a><br /><br />关键概念<br /><h2>Service</h2><br />一个低功耗蓝牙设备可以定义许多 Service, Service 可以理解为一个功能的集合。设备中每一个不同的 Service 都有一个 128 bit 的 UUID 作为这个 Service 的独立标志。蓝牙核心规范制定了两种不同的UUID，一种是基本的UUID，一种是代替基本UUID的16位UUID。所有的蓝牙技术联盟定义UUID共用了一个基本的UUID：<br /> 0x0000xxxx-0000-1000-8000-00805F9B34FB<br /> 为了进一步简化基本UUID，每一个蓝牙技术联盟定义的属性有一个唯一的16位UUID，以代替上面的基本UUID的‘x’部分。例如，心率测量特性使用0X2A37作为它的16位UUID，因此它完整的128位UUID为：<br /> 0x00002A37-0000-1000-8000-00805F9B34FB<br /><br /><h2>Characteristic</h2><br />在 Service 下面，又包括了许多的独立数据项，我们把这些独立的数据项称作 Characteristic。同样的，每一个 Characteristic 也有一个唯一的 UUID 作为标识符。在 Android 开发中，建立蓝牙连接后，我们说的通过蓝牙发送数据给外围设备就是往这些 Characteristic 中的 Value 字段写入数据；外围设备发送数据给手机就是监听这些 Charateristic 中的 Value 字段有没有变化，如果发生了变化，手机的 BLE API 就会收到一个监听的回调。<br />更详细的内容可以参见<br /> <a href="https://link.jianshu.com?t=https://www.bluetooth.com/specifications/adopted-specifications">GATT Profile 简介</a><br /> <a href="https://link.jianshu.com?t=http://blog.chinaunix.net/uid-21411227-id-5750680.html">通用属性配置文件（GATT）及其服务，特性与属性介绍</a><br /> <a href="https://link.jianshu.com?t=https://www.bluetooth.com/specifications/generic-attributes-overview">GATT specification</a><br /> <a href="https://link.jianshu.com?t=https://www.bluetooth.com/specifications/gatt/services">GATT Services</a><br /> <a href="https://link.jianshu.com?t=http://blog.csdn.net/u013378580/article/details/52891462">蓝牙【GATT】协议介绍</a></div><div class='page'><h1 class='title level-3'>捕获ble数据包</h1><br/><br /><a href=""><img src="images\371-1.png" alt="images\371-1.png" /></a><br /></div><div class='page'><h1 class='title level-3'>针对手机的蓝牙</h1><br/><br /><a href=""><img src="images\372-1.png" alt="images\372-1.png" /></a></div><div class='page'><h1 class='title level-4'>手机中蓝牙日志的位置</h1><br/><h3>android 8版本，默认位置/data/misc/bluetooth/logs</h3><br /><h3>android 7， 默认位置 /sdcard/</h3><br /><br /><strong>配置hci路径：</strong><br /><h3>/etc/bluetooth/bt_statck.conf</h3><br /></div><div class='page'><h1 class='title level-5'>红米4x MIUI10 获取蓝牙日志</h1><br/>与红米note8pro区别在于<br />打开蓝牙调试日志和蓝牙数据包日志开关两个选项<br /><br />生成的日志位于sdcard目录下，即btsnoop_hci.log<br /><a href=""><img src="images\502-1.png" alt="images\502-1.png" /></a><br /><br />一次蓝牙日志获取完毕后，冲洗你关闭并打开蓝牙调试日志和蓝牙数据包日志开关两个选项<br />从而保证第二次蓝牙日志正常获取<br /></div><div class='page'><h1 class='title level-5'>红米note8pro MIUI12获取蓝牙日志</h1><br/>1.打开开发者选项，打开蓝牙调试日志和蓝牙数据包日志开关（MIUI12中仅有“打开蓝牙数据包日志”）<br />2.在拨号盘输入一次  *#*#5959#*#*  即开始抓蓝牙日志<br />3.操作APP，进行蓝牙通信<br />4.再拨号盘输入一次  *#*#5959#*#*<br />5.等待大概半分钟，在文件管理器中 /sdcard/MIUI/debug_log下会生成蓝牙日志文件<br />如下图，该目录下生成了整个bug报告的压缩包<br /><a href=""><img src="images\501-1.png" alt="images\501-1.png" /></a><br />其中蓝牙hci日志位于一下两个位置，该两位置的蓝牙日志文件均相同<br />bugreport-2020-12-16-162220.zip\common\bt_log20201216_162204\CsLog_2020_1216_162104<br />bugreport-2020-12-16-162220.zip\debuglogger\connsyslog\bthci\CsLog_2020_1216_162104<br /><a href=""><img src="images\501-2.png" alt="images\501-2.png" /></a><br /><br />6.使用wireshark打开蓝牙日志文件<br /><br /><br /></div><div class='page'><h1 class='title level-3'>针对硬件设备</h1><br/><br /><a href=""><img src="images\374-1.png" alt="images\374-1.png" /></a></div><div class='page'><h1 class='title level-2'>MQTT</h1><br/>看雪iot初级-物联网协议<br />看雪iot中级<br />attify课程无线电部分<br /><br /><a href=""><img src="images\316-1.png" alt="images\316-1.png" /></a><br /><br /><a href=""><img src="images\316-2.png" alt="images\316-2.png" /></a><br /><br /><a href=""><img src="images\316-3.png" alt="images\316-3.png" /></a><br /><br />本次测试<br />订阅消息时，-h参数可以指定服务器ip，如果服务器为本机，可省略<br /><a href=""><img src="images\316-4.png" alt="images\316-4.png" /></a><br /><br />抓包MQTT<br />wireshark监听本地回环ip，此时需要使用npacp，在mosquitto工具中自带，可以安装<br /><a href=""><img src="images\316-5.png" alt="images\316-5.png" /></a><a href=""><img src="images\316-6.png" alt="images\316-6.png" /></a><br />抓取tcp2333端口的报文，因为MQTT基于tcp，所以有tcp三次握手<br /><a href=""><img src="images\316-7.png" alt="images\316-7.png" /></a><br /><br /><br />MQTT消息报文<br /><a href=""><img src="images\316-8.png" alt="images\316-8.png" /></a><br /><br />固定头部<br /><a href=""><img src="images\316-9.png" alt="images\316-9.png" /></a><br /><a href=""><img src="images\316-10.png" alt="images\316-10.png" /></a><br /><br />可变头部<br /><a href=""><img src="images\316-11.png" alt="images\316-11.png" /></a><br /><br /><a href=""><img src="images\316-12.png" alt="images\316-12.png" /></a><br /><br /><br /></div><div class='page'><h1 class='title level-2'>RFID</h1><br/>看雪iot初级-物联网协议<br />看雪iot中级<br />attify课程无线电部分<br /><br />相关资料 <br /><a href="file://D:\CherryTreeNoteBook\技术思维导图\物联网安全\物联网安全7-RFID初探.xmind">物联网安全7-RFID初探  </a><br /><a href="file://D:\CherryTreeNoteBook\技术思维导图\物联网安全\物联网安全8-RFID实战：克隆与修改，逆向工程，监听，数据解密等.xmind">物联网安全8-RFID实战：克隆与修改，逆向工程，监听，数据解密等</a></div><div class='page'><h1 class='title level-2'>SDR平台</h1><br/><br /><a href="https://www.cnblogs.com/k1two2/p/4611003.html">https://www.cnblogs.com/k1two2/p/4611003.html</a><br /><span style="color:#17191c;">Great Scott Gadgets生产的HackRF<br />nuand生产的bladeRF<br />Ettus生产的USRP (B200/210)</span><br /><a href=""><img src="images\416-1.png" alt="images\416-1.png" /></a><br /><br />蓝牙<br />ubertooth<br /><a href=""><img src="images\416-2.png" alt="images\416-2.png" /></a><br /><br /><br /><br />zigbee<br /><a href=""><img src="images\416-3.png" alt="images\416-3.png" /></a><br /></div><div class='page'><h1 class='title level-3'>B210</h1><br/><a href="物联网安全--无线电--SDR上位机软件--Universal_radio_hacker--urh_B210_汽车无线钥匙.html">Universal radio hacker + B210 汽车无线钥匙信号抓取、截取分析、重放</a><br /><br /></div><div class='page'><h1 class='title level-4'>荣威汽车钥匙信号</h1><br/>信号1<br /><a href=""><img src="images\517-1.png" alt="images\517-1.png" /></a><br />eaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaf55aa5a6a59a5a6a9a55955955555a5666a95a56596669a9655a56a5802aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaf55aa5a6a59a5a6a9a55955955555a5666a95a56596669a9655a56a5802aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaf55aa5a6a59a5a6a9a55955955555a5666a95a56596669a9655a56a5802aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaf55aa5a6a59a5a6a9a55955955555a5666a95a56596669a9655a56a5802aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaf55aa5a6a59a5a6a9a55955955555a5666a95a56596669a9655a56a5801ffffe<br />7fc7fff8fff7ffffffffbc7ffffdfffffffffffffffffffffffffff7fefffffff7ff7ffffffe0ffbfeffbfffffc7fffffffff80ff83fff7fffffffffffffffffffdfffffffffffbf7ffffffeffffb7ffbfffffe3ffffffff3fffffffffffffffdfffffbeffefffffffffdfeffffffffffffffffffbffff77fffffffff8fffffff7fffffffbeffffffffffffffcc6ffbfffffffffffef8ffffffffffffffffffeffffffffffffffffffffffffffffffffff8ffffffdeffffff5fffffffe3ffffffffffffffe3fffffff7fffffffffbfdffffebfffffffffff1be3efffffffffdfffffffffffffcfb387fdfffffffffffbffffffffffbff7f9ffff807ffff7effffffff77fff7ffffffbfffffffff7dffc7fffffffffdffffffffffffdff77fffffffffffffffffffffffffeee3fbffdfffffffe7f7dbffffffffffffefa7ffffe7ffffeff9dfffffefffffffeffff83fdffffffffffff7ffffffeffdfffbfffffd7ffffffffffff7fffffffffbbfffffdffffffffffbfff07fffbeffffff7fc5bbffc7fffffffe3fffbf7fff7fffbeffffffffffbffffff87bffeff9fffffffffbffd8000<br /> <br /><br />信号2<br /><a href=""><img src="images\517-2.png" alt="images\517-2.png" /></a><br />eaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaf55aa5a6a59a5a6a9a55955955555a566969656969956a99656a559a802aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaf55aa5a6a59a5a6a9a55955955555a566969656969956a99656a559a802aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaf55aa5a6a59a5a6a9a55955955555a566969656969956a99656a559a802aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaf55aa5a6a59a5a6a9a55955955555a566969656969956a99656a559a802aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaf55aa5a6a59a5a6a9a55955955555a566969656969956a99656a559a801fff<br />ffff7fffffffffc1ffdffff7ffffbffe3fffffffffffffffffbffffdc7ffffffffffffffff07ffffffffffffffffffffffffff47ffffffffef7fffbffffffffffffffffffffffffe1ffffffffffffffffffffffffffffffffffdfffffffffffffffffffffffffffffffffffffffffffffffffbfffffffffffffffffbffffffff7fdfffffffffffff7fffffffffffffffffe07fffffffbfffffffffffe07fffcffffffffffffbffffffffbffff7ffffffffffffffffffffffffffffffffffffffffffffffffffc7fffffffffffffff7ffff8fffffffffffffe3ffffffffffffffffffffebfffffff8fffffffffffffffffffffffffffffffffffefffffff07fff1fffffebffffffff1fffeffffffffffffe03ff7fffffffffffff7fff7ffffffffffffcffffff1ffffffffffffffc07fdffffffffffffff9ffffffffffffeffffffffffffffffffffffdfffffffffffffffffffffffffdfffeff7fffffffffffbffffffffffffffffffffffffffffffffffffff7fffffffffffffffffffbbdfffff03ff8fffffc7ffffffffffffffbfbfff7ffffffffff7fffe3ffffffffffffffffc000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<br />信号1与信号2比较，前半部分有相同模式<br /><a href=""><img src="images\517-3.png" alt="images\517-3.png" /></a><br />后半部分无相同模式<br /><a href=""><img src="images\517-4.png" alt="images\517-4.png" /></a><br />经过测试最短的可以开车门的信号（需要多发送几次），与信号1 信号2的不同有关<br /><a href=""><img src="images\517-5.png" alt="images\517-5.png" /></a><br />Bit<br />1111010101011010101001011010011010100101100110100101101001101010100110100101010110010101010110010101010101010101010110100101011001100110101010010101101001010110010110010110011001101001101010010110010101011010010101101010010110000000001<br />Hex<br />f55aa5a6a59a5a6a9a55955955555a5666a95a56596669a9655a56a5802<br /> <br /></div><div class='page'><h1 class='title level-3'>HackRF</h1><br/><br /></div><div class='page'><h1 class='title level-4'>GPS欺骗</h1><br/>GPS欺骗<br />使用工具：HackRF、gps-sdr-sim<br />安装HackRF：<br />sudo apt-get update<br />sudo apt-get install gnuradio<br />sudo apt-get install gqrx-sdr<br />sudo apt-get install hackrf<br />sudo apt-get install libhackrf-dev<br /> <br />连接上HackRF，运行hackrf_info命令显示信息，说明找到设备，安装成功<br />HackRF回显<br />hackrf_info<br /> <br />下载并编译gps-sdr-sim<br />git clone https://github.com/osqzss/gps-sdr-sim.git<br />cd gps-sdr-sim<br />gcc gpssim.c -lm -O3 -o gps-sdr-sim<br /> <br />从如下网址下载星历数据，并进行解压（例如下载brdc3540.14n.Z 文件，解压得到brdc3540.14n，该文件之后会用于生成GPS数据）<br />ftp://cddis.gsfc.nasa.gov/pub/gps/data/daily/2014/brdc<br />生成100秒的GPS信号仿真数据，该命令中31.603202,120.466576即伪造的经纬度<br />生成GPS仿真数据<br />./gps-sdr-sim -e brdc3540.14n -l 31.603202,120.466576,100 -b 8 -d 100<br />发射GPS仿真数据<br />hackrf_transfer -t gpssim.bin -f 1575420000 -s 2600000 -a 1 -x 0<br /> <br />检测GPS信号伪造效果<br />以小米手机为例，旧版本的小米手机中可以设置手机仅使用GPS进行定位，具体设置方法为：<br />设置-&gt;更多设置-&gt;系统安全-&gt;位置信息→仅限设备（使用GPS确定位置）<br />之后，手机中安装APP“GPS工具箱”，使用该APP即可查看手机当前GPS位置，并在发射GPS仿真数据后，查看到GPS信息修改为伪造信息。<br /></div><div class='page'><h1 class='title level-4'>汽车钥匙重放</h1><br/>汽车钥匙重放<br />1.前置条件：<br />HackRF one   Ubuntu系统<br />USB数据线    gqrx<br /> <br />hackrf<br />打开已经装好的Ubuntu系统对gqrx和hackrf上位机工具进行安装<br />执行命令如下：<br />安装hackrf上位机工具<br />sudo apt install hackrf<br />安装gqrx<br />sudo apt-get install gqrx-sdr<br /> <br />2.安装成功后，在shell中输入gqrx并敲击回车，会提示如图1所示信息：<br /><a href="file:///C:\Users\Q\AppData\Local\Temp\msohtmlclip1\01\clip_image002.jpg"><img src="images\337-1.png" alt="images\337-1.png" /></a><br />图2 gqrx软件主界面示意图<br /> <br />4.在主界面选择右边的Frequency输入款里面输入433000.000（通常车钥匙的频率为433或者443），点击左上角的监听按钮开始监听，如图3所示。<br /><a href="file:///C:\Users\Q\AppData\Local\Temp\msohtmlclip1\01\clip_image003.png"><img src="images\337-2.png" alt="images\337-2.png" /></a><br />图4 车钥匙频率图<br /> <br />6.通过图4可知车钥匙的频率为434427.136，可以近似为434000.000kHz。<br /> <br />7.将车钥匙远离汽车，运行以下命令进行录制，在录制期间按车钥匙的开锁键进行信号录制。<br />车钥匙信号录制<br />hackrf_transfer -r WMopen.raw -f 434000000 -g 16 -l 32 -a 1 -s 8000000 -b 4000000<br /> <br />其中hackrf_transfer为录制和释放信号的固定命令开头，-r为将要录制的信号放入后面指定文件名的文件中；-f是录制的频率；-g为指定的基带大小；-l为增益大小；-a为1是开启信号放大，0未关闭；-s是接收的数据流缓冲区大小；-b是设置基带滤波器的带宽，以HZ为单位。<br /> <br />8.录制好命令后带着HackRF进入到车的有效感应范围进行信号的重放，重放命令如下：<br />车钥匙信号重放命令<br />hackrf_transfer -t WMopen.raw -f 434000000 -x 47 -a 1 -s 8000000 -b 4000000<br />出现错误，断开虚拟机与HackRF的连接进行重连即可避免此问题。<br /></div><div class='page'><h1 class='title level-3'>ubertooth</h1><br/>相关概念<br /><strong><h2>蓝牙地址</h2></strong><br /><h3> BD_ADDR：BluetoothDevice Address；</h3><br /><h3> LAP:LowerAddress Part 低地址部分；</h3><br /><h3> UAP: UpperAddress Part 高地址部分；</h3><br /><h3> NAP: Non-significantAddress Part 无效地址部分。<br /></h3><a href="https://img-blog.csdn.net/20140730181920765?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHViaW4zNDE3MTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"><img src="images\473-1.png" alt="images\473-1.png" /></a><br /><br /><strong><h2>蓝牙时钟</h2></strong><strong><br /></strong><h3> 每个蓝牙设备都有一个独立运行的内部系统时钟，称为本地时钟（Local Clock），决定定时器的收发跳频。为了与其他设备同步，本地时钟要加一个偏移量（offset），提供给其他设备同步。<br /> 蓝牙基带四个关键周期：</h3><strong><h3>312.5uS、625uS、1.25mS、1.28S</h3></strong><h3>。</h3><br /><a href="https://img-blog.csdn.net/20140730182026078?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHViaW4zNDE3MTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"><img src="images\473-2.png" alt="images\473-2.png" /></a><br /><strong><h3>CLKN：</h3></strong><h3>本地时钟：<br /></h3><strong><h3>CLKE:</h3></strong><h3>预计时钟，扫描寻呼过程中用到；<br /></h3><strong><h3>CLK：</h3></strong><h3>设备实际运行的时钟频率。<br />CLKE、CLK由CLKN加上一个偏移量得到的。<br /></h3><a href="https://img-blog.csdn.net/20140730182326952?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHViaW4zNDE3MTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"><img src="images\473-3.png" alt="images\473-3.png" /></a><br /><br /></div><div class='page'><h1 class='title level-4'>ubertooth结果分析</h1><br/>ubertooth-rx -z -q /test.pcap<br /><a href=""><img src="images\493-1.png" alt="images\493-1.png" /></a><br /><a href=""><img src="images\493-2.png" alt="images\493-2.png" /></a><br />该命令输出结果中，LAP表示设备低地址部分<br />该命令最终目的是发现周围设备，所以指令执行完毕后会输出发现的设备<br /><br /><a href=""><img src="images\493-3.png" alt="images\493-3.png" /></a><br />同样的可以在wireshark查看抓取到的数据包，其中可以看到LAP，用于标识地址<br /><br /><br /><br />ubertooth-rx -l a3e8db<br /><br /><br /></div><div class='page'><h1 class='title level-4'>wireshark解析ble包</h1><br/><h3>Edit → Preferences → Protocols → DLT_USER → Edit → New </h3><br /><h3>在payload protocol中输入btle</h3><br /></div><div class='page'><h1 class='title level-4'>wireshark实时输出数据包</h1><br/><h2>Wireshark设置</h2><br /><h3>到了这一步，前期准备工作就都完成了。现在需要把Ubertooth和Wireshark进行联动，将Ubertooth收集到的数据传到Wireshark进行解析。这里主要参考</h3><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Capturing-BLE-in-Wireshark">官方Wiki</a><h3>，步骤如下：</h3><br /><h3>1.在终端中运行命令：</h3><code><h3>mkfifo /tmp/pipe</h3></code><br /><h3>2.打开Wireshark，选择 &#39;Capture -&gt; Options&#39; 对抓包接口进行设置</h3><br /><h3>3.点击右下角 ‘Manage Interfaces’ 对接口进行管理</h3><br /><h3>4.切换到 &#39;Pipes&#39; 选项卡</h3><br /><h3>5.保存设置，选中 &#39;/tmp/pipe&#39; 并点击开始</h3><br /><h3>6.此时，在终端中运行命令：</h3><code><h3>ubertooth-btle -f -c /tmp/pipe</h3></code><br /><a href="https://image.3001.net/images/20190711/1562814350_5d26a78e58160.png!small"><img src="images\492-1.png" alt="images\492-1.png" /></a><br /><h3>切回Wireshark，应该可以看到滚动的数据包了。</h3><br /><h3>这里有一点需要注意，“mkfifo /tmp/pipe” 命令需要在所有步骤前进行，即先创建pipe这个文件，再设置wireshark读取，最后用Ubertooth-btle命令写入，顺序错了是会不成功的。</h3><br /><br />wireshark实时抓包ble<br />ubertooth-btle -f -c /tmp/pipe<br /><br />wireshark实时输出经典蓝牙数据<br />ubertooth-rx -z -q /tmp/pipe<br /></div><div class='page'><h1 class='title level-4'>安装与ble抓包</h1><br/>环境：信睿网络镜像<br /><br /><h2>安装编译环境</h2><br />sudo apt-get install cmake libusb-1.0-0-dev make gcc g++ libbluetooth-dev \ pkg-config libpcap-dev python-numpy python-pyside python-qt4<br /><br />注意整个命令是一整条 ，\ 会将整个命令分为两节，后半部分pkg-config libpcap-dev python-numpy python-pyside python-qt4可以在&gt;之后写上<br /><br /><br /><h2>安装 libbtbb 库</h2><br />wget https://github.com/greatscottgadgets/libbtbb/archive/2018-12-R1.tar.gz -O libbtbb-2018-12-R1.tar.gz<br />tar -xf libbtbb-2018-12-R1.tar.gz<br />cd libbtbb-2018-12-R1<br />mkdir build<br />cd build<br />cmake ..<br />make<br />sudo make install<br /><br /><br /><h2>安装 Ubertooth 工具</h2><br />wget https://github.com/greatscottgadgets/ubertooth/releases/download/2018-12-R1/ubertooth-2018-12-R1.tar.xz tar xf ubertooth-2018-12-R1.tar.xz <br />cd ubertooth-2018-12-R1/host <br />mkdir build <br />cd build <br />cmake .. <br />make <br />sudo make install<br /><br /><h2>刷新固件</h2><br />进入DFU模式（类似与安卓刷机前进入bootloader中）<br />用“金属或铁丝”之类的东西，把这两个孔连接，然后重新插入，设备灯光会变成跑马灯<br /><a href=""><img src="images\476-1.png" alt="images\476-1.png" /></a><br /><br />进入之前下载的ubertooth-2018-12-R1的ubertooth-one-firmware-bin目录下<br /><a href=""><img src="images\476-2.png" alt="images\476-2.png" /></a><br />执行更新固件的命令<br /><h3>ubertooth-dfu -d bluetooth_rxtx.dfu -r</h3><br /><br />若固件升级完毕，则返回如下输出<br />iot@ubuntu:~/Desktop/new/ubertooth-2018-12-R1/ubertooth-one-firmware-bin$ ubertooth-dfu -d bluetooth_rxtx.dfu -r<br />Checking firmware signature<br />........................................<br />........................................<br />........................................<br />.<br />Detached<br />iot@ubuntu:~/Desktop/new/ubertooth-2018-12-R1/ubertooth-one-firmware-bin$ <br /><br /><br />使用如下命令查看固件版本，当前最新版本即为2018-12-R1 <br />$ ubertooth-util -v <br />Firmware version: 2018-12-R1 (API:1.05)<br /><br /><h2>抓取ble包并保存</h2><br />之后可以使用<strong><small>ubertooth-btle -f -c test.pcap</small></strong>将抓取的ble包保存到本地<br />注意依照上面安装流程，仅上面的抓包命令运行成功，相关命令可能运行失败<br /><br /><br /></div><div class='page'><h1 class='title level-4'>可能的报错及其解决方案</h1><br/><h2>安装过程中如果报缺少库的错误，则执行如下指令</h2><br />报错：<br />error while loading shared libraries: libubertooth.so.1: cannot open shared object file: No such file or directory<br /><br />解决方案：<br />sudo ldconfig<br /><br /></div><div class='page'><h1 class='title level-4'>抓包传统蓝牙</h1><br/>ubertooth命令手册<br /><a href="https://github.com/greatscottgadgets/ubertooth/tree/master/host/doc">https://github.com/greatscottgadgets/ubertooth/tree/master/host/doc</a><br /><br />ubertooth基本命令<br /><a href="https://github.com/greatscottgadgets/ubertooth/blob/master/host/doc/ubertooth.md">https://github.com/greatscottgadgets/ubertooth/blob/master/host/doc/ubertooth.md</a><br /><h3>Useful commands:</h3><br />• ubertooth-btle(1) : BLE sniffing and other fun<br />• ubertooth-rx(1) : Classic Bluetooth device discovery and rudimentary sniffing<br />• ubertooth-scan(1) : Active scanning of undiscoverable devices<br />• ubertooth-afh(1) : Detecting the AFH map of a Classic Bluetooth piconet<br />• ubertooth-ego(1) : Yuneec E-Go electric skateboard sniffing<br /><br /><h3>Utility commands:</h3><br />◇ ubertooth-dfu(1) : Firmware update tool<br />◇ ubertooth-dump(1) : Dumping raw RF symbols to disk<br />◇ ubertooth-util(1) : &quot;Everything else&quot;<br /><br /><h3>Less useful commands:</h3><br />◇ ubertooth-debug(1) : Peeking and poking registers on the CC2400<br />◇ ubertooth-specan(1) : Raw RSSI values used by graphical specan<br /><br /><br /><br />ubertooth-scan命令：用于识别周围蓝牙设备，需要结合蓝牙加密狗设备一起使用<br /><a href="https://github.com/greatscottgadgets/ubertooth/blob/master/host/doc/ubertooth-scan.md">https://github.com/greatscottgadgets/ubertooth/blob/master/host/doc/ubertooth-scan.md</a><br /><br /><br />识别周围蓝牙信号的命令<br />ubertooth-rx -z<br />ubertooth-rx -z -t 20<br /><br />-rx即检测经典蓝牙 <br />-z使用测量模式，即发现一定区域内所有蓝牙设备 <br />-t指定时间，检测20秒<br />-q将捕获数据保存到pcap文件中<br /><br /><br /><a href="https://github.com/greatscottgadgets/ubertooth/issues/322">https://github.com/greatscottgadgets/ubertooth/issues/322</a><br /><a href="https://github.com/greatscottgadgets/ubertooth/issues/298">https://github.com/greatscottgadgets/ubertooth/issues/298</a></div><div class='page'><h1 class='title level-4'>资料参考</h1><br/><a href="https://www.fujieace.com/hacker/ubertooth-one.html">https://www.fujieace.com/hacker/ubertooth-one.html</a><br /><a href="https://www.freebuf.com/articles/wireless/106298.html">https://www.freebuf.com/articles/wireless/106298.html</a><br /><a href="https://www.freebuf.com/articles/network/208073.html">https://www.freebuf.com/articles/network/208073.html</a><br /><br /><br /></div><div class='page'><h1 class='title level-5'>Ubertooth one“蓝牙扫描嗅探”使用教程</h1><br/><a href="https://www.fujieace.com/hacker/ubertooth-one.html">Ubertooth one“蓝牙扫描嗅探”使用教程 - 付杰博客 (fujieace.com)</a><br /><br /><h1>Ubertooth one“蓝牙扫描嗅探”使用教程</h1><br /><h3>Ubertooth One是一款开源蓝牙扫描嗅探器，当然了，也可以扫描嗅探</h3><strong><h3>低功耗蓝牙</h3></strong><h3>，Ubertooth One是适用于蓝牙实验的开源2.4 GHz无线开发平台。</h3><br /><h3>蓝牙低能耗（Bluetooth Low Energy，或称Bluetooth LE、BLE，旧商标Bluetooth Smart）也称低功耗蓝牙，是蓝牙技术联盟设计和销售的一种个人局域网技术，旨在用于医疗保健、运动健身、信标、安防、家庭娱乐等领域的新兴应用。相较经典蓝牙，低功耗蓝牙旨在保持同等通信范围的同时显著降低功耗和成本。</h3><br /><h3> </h3><br /><h3>由于我个人对硬件无线网这方面比较感兴趣，今年1月份我也入手了一个“Ubertooth one”硬件，按照freebuf和github的教程，搞了很长一段时间依然没有搞明白，没有成功，我还以为是我购买的硬件有问题。</h3><br /><h3>时隔多月，终于：今天，在高手的指导下，我总算研究明白了，Ubertooth one搞成功了，具体的操作过程如下：</h3><br /><h3> </h3><br /><br /><h2>一、先决条件</h2><br /><h3>在操作之前，确保我们的操作系统满足这些条件，请根据个人的系统来执行相应的命令，具体如下：</h3><br /><h3> </h3><br /><h3>Debian / Ubuntu</h3><br /><code>sudo apt-get </code><code><h3>install</h3></code><code> cmake libusb</code><code><h3>-1.0-0</h3></code><code>-dev make gcc </code><code><h3>g</h3></code><code>++ libbluetooth-dev \<br />pkg-config libpcap-dev python-numpy python-pyside python-qt4</code><h3> </h3><br /><h3>Fedora / Red Hat</h3><br /><code><h3>su</h3></code><code> -c </code><code><h3>&quot;yum install libusb1-devel make gcc wget tar bluez-libs-devel&quot;</h3></code><h3> </h3><br /><h3>如果你是其它的操作系统，请参考官方文档：</h3><br /><h3>https://github.com/greatscottgadgets/ubertooth/wiki/Build-Guide</h3><br /><h3> </h3><br /><br /><h2>二、安装 libbtbb 库</h2><br /><code>wget https://github.com/greatscottgadgets/libbtbb/archive/2018-12-R1.tar.gz -O libbtbb-2018-12-R1.tar.gz<br />tar -xf libbtbb-2018-12-R1.tar.gz<br /></code><code><h3>cd</h3></code><code> libbtbb-2018-12-R1<br />mkdir build<br /></code><code><h3>cd</h3></code><code> build<br />cmake ..<br />make<br />sudo make install</code><h3> </h3><br /><br /><h2>三、安装 Ubertooth 工具</h2><br /><h3>Ubertooth存储库包含用于嗅探蓝牙数据包，配置Ubertooth和更新固件的主机代码。所有这三个都是默认使用以下方法构建和安装的：</h3><br /><code>wget </code><code><h3>https:</h3></code><code>/</code><code><h3>/github.com/greatscottgadgets/ubertooth/releases/download/2018</h3></code><code>-</code><code><h3>12</h3></code><code>-R1/ubertooth-</code><code><h3>2018</h3></code><code>-</code><code><h3>12</h3></code><code>-R1.tar.xz<br />tar xf ubertooth-</code><code><h3>2018</h3></code><code>-</code><code><h3>12</h3></code><code>-R1.tar.xz<br />cd ubertooth-</code><code><h3>2018</h3></code><code>-</code><code><h3>12</h3></code><code>-R1/host<br />mkdir build<br />cd build<br />cmake ..<br />make<br />sudo make install</code><h3> </h3><br /><br /><h2>四、Ubertooth one 刷新固件</h2><br /><h3>由于我是新购买的 Ubertooth one ，固件是需要自己刷的，如果你也是新手的话，很容易踩这个坑。以我自己购买的这个硬件为例子，Ubertooth one刷新固件具体操作步骤如下：</h3><br /><h3> </h3><br /><strong><h3>1、进入DFU模式</h3></strong><br /><h3>如果不进入DFU模式是刷新不了固件的，我们常 说的手机刷系统一般进入的是fastboot模式，这个原理有点类似。</h3><br /><h3> </h3><br /><h3>如何进入Ubertooth one的DFU模式？这里我要重点说一下：</h3><br /><h3> </h3><br /><h3>首先：用“金属或铁丝”之类的东西，把这两个孔连接。</h3><br /><h3> </h3><br /><h3>我放大一下，大家再仔细看一下这两个连接的孔：</h3><br /><br /><h3> </h3><br /><h3>其次：再插入USB，看见LED灯和之前的闪烁方式不一样了，就说明进入DFU模式了。</h3><br /><h3> </h3><br /><strong><h3>2、刷新固件</h3></strong><br /><h3>关于Ubertooth one刷新固件知识可以参考：https://github.com/greatscottgadgets/ubertooth/wiki/Firmware</h3><br /><h3> </h3><br /><h3>我的操作具体步骤命令如下：</h3><br /><h3> </h3><br /><code>首先：获取最新的固件版本<br />$ wget </code><code><h3>https:</h3></code><code>/</code><code><h3>/github.com/greatscottgadgets/ubertooth/releases/download/2018</h3></code><code>-</code><code><h3>12</h3></code><code>-R1/ubertooth-</code><code><h3>2018</h3></code><code>-</code><code><h3>12</h3></code><code>-R1.tar.xz<br /><br />其次：解压缩<br />$ tar xf ubertooth-</code><code><h3>2018</h3></code><code>-</code><code><h3>12</h3></code><code>-R1.tar.xz<br /><br />再次：进入ubertooth-one-firmware-bin目录<br />$ cd ubertooth-</code><code><h3>2018</h3></code><code>-</code><code><h3>12</h3></code><code>-R1/ubertooth-one-firmware-bin<br /><br />最后：执行更新固件命令<br />$ ubertooth-dfu -d bluetooth_rxtx.dfu -r</code><h3> </h3><br /><h3>查看自己的固件版本命令：</h3><br /><code>$ ubertooth-util -v<br />Firmware </code><code><h3>version:</h3></code><code> </code><code><h3>2018</h3></code><code>-</code><code><h3>12</h3></code><code>-R1 (</code><code><h3>API:</h3></code><code><h3>1.05</h3></code><code>)</code><h3> </h3><br /><br /><h2>五、开始使用 Ubertooth one 扫描或嗅探蓝牙</h2><br /><h3>由于Ubertooth one是一款蓝牙硬件，我们只需要用相应的扫描或嗅探蓝牙软件搭配起来就可以直接使用了。</h3><br /><h3>以下都是一些扫描或嗅探蓝牙的工具，也可以称为Linux命令，如果有不会用任何一个工具的？完全可以用  --help 查看具体的用法以及各个功能是什么？</h3><br /><h3> </h3><br /><strong><h3>1、hcitool</h3></strong><br /><h3>hcitool scan：扫描附近蓝牙设备</h3><br /><h3>hcitool lescan：扫描附近低功耗蓝牙设备</h3><br /><h3> </h3><br /><strong><h3>2、ubertooth-scan</h3></strong><br /><h3> </h3><br /><strong><h3>3、ubertooth-specan-ui</h3></strong><br /><h3> </h3><br /><strong><h3>4、spectool</h3></strong><br /><h3> </h3><br /><strong><h3>5、gatttool</h3></strong><br /><br /><br /></div><div class='page'><h1 class='title level-5'>蓝牙技术概述</h1><br/><a href="https://blog.csdn.net/xubin341719/article/details/38145507">https://blog.csdn.net/xubin341719/article/details/38145507</a><br /></div><div class='page'><h1 class='title level-5'>使用Ubertooth监听蓝牙通信</h1><br/><a href="https://www.freebuf.com/articles/network/208073.html">使用Ubertooth监听蓝牙通信 - FreeBuf网络安全行业门户</a><br /><h2>使用Ubertooth监听蓝牙通信</h2><br /><a href="https://www.freebuf.com/author/MactavishMeng">MactavishMeng </a>2019-07-11 11:14:31 654996<br /><br /><strong><h3>作为没有使用过Ubertooth的小白，尝试从零开始搭建Ubertooth的环境，相关配置、依赖，来进行蓝牙数据的监听，配合Wireshark，进行蓝牙数据监听和分析。</h3></strong><br /><br /><br /><h2>环境说明</h2><br /><h3>VMWare版本：14.0.0 build-6661328</h3><br /><h3>操作系统：Ubuntu 14.04.5 LTS</h3><br /><h3>Ubertooth软件版本：ubertooth 2018-12-R1</h3><br /><h3>Libbtbb版本：libbtbb 2018-12-R1</h3><br /><h3>Wireshark版本： Version 2.6.6 (Git v2.6.6 packaged as 2.6.6-1~ubuntu14.04.0)</h3><br /><h3>本次编译安装的目的，是能够借助Wireshark去查看和分析监听到的蓝牙数据包，因此需要2个部分：Ubertooth（应用程序本体）和libbtbb（蓝牙基带库，源码中带有Wireshark插件）</h3><br /><h3>实际上还有一部分需要关注，附带在Ubertooth下载的源码里，就是硬件对应的固件。由于固件是和软件配套的，因此在编译软件的时候需要给硬件刷入对应的固件，否则会报api不匹配的问题（下文中会说到）</h3><br /><br /><h2>软件编译</h2><br /><h3>软件的编译部分其实很简单，使用Ubuntu系统的话官方git上是有相关说明的，而且很详细，可以傻瓜的照做。下面就简单说明一下。</h3><br /><h3>首先先给出</h3><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Build-Guide">官方WiKi (Build-Guide)</a><h3>的链接，如果阅读能力强的可以直接看官方说明，下面的描述都以Ubuntu为例。</h3><br /><h3>首先安装编译环境，如cmake, gcc等，一条命令：</h3><br /><code>sudo apt-get install cmake libusb-1.0-0-dev make gcc g++ libbluetooth-dev \<br />pkg-config libpcap-dev python-numpy python-pyside python-qt4<br /></code><br /><h2>libbtbb(蓝牙基带库)</h2><br /><h3>接下来安装蓝牙基带库（Bluetooth Baseband Library），下载源码并解压，这里也是借用了官方给出的命令，正好我安装的也是2018-12-R1的版本。</h3><br /><code>wget https://github.com/greatscottgadgets/libbtbb/archive/2018-12-R1.tar.gz -O libbtbb-2018-12-R1.tar.gz<br />tar -xf libbtbb-2018-12-R1.tar.gz<br /></code><h3>如果不用</h3><code><h3>wget</h3></code><h3>命令的话，也可以直接在</h3><a href="https://github.com/greatscottgadgets/libbtbb/releases">Releases页面</a><h3>上下载（注意版本和文件名哦），然后手动解压~~</h3><br /><h3>接下来按照官方的说明，</h3><code><h3>cd</h3></code><h3>命令进入解压好的文件夹，使用</h3><code><h3>mkdir</h3></code><h3>命令新建一个名为</h3><code><h3>build</h3></code><h3>的文件夹，用于编译源码。之后就是简单粗暴的</h3><code><h3>make</h3></code><h3>过程。不过注意，最后的</h3><code><h3>make install</h3></code><h3>一定要用</h3><code><h3>sudo</h3></code><h3>去跑（长期用Kali已经忘记还有”以管理员身份运行“这回事了……）完整的命令如下：</h3><br /><code>cd libbtbb-2018-12-R1<br />mkdir build<br />cd build<br />cmake ..<br />make<br />sudo make install<br /></code><h3>如果没有报错，那就说明安装成功了。下面放出几张我build过程的截图：</h3><br /><a href="https://image.3001.net/images/20190711/1562814237_5d26a71d3ec0f.png!small"><img src="images\481-1.png" alt="images\481-1.png" /></a><br /><a href="https://image.3001.net/images/20190711/1562814249_5d26a729dbc75.png!small"><img src="images\481-2.png" alt="images\481-2.png" /></a><br /><a href="https://image.3001.net/images/20190711/1562814254_5d26a72e805d8.png!small"><img src="images\481-3.png" alt="images\481-3.png" /></a><br /><br /><h3>根据官方说明，首次安装的时候可能会报错，或者出现找不到lib库的情况，此时则需要在命令行中执行</h3><br /><code>sudo ldconfig<br /></code><h3>即可，虽然不知道为什么，而且我安装的时候并未出现任何报错的提示。</h3><br /><br /><h2>Ubertooth工具软件</h2><br /><h3>Ubertooth工具软件就是指在命令行中输入</h3><code><h3>ubertooth-xxx</h3></code><h3>这样的命令能执行的那个玩意。编译的时候和libbtbb类似，用</h3><code><h3>wget</h3></code><h3>命令或者直接在</h3><a href="https://github.com/greatscottgadgets/ubertooth/releases">Release页面</a><h3>进行下载，并解压。官方的命令如下：</h3><br /><code>wget https://github.com/greatscottgadgets/ubertooth/releases/download/2018-12-R1/ubertooth-2018-12-R1.tar.xz<br />tar xf ubertooth-2018-12-R1.tar.xz<br /></code><h3>后面的步骤也是一样的，新建build文件夹，在这个文件夹里cmake - make - make install完成安装：</h3><br /><code>cd ubertooth-2018-12-R1/host<br />mkdir build<br />cd build<br />cmake ..<br />make<br />sudo make install<br /></code><h3>需要注意的是，这里是在</h3><code><h3>host</h3></code><h3>文件夹下进行编译，解压出的源码中还有很多其他的文件夹，注意不要弄错了</h3><br /><h3>同样的，这里官方也给了提示，如果首次编译或报找不到lib库的问题，请在命令行中输入：</h3><br /><code>sudo ldconfig<br /></code><h3>至此，基带和工具全部都安装完成了，这时候插上Ubertooth，将其分配给虚拟机，并在命令行中输入</h3><code><h3>ubertooth-util -v</h3></code><h3>即可查看到当前你的Ubertooth的固件版本。</h3><br /><a href="https://image.3001.net/images/20190711/1562814275_5d26a7431361c.png!small"><img src="images\481-4.png" alt="images\481-4.png" /></a><br /><h3>这里是我已经刷过了固件，所以显示的版本是2018-12-R1（原来没刷固件之前忘记截图了），能看到固件，说明btbb库和Ubertooth工具都安装成功了。</h3><br /><br /><h2>Wireshark插件</h2><br /><h3>根据官方libbtbb github的 </h3><a href="https://github.com/greatscottgadgets/libbtbb/issues/50">issus 50</a><h3>，作者对Wireshark插件的问题进行了回答：<br /></h3><br />• 对于Wireshark 2.0之前的版本，需要编译<code>plugins-legacy</code>中的插件<br />• 对于Wireshark 2.0 ~ 2.2 的版本，需要编译<code>plugins</code>中的插件<br />• 对于Wireshark 2.2+的版本，无需编译任何插件即可，因为Wireshark官方已经自带了相关插件。<br /><br /><h3>因此插件的编译步骤可以直接略过。</h3><br /><br /><h2>固件更新</h2><br /><h3>在使用之前，需要对Ubertooth硬件中的固件进行更新。上面Ubertooth tools部分提到了</h3><code><h3>ubertooth-util -v</h3></code><h3>命令可以查看到当前刷入的固件版本，同时有一个</h3><code><h3>API 版本</h3></code><h3>的问题，Ubertooth要求固件的API版本与Ubertooth tools的版本一致，否则不能使用。</h3><br /><h3>在Ubertooth tools的源码中是包含了固件的，固件是</h3><code><h3>.dfu</h3></code><h3>格式的文件。源码中有可以直接用的固件，在</h3><code><h3>ubertooth-2018-12-R1/ubertooth-one-firmware-bin/bluetooth_rxtx.dfu</h3></code><h3>。更新固件的命令是：</h3><br /><code>ubertooth-dfu -d bluetooth_rxtx.dfu -r<br /></code><h3>我在虚拟机中执行这一步的时候报错了，每次执行的时候都会尝试切换到DFU模式，然后USB显示无法识别，同时硬件上面的四个由深到浅的红色指示灯一直循环跑马灯。不知道这里是我虚拟机有问题，还是我的USB口有问题。</h3><br /><a href="https://image.3001.net/images/20190711/1562814292_5d26a7546193c.png!small"><img src="images\481-5.png" alt="images\481-5.png" /></a><br /><h3>尝试了很久都不成功之后，找了一台macbook，安装ubertooth tool，执行上面的命令，成功刷入。</h3><br /><h3>这里官方给出了一个troubleshooting，如果有报错</h3><code><h3>libUSB Error: Command Error: (-1)</h3></code><h3>，或者硬件上面四个灯跑马灯的话，需要重新编译固件，就要用到</h3><code><h3>ubertooth-2018-12-R1/firmware</h3></code><h3>文件夹的内容了，编译命令如下：</h3><br /><code>cd ubertooth-2018-12-R1/firmware<br />make clean all &amp;&amp; make<br />ubertooth-dfu -r -d bluetooth_rxtx/bluetooth_rxtx.dfu<br /></code><h3>在之前一直提示</h3><code><h3>Unable to find Ubertooth</h3></code><h3>错误的时候，我也尝试编译了固件，证明并不是固件的问题。由于没有成功刷入编译的固件，此部分不再赘述。</h3><br /><br /><h2>抓包验证</h2><br /><br /><h2>Wireshark设置</h2><br /><h3>到了这一步，前期准备工作就都完成了。现在需要把Ubertooth和Wireshark进行联动，将Ubertooth收集到的数据传到Wireshark进行解析。这里主要参考</h3><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Capturing-BLE-in-Wireshark">官方Wiki</a><h3>，步骤如下：</h3><br /><h3>1.在终端中运行命令：</h3><code><h3>mkfifo /tmp/pipe</h3></code><br /><h3>2.打开Wireshark，选择 &#39;Capture -&gt; Options&#39; 对抓包接口进行设置</h3><br /><h3>3.点击右下角 ‘Manage Interfaces’ 对接口进行管理</h3><br /><h3>4.切换到 &#39;Pipes&#39; 选项卡</h3><br /><h3>5.保存设置，选中 &#39;/tmp/pipe&#39; 并点击开始</h3><br /><h3>6.此时，在终端中运行命令：</h3><code><h3>ubertooth-btle -f -c /tmp/pipe</h3></code><br /><a href="https://image.3001.net/images/20190711/1562814350_5d26a78e58160.png!small"><img src="images\481-6.png" alt="images\481-6.png" /></a><br /><h3>切回Wireshark，应该可以看到滚动的数据包了。</h3><br /><h3>这里有一点需要注意，“mkfifo /tmp/pipe” 命令需要在所有步骤前进行，即先创建pipe这个文件，再设置wireshark读取，最后用Ubertooth-btle命令写入，顺序错了是会不成功的。</h3><br /><br /><h2>一些小问题</h2><br /><br /><h3>DLT=147, check your Preferences-&gt;Protocols-&gt;DLT_USER</h3><br /><h3>这个问题我的个人理解是Wireshark没有能识别出这类数据包的具体类别，因此需要手动指定一下。</h3><br /><h3>这个是没进行操作之前（有报错的时候）。</h3><br /><a href="https://image.3001.net/images/20190711/1562814363_5d26a79ba82dd.png!small"><img src="images\481-7.png" alt="images\481-7.png" /></a><br /><h3>步骤很简单：</h3><br /><h3>1.点击 Edit -&gt; Preference (编辑 -&gt; 首选项)；</h3><br /><h3>2.在左侧选择 </h3><code><h3>Protocol</h3></code><h3>下的</h3><code><h3>DLT_USER</h3></code><h3>选项；</h3><br /><h3>3.点击</h3><code><h3>Edit</h3></code><h3>按钮；</h3><br /><h3>4.点击左下角的 “+” 添加一条记录，在</h3><code><h3>DLT</h3></code><h3>处选择DLT=147，</h3><code><h3>Payload protocol</h3></code><h3>部分双击修改，填入btle，点击OK保存。</h3><br /><h3>此时显示就正常了。</h3><br /><br /><h3>这是修复过的样子：</h3><br /><a href="https://image.3001.net/images/20190711/1562814393_5d26a7b95388c.png!small"><img src="images\481-8.png" alt="images\481-8.png" /></a><br /><br /><h3>undefined symbol: new_create_dissector_handle</h3><br /><h3>这个问题是在Wireshark 2.2+版本下按照官方Build Guide编译插件后造成的。原因在上面的插件编译那一节已经说到了，2.2+版本可以直接用，不需要进行任何插件的编译工作。</h3><br /><h3>因为折腾了很久才明白各个版本之间的区别，因此还是在这里提一句，记录一下。</h3><br /><h3>下面是这个错误报错的截图：</h3><br /><a href="https://image.3001.net/images/20190711/1562814400_5d26a7c0ac8a6.png!small"><img src="images\481-9.png" alt="images\481-9.png" /></a><br /><br /><a href=""><img src="images\481-10.png" alt="images\481-10.png" /></a><br /></div><div class='page'><h1 class='title level-5'>雪碧BLE Hacking：使用Ubertooth one扫描嗅探低功耗蓝牙</h1><br/><a href="https://www.freebuf.com/articles/wireless/106298.html">BLE Hacking：使用Ubertooth one扫描嗅探低功耗蓝牙 - FreeBuf网络安全行业门户</a><br /><h2>BLE Hacking：使用Ubertooth one扫描嗅探低功耗蓝牙</h2><br /><a href="https://www.freebuf.com/author/%E6%BC%8F%E6%B4%9E%E7%9B%92%E5%AD%90">漏洞盒子 </a> 2016-06-12 11:34:17 1178455 3<br /><br /><strong><h3>本文作者：</h3></strong><a href="http://www.0xroot.cn/">雪碧0xroot</a><strong><h3>@漏洞盒子安全实验室</h3></strong><br /><br /><br /><h2>0x00 前言</h2><br /><strong><h3>低功耗蓝牙(Low Energy; LE)，又视为Bluetooth Smart或蓝牙核心规格4.0版本。其特点具备节能、便于采用，是蓝牙技术专为物联网(Internet of Things; IOT)开发的技术版本。</h3></strong><br /><br /><h3>类似文章推荐：</h3><a href="http://www.freebuf.com/news/88281.html">永不消逝的电波（三）：低功耗蓝牙（BLE）入门之如何调戏别人的小米手环</a><h3>。</h3><br /><h3>BLE主打功能是快速搜索，快速连接，超低功耗保持连接和传输数据，弱点是数据传输速率低，由于BLE的低功耗特点，因此普遍用于穿戴设备。</h3><br /><h3>我们比较熟悉的网络有 Zigbee，WIFI、Bluetooth（传统蓝牙），三者之间的关系如下：</h3><br /><a href="https://image.3001.net/images/20160607/14652880952990.png!small"><img src="images\480-1.png" alt="images\480-1.png" /></a><br /><h3>不同的无线数据传输协议在数据传输速率利传输距离有各自的使用范围。Zigbee、蓝牙以及 WIFI 标准都是工作在 2.4GHz 频段的无线通信标准。</h3><br /><h3>传统蓝牙数据传输速率小于 3Mbps，典型数据传输距离为 2-10m，蓝牙技术的典型应用是在两部手机之间进行小量数据的传输。</h3><br /><h3>WIFI 最高数据传输速率可达 50Mbps，典型数据传输距离在 30-100m，WIFI 技术提供了一种 Intemet 的无线接入技术。</h3><br /><br /><h2>0x01 蓝牙与低功耗蓝牙</h2><br /><br /><h3>1.1 标准<br /></h3><br /><h3>蓝牙无线技术是使用范围最广泛的全球短距离无线标准之一，全新的蓝牙 4.0 版本将传统蓝牙，高速蓝牙和低功耗蓝牙技术三种蓝牙技术合而为一。它集成了蓝牙技术在无线连接上的固有优势，同时增加了高速蓝牙和低功耗蓝牙的特点，这三个规格可以组合使用，也可以单独使用，低功耗蓝牙即 ble 是蓝牙 4.0 的核心规范，该技术最大特点是拥有超低的运行功耗和待机功耗，蓝牙低功耗设备使用一粒纽扣电池可以连续工作数年之久，可应用与对成本和功耗都有严格要求的无线方案，而且随之智能机的发展将有着更加广泛的领域。</h3><br /><h3>BLE分为三部分Service、Characteristic、Descriptor，这三部分都由UUID作为唯一标示符。一个蓝牙4.0的终端可以包含多个Service，一个Service可以包含多个Characteristic，一个Characteristic包含一个Value和多个Descriptor，一个Descriptor包含一个Value。</h3><br /><h3>BLE 规范中定义了 GAP（Generic Access Profile）和 GATT（Generic Attribute）两个基本配置文件。</h3><br /><strong><h3>GAP 层</h3></strong><h3>负责设备访问模式和进程，包括设备发现，建立连接，终止连接。初始化安全特征和设备配置。</h3><br /><strong><h3>GATT 层</h3></strong><h3>用于已连接的蓝牙设备之间的数据通信。</h3><br /><br /><h3>1.2 BLE特点&amp;优势</h3><br /><strong><h3>1.2.1高可靠性</h3></strong><br /><h3>对于无线通信而言，由于电磁波在传输过程中容易受很多因素的干扰，例如，障碍物的阻挡、天气状况等，因此，无线通信系统在数据传输过程中具有内在的不可靠性。蓝牙技术联盟 SIG 在指定蓝牙 4.0 规范时已经考虑到了这种数据传输过程中的内在的不确定性，在射频，基带协议，链路管理协议中采用可靠性措施，包括：差错检测和矫正，进行数据编解码，数据降噪等，极大地提高了蓝牙无线数据传输的可靠性，另外，使用自适应调频技术，能最大程度地减少和其他 2.4G 无线电波的串扰。</h3><br /><strong><h3>1.2.2 低成本、低功耗</h3></strong><br /><h3>低功耗蓝牙支持两种部署方式：双模式和单模式，一般智能机上采用双模式，外设一般采用 BLE 单模。</h3><br /><h3>BLE 技术可以应用于 8-bit MCU， 目前 TI 公司推出的兼容 BluetoothLE 协议的 SoC芯片 CC254X 每片价格在 7.6 元左右， 外接几个阻容器件构成的滤波电路和 PCB 天线即可实现网络节点的构建。Nodic的NRF51822也不过才10元人民币。</h3><br /><h3>低功耗设计：蓝牙 4.0 版本强化了蓝牙在数据传输上的低功耗性能，功耗较传统蓝牙降低了 90%。</h3><br /><strong><h3>传统蓝牙</h3></strong><h3>设备的待机耗电量一直是其缺陷之一，这与传统蓝牙技术采用16至32个频道进行广播有很大关系，而低功耗蓝牙仅适用 3个广播通道，且每次广播时射频的开启时间也有传统的 22.5ms 减少到 0.6~1.2ms，这两个协议规范的改变，大幅降低了因为广播数据导致的待机功耗。</h3><br /><strong><h3>低功耗蓝牙</h3></strong><h3>设计用深度睡眠状态来替换传统蓝牙的空闲状态，在深度睡眠状态下，主机 Host 长时间处于超低的负载循环 Duty Cycle 状态，只在需要运作时由控制器来启动，由于主机较控制器消耗的能源更多，因此这样的设计也节省了更多的能源。</h3><br /><strong><h3>1.2.3 快速启动、瞬间连接</h3></strong><br /><h3>此前蓝牙版本的启动速度非常缓慢，2.1 版本的蓝牙启动连接需要 6s 时间，而蓝牙4.0 版本仅需要 3ms 即可完成，几乎是瞬间连接。</h3><br /><strong><h3>1.2.4 传输距离极大提供</h3></strong><br /><h3>传统蓝牙传输距离一般 2-10m，而蓝牙 4.0 的有效传输距离可以达到 60~100m，传输距离提升了 10 倍，极大开拓了蓝牙技术的应用前景。</h3><br /><strong><h3>1.2.5 高安全性</h3></strong><br /><h3>为了保证数据传输的安全性，使用 AES-128 CCM 加密算法进行数据包加密认证，对于初学阶段，安全性问题可以暂时不考虑。</h3><br /><br /><h3>1.3 协议栈</h3><br /><h3>协议栈内容请参考：</h3><a href="http://j2abro.blogspot.com.au/2014/06/understanding-bluetooth-advertising.html">Understanding Bluetooth Advertising Packets</a><h3>一文。</h3><br /><h3>中文版：</h3><a href="http://blog.csdn.net/ooakk/article/details/7302425">http://blog.csdn.net/ooakk/article/details/7302425</a><br /><br /><a href="https://image.3001.net/images/20160607/14652943485522.gif!small"><img src="images\480-2.png" alt="images\480-2.png" /></a><br /><br /><a href="https://image.3001.net/images/20160607/14652865606217.png!small"><img src="images\480-3.png" alt="images\480-3.png" /></a><br /><a href="https://image.3001.net/images/20160607/14652871741879.png!small"><img src="images\480-4.png" alt="images\480-4.png" /></a><br /><br /><br /><h3>1.4 通信信道</h3><br /><h3>BLE 工作在 ISM 频带，定义了两个频段，2.4GHz 频段和 896/915MHz 频带。在IEEE802.15.4 中共规定了 27 个信道：</h3><br /><h3>在 2.4GHz 频段，共有 16 个信道，信道通信速率为 250kbps：</h3><br /><h3>在 915MHz 频段，共有 10 个信道，信道通信速率为 40kbps：</h3><br /><h3>在 868MHz 频段，有 1 个信道，信道通信速率为 20kbpS。</h3><br /><a href="https://image.3001.net/images/20160607/14652902194718.png!small"><img src="images\480-5.png" alt="images\480-5.png" /></a><br /><br /><h3>BLE 工作在 2.4GHz 频段，仅适用 3 个广播通道，适用所有蓝牙规范版本通用的自适应调频技术。</h3><br /><h3>BlueTooth 有79个射频信道，按0-78排序，并于2402 MHz开始，以1 MHz分隔：</h3><br /><code>channel 00 : 2.402000000 Ghz<br />channel 01 : 2.403000000 Ghz<br />…<br />channel 78 : 2.480000000 Ghz</code><h3>BTLE有40个频道（也称为信道），按37在第一个，后面由0-36，然后第39信道（那么38呢 :) ）第38信道位于10和11之间：</h3><br /><code>channel 37 : 2.402000000 Ghz<br />channel 00 : 2.404000000 Ghz<br />channel 01 : 2.406000000 Ghz<br />channel 02 : 2.408000000 Ghz<br />channel 03 : 2.410000000 Ghz<br />channel 04 : 2.412000000 Ghz<br />channel 05 : 2.414000000 Ghz<br />channel 06 : 2.416000000 Ghz<br />channel 07 : 2.418000000 Ghz<br />channel 08 : 2.420000000 Ghz<br />channel 09 : 2.422000000 Ghz<br />channel 10 : 2.424000000 Ghz<br />channel 38 : 2.426000000 Ghz<br />channel 11 : 2.428000000 Ghz<br />channel 12 : 2.430000000 Ghz<br />channel 13 : 2.432000000 Ghz<br />channel 14 : 2.434000000 Ghz<br />channel 15 : 2.436000000 Ghz<br />channel 16 : 2.438000000 Ghz<br />channel 17 : 2.440000000 Ghz<br />channel 18 : 2.442000000 Ghz<br />channel 19 : 2.444000000 Ghz<br />channel 20 : 2.446000000 Ghz<br />channel 21 : 2.448000000 Ghz<br />channel 22 : 2.450000000 Ghz<br />channel 23 : 2.452000000 Ghz<br />channel 24 : 2.454000000 Ghz<br />channel 25 : 2.456000000 Ghz<br />channel 26 : 2.458000000 Ghz<br />channel 27 : 2.460000000 Ghz<br />channel 28 : 2.462000000 Ghz<br />channel 29 : 2.464000000 Ghz<br />channel 30 : 2.466000000 Ghz<br />channel 31 : 2.468000000 Ghz<br />channel 32 : 2.470000000 Ghz<br />channel 33 : 2.472000000 Ghz<br />channel 34 : 2.474000000 Ghz<br />channel 35 : 2.476000000 Ghz<br />channel 36 : 2.478000000 Ghz<br />channel 39 : 2.480000000 Ghz</code><strong><h3>40个频道中:37、38、39为广播信道,另外37个频道用于数据的传输：</h3></strong><br /><h3>使用德州仪器（TI）CC2540蓝牙低功耗模块配合官方的SmartRF协议软件包监听器：PACKET-SNIFFER，可对三个蓝牙广播信道进行嗅探。</h3><br /><a href="https://image.3001.net/images/20160608/14653540907695.png!small"><img src="images\480-6.png" alt="images\480-6.png" /></a><br /><br /><h3>使用方法可参考：</h3><a href="http://www.ti.com.cn/tool/cn/packet-sniffer">Ti.com.cn/packet-sniffer</a><h3> </h3><strong><h3>这种嗅探方案优点是廉价,不足是只能嗅探到广播信道的数据包，无法捕获连接完成后也就是设备通信过程中的数据包：</h3></strong><br /><br /><a href="https://image.3001.net/images/20160608/14653527742820.png!small"><img src="images\480-7.png" alt="images\480-7.png" /></a><br /><a href="https://image.3001.net/images/20160608/1465352867553.png!small"><img src="images\480-8.png" alt="images\480-8.png" /></a><br /><a href="https://image.3001.net/images/20160608/14653530714388.png!small"><img src="images\480-9.png" alt="images\480-9.png" /></a><br /><h3>基于HackRF嗅探蓝牙数据包实际上也是可行的：</h3><br /><a href="https://image.3001.net/images/20160608/14653712427619.png!small"><img src="images\480-10.png" alt="images\480-10.png" /></a><br /><h3>其方法参考jxj童鞋的</h3><a href="http://sdr-x.github.io/BTLE-SNIFFER/">BTLE packet sniffer based on HACKRF (function and performance similar to TI&#39;s packet sniffer)</a><br /><br /><h3>HackRF.NET 中文版：</h3><a href="http://www.hackrf.net/2015/11/btle-sniffer/">基于HACKRF的低功耗蓝牙（BTLE）packet sniffer/scanner</a><br /><br /><br /><h2>0x02 环境搭建：</h2><br /><h3>我们说到上面的方案只能嗅探到广播信道的数据包，无法捕获通信过程中的蓝牙数据包，接下来我们将使用Ubertooth One来弥补上面方案的缺陷。</h3><br /><br /><br /><br /><h3>2.1安装lib库</h3><br /><code>apt-get install python-software-properties<br />add-apt-repository ppa:pyside<br />apt-get update<br />apt-get install libnl-dev libusb-1.0-0-dev pyside-tools</code><br /><h3>2.2 安装libbtbb</h3><br /><code>wget https://github.com/greatscottgadgets/libbtbb/archive/2015-09-R2.tar.gz -O libbtbb-2015-09-R2.tar.gz<br />tar xf libbtbb-2015-09-R2.tar.gz<br />cd libbtbb-2015-09-R2<br />mkdir build<br />cd build<br />cmake ..<br />make<br />sudo make install<br /></code><br /><h3>2.3 安装ubertooth</h3><br /><code>wget https://github.com/greatscottgadgets/ubertooth/releases/download/2015-09-R2/ubertooth-2015-09-R2.tar.xz -O ubertooth-2015-09-R2.tar.xz<br />tar xf ubertooth-2015-09-R2.tar.xz<br />cd ubertooth-2015-09-R2/host<br />mkdir build<br />cd build<br />cmake ..<br />make<br />sudo make install<br />sudo ldconfig<br /></code><br /><h3>2.4 安装wireshark<br /></h3><br /><code>sudo apt-get install checkinstall<br />wget https://www.wireshark.org/download/src/wireshark-2.0.3.tar.bz2<br />tar -xvf wireshark-2.0.3.tar.bz2<br />cd wireshark-2.0.3<br />./configure<br />make<br />make install<br /></code><br /><h3>2.5 安装kismet</h3><br /><code>wget https://kismetwireless.net/code/kismet-2013-03-R1b.tar.xz<br />tar xf kismet-2013-03-R1b.tar.xz<br />cd kismet-2013-03-R1b<br />ln -s ../ubertooth-2015-09-R2/host/kismet/plugin-ubertooth .<br />./configure<br />make &amp;&amp; make plugins<br />sudo make suidinstall<br />sudo make plugins-install</code><br /><h3>2.6 安装BLE解密工具crackle (</h3><a href="https://github.com/mikeryan/crackle">开源项目地址</a><h3>)</h3><br /><code>git clone https://github.com/mikeryan/crackle.git<br />cd crackle<br />make<br />make install</code><h3>找到kismet的配置文件kismet.conf ，把&quot;pcapbtbb&quot;加入到kismet.conf的logtypes= 里边</h3><br /><a href="https://image.3001.net/images/20160608/14653550899905.png!small"><img src="images\480-11.png" alt="images\480-11.png" /></a><br /><a href="https://image.3001.net/images/20160608/14653551808857.png!small"><img src="images\480-12.png" alt="images\480-12.png" /></a><br /><br /><br /><h2> 0x03 嗅探扫描<br /></h2><br /><br /><h3>3.1 spectool</h3><br /><strong><h3>spectool_curses</h3></strong><br /><br /><br /><strong><h3>spectool_gtk</h3></strong><h3> 扫描附近信号并在频谱上显示：<br /></h3><br /><a href="https://image.3001.net/images/20160607/14653042821104.png!small"><img src="images\480-13.png" alt="images\480-13.png" /></a><br /><br /><strong><h3>spectool_raw </h3></strong><h3>RAW中文解释是“原材料”或“未经处理的东西”,这里猜测是显示设备捕获到的未经处理的信号数据：<br /></h3><br /><a href="https://image.3001.net/images/20160608/14653558903325.png!small"><img src="images\480-14.png" alt="images\480-14.png" /></a><br /><strong><h3>spectool_net </h3></strong><h3> 将Ubertooth One作为一台“硬件服务器”，并监听TCP：30569端口，局域网内任何可以跟主机建立通信的PC可通过Ubertoothe主机IP+30569共享设备。连接方式：在另外一台主机终端上执行：spectool_gtk <br /></h3><br /><h3>---&gt;选择Open Network Device ---&gt;输入ip、端口。<br /></h3><br /><a href="https://image.3001.net/images/20160608/14653560742049.png!small"><img src="images\480-15.png" alt="images\480-15.png" /></a><br /><br /><br /><h3>3.2 hcitool</h3><br /><code>root@0xroot:~# hcitool --help<br />hcitool - HCI Tool ver 4.99<br />Usage:<br />    hcitool [options] &lt;command&gt; [command parameters]<br />Options:<br />    --help    Display help<br />    -i dev    HCI device<br />Commands:<br />    dev     Display local devices<br />    inq     Inquire remote devices<br />    scan    Scan for remote devices<br />    name    Get name from remote device<br />    info    Get information from remote device<br />    spinq    Start periodic inquiry<br />    epinq    Exit periodic inquiry<br />    cmd     Submit arbitrary HCI commands<br />    con     Display active connections<br />    cc      Create connection to remote device<br />    dc      Disconnect from remote device<br />    sr      Switch master/slave role<br />    cpt     Change connection packet type<br />    rssi    Display connection RSSI<br />    lq      Display link quality<br />    tpl     Display transmit power level<br />    afh     Display AFH channel map<br />    lp      Set/display link policy settings<br />    lst     Set/display link supervision timeout<br />    auth    Request authentication<br />    enc     Set connection encryption<br />    key     Change connection link key<br />    clkoff    Read clock offset<br />    clock    Read local or remote clock<br />    lescan    Start LE scan<br />    lewladd    Add device to LE White List<br />    lewlrm    Remove device from LE White List<br />    lewlsz    Read size of LE White List<br />    lewlclr    Clear LE White list<br />    lecc    Create a LE Connection<br />    ledc    Disconnect a LE Connection<br />    lecup    LE Connection Update<br /></code><strong><h3>hcitool scan :</h3></strong><h3>扫描附近蓝牙设备 </h3><br /><strong><h3>hcitool lescan :</h3></strong><h3>扫描附近低功耗蓝牙设备<br /></h3><br /><a href="https://image.3001.net/images/20160607/14652859347691.png!small"><img src="images\480-16.png" alt="images\480-16.png" /></a><br /><br /><br /><h3>3.3 gatttool<br /></h3><br /><code>root@0xroot:~# gatttool -h<br />Usage:<br />  gatttool [OPTION...]<br /><br />Help Options:<br />  -h, --help                                Show help options<br />  --help-all                                Show all help options<br />  --help-gatt                               Show all GATT commands<br />  --help-params                             Show all Primary Services/Characteristics arguments<br />  --help-char-read-write                    Show all Characteristics Value/Descriptor Read/Write arguments<br /><br />Application Options:<br />  -i, --adapter=hciX                        Specify local adapter interface<br />  -b, --device=MAC                          Specify remote Bluetooth address<br />  -m, --mtu=MTU                             Specify the MTU size<br />  -p, --psm=PSM                             Specify the PSM for GATT/ATT over BR/EDR<br />  -l, --sec-level=[low | medium | high]     Set security level. Default: low<br />  -I, --interactive                         Use interactive mode<br />gatttool -b 1C:96:5A:FF:4B:E7 -I<br />[   ][1C:96:5A:FF:4B:E7][LE]&gt; help<br />help                                           Show this help<br />exit                                           Exit interactive mode<br />quit                                           Exit interactive mode<br />connect         [address]                      Connect to a remote device<br />disconnect                                     Disconnect from a remote device<br />primary         [UUID]                         Primary Service Discovery<br />characteristics [start hnd [end hnd [UUID]]]   Characteristics Discovery<br />char-desc       [start hnd] [end hnd]          Characteristics Descriptor Discovery<br />char-read-hnd   &lt;handle&gt; [offset]              Characteristics Value/Descriptor Read by handle<br />char-read-uuid  &lt;UUID&gt; [start hnd] [end hnd]   Characteristics Value/Descriptor Read by UUID<br />char-write-req  &lt;handle&gt; &lt;new value&gt;           Characteristic Value Write (Write Request)<br />char-write-cmd  &lt;handle&gt; &lt;new value&gt;           Characteristic Value Write (No response)<br />sec-level       [low | medium | high]          Set security level. Default: low<br />mtu             &lt;value&gt;                        Exchange MTU for GATT/ATT<br />[   ][1C:96:5A:FF:4B:E7][LE]&gt; </code><br /><small>3.4 ubertooth-scan</small><br /><code>root@0xroot:~# ubertooth-scan --help<br />ubertooth-scan: invalid option -- &#39;-&#39;<br />ubertooth-scan - active(bluez) device scan and inquiry supported by Ubertooth<br />Usage:<br />    -h this Help<br />    -U&lt;0-7&gt; set ubertooth device to use<br />    -s hci Scan - perform HCI scan<br />    -t scan Time (seconds) - length of time to sniff packets. [Default: 20s]<br />    -x eXtended scan - retrieve additional information about target devices<br />    -b Bluetooth device (hci0)<br /></code><strong><small>ubertooth-scan -s</small></strong><br /><br /><a href="https://image.3001.net/images/20160607/14652859441686.png!small"><img src="images\480-17.png" alt="images\480-17.png" /></a><br /><br /><br /><small>3.5 ubertooth-btle</small><br /><code>ubertooth-btle - passive Bluetooth Low Energy monitoring<br />Usage:<br />    -h this help<br /><br />    Major modes:<br />    -f follow connections<br />    -p promiscuous: sniff active connections<br />    -a[address] get/set access address (example: -a8e89bed6)<br />    -s&lt;address&gt; faux slave mode, using MAC addr (example: -s22:44:66:88:aa:cc)<br />    -t&lt;address&gt; set connection following target (example: -t22:44:66:88:aa:cc)<br /><br />    Interference (use with -f or -p):<br />    -i interfere with one connection and return to idle<br />    -I interfere continuously<br /><br />    Data source:<br />    -U&lt;0-7&gt; set ubertooth device to use<br /><br />    Misc:<br />    -r&lt;filename&gt; capture packets to PCAPNG file<br />    -q&lt;filename&gt; capture packets to PCAP file (DLT_BLUETOOTH_LE_LL_WITH_PHDR)<br />    -c&lt;filename&gt; capture packets to PCAP file (DLT_PPI)<br />    -A&lt;index&gt; advertising channel index (default 37)<br />    -v[01] verify CRC mode, get status or enable/disable<br />    -x&lt;n&gt; allow n access address offenses (default 32)<br /><br />If an input file is not specified, an Ubertooth device is used for live capture.<br />In get/set mode no capture occurs.<br /></code><strong><small>ubertooth-btle -f -c test.pcap</small></strong><small>抓包&amp;保存到本地</small><br /><a href="https://image.3001.net/images/20160607/14652859592797.png!small"><img src="images\480-18.png" alt="images\480-18.png" /></a><br /><br /><small>使用这条命令我们可以把设备捕获到的数据包保存到本地，完成后可导入wireshark进行数据包、协议分析。</small><br /><h3>wireshark导入嗅探到的蓝牙数据包需要处理一下才能正常查看，不然无法正常分析数据：</h3><br /><a href="https://image.3001.net/images/20160608/14653568829667.png!small"><img src="images\480-19.png" alt="images\480-19.png" /></a><br /><br /><h3>Edit → Preferences → Protocols → DLT_USER → Edit → New </h3><br /><h3>在payload protocol中输入btle</h3><br /><a href="https://image.3001.net/images/20160608/14653571448727.png!small"><img src="images\480-20.png" alt="images\480-20.png" /></a><br /><br /><a href="https://image.3001.net/images/20160607/14652859763628.png!small"><img src="images\480-21.png" alt="images\480-21.png" /></a><br /><h3>使用规则过滤数据包：参考</h3><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Capturing-BLE-in-Wireshark">Capturing BLE in Wireshark</a><br /><br /><code>btle.data_header.length &gt; 0 || btle.advertising_header.pdu_type == 0x05</code><a href="https://image.3001.net/images/20160607/14652859864579.png!small"><img src="images\480-22.png" alt="images\480-22.png" /></a><br /><small> </small><br /><br /><h3>3.6 crackle<br /></h3><br /><h3>如果捕获到足够的数据包尤其是btsmp，那接下来便可以用crackle来破解tk和ltk：</h3><br /><code>crackle -i &lt;file.pcap&gt;</code><h3>解密数据包，并把解密后的包另存：</h3><br /><code>crackle -i &lt;file.pcap&gt; -o &lt;output.pcap&gt;<br />crackle -i &lt;file.pcap&gt; -o &lt;out.pcap&gt; -l &lt;ltk&gt;<br /></code><br /><h2>0x04 参考 &amp;&amp; 感谢</h2><br /><a href="http://blog.cyberexplorer.me/2014/01/sniffing-and-decoding-nrf24l01-and.html">Sniffing and decoding NRF24L01+ and Bluetooth LE packets for under $30</a><br /><br /><a href="https://dominicspill.com/kiwicon/Spill-Ubertooth-Kiwicon-2012.pdf">Bluetooth sniffing with Ubertooth ： https://dominicspill.com/kiwicon/Spill-Ubertooth-Kiwicon-2012.pdf</a><br /><a href="http://www.security-sleuth.com/sleuth-blog/2015/9/6/now-i-wanna-sniff-some-bluetooth-sniffing-and-cracking-bluetooth-with-the-ubertoothone">Now I wanna sniff some Bluetooth: Sniffing and Cracking Bluetooth with the UbertoothOne</a><br /><a href="http://j2abro.blogspot.com.au/2014/06/understanding-bluetooth-advertising.html">http://j2abro.blogspot.com.au/2014/06/understanding-bluetooth-advertising.html</a><br /><a href="https://www.freebuf.com/articles/wireless/106298.html">路人甲@乌云drops:Bluetooth Low Energy 嗅探</a><br /><a href="http://j2abro.blogspot.com.au/2014/06/understanding-bluetooth-advertising.html">疯狗@乌云drops：物联网安全拔“牙”实战——低功耗蓝牙（BLE）初探</a><br /><a href="http://j2abro.blogspot.com.au/2014/06/understanding-bluetooth-advertising.html">http://j2abro.blogspot.com.au/2014/06/understanding-bluetooth-advertising.html </a><br /><a href="http://j2abro.blogspot.com.au/2014/06/analyzing-bluetooth-advertising-with.html">http://j2abro.blogspot.com.au/2014/06/analyzing-bluetooth-advertising-with.html </a><br /><a href="http://cerescontrols.com/tutorials-3/sniffing-bluetooth-packets-with-kismet-and-wireshark-in-ubuntu-12-04/">http://cerescontrols.com/tutorials-3/sniffing-bluetooth-packets-with-kismet-and-wireshark-in-ubuntu-12-04/</a><br /><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Build-Guide">https://github.com/greatscottgadgets/ubertooth/wiki/Build-Guide</a><br /><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Capturing-BLE-in-Wireshark">https://github.com/greatscottgadgets/ubertooth/wiki/Capturing-BLE-in-Wireshark</a><br /><a href="http://stackoverflow.com/questions/23877761/sniffing-logging-your-own-android-bluetooth-traffic">http://stackoverflow.com/questions/23877761/sniffing-logging-your-own-android-bluetooth-traffic</a><br /><a href="https://lacklustre.net/bluetooth/wireshark.html">https://lacklustre.net/bluetooth/wireshark.html</a><br /><a href="https://blog.lacklustre.net/posts/BLE_Fun_With_Ubertooth:_Sniffing_Bluetooth_Smart_and_Cracking_Its_Crypto/">https://blog.lacklustre.net/posts/BLE_Fun_With_Ubertooth:_Sniffing_Bluetooth_Smart_and_Cracking_Its_Crypto/</a><br /><a href="http://superuser.com/questions/947593/how-can-i-sniff-bluetooth-traffic-coming-from-my-and-another-device">http://superuser.com/questions/947593/how-can-i-sniff-bluetooth-traffic-coming-from-my-and-another-device</a><br /><a href="http://www.backtrack-linux.org/forums/showthread.php?t=41552">http://www.backtrack-linux.org/forums/showthread.php?t=41552</a><br /><a href="http://www.splitbits.com/2014/05/14/ubertooth-spectools-chromebook/">http://www.splitbits.com/2014/05/14/ubertooth-spectools-chromebook/</a><br /><a href="http://ubertooth.sourceforge.net/usage/start/">http://ubertooth.sourceforge.net/usage/start/</a><br /><a href="http://hackerific.net/2012/01/28/Spectrum-Tools-and-Ubertooth-One/">http://hackerific.net/2012/01/28/Spectrum-Tools-and-Ubertooth-One/</a><br /><a href="https://penturalabs.wordpress.com/2014/02/20/ubertooth-updated-for-2014/">https://penturalabs.wordpress.com/2014/02/20/ubertooth-updated-for-2014/</a><br /><a href="https://blog.lacklustre.net/">https://blog.lacklustre.net/</a><br /><strong><h3>* 作者：雪碧0xroot@漏洞盒子安全实验室，转载请注明来自FreeBuf黑客与极客（FreeBuf.COM）</h3></strong><br /><strong><h3>博客地址：</h3></strong><a href="http://www.spriteking.com/archives/1546">spriteking.com/archives/1546</a><br /><br /><a href=""><img src="images\480-23.png" alt="images\480-23.png" /></a><br /><a href=""><img src="images\480-24.png" alt="images\480-24.png" /></a><br /><br /><br /><br /></div><div class='page'><h1 class='title level-2'>SDR上位机软件</h1><br/></div><div class='page'><h1 class='title level-3'>GNU Radio</h1><br/></div><div class='page'><h1 class='title level-3'>gqrx</h1><br/>可以用于显示信号的波峰波谷，从而判断信号关键频率<br />示例<a href="物联网安全--无线电--SDR平台--HackRF--汽车钥匙重放.html">hackrf汽车钥匙重放</a></div><div class='page'><h1 class='title level-3'>Universal radio hacker</h1><br/></div><div class='page'><h1 class='title level-4'>urh B210 汽车无线钥匙</h1><br/><h1>Universal radio hacker + B210 汽车无线钥匙信号抓取、截取分析、重放</h1><br />该软件支持多种SDR平台<br /><a href=""><img src="images\523-1.png" alt="images\523-1.png" /></a><br />软件使用 注意点：<br />信号源距离天线距离不同，抓取到的波形不同，如果距离较近，则抓取信号波形起伏较大，数据量较大<br />该软件信号抓取完毕后可以对数据进行保存，如果信号数据较大，则软件会弹出超过数据最大值的告警，<br />所以尽量抓取的时间窗口尽量短，尽量避免一次抓取多个信号，且尽量保证单个数据文件小于1M<br />抓取的数据包在该软件打开时可能报各种错误，此时可以重试或进一步查询报错信息<br />使用二分法可以确定触发指定功能的最小数据是什么样的<br />信号处理函数常使用c语言编写，c语言编译器一般为8字节对齐，所以将信号数据8字节为一组显示，可能有收获<br /> <br />关于录制得到的信号文件打开报错<br />使用urh录制无线信号，常出现录制后保存的信号文件打开报错的情况，此时需要注意，录制信号过程中需要保持信号源稳定不动，且最好天线直接指向信号源，该方法可以最大程度上保证录制信号的正确性，进一步保证保存的信号文件可以正常打开（原理是防止阻尼效应）特别是对于信号源电量不足的情况，天线接近信号源可以保证数据正确接收<br />信号源距离天线距离不同，抓取到的波形不同，如果距离较近，则抓取信号波形起伏较大，数据量较大，Universal radio hacker软件对于自身捕获的大于1m的信号文件，在打开时会报错误（该错误可以通过取消勾选edit-&gt;Auto detect signals on loa<br />软件使用 注意点：ding从而正常加载，但是若取消勾选，则会导致加载的数据包不能正确解析符号），所以需要尽量保证抓取信号数据包小于1m<br />该软件信号抓取完毕后可以对数据进行保存，如果信号数据较大，则软件会弹出超过数据最大值的告警，所以尽量抓取的时间窗口尽量短，尽量避免一次抓取多个信号<br /><br />信号抓取成功案例<br />在实际测试中最佳实践是<br />1、 将信号源牢牢固定<br />2、 将天线顶端仅靠信号源<br />3、 开始捕获信号后快速触发信号并快速关停，从而保证数据信号文件尽量小于1m<br />通过以上三个原则捕获四次连续的开车门信号，其noise center等参数均保持稳定且均可以重放成功<br /><a href=""><img src="images\523-2.png" alt="images\523-2.png" /></a><a href=""><img src="images\523-3.png" alt="images\523-3.png" /></a><a href=""><img src="images\523-4.png" alt="images\523-4.png" /></a><a href=""><img src="images\523-5.png" alt="images\523-5.png" /></a><br /><br />另外，通过修改捕获样本率以及带宽，可以在较为宽松的环境下成功录制信号并重放，有实例显示样本率设置6.0-8.0M，带宽设置2M，不同样本率以及带宽录制得到的信号文件具体内容有所不同<br /><a href=""><img src="images\523-6.png" alt="images\523-6.png" /></a><br /><br />采样率、带宽、频率可以通过信号分析确定<br /><a href=""><img src="images\523-7.png" alt="images\523-7.png" /></a><br /><br />结合b210抓取信号<br />file-》record signal<br /><a href=""><img src="images\523-8.png" alt="images\523-8.png" /></a><br /><br />打开数据文件<br /><a href="file:///C:\Users\Q\AppData\Local\Temp\msohtmlclip1\01\clip_image003.png"><img src="images\523-9.png" alt="images\523-9.png" /></a><br /> <br />播放信号<br /><a href="file:///C:\Users\Q\AppData\Local\Temp\msohtmlclip1\01\clip_image004.png"><img src="images\523-10.png" alt="images\523-10.png" /></a><br /> <br />分析信号数据<br /><a href="file:///C:\Users\Q\AppData\Local\Temp\msohtmlclip1\01\clip_image005.png"><img src="images\523-11.png" alt="images\523-11.png" /></a><br /> <br />生成数据功能中存在fuzz，值得关注<br /><a href="file:///C:\Users\Q\AppData\Local\Temp\msohtmlclip1\01\clip_image006.png"><img src="images\523-12.png" alt="images\523-12.png" /></a></div><div class='page'><h1 class='title level-4'>资料</h1><br/><a href="https://blog.csdn.net/opensourcesdr/article/details/104821001">https://blog.csdn.net/opensourcesdr/article/details/104821001</a><br /><h1>Universal Radio Hacker（URH）：一个用于逆向解析和攻击无线通信协议的开源工具</h1><br /><h3>本文介绍一个用于逆向解析和攻击无线通信（私有）协议的开源工具。该工具是Johannes Pohl和Andreas Noack研发的，该成果也已发表在12th USENIX Workshop on Offensive Technologies（woot&#39;18），woot是一个与Usenix Security一起举办的workshop。Universal Radio Hacker: A Suite for Analyzing and Attacking Stateful Wireless Protocols的原文及其演讲PPT下载链接为：</h3><a href="https://www.usenix.org/conference/woot18/presentation/pohl">https://www.usenix.org/conference/woot18/presentation/pohl</a><br /><h3>本文基于对原文的学习和工具的使用，介绍URH的基本内容和使用方法。</h3><br /><br /><br /><h1>一、背景介绍</h1><br /><h3>物联网设备普遍使用各自的无线私有协议。这些私有协议往往关注如何在物联网设备的资源受限情况下，能够稳定可靠运行。但是，协议往往忽视了信息安全防护。这也就导致各种无线智能设备存在加大的安全隐患，例如无线门锁或者汽车的无线钥匙等很容易遭受无线窃听、重放、篡改等攻击。网络攻击者要想对这些无线设备发起深层次的攻击，就需要深入的逆向解析这些无线私有协议。</h3><br /><h3>软件无线电设备可以设定成物联网设备工作频段，来进行信号发送和接收，这为攻击者们开展无线协议逆向工作提供了很大的便利。但是，目前看来，绝大多数的软件无线电设备工具适用于的协议逆向的工作频段往往集中在高频频段（3－30MHz，例如13.56MHz的RFID的频段），而且这些工具也无法用于充分分析协议逻辑，必须配合其他的定制化工具或者相关芯片的资料才行。</h3><br /><h3>因此，本文（Universal Radio Hacker: A Suite for Analyzing and Attacking Stateful Wireless Protocols），研制了一种开源工具Universal Radio Hacker（URH），可配合常见的软件无线电设备来对无线私有协议开展协议逆向分析，实现了信号解调、可定制的解码、协议模糊测试和仿真功能。总体来看，URH将协议逆向分析工作分成了以下几个阶段，即信号解析、信号分析、信号生成、信号仿真四个阶段。四个阶段中，上一个阶段的产出可以输入给下一个阶段使用。URH聚焦协议逻辑的分析，而不是仅仅关注对高频信号和数字信号解析过程。</h3><br /><br /><h1>二、URH设计目标</h1><br /><h3>URH是一种用于分析无线私有协议的工具。URH通过控制软件无线电设备（例如USRP、HackRF等）接收无线采样信号，并将信号转化为01比特序列。但是URH的功能不仅仅局限于此，URH的目标是帮助你实现对某些物联网设备无线通信攻击的完整过程。<br />具体来看，URH有以下三个设计目标：<br />（1）提供一个直观的无线私有协议分析界面，并不需要使用者有太多深入的射频知识；<br />（2）给用户提供一个覆盖对一个有状态无线私有协议发起攻击涉及的所有完整操作；<br />（3）此工具需要提供给于其他软件配合工作的接口。</h3><br /><h3>三、URH具体实现方法</h3><br /><br /><h2>1、URH实现方法概览</h2><br /><h3>URH为了实现设计目标，将无线协议逆向解析分成以下三个主要步骤：</h3><br /><h3>（1）信号解析：信号解析包括对原始采样信号的解调解码，其目标是将接收到的信号映射成数字bit数据。</h3><br /><h3>（2）信号分析：将信号解析的bit数据解码成可读性高的文本，其目标是分析发现协议的通信交互逻辑。</h3><br /><h3>（3）信号生成与信号仿真：对于无状态协议的攻击，信号生成阶段是在协议逻辑分析的基础上生成可以跟物联网设备通信交互的数据包。对于有状态协议的攻击，则需要通过信号仿真阶段来实现对协议的仿真和特定协议字段的模糊测试与逆向分析。</h3><br /><a href=""><img src="images\524-1.png" alt="images\524-1.png" /></a><br /><br /><h2>2、信号解析</h2><br /><h3>信号解析的主要目的是从接收到的信号中提取出二进制的比特数据。为此，接收信号需要进行正确的解调。在解调方面，虽然每个已调信号可能有幅度、频率和相位不同的调制方法，但是URH希望能够提供一种尽可能通用的解调方法。因此，URH不得不针对已调信号进行一些预处理。URH针对ASK、PSK和FSK三种调制，分别实现了预处理算法。无论已调信号用的是什么调制方式，URH都是将已调信号预处理成一种矩形信号，如下图所示。</h3><br /><a href=""><img src="images\524-2.png" alt="images\524-2.png" /></a><br /><br /><h2>3、信号分析</h2><br /><h3>一旦得到了信号解析结果（即01bit），接下来的分析工作就是实际的协议逻辑分析工作。</h3><br /><a href=""><img src="images\524-3.png" alt="images\524-3.png" /></a><br /><a href=""><img src="images\524-4.png" alt="images\524-4.png" /></a><br /><h3>4、信号生成</h3><br /><h3>在完成了信号解析和信号分析之后，你就掌握了一些协议的格式，接下来为了验证你的分析是否正确，就可以通过自己封装一些数据包并发送给物联网接收设备来验证一下了。信号生成就是实现这个操作的阶段。</h3><br /><a href=""><img src="images\524-5.png" alt="images\524-5.png" /></a><br /><br /><h2>5、信号仿真</h2><br /><h3>信号生成阶段的最大局限就是，对于那些有状态的协议，由于无法伪造有效的序列号或者加密后的挑战响应值，所以无法实施有效的攻击。为了解决这个问题，URH提供了一个信号仿真的功能。解决方案细节见论文原文。<br /></h3><a href=""><img src="images\524-6.png" alt="images\524-6.png" /></a><br /><br /><h1>三、URH的安装使用</h1><br /><a href="https://github.com/jopohl/urh#Installation">https://github.com/jopohl/urh#Installation</a><br /><br /><h2>1、Windows</h2><br /><h3>On Windows, URH can be installed with its </h3><a href="https://github.com/jopohl/urh/releases">Installer</a><h3>. No further dependencies are required.</h3><br /><h3>If you get an error about missing </h3><code><h3>api-ms-win-crt-runtime-l1-1-0.dll</h3></code><h3>, run Windows Update or directly install </h3><a href="https://support.microsoft.com/en-us/help/2999226/update-for-universal-c-runtime-in-windows">KB2999226</a><h3>.</h3><br /><br /><h2>2、Linux</h2><br /><h3>Install via Package Manager</h3><br /><h3>URH is included in the repositories of many linux distributions such as </h3><strong><h3>Arch Linux</h3></strong><h3>, </h3><strong><h3>Gentoo</h3></strong><h3>, </h3><strong><h3>Fedora</h3></strong><h3>, </h3><strong><h3>openSUSE</h3></strong><h3> or </h3><strong><h3>NixOS</h3></strong><h3>. There is also a package for </h3><strong><h3>FreeBSD</h3></strong><h3>. If available, simply use your package manager to install URH.</h3><br /><h3>Generic Installation with pip (Ubuntu/Debian)</h3><br /><h3>URH you can also be installed with using </h3><code><h3>python3 -m pip install urh</h3></code><h3>. In case you are running </h3><strong><h3>Ubuntu</h3></strong><h3> or </h3><strong><h3>Debian</h3></strong><h3> read on for more specific instructions.</h3><br /><h3>In order to use native device backends, make sure you install the </h3><strong><h3>-dev</h3></strong><h3> package for your desired SDRs, that is </h3><code><h3>libairspy-dev</h3></code><h3>, </h3><code><h3>libhackrf-dev</h3></code><h3>, </h3><code><h3>librtlsdr-dev</h3></code><h3>, </h3><code><h3>libuhd-dev</h3></code><h3>.</h3><br /><h3>If your device does not have a </h3><code><h3>-dev</h3></code><h3> package, e.g. LimeSDR, you need to manually create a symlink to the </h3><code><h3>.so</h3></code><h3>, like this:</h3><br /><code>sudo ln -s /usr/lib/x86_64-linux-gnu/libLimeSuite.so.17.02.2 /usr/lib/x86_64-linux-gnu/libLimeSuite.so</code><strong><h3>before</h3></strong><h3> installing URH, using:</h3><br /><code>1. <br /><br /></code><code><h3>sudo</h3></code><code> apt-get update<br /><br /><br />2. <br /><br /></code><code><h3>sudo</h3></code><code> apt-get install python</code><code><h3>3</h3></code><code>-numpy python</code><code><h3>3</h3></code><code>-psutil python</code><code><h3>3</h3></code><code>-zmq python</code><code><h3>3</h3></code><code>-pyqt</code><code><h3>5</h3></code><code> g++ libpython</code><code><h3>3</h3></code><code>-dev python</code><code><h3>3</h3></code><code>-pip cython</code><code><h3>3</h3></code><code><br /><br /><br />3. <br /><br /></code><code><h3>sudo</h3></code><code> pip</code><code><h3>3</h3></code><code> install urh<br /><br /><br /></code><br /><h1>四、URH基本功能：</h1><br /><h3>我用HackRF和无线门铃测试了一下URH的基本功能。用到的硬件包括：</h3><br /><h3>（1）HackRF One：</h3><a href="https://item.taobao.com/item.htm?spm=a230r.1.14.171.eaff79bavAjPbV&id=526187854860&ns=1&abbucket=8#detail">https://item.taobao.com/item.htm?spm=a230r.1.14.171.eaff79bavAjPbV&amp;id=526187854860&amp;ns=1&amp;abbucket=8#detail</a><br /><h3>（2）SMA拉杆天线：</h3><a href="https://item.taobao.com/item.htm?spm=a1z10.1-c.w4023-13255721722.13.33ba3d88e65hf9&id=563602659653">https://item.taobao.com/item.htm?spm=a1z10.1-c.w4023-13255721722.13.33ba3d88e65hf9&amp;id=563602659653</a><br /><h3>（3）无线门铃：工作频段315MHz。</h3><br /><br /><h2>1、扫描频谱Scanning the spectrum</h2><br /><h3>选择File—》Spectrum Analyzer</h3><br /><a href=""><img src="images\524-7.png" alt="images\524-7.png" /></a><br /><h3>下边的图是我用URH来接收无线门铃信号的频谱，无线门铃的发射信号频率为315MHz。</h3><br /><a href=""><img src="images\524-8.png" alt="images\524-8.png" /></a><br /><h3>在左边的Device setting可以选择设备Device，设置接收信号中心频率、采样率、带宽、增益等，当你想更换接收信号频率时，可以在左边的Frequency这里修改，也可以直接在右边的频谱中点击你想接收的频率就可以自动切换过去。</h3><br /><br /><h2>2、信号录制</h2><br /><h3>点击File---&gt;Record Signal</h3><br /><a href=""><img src="images\524-9.png" alt="images\524-9.png" /></a><br /><h3>右边界面中的信号，放大后如下图所示</h3><br /><a href=""><img src="images\524-10.png" alt="images\524-10.png" /></a><br /><br /><h2>3、信号解析</h2><br /><h3>Interpretation界面：</h3><br /><a href=""><img src="images\524-11.png" alt="images\524-11.png" /></a><br /><h3>可以用鼠标选择信号波形，选中的区域为蓝色。选中的区域之后，下边的01序列也会相应灰色高亮显示出来。</h3><br /><a href=""><img src="images\524-12.png" alt="images\524-12.png" /></a><br /><h3>Signal View的下拉菜单中选择Spectrogram。</h3><br /><a href=""><img src="images\524-13.png" alt="images\524-13.png" /></a><br /><br /><h2>4、信号分析</h2><br /><h3>Analysis界面，这里是URH解析之后的01序列。</h3><br /><a href=""><img src="images\524-14.png" alt="images\524-14.png" /></a><br /><h3>如果勾选“mark diffs in protocol”之后，会把每行不一样的比特以红色标记出来，方便分析者对比。</h3><br /><h3>更多功能介绍以及论文的一些实现细节还待深入研究，未完待续。</h3><br /><br /><h1>五、有用的链接</h1><br /><a href="https://www.usenix.org/conference/woot18/presentation/pohl">https://www.usenix.org/conference/woot18/presentation/pohl</a><br /><a href="https://github.com/jopohl/urh">https://github.com/jopohl/urh</a><br /><br /><br /></div><div class='page'><h1 class='title level-2'>WiFi协议</h1><br/><br /></div><div class='page'><h1 class='title level-3'>ssid与bssid</h1><br/><a href=""><img src="images\302-1.png" alt="images\302-1.png" /></a>	<br /><a href=""><img src="images\302-2.png" alt="images\302-2.png" /></a><br /><br />BSSID即AP的mac地址<br /><br /></div><div class='page'><h1 class='title level-3'>频谱划分</h1><br/>wifi频谱划分<br /><a href=""><img src="images\301-1.png" alt="images\301-1.png" /></a><br /><br /><a href=""><img src="images\301-2.png" alt="images\301-2.png" /></a><br /><br /><a href=""><img src="images\301-3.png" alt="images\301-3.png" /></a><br /><br /></div><div class='page'><h1 class='title level-3'>认证方式</h1><br/><a href=""><img src="images\304-1.png" alt="images\304-1.png" /></a><br /><br />连接之后使用web端认证，该方式属于无认证连接方式，已经可以劫持和嗅探ap中的数据</div><div class='page'><h1 class='title level-4'>wep</h1><br/>随机数生成算法有问题，可以被破解<br /><a href=""><img src="images\305-1.png" alt="images\305-1.png" /></a><br /></div><div class='page'><h1 class='title level-4'>wpa</h1><br/><a href=""><img src="images\306-1.png" alt="images\306-1.png" /></a><br /><br /><a href=""><img src="images\306-2.png" alt="images\306-2.png" /></a><br /><br /> 暴力破解WPA    需要使用无线网卡<br /><a href=""><img src="images\306-3.png" alt="images\306-3.png" /></a><br /><br />air无线攻击套件命令<br />查看无线网卡名iwconfig<br />关掉占用网卡进程airmon-ng check kill<br />设置网卡为监听模式 airmon-ng start INTERFACE<br />扫描附近wifiairodump-ng INTERFACE<br />监听制定路由器流量并保存到本地airodump-ng -c CHANNEL --bssid AP_MAC -w FILENAME INTERFACE<br />攻击路由器使连接设备断线重新连接airplay-ng -0 50 -a BSSID INTERFACE<br />使用字典对抓取到的握手包暴力破解aircrack-ng -w PASSWORD_FILENAME FILENAME<br /><br />查看支持无线扩展的网卡名<br /><a href=""><img src="images\306-4.png" alt="images\306-4.png" /></a><br /><br />关闭占用无线网卡的其他进程<br /><a href=""><img src="images\306-5.png" alt="images\306-5.png" /></a><br /><br />设置网卡为激活状态（监听）以网卡名作为参数，启动后发现多了一个网卡mon0<br /><a href=""><img src="images\306-6.png" alt="images\306-6.png" /></a><br /><br />扫描当前有哪些wifi<br /><a href=""><img src="images\306-7.png" alt="images\306-7.png" /></a><br /><br />监听ap流量 -c指定信道 -bssid指定mac地址 -w指定数据保存的文件名<br /><a href=""><img src="images\306-8.png" alt="images\306-8.png" /></a><br />可以查看到当前wifi中只有一个sta是活跃的<br /><a href=""><img src="images\306-9.png" alt="images\306-9.png" /></a><br /><br />此时需要抓取到网络握手包才能进行破解，所以需要等待有设备重新连入该WiFi，或者使用airplay-ng工具使某些设备掉线，设备存在掉线重连机制，从而抓取握手包<br />-0指定发送下线数据包的数量，-a指定ap的mac，-c指定强制下线的设备的mac地址，如果不加，则该ap下所有sta均下线<br /><a href=""><img src="images\306-10.png" alt="images\306-10.png" /></a><br /><br />以字典和抓包文件作为参数，使用aircrack-ng暴力破解<br /><a href=""><img src="images\306-11.png" alt="images\306-11.png" /></a><br />破解成功<br /><a href=""><img src="images\306-12.png" alt="images\306-12.png" /></a><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /></div><div class='page'><h1 class='title level-4'>wps</h1><br/><a href=""><img src="images\307-1.png" alt="images\307-1.png" /></a><br />wps存在前七位验证分为两部分，先验证前四位，只有前四位通过才会验证后三位，进一步降低破解难度</div><div class='page'><h1 class='title level-3'>无线接入的三个阶段</h1><br/><a href=""><img src="images\303-1.png" alt="images\303-1.png" /></a><br /><br />扫描可以分为主动扫描和被动扫描<br />认证方式包括wep、wpa等<br />关联阶段ap向spa发送关联请求，sta响应该关联请求，之后可以进行数据传输</div><div class='page'><h1 class='title level-2'>Z-Wave</h1><br/>我国民用禁用该频段<br /><a href=""><img src="images\317-1.png" alt="images\317-1.png" /></a><br /><br /><a href=""><img src="images\317-2.png" alt="images\317-2.png" /></a><br /><br /><a href=""><img src="images\317-3.png" alt="images\317-3.png" /></a><br /><br /><a href=""><img src="images\317-4.png" alt="images\317-4.png" /></a></div><div class='page'><h1 class='title level-2'>zigbee</h1><br/>默认信任中心连接密钥 <br />0x5A 0x69 0x67 0x42 0x65 0x65 0x 41 0x6c 0x6c 0x69 0x61 0xe 0x63 0x65 0x 30 0x39<br />速度慢，距离近，成本低，低功耗，支持多个设备连接成不同拓扑结构<br />传输控制命令和传感器采集的数据<br />相关资料 <a href="file://D:\CherryTreeNoteBook\技术思维导图\物联网安全\物联网安全11-ZigBee协议初探.xmind">物联网安全11-ZigBee协议初探</a> <a href="file://D:\CherryTreeNoteBook\技术思维导图\物联网安全\物联网安全12-ZigBee协议嗅探与分析实战.xmind">物联网安全12-ZigBee协议嗅探与分析实战</a><br /><br /><br />嗅探zigbee工具<br />所需硬件工具： Atmel RzRaven USB Stick ，刷入的固件为 KillerBee。<br />所需软件工具 : KillerBee (https://github.com/riverloopsec/killerbee)<br /><br /><a href=""><img src="images\308-1.png" alt="images\308-1.png" /></a><br /></div><div class='page'><h1 class='title level-3'>安全机制</h1><br/><a href=""><img src="images\312-1.png" alt="images\312-1.png" /></a><br /><br /><a href=""><img src="images\312-2.png" alt="images\312-2.png" /></a></div><div class='page'><h1 class='title level-3'>架构</h1><br/><a href=""><img src="images\310-1.png" alt="images\310-1.png" /></a></div><div class='page'><h1 class='title level-3'>节点类型</h1><br/><a href=""><img src="images\309-1.png" alt="images\309-1.png" /></a><br />也可分为全功能节点（可以作为三种功能节点） 半功能节点（只能作为终端设备，仅传递采集到的数据）</div><div class='page'><h1 class='title level-3'>数据抓包</h1><br/><a href=""><img src="images\313-1.png" alt="images\313-1.png" /></a><br /><br /></div><div class='page'><h1 class='title level-3'>嗅探实例</h1><br/><a href=""><img src="images\370-1.png" alt="images\370-1.png" /></a><br /></div><div class='page'><h1 class='title level-3'>组网流程</h1><br/> 协调器上电之后自动组网，理论上最大支持65535个节点，网络中任意节点均可数据通讯，设备接入或断开时，网络自动修复<br /> 一个网络中只能存在一个协调器	<br /> <br /><a href=""><img src="images\311-1.png" alt="images\311-1.png" /></a><br /> <br /> <a href=""><img src="images\311-2.png" alt="images\311-2.png" /></a></div><div class='page'><h1 class='title level-2'>常用sdr设备</h1><br/><a href=""><img src="images\369-1.png" alt="images\369-1.png" /></a></div><div class='page'><h1 class='title level-2'>调制技术</h1><br/><a href=""><img src="images\368-1.png" alt="images\368-1.png" /></a></div><div class='page'><h1 class='title level-2'>伪基站技术</h1><br/>软件bts可以搭建2g  3g  4g（需要白卡）的伪基站，所需硬件USRP B210<br /><br />4g信道频率占满，导致通讯模块从使用4g网络切换为使用3g网络，如果3g网络频段被占满，则转到2g频段，部分通讯模块4g频段占满后直接转2g频段，部分通讯模块不支持频段转换<br /><br />stackoverflow 4g降频，研究<br /><br />蓝牙 ubertooth研究抓取</div><div class='page'><h1 class='title level-2'>物联网通讯协议</h1><br/><a href=""><img src="images\300-1.png" alt="images\300-1.png" /></a><br /><br /><a href=""><img src="images\300-2.png" alt="images\300-2.png" /></a><br /><br /><br /><a href=""><img src="images\300-3.png" alt="images\300-3.png" /></a><br /><br /><a href=""><img src="images\300-4.png" alt="images\300-4.png" /></a><br /><br /><a href=""><img src="images\300-5.png" alt="images\300-5.png" /></a><br /><br /><a href=""><img src="images\300-6.png" alt="images\300-6.png" /></a><br /><br /><a href=""><img src="images\300-7.png" alt="images\300-7.png" /></a><br /><br />1. CoAP – <a href="https://en.wikipedia.org/wiki/Constrained_Application_Protocol">https://en.wikipedia.org/wiki/Constrained_Application_Protocol</a><br />2. MQTT – <a href="https://en.wikipedia.org/wiki/MQTT">https://en.wikipedia.org/wiki/MQTT</a><br />3. AMQP – <a href="https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol">https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol</a><br />4. WebSocket – <a href="https://en.wikipedia.org/wiki/WebSocket">https://en.wikipedia.org/wiki/WebSocket</a><br />5. CANbus – <a href="https://en.wikipedia.org/wiki/CAN_bus">https://en.wikipedia.org/wiki/CAN_bus</a><br />6. Modbus – <a href="https://en.wikipedia.org/wiki/Modbus">https://en.wikipedia.org/wiki/Modbus</a><br />7. Profibus – <a href="https://en.wikipedia.org/wiki/Profibus">https://en.wikipedia.org/wiki/Profibus</a><br />8. DNP3 – <a href="https://en.wikipedia.org/wiki/DNP3">https://en.wikipedia.org/wiki/DNP3</a><br />9. BACNet – <a href="https://en.wikipedia.org/wiki/BACnet">https://en.wikipedia.org/wiki/BACnet</a><br />10. HL7 – <a href="https://en.wikipedia.org/wiki/Health_Level_7">https://zh.wikipedia.org/wiki/Health_Level_7</a><br />11. XMPP – <a href="https://en.wikipedia.org/wiki/XMPP">https://en.wikipedia.org/wiki/XMPP</a><br />12. UPnP – <a href="https://en.wikipedia.org/wiki/Universal_Plug_and_Play">https://en.wikipedia.org/wiki/Universal_Plug_and_Play</a><br /><br /></div></body></html>